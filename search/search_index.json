{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Cylindra","text":"<p>Cylindra is a Python module for image analysis of cylindric structures in cryo-ET. Spectral analysis, simulation and subtomogram averaging of heterogenic cylindrical structures are implemented.</p>"},{"location":"#index","title":"Index","text":""},{"location":"#getting-started","title":"Getting Started","text":"<ul> <li>Installation</li> <li>Basics</li> </ul>"},{"location":"#in-depth-tutorials","title":"In-depth Tutorials","text":"<ul> <li>Open an Image</li> <li>Fit Splines</li> <li>Measure Lattice Parameters</li> <li>Inspect CFT Results</li> <li>Load &amp; Save Projects</li> <li>Custom Workflows</li> <li>Spline</li> <li>Molecules</li> <li>Subtomogram Alignment and Averaging</li> <li>Working with Many Projects</li> <li>Working with External Softwares</li> <li>Tomogram Simulation</li> <li>Case Studies</li> </ul>"},{"location":"#developers-guide","title":"Developers Guide","text":"<ul> <li>The Plugin System</li> </ul>"},{"location":"#others","title":"Others","text":"<ul> <li>Process Images</li> <li>API Reference</li> </ul>"},{"location":"#major-dependencies","title":"Major Dependencies","text":"<p>These are the major dependencies of <code>cylindra</code>. You don't have to fully understand them, but knowing them will help you to use <code>cylindra</code> more efficiently.</p> Show list <ul> <li>numpy: Most of the basic mathmatical operations, such as   trigonometric functions and vector operations are done with this library.</li> <li>scipy: Some of the advanced functions, such as Fourier   transformation, 3D rotation and spline fitting are done with this library.</li> <li>polars: A library for tabular data analysis, with beautifully   designed API.</li> <li>napari: Multi-dimensional image viewer. Many of the   visualization functions in <code>cylindra</code> are based on this library.</li> <li>magicgui: A powerful GUI generator for   Python. This library \"hides\" the complexity of GUI programming, making the code   very clean.</li> <li>magic-class: An extension of   <code>magicgui</code> that can convert Python classes into a multi-functional GUI.Multi-threading, macro recording, command palette and undoing are implemented in   this library.</li> <li>impy: A Python library for image processing.</li> <li>acryo: A Python library for parallel cryo-ET   data analysis.</li> </ul>"},{"location":"#reference","title":"Reference","text":"<p>If you find <code>cylindra</code> useful in your work, please consider citing our paper.</p> <pre><code>Heterogeneous local structures of the microtubule lattice revealed by cryo-ET and non-averaging analysis\nHanjin Liu, Hiroshi Yamaguchi, Masahide Kikkawa, Tomohiro Shima\nbioRxiv 2024.04.30.591984; doi: https://doi.org/10.1101/2024.04.30.591984\n</code></pre>"},{"location":"basics/","title":"Basics","text":"<p>Before start analyzing data, here's the basics of what you should know.</p>"},{"location":"basics/#components","title":"Components","text":"<p>A <code>Tomogram</code> is a data structure with following information:</p> <ul> <li>Image Data: a 3D array of the actual image data. this is not necessarily loaded   into memory; by default, image data is in a memory-mapped state, which means that the   data is read from the disk only when it is needed.</li> <li>Image metadata: voxel size, missing wedge, path to the data source, etc. - Multiscale images: a list of images with different binning factors. For example,   you can have a tomogram with 4\u00d74\u00d74 and 2\u00d72\u00d72 binned images   and switch between them for different purposes (without actually saving them as   separate image files).</li> </ul> <p>A <code>Tomogram</code> is connected with following components:</p> <ul> <li><code>Spline</code>: a piecewise cubic curve that represents the center line of a cylindric   structure. A spline is defined by a set of the coefficients of the curves, so that   it is very hard to directly interpret the internal data. However, you can easily   sample points along the spline, differentiating the spline, and so on. In <code>cylindra</code>,   many local properties and global properties are also stored in the <code>Spline</code> object.</li> <li><code>Molecules</code>: a collection of molecules. This class is directly imported from   acryo. A <code>Molecules</code> object   is a collection of 3D points, 3D rotations and scalar features for each molecule.</li> </ul>"},{"location":"basics/#coordinate-systems","title":"Coordinate Systems","text":""},{"location":"basics/#origin","title":"Origin","text":"<p>The corner pixel of an image is the origin of the coordinate system. If a molecule is located at (0, 0, 0), it means that the center of the molecule is at the center of the pixel at the corner.</p>"},{"location":"basics/#ordering","title":"Ordering","text":"<p>Following the convention of <code>napari</code> and <code>acryo</code>, the 3D coordinates are stored in (z, y, x) order.</p> Why not (x, y, z)? <p>The (z, y, x) order is more natural in the mathematical perspective. A matrix is indexed by (row, column), which corresponds to (y, x). Therefore, if you have a 3D array <code>arr</code> and a molecule at position <code>(z, y, x)</code>, you can access the value of the molecule by <code>arr[z, y, x]</code>.</p> <p>Therefore, if you have a 3D image <code>img</code>, <code>img.shape[0]</code> is the size of z axis. If a list of points is stored in a (N, 3) array <code>points</code>, <code>points[:, 0]</code> is the list of z coordinates.</p>"},{"location":"basics/#coordinates-of-subtomograms","title":"Coordinates of subtomograms","text":"<p>Subtomograms sampled from the tomogram also have (Z, Y, X) coordinates, but the origin and the direction of the axes are different from the original tomogram.</p> <p>The origin of the subtomogram is defined so that the center of the subtomogram is at the position of the corresponding molecule in the original tomogram.</p> <p>The direction of the axes depends on the rotation of molecules.</p> <ul> <li> <p>If the molecules are initialized on the surface of a cylinder using   <code>map_monomers</code>,   or <code>map_along_pf</code>,   the Y axis is parallel to the spline and the Z axis is parallel to the vector from the   spline to the molecule.</p> </li> <li> <p>If the molecules are initialized along a spline using   <code>map_along_spline</code>,   the Y axis is parallel to the spline and the Z axis is rotated so that it satisfies   the twist parameter of the spline.</p> </li> </ul>"},{"location":"basics/#manual-and-programmatic-operations","title":"Manual and Programmatic Operations","text":"<p>Owing to <code>magicgui</code> and <code>magic-class</code>, all the operations can be done either manually or programmatically. For example, clicking the <code>File &gt; Open image</code> item will open a dialog for you to select an image file, scale and so on. This function can also be called programmatically by <code>ui.open_image(...)</code>.</p> <p>Throughout this documentation, you'll find following notations:</p> <p> API: <code>ui.&lt;method-name&gt;</code></p> <p> GUI: <code>XXX &gt; YYY</code> or maybe some shortcut keys</p> <p>These notations tell you how to do the same thing programmatically or manually. You can also open the command palette (Ctrl+P) to search for the operation.</p>"},{"location":"basics/#macro-recording","title":"Macro Recording","text":"<p>Since all the manual operations can be described as function calls, <code>magic-class</code> automatically record all the operations you have done. Macro recording starts when you opened an image and will be refreshed when another image is opened or the session is initialized. This \"macro recording\" feature will make your data analysis reproducible and shareable.</p> <p>You can see the recorded macro script in <code>Others &gt; Macro &gt; Show macro</code> or by Ctrl+Shift+M.</p>"},{"location":"basics/#project-files","title":"Project Files","text":"<p>A session of analysis can be saved as a project file. A project file is a collection of files needed to recover the current GUI state. Once a project is saved, you can resume the analysis or view the results by loading the project file.</p> <p>\u2192 Learn more</p>"},{"location":"basics/#working-with-other-softwares","title":"Working with Other Softwares","text":"<p>As data analyses of electron microscopy is a complicated process, you may need to combine many softwares together. <code>cylindra</code> provides functions to read or convert components such as <code>Spline</code> and <code>Molecules</code> objects for other softwares. If you find that some softwares would be nice to be supported but not currently, please open an issue for the feature request or submit a pull request to the repository.</p> <p>\u2192 Learn more</p>"},{"location":"basics/#configure-global-variables","title":"Configure Global Variables","text":"<p> GUI: <code>Others &gt; Configure cylindra</code></p> <p></p> <p>Parameters in this dialog will be used across different sessions, but does not affect the calculation results.</p>"},{"location":"cli/","title":"CLI Usage","text":"<p>Most of the methods in <code>cylindra</code> can only be called from the GUI or in python scripts, as any operations can be written in a python script and run by <code>python file-name.py</code>.</p> <pre><code>cylindra -h\n</code></pre> Output:<pre><code>\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 cylindra options commands arguments                \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\noptions\n    -v, --version   Show version.\n    -h, --help      Show this message and exit.\n\ncommands\n    open     Open a project or an image.\n    preview  View a project, image etc.\n    find     Find cylindra projects.\n    run      Run a script.\n    config   Edit/view the configuration.\n    average  Average images.\n    new      Create a new project.\n    add      Add splines by coordinates.\n</code></pre>"},{"location":"fit_splines/","title":"Fit Splines","text":"<p>All the analysis begin with the spline fitting.</p> Try it out with the demo data <p>Reconstructed, binned tomograms of short microtubules are available in the GitHub repository, which have been used for testing the programs. You can download it to try following instructions.</p>"},{"location":"fit_splines/#draw-splines","title":"Draw Splines","text":"<p> API: <code>register_path</code></p> <p> GUI:  or F1</p> <p>You can use the built-in functionality of <code>napari</code> to place points first, and fit the points with a spline.</p> <p></p> <p>To delete the last spline, click .</p> <p>Note</p> <p>You can view the image from the different direction using the <code>napari</code> viewer buttons.</p> Auto-picking tool <p>The <code>cylindra</code> toolbar has an auto-picking tool. If you have placed two or more points, you can extend it with a fast auto-centering function ( or F3).</p> <p>In the future version, other auto-picking tools (AI-powered, fully automated, etc) may be added.</p> <p>Important: Configure the spline for your cylindric structure</p> <p>Each spline is tagged with a <code>SplineConfig</code> object, which describes the average feature of the cylindric structure it represents. Default values are optimized for microtubules. If you want to analyze other structures, you should first learn the spline config here. If <code>cylindra</code> don't have a config preset for your structure, you need to define a custom config. Please follow the instructions here.</p>"},{"location":"fit_splines/#fit-automatically","title":"Fit Automatically","text":"<p>Manually drawn splines usually does not fit the cylindric structure well. <code>cylindra</code> provides some automatic spline fitting methods using template-free image alignment.</p>"},{"location":"fit_splines/#rough-fitting","title":"Rough fitting","text":"<p> API: <code>fit_splines</code></p> <p> GUI: <code>Splines &gt; Fitting &gt; Fit splines</code></p> <p>This rough spline fitting method is based on the auto-correlation first introduced in Blestel et al., 2009, although the original method only applies to 2D images. In this method, Sub-volumes are sampled and the center of each sub-volume is estimated by the auto-correlation. Spline will try to pass nearby the estimated centers as much as possible, while avoiding the outliers.</p> <p></p> List of parameters <ol> <li>The registered splines should be shown in the top \"splines\" row.</li> <li>\"max interval (nm)\" is the maximum distance between sampling points along the    spline. This value does not have to be too small. The regions between sampling    points will be interpolated by cubic functions.</li> <li>Available bin sizes are listed up in the \"bin size\" combo box.</li> <li>\"max fit error (nm)\" is the maximum distance between the estimated center of    each sub-volume and the spline that passes nearby. Setting this value larger    will result in more smooth splines.</li> <li>\"degree precision\" is the precision of the spline tangent angle estimation.</li> <li>\"edge \u03c3\" is the standard deviation used to mask the region outside the    cylinder. This mask will lower the weight of the pixels outside the cylinder to    exclude the outer components. However, if the initial spline is far from the    actual center line, you should not mask the image.</li> <li>\"max shift\" is the maximum shift of the sampling points to the estimated center.</li> </ol> <p>Note</p> <p>If the filament is thin, fitting to the centroid may work better. To do this, use following methods instead.</p> <p> API: <code>fit_splines_by_centroid</code></p> <p> GUI: <code>Splines &gt; Fitting &gt; Fit splines by centroid</code></p>"},{"location":"fit_splines/#refine-the-fitting","title":"Refine the fitting","text":"<p> API: <code>refine_splines</code></p> <p> GUI: <code>Splines &gt; Fitting &gt; Refine splines</code></p> <p>This method is to further refine the splines after rough fitting. In this function, the lattice helical parameters at this moment are determined by global-CFT analysis, and the average projection along the spline axis is calculated. Each sub-volume along the spline is aligned to the average to update the spline positions.</p> <p></p> List of parameters <ol> <li>The registered splines should be shown in the top \"splines\" row.</li> <li>\"max interval (nm)\" is the maximum distance between sampling points along the    spline. This value does not have to be too small. The regions between sampling points will be interpolated by cubic functions.</li> <li>\"max fit error (nm)\" is the maximum distance between the estimated center of    each sub-volume and the spline that passes nearby. Setting this value larger will result in more smooth splines.</li> <li>\"correlation allowed\" is the top correlation coefficients allowed to make the    average. Setting to &lt;1 will exclude the badly aligned sub-volumes.</li> <li>Available bin sizes are listed up in the \"bin size\" combo box.</li> </ol>"},{"location":"fit_splines/#fit-manually","title":"Fit Manually","text":"<p> GUI: <code>Splines &gt; Fitting &gt; Fit splines manually</code> or Ctrl+K \u2192 Ctrl+/</p> <p>Sometimes spline fitting may fail, probably due to the poor quality of the image or the fitting being affected by the nearby structures. In this case, you can carefully fit the splines manually in a new window.</p> <p></p> <p>In this window, you can left-click in the projection to select the center of the structure. You can move along the spline by changing the \"Position\" box (Up, Down), or go to other splines by changing the \"Spline No.\" box (Left, Right).</p>"},{"location":"fit_splines/#the-spline-object","title":"The Spline Object","text":"<p>All the registered <code>Spline</code> objects are stored in the <code>ui.splines</code> property. It is a <code>list</code> like structure with all the registered splines as its elements.</p> <pre><code>spl = ui.splines[0]  # the first Spline object\nspl\n</code></pre> Output:<pre><code>Spline[&lt;edge coordinates shown here&gt;]\n</code></pre> <p>The <code>Spline</code> object has a <code>props</code> property. This object stores the local and global properties of the spline. Since we have not run any analysis yet, the properties are empty.</p> <pre><code>spl.props\n</code></pre> Output:<pre><code>SplineProps(\nlocal=\nshape: (0, 0)\n\u250c\u2510\n\u255e\u2561\n\u2514\u2518\nglobal=\nshape: (0, 0)\n\u250c\u2510\n\u255e\u2561\n\u2514\u2518\n)\n</code></pre>"},{"location":"inspect_results/","title":"Inspect CFT Results","text":"<p>To clarify if the analysis is done correctly or to determine the parameters, you may sometimes want to inspect the results of the CFT. This can be done by the spectra inspector widget.</p> <p> GUI: <code>Analysis &gt; Open spectra inspector</code> or Ctrl+K \u2192 Ctrl+V</p> <p>In this window, you can see the local- and global-CFT power spectra of the existing splines, and the estimated peak positions (red markers) if available. You can change the current spline and bin size for inspection in this GUI.</p> <p></p> <p>The upsampled local-CFT is useful to check the sub-pixel peak positions.</p> <p></p> <p>If the spline is not well fitted to the image, the peaks of the local power spectrum are blurred, especially in the x (angular) direction.</p> <p></p> <p>Note</p> <p>This widget is also used to measure the lattice parameters of unknown structures. See here for more information.</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#create-a-virtual-environment","title":"Create a virtual environment","text":"<p>Installing in a virtual environment is highly recommended. If you are using <code>conda</code>, you can create an environment with the command below, with \"my-env\" replaced with any names you'd like.</p> <pre><code>conda create -n my-env python  # create environment\nconda activate my-env  # enter the virtual environment\n</code></pre>"},{"location":"installation/#install-cylindra","title":"Install Cylindra","text":"<p>Now, it's ready to install <code>cylindra</code>. Following command will install <code>cylindra</code> and all the relevant dependencies in the current virtual environment. Note that if you don't install from PyPI, you'll need <code>git</code> and <code>rustup</code> command.</p> From PyPIFrom napari hubFrom the GitHub main branchBuild from the source <pre><code>pip install cylindra[all] -U\n</code></pre> <p><code>cylindra</code> is available as a napari plugin. You can install it from the napari plugin manager.</p> <ol> <li>Launch <code>napari</code>.</li> <li>Click <code>Plugins &gt; Install/Uninstall plugins...</code>.</li> <li>Type \"cylindra\" in the filter box. Click the \"Install\" button.</li> </ol> <pre><code>pip install git+https://github.com/hanjinliu/cylindra.git\n</code></pre> <pre><code>git clone https://github.com/hanjinliu/cylindra\ncd cylindra\npip install .[all]\n</code></pre> Avoid installing optional dependencies <p>The \"all\" option tells <code>pip</code> to install everything that will be used in <code>cylindra</code>. If you don't want all of these, you can manually select the dependencies. The optional dependencies are:</p> <ul> <li><code>pyqt5</code> ... This is the default GUI backend. You can also use <code>pyqt6</code> or   <code>pyside6</code>.</li> <li><code>scikit-learn</code> ... Conventional machine learning library. Princilple component   analysis (PCA) and k-means clustering need this library.</li> <li><code>mrcfile</code> ... A library for reading and writing MRC files. This is needed if you   want to use MRC files.</li> <li><code>tifffile</code> ... A library for reading and writing TIFF files. This is needed if you   want to use TIFF files.</li> </ul> <p>You can check if the installation succeeded by running <code>cylindra -v</code>.</p>"},{"location":"lattice_params/","title":"Measure Lattice Parameters","text":"<p>In this section, we will see how to measure the lattice parameters and store the results in the <code>Spline</code> object.</p>"},{"location":"lattice_params/#estimate-the-radius","title":"Estimate the Radius","text":""},{"location":"lattice_params/#the-global-radius","title":"The global radius","text":"<p> API: <code>measure_radius</code></p> <p> GUI: <code>Analysis &gt; Radius &gt; Measure radius</code></p> <p>To run many of the lattice analyses, you have to know the size of the cylinders. This is the simplest method to estimate the radius using the radial profile of sampled sub-volumes along the spline. This method should only be used if the radius is almost constant along the cylindric structure.</p> <p></p> List of parameters <ol> <li>The registered splines should be shown in the top \"splines\" row.</li> <li>Available bin sizes are shown in the \"bin size\" combo box. Since peak detection    is performed by calculating the centroid, scaling down does not affect a lot.    usually ~0.5 nm/pixel is enough.</li> <li>\"min radius\" is the minimum radius to be considered as a valid peak.</li> </ol> <p>After this estimation, the radius is stored as a global property of the spline. It is available in the <code>spline</code> properties.</p> <pre><code>spl = ui.splines[0]  # the first Spline object\nprint(spl.props.get_glob(\"radius\"))  # print the global radius of the spline\nprint(spl.radius)  # a shorthand for spl.props.get_glob(\"radius\")\n</code></pre> If the estimated value is not appropriate <ul> <li>If you forgot to invert the image, this step will be the first step that the   result goes wrong. Make sure the image is inverted.</li> <li>This method uses the radial profile of the raw intensity values. If the cylinder   structure is coated with dense components inside and/or outside of the cylinder,   the result will be affected. If there's any a priori knowledge about the radius,   you can set it manually with <code>set_radius</code> method.</li> </ul> <p>Note</p> <p>If the cylinder structure is supposed to change, you may want to measure local radius.</p>"},{"location":"lattice_params/#set-global-radius-manually","title":"Set global radius manually","text":"<p> API: <code>set_radius</code></p> <p> GUI: <code>Analysis &gt; Radius &gt; Set radius</code></p> <p>If you already know the radius, or the rule to calculate the radius, you can set it manually. If the latter, you'll use the expression system.</p> <p></p> List of parameters <ol> <li>The registered splines should be shown in the top \"splines\" row.</li> <li>\"radius\" is the radius in nm. If a scalar is given, radii of all the selected    splines will be updated with the same value. If an expression is given, radius    values will be calculated by evaluating the expression using the global    properties of the spline.</li> </ol> set radius using an expression <p>Calculate the radius based on the number of protofilaments.</p> <pre><code>ui.set_radius(splines=[0, 1], radius=\"col('npf') * 0.78\")\n</code></pre> <p>The replace method is useful to map the number of protofilaments to the radius value.</p> <pre><code>ui.set_radius(splines=[0, 1], radius=\"col('npf').replace({13: 10.0, 14: 11.0})\")\n</code></pre>"},{"location":"lattice_params/#the-local-radius","title":"The local radius","text":"<p> API: <code>measure_local_radius</code></p> <p> GUI: <code>Analysis &gt; Radius &gt; Measure local radius</code></p> <p>In some cases, the radius is not constant. This method will measure the radius of each sub-volume along the spline and store it as a local property of the spline.</p> <p></p> List of parameters <ol> <li>The registered splines should be shown in the top \"splines\" row.</li> <li>\"interval\" is the sampling interval in nm. If you already analyzed some local    parameters, the spline should be tagged with the anchors. In this case, you can    directly use the anchors instead of manually setting this value.</li> <li>\"depth\" is the size of sub-volumes in nm parallel to the spline.</li> <li>Available bin sizes are shown in the \"bin size\" combo box. Since peak detection    is performed by calculating the centroid, scaling down does not affect a lot.    usually ~0.5 nm/pixel is enough.</li> <li>\"min radius\" is the minimum radius to be considered as a valid peak.</li> <li>If you want to update the global property of \"radius\" by the mean of local    radius, check the \"Also update the global radius\" checkbox.</li> </ol>"},{"location":"lattice_params/#infer-polarity","title":"Infer Polarity","text":"<p> API: <code>infer_polarity</code></p> <p> GUI: <code>Splines &gt; Orientation &gt; Infer polarity</code></p> <p>Many biological filamentous structures have polarity. This feature usually needs to be determined by subtomogram averaging, but in some cases we can undoubtedly distinguish the polarity by seeing the chirality of the molecules.</p> <p>In <code>cylindra</code>, an automatic polarity inference method is implemented. This method works very well for microtubules, using the fact that clockwise appearance of tubulin molecules corresponds to the minus-to-plus direction. Theoretically, it should also work for other helical structures such as actin filament, but it's not guaranteed.</p> <p>Note</p> <p>If the polarity is not inferred correctly, you can set it manually using the <code>set_spline_props</code> method.</p>"},{"location":"lattice_params/#running-cft","title":"Running CFT","text":"<p>CFT (cylindric Fourier Transformation) is a method introduced in our work to measure the local and global lattice parameters of microtubules. It composed of following steps:</p> <ol> <li>Coordinate transformation from the Cartesian coordinate \\((z, y, x)\\) to the    cylindrical coordinate \\((r, y', \\theta)\\).</li> <li>3D Discrete Fourier Transformation around the peak locations with up-sampling. The    expected peak locations are defined in the spline configurations.</li> <li>Project the 3D cylindric power spectrum to \\((y', \\theta)\\). The peak frequencies are    used to calculate the lattice parameters.</li> </ol> <p>Note that the \\(y'\\) coordinate is parallel to the spline in the Cartesian coordinate. If the tilt axis of your tomogram is \\(y\\), you should have drawn splines almost parallel to the \\(y\\) axis. Therefore, you can assume \\(y \\approx y'\\).</p> Why not FFT? <p>The FFT (Fast Fourier Transformation) is a widely used algorithm to calculate the Fourier Transformation very efficiently. However, FFT is not suitable for up-sampling because it results in a very large output image (10\u00d7 up-sampling in two axes results in a 100\u00d7 larger image). In this case, discrete Fourier transformation is must faster and more memory efficient.</p> <p>After the radius is estimated, you can run CFT to measure the lattice parameters.</p>"},{"location":"lattice_params/#local-cft","title":"local-CFT","text":"<p> API: <code>local_cft_analysis</code></p> <p> GUI: <code>Analysis &gt; Local CFT analysis</code></p> <p>Local-CFT is a CFT analysis performed by building local cylindric coordinate systems along the spline. The local coordinate system is \"straight\"; the \\(y'\\) axis is not curved when it's viewed in the Cartesian coordinate system.</p> <p></p> List of parameters <ol> <li>The registered splines should be shown in the top \"splines\" row.</li> <li>\"interval\" is the sampling interval in nm. You can use existing spline anchors    if you already have ones, such as after running \"Measure local radius\".</li> <li>\"depth\" is the size of sub-volumes in nm parallel to the spline (\\(y'\\) axis).</li> <li>Available bin sizes are shown in the \"bin size\" combo box. Since power spectra    will be up-sampled, ~0.5 nm/pixel is usually enough.</li> <li>If you want to build local cylindric coordinate systems using the global radius,    the \"radius\" parameter should be \"global\". Change to \"local\" if you'll use the    local radius.</li> <li>If you want to update all the global properties, check the \"Also update the    global properties\" checkbox.</li> </ol> <p>After local-CFT, the spline local properties are updated. You can access them as a <code>DataFrame</code> by:</p> <pre><code>ui.splines[0].props.loc\n</code></pre> Output:<pre><code>shape: (3, 8)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 rise_angle \u2506 rise_length \u2506 pitch    \u2506 \u2026 \u2506 npf \u2506 start \u2502\n\u2502 ---        \u2506 ---         \u2506 ---      \u2506   \u2506 --- \u2506 ---   \u2502\n\u2502 f32        \u2506 f32         \u2506 f32      \u2506   \u2506 u8  \u2506 i8    \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 9.999075   \u2506 0.944843    \u2506 4.099899 \u2506 \u2026 \u2506 13  \u2506 3     \u2502\n\u2502 10.028508  \u2506 0.947809    \u2506 4.099899 \u2506   \u2506 13  \u2506 3     \u2502\n\u2502 10.003416  \u2506 0.945541    \u2506 4.095563 \u2506   \u2506 13  \u2506 3     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>... or as a series:</p> <pre><code>ui.splines[0].props.get_loc(\"rise_angle\")\n</code></pre> Output:<pre><code>shape: (3,)\nSeries: 'rise_angle' [f32]\n[\n    9.999075\n    10.028508\n    10.003416\n]\n</code></pre>"},{"location":"lattice_params/#global-cft","title":"global-CFT","text":"<p> API: <code>global_cft_analysis</code></p> <p> GUI: <code>Analysis &gt; Global CFT analysis</code></p> <p>Unlike local-CFT, global-CFT builds a distorted cylindric coordinate system; The \\(y'\\) axis is exactly the spline. This coordinate mapping will straighten the lattice, which makes it possible to measure the average lattice parameters.</p> <p></p> List of parameters <ol> <li>The registered splines should be shown in the top \"splines\" row.</li> <li>Available bin sizes are shown in the \"bin size\" combo box. Global-CFT uses a    a very long region, you can use larger bin sizes.</li> </ol> <p>This method will update the global properties of the spline. You can access them similarly.</p> <pre><code>ui.splines[0].props.glob\n</code></pre> Output:<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 radius    \u2506 orientation \u2506 rise_angle \u2506 \u2026 \u2506 twist    \u2506 npf \u2506 start \u2502\n\u2502 ---       \u2506 ---         \u2506 ---        \u2506   \u2506 ---      \u2506 --- \u2506 ---   \u2502\n\u2502 f32       \u2506 str         \u2506 f32        \u2506   \u2506 f32      \u2506 u8  \u2506 i8    \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 11.086255 \u2506 MinusToPlus \u2506 10.027519  \u2506 \u2026 \u2506 0.036526 \u2506 13  \u2506 3     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>... or as a scalar:</p> <pre><code>ui.splines[0].props.get_glob(\"rise_angle\")\n</code></pre> Output:<pre><code>10.027519226074219\n</code></pre>"},{"location":"lattice_params/#properties-of-the-splines","title":"Properties of the Splines","text":"<p>After running CFT, splines will have the following properties:</p> <ol> <li><code>\"rise_angle\"</code></li> <li><code>\"rise_length\"</code></li> <li><code>\"pitch\"</code></li> <li><code>\"spacing\"</code></li> <li><code>\"skew_angle\"</code></li> <li><code>\"twist\"</code></li> <li><code>\"radius\"</code></li> <li><code>\"npf\"</code></li> <li><code>\"start\"</code></li> <li><code>\"orientation\"</code> (global only)</li> </ol> <p></p>"},{"location":"lattice_params/#sweep-along-the-splines","title":"Sweep along the Splines","text":"<p>After running local-CFT, you'll find the GUI being updated.</p> <p>In the \"Spline Control\" panel, you can check the fitting results by seeing the projections of each sub-volume along the spline.</p> <p></p> <p>Local lattice parameters are plotted in the \"Local Properties\" panel. You can interactively see the profiles in the figures.</p> <p></p>"},{"location":"lattice_params/#run-this-workflow-easily","title":"Run this workflow easily","text":"<p>The \"fit \u2192 refine \u2192 measure radius \u2192 CFT\" workflow can be quickly run from the toolbar, or F2 key.</p> <p></p> Manually set parameters <p> API: <code>set_spline_props</code></p> <p> GUI: <code>Splines &gt; Set spline properties</code></p> <p>This method is useful when you want to set the protofilament number, start number and/or orientation of the splines manually, especially when the automatic inference fails but you are sure about the values.</p>"},{"location":"open_image/","title":"Start Cylindra","text":"<p>This section describes how to start <code>cylindra</code>, open images and prepare for the analysis.</p>"},{"location":"open_image/#launch-the-gui","title":"Launch the GUI","text":"<p>You can launch the GUI application using <code>cylindra</code> command.</p> <pre><code>cylindra\n</code></pre> <p>Note</p> <p>The <code>cylindra</code> command is enabled only when you are in the virtual environment. For conda users, you can activate with <code>conda activate my-env</code></p> <p>After the startup, the <code>napari</code> viewer will be shown with the <code>cylindra</code> widget added on the right side as a dock widget.</p> Launch programatically <p>You can use the <code>start</code> function to launch the GUI. The GUI object is returned.</p> <pre><code>from cylindra import start\n\nui = start()\n</code></pre> <p><code>napari</code> has a integrate IPython console for running Python code. You can open it with Ctrl+Shift+C. If you launched the <code>napari</code> viewer from <code>cylindra</code>, following variables are pushed to the console global namespace:</p> <ul> <li><code>ui</code>: The currently opened <code>cylindra</code> main GUI object.</li> <li><code>viewer</code>: The <code>napari</code> viewer object.</li> <li><code>np</code>: <code>numpy</code> module.</li> <li><code>ip</code>: <code>impy</code> module.</li> <li><code>pl</code>: <code>polars</code> module.</li> <li><code>plt</code>: <code>matplotlib.pyplot</code> module.</li> <li><code>Path</code>: <code>pathlib.Path</code> class.</li> </ul>"},{"location":"open_image/#open-an-image","title":"Open an Image","text":"<p> API: <code>open_image</code>.</p> <p> GUI: <code>File &gt; Open image</code> or Ctrl+K \u2192 Ctrl+O.</p> <p>In GUI, an open-image dialog is shown.</p> <p></p> <p>In this dialog, you can configure how to open the image. Note that the image opened in the viewer is NOT the original image. <code>cylindra</code> uses a binned and optionally filtered image for visualization.</p> Open an image from IMOD or RELION project <p>If tomograms are reconstructed using IMOD or RELION, the built-in plugins can directly read it. See here for more details.</p> <p>Important: Use dark background images</p> <p>Most of the methods require dark-background images, while most of the raw images of electron microscopy are light-background. You have to manually prepare an inverted image file, or check the \"Invert intensity\" option in the open-image dialog. The loaded image can also be inverted from the menu (see Invert Images).</p> <ol> <li>Click \"Select file\" to select the image file to open. tiff and mrc files are    supported.</li> <li>Set the appropriate pixel scale. You can click \"Scan header\" to automatically detect    the pixel scale.</li> <li>Set the tilt range and the tilt axis used for calculating missing wedges.</li> <li>Set the bin sizes used during your analysis. For example, setting to <code>[2, 4]</code> will    start calculation of 2\u00d7 and 4\u00d7 binned images, which will be loaded into    the memory, and leave the original image in the memory-mapped state (ready to be read    in the future). The 4\u00d7 binned image will be shown in the viewer as a    reference. In the later analysis, you can switch between the original, 2\u00d7    binned and 4\u00d7 binned images. See Use Multi-scaled Images    for more details.</li> <li>Set the filter to apply to the image. The filter is applied to the reference image    shown in the viewer, not to the original image.</li> <li>If you want to invert the image, check \"Invert intensity\".</li> <li>If you want to load the original image into the memory, check \"Load the entire image    into memory\".</li> <li>If the tomogram is stored in HDD, check \"Cache image on SSD\". Tomogram will be copied    to the cache directory in SSD and automatically deleted at exit. This option will    improve the performance a lot during your analysis.</li> <li>You can preview the selected image by clicking \"Preview\". A preview window will be    shown, which only loads separate image slices to accelerate the image loading.</li> <li>Click \"Open\" to calculate the binning/filtering and show the reference image.</li> </ol> <p></p> <p>After opening an image, you'll find three layers added to the viewer:</p> <ul> <li><code>\"Drawing Layer\"</code>: a Points layer used to manually draw splines.</li> <li><code>\"Splines\"</code>: a Points layer showing the registered splines.</li> <li><code>&lt;name of the tomogram&gt;</code>: an Image layer showing the reference image.</li> </ul> <p>The <code>\"Drawing Layer\"</code> will be selected, with the \"add points\" mode activated by default.</p> Handedness since napari v0.6 <p>Since v0.6, napari introduced full accessivility to the axis directionality, and the default handedness was changed from \"left-handed\" to \"right-handed\". This means that if you set the axis directionality to wrong parameters, tomograms and the average images will be flipped. <code>cylindra</code> will automatically change the viewer handedness to \"left-handed\" on startup, so you don't have to worry about it. However, if you find the 3D images flipped, you may want to check the handedness.</p> Use custom reference image <p>In some cases, you may already have a reference image for each tomogram.</p> <ul> <li>Saving binned (and filtered) images does not take much storage space. For example,   a 4\u00d7 binning increases the total storage size only by 1/64 = 1.6%. Directly   using this image as the reference image will save time.</li> <li>There are many softwares that implement powerful denoising methods, such as   Topaz,   cryoCARE and   IsoNet.   It is a good idea to use these denoised images as the reference image while using   the original image for the analysis. In this case, you can load any image as the   reference using <code>open_reference_image</code>.</li> </ul> <p>To use a custom reference image check \"Use user-supplied reference image\" and provide the reference path in the open-image dialog.</p> <p>Alternatively, you can open a reference image after opening the tomogram using following method.</p> <p> API: <code>open_reference_image</code>.</p> <p> GUI: <code>File &gt; Open reference image</code></p>"},{"location":"open_image/#use-multi-scaled-images","title":"Use Multi-scaled Images","text":"<p>Tomograms can be loaded as multi-scaled images, which means that you can switch between the original and binned images. Many methods in <code>cylindra</code> have a <code>bin_size</code> argument. All the bin sizes registered as multi-scales are available for this argument. Usually, the bin sizes are set using the <code>bin_size</code> argument of the open-image dialog.</p>"},{"location":"open_image/#i-add-a-new-bin-size-to-the-multi-scale-list-after-you-opened-the-image","title":"(i) Add a new bin size to the multi-scale list after you opened the image","text":"<p> API: <code>add_multiscale</code>.</p> <p> GUI: <code>File &gt; Add multi-scale</code></p>"},{"location":"open_image/#ii-choose-which-multi-scale-image-to-be-shown-in-the-viewer","title":"(ii) Choose which multi-scale image to be shown in the viewer","text":"<p> API: <code>set_multiscale</code>.</p> <p> GUI: <code>File &gt; Set multi-scale</code></p> <p>It is useful when you have a low-resolution image (to see the overall state of your sample) and a high-resolution image (to see the detailed structures of the components) as the multi-scale images.</p>"},{"location":"open_image/#invert-images","title":"Invert Images","text":"<p> API: <code>invert_image</code>.</p> <p> GUI: <code>Image &gt; Invert image</code></p> <p>Raw images are usually light-background images, but most of the analysis methods require dark-background images. You can invert all the images (original image, multi- scaled images, and the reference image) using this method.</p> <p>Note</p> <p>Since the original image is memory-mapped, the inversion will be done when the image is read from the memory. Therefore, it takes a bit longer in the later analysis compared to using an already-inverted image saved separately. They are, however, not that different in most cases, because the inversion is much faster than most of the image processing methods such as cross-correlation calculation and coordinate transformation.</p> <p>Note that <code>open_image</code> can also run this method by specifying the <code>invert</code> argument.</p>"},{"location":"open_image/#process-the-reference-image","title":"Process the Reference Image","text":""},{"location":"open_image/#filter-the-reference-image","title":"Filter the Reference Image","text":"<p> API: <code>filter_reference_image</code>.</p> <p> GUI: <code>Image &gt; Filter reference image</code></p> <p>The reference image shown in the viewer can be filtered for better visualization. Currently, following filters are implemented:</p> <ul> <li><code>method=\"LowPass\"</code>: low-pass filter</li> <li><code>method=\"Gaussian\"</code>: Gaussian filter</li> <li><code>method=\"DoG\"</code>: Difference of Gaussian (DoG) filter</li> <li><code>method=\"LoG\"</code>: Laplacian of Gaussian (LoG) filter</li> </ul> <p>Note that <code>open_image</code> can also run this method by specifying the <code>filter</code> argument.</p>"},{"location":"open_image/#deconvolve-the-reference-image","title":"Deconvolve the Reference Image","text":"<p> API: <code>deconvolve_reference_image</code>.</p> <p> GUI: <code>Image &gt; Deconvolve reference image</code></p> <p>If you have information about the contrast transfer function (CTF) of the tomogram, you can run Wiener deconvolution on the reference image. This will improve the quality of the reference image much better than the filtering methods.</p> <p>The implementation of this method is directly ported from IsoNet (MIT license).</p>"},{"location":"open_image/#saving-the-reference-image","title":"Saving the Reference Image","text":"<p> API: <code>save_reference_image</code>.  GUI: <code>File &gt; Save reference image</code></p> <p>The processed reference image can be saved to a file. The save path will be recorded when the project is saved, and the reference image can directly be used when the project is loaded. See Load &amp; Save Projects for more details.</p>"},{"location":"plugins/","title":"The Plugin System","text":"<p>With workflows, you can automate your tasks using combination of methods defined in <code>cylindra</code>. However, you may need some additional methods (e.g. particle detection based on neural network or custom subtomogram alignment methods) that you want to use during sessions.</p> <p>The <code>cylindra.plugin</code> submodules provide interfaces to register plugins. The registered plugins will be available in the \"Plugin\" menu and will be recorded in the macro, thus works as other methods in <code>cylindra</code>.</p>"},{"location":"plugins/#your-first-plugin","title":"Your First Plugin","text":"<p>Plugins must be defined in a python package, as they must be importable by the <code>from XXX import YYY</code> statement.</p>"},{"location":"plugins/#step-1-make-a-package","title":"Step 1. Make a Package","text":"<p>The file structure of a package should be as follows:</p> <pre><code>my-first-plugin/\n\u251c\u2500\u2500 LICENSE\n\u251c\u2500\u2500 pyproject.toml\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 my_first_plugin/\n\u2502   \u251c\u2500\u2500 __init__.py\n:   :\n\u2502\n\u2514\u2500\u2500 tests/\n</code></pre> <p>The easiest way to create a package is to use the <code>cylindra plugin</code> command. It uses cookiecutter to automatically create the necessary files and directories for you.</p> <pre><code>pip install cookiecutter -U\ncylindra plugin new .\n</code></pre> Other ways? <p>Alternatively, you can also use <code>hatch</code>.</p> <pre><code>pip install hatch -U\nhatch new my-first-plugin\n</code></pre> <p>Note</p> <p>If your plugin needs special build steps, such as compiling C or Rust code, you will need to rewrite the <code>pyproject.toml</code> file.</p>"},{"location":"plugins/#step-2-define-plugin-functions","title":"Step 2. Define Plugin Functions","text":"<pre><code>my-first-plugin/\n:\n\u251c\u2500\u2500 my_first_plugin/\n\u2502   \u251c\u2500\u2500 __init__.py\n:   \u2514\u2500\u2500 core.py\n</code></pre> <p>When <code>cylindra</code> looks for the plugins, it searches for the variables defined under your modules.</p> <ul> <li>If your plugins are to be defined under the namespace <code>my_first_plugin</code>, you should   expose all the plugin functions in the <code>__init__.py</code> file.</li> <li>Plugin functions should be decorated with <code>cylindra.plugin.register_function</code>.</li> </ul> <p>Let's start with a simple plugin function that prints a message and a random array.</p> my_first_plugin/__init__.py<pre><code>from .core import my_plugin_function\n</code></pre> my_first_plugin/core.py<pre><code>import numpy as np\nfrom cylindra.plugin import register_function\n\n@register_function\ndef my_plugin_function(ui):\n    ui.logger.print(\"My first plugin!\")\n    ui.logger.print(np.random.rand(5))\n</code></pre>"},{"location":"plugins/#step-3-metadata","title":"Step 3. Metadata","text":"<p>The \"pyproject.toml\" file describes the metadata of the package. The mandatory fields are alreadly filled by the <code>cylindra plugin new</code> command, but there are still some fields that are needed to be updated.</p> <p>If your plugin depends on other packages, you should list them in the <code>dependencies</code>. Because <code>cylindra</code> plugins always depend on <code>cylindra</code>, <code>\"cylindra\"</code> is already included by default. If there are others, add them like below:</p> <pre><code>[project]\ndependencies = [\n    \"cylindra\",\n    \"numpy&gt;=2.1.0\",\n]\n</code></pre>"},{"location":"plugins/#step-4-install-the-plugin","title":"Step 4. Install the Plugin","text":"<p>Now, your package is ready to be installed by Python package manager.</p> <pre><code>pip install -e my_first_plugin\n</code></pre> The <code>-e</code> option <p>The <code>-e</code> option installs the package in the editable mode, so you can modify the plugin functions without reinstalling the package. This is very useful during the development. However, if you modified the pyproject.toml itself, you'll have to reinstall the package.</p>"},{"location":"process_images/","title":"Process Images","text":"<p> GUI: <code>File &gt; Process images</code></p> <p>There are many tools available for processing tomographic images. <code>cylindra</code> also provides basic functions for image processing.</p> <p></p> <p>To simplify the path specification, the \"suffix\" parameter is available. When the \"input image\" path changed, the \"output image\" path will be automatically filled with the suffix. For example, if the input image is <code>path/to/image.mrc</code>, and the suffix is \"_processed\", the output image will be <code>path/to/image_processed.mrc</code>.</p>"},{"location":"project_io/","title":"Load &amp; Save Projects","text":"<p>In <code>cylindra</code>, a project is managed by a <code>CylindraProject</code> instance.</p>"},{"location":"project_io/#save-the-current-session-as-a-project","title":"Save the Current Session as a Project","text":"<p> API: <code>save_project</code></p> <p> GUI: <code>File &gt; Save Project</code> or Ctrl+K \u2192 Ctrl+S</p> <p>If you want to save the current session as a project, you can use this method to save the current state.</p> <ul> <li><code>project.json</code> ... The main project file, which has the description of this project.</li> <li><code>default_spline_config.json</code> ... The default <code>SplineConfig</code>. See here   for the details.</li> <li><code>globalprops.csv</code> ... The global properties of the splines.</li> <li><code>localprops.csv</code> ... The local properties of the splines.</li> <li>CSV or parquet files ... Coordinates and features of molecules.</li> <li><code>script.py</code> ... An executable Python script to reproduce the session.</li> <li><code>spline-*.json</code> ... The spline objects in JSON format (not human readable, should   always be read by from_json) method.</li> </ul> <p>The project can be a directory, a zip file or a tar file.</p>"},{"location":"project_io/#load-project","title":"Load Project","text":"<p> API: <code>load_project</code></p> <p> GUI: <code>File &gt; Load Project</code> or Ctrl+K \u2192 Ctrl+P</p> <p>Saved projects can be loaded to the GUI. Loading a project does not rerun the script. It uses the saved files to reproduce the session.</p> <p></p> <p>To reduce the loading time, you can uncheck the \"read image\" option. This will postpone the evaluation of the image chunks (thus loading the image as a <code>dask</code> array). If the reference image is available, it will be loaded if \"read reference\" is checked. As reference image is usually much smaller than the original tomogram, this option will save a lot of time while will not affect the visual inspection of the tomogram.</p>"},{"location":"project_io/#stash-the-session","title":"Stash the Session","text":"<p> GUI: <code>File &gt; Stash</code></p> <p>You may want to temporarily save the session for later use. In <code>cylindra</code>, some \"stash\" operations are available. Stashed sessions are cached in the user directory, and can be readily loaded from the GUI.</p> <p>Note</p> <p>If you already know the <code>git stash</code> command, you should be familiar with this.</p>"},{"location":"project_io/#reuse-the-existing-projects","title":"Reuse the Existing Projects","text":"<p> API: <code>load_project_for_reanalysis</code></p> <p> GUI: <code>Analysis &gt; Load Project for Reanalysis</code></p> <p>Drawing splines is a most time-consuming step. <code>cylindra</code> is implemented with a method that automatically filter the script in a project file and only run until it reaches any non-manual line. For example, if you have a project file that contains a <code>script.py</code> file with a <code>main</code> function like this:</p> <pre><code>def main(ui):\n    ui.open_image(path='path/to/image.tif', ...)\n    ui.register_path(coords=[[19, 190, 29], [19, 100, 50]], ...)\n    ui.register_path(coords=[[20, 100, 32], [20, 190.0, 63]], ...)\n    ui.fit_splines(splines='all', ...)\n    ui.refine_splines(splines='all', ...)\n</code></pre> <p>then, the filtered script will be:</p> <pre><code>def main(ui):\n    ui.open_image(path='path/to/image.tif', ...)\n    ui.register_path(coords=[[19, 190, 29], [19, 100, 50]], ...)\n    ui.register_path(coords=[[20, 100, 32], [20, 190.0, 63]], ...)\n</code></pre>"},{"location":"simulate/","title":"Simulate Tomograms","text":"<p><code>cylindra</code> implements several methods to simulate cylindric structures.</p>"},{"location":"simulate/#open-simulator-widget","title":"Open simulator widget","text":"<p> GUI: <code>Image &gt; Simulate cylindric structure</code> or Ctrl+K \u2192 I</p> <p>The simulator widget is available at <code>ui.simulator</code>.</p>"},{"location":"simulate/#prepare-a-spline-with-arbitrary-shape","title":"Prepare a spline with arbitrary shape","text":"<p>Before running simulation, you have to place molecules at the desired positions and orientations. To do this, you can first create an empty image, and draw splines of any shape on it.</p> <p> API: <code>create_empty_image</code></p> <p> GUI: <code>Simulator widget &gt; Create &gt; Create empty image</code></p> <p></p> <p>The image size and the pixel scale will be directly used as the simulated tomograms.</p> <p>Note</p> <p>You can also call mapping functions on splines tagged with helical parameters measured by CFT.</p>"},{"location":"simulate/#simulate-cylinder-with-constant-periodicity","title":"Simulate cylinder with constant periodicity","text":"<p> API: <code>generate_molecules</code></p> <p> GUI: <code>Simulator widget &gt;</code> </p> <p>With spline-to-molecules mapping functions, the molecules were initialized based on the helical parameters of the spline. Instead of referring to the measured parameters, you can generate molecules along the spline with arbitrary parameters. Following GIF shows how to adjust parameters while previewing the result.</p> <p></p> <p>The generated molecules will be added to the viewer with some names like <code>Mole(Sim)-0</code>.</p>"},{"location":"simulate/#apply-local-conformational-changes-to-molecules","title":"Apply local conformational changes to molecules","text":"<p>The method above can only generate molecules with constant parameters. To simulate local conformational changes, you can use the following method. Common parameters are:</p> <ul> <li><code>by</code>: the amount of change.</li> <li><code>yrange</code>: the longitudinal range of the local region. <code>yrange=(5, 10)</code> means that the   5th molecules to the 9th (end excluded!) molecules from the edge will be affected.</li> <li><code>arange</code>: the lateral range of the local region. <code>arange=(2, 5)</code> means that the   molecules in the 2nd to 4th (end excluded!) protofilaments will be affected.</li> </ul> <p>and the preview is also available.</p>"},{"location":"simulate/#local-expansioncompaction","title":"Local expansion/compaction","text":"<p> API: <code>expand</code></p> <p> GUI: <code>Simulator widget &gt;</code> </p> Programatically apply local expansion <p>This script will expand the 10th to 20th molecules (all the protofilaments) from the tip in the layer named <code>\"Mole(Sim)-0\"</code> by 0.1 nm.</p> <pre><code>ui.simulator.expand(\"Mole(Sim)-0\", by=0.1, yrange=(10, 20))\n</code></pre>"},{"location":"simulate/#local-twisting","title":"Local twisting","text":"<p> API: <code>twist</code></p> <p> GUI: <code>Simulator widget &gt;</code> </p>"},{"location":"simulate/#local-dilation","title":"Local dilation","text":"<p> API: <code>dilate</code></p> <p> GUI: <code>Simulator widget &gt;</code> </p>"},{"location":"simulate/#define-conformational-changes-by-expressions","title":"Define conformational changes by expressions","text":"<p> API: <code>displace</code></p> <p> GUI: <code>Simulator widget &gt;</code> </p> simulate supertwist <p>After seam-searching, column \"isotype-id\" will be added to the molecules layer, which indicates the alpha/beta isotype of each molecule.</p> <pre><code>dtheta = 0.05\nui.simulator.displace(\n    layer=\"Mole(Sim)-0\",\n    twist=pl.when(pl.col(\"isotype-id\").eq(1)).then(-dtheta).otherwise(dtheta)\n)\n</code></pre>"},{"location":"simulate/#asign-density-to-molecules","title":"Asign Density to Molecules","text":"<p> API: <code>add_component</code></p> <p> GUI: <code>Simulator widget &gt;</code> </p> <p>Note</p> <p>Before this step, you can run any operations on the molecules, such as filtration and split/combine.</p> <p>Once the molecules are ready, you have to assign a template image to each molecules layer for simulation. In this method, you can select image files and assign them to one of the molecules layers in the viewer. The image don't have to be scaled; it will automatically be rescaled to the pixel scale of the tomogram.</p> <p>Warning</p> <p>If you use more than one density, they should be in the same contrast range; otherwise, some components will be dimmer than others.</p>"},{"location":"simulate/#simulate-tomograms-from-molecules","title":"Simulate Tomograms from Molecules","text":"<p>There are several methods to simulate images from molecules.</p>"},{"location":"simulate/#1-simulate-tomograms-and-save-as-image-files","title":"1. Simulate tomograms and save as image files","text":"<p> API: <code>simulate_tomogram</code></p> <p> GUI: <code>Simulator widget &gt; Simulate &gt; Simulate tomogram</code></p> <p>This method is composed of following steps:</p> <ol> <li>Simulate tilt series: Tilt series images are simulated by summing all the    projections of registered densities. After this step,    you will get a \"perfect\" tilt series.</li> <li>Apply CTF (optional): Contrast transfer function (CTF) is applied to the tilt    series images, if CTF parameters are specified. If specified, the simulated CTF will    be plotted in the logger.</li> <li> <p>Add white Gaussian noise (optional): White Gaussian noise is added to the tilt    series images. Noise is defined by noise-to-signal ratio (NSR), where the \"signal\" is    the maximum intensity of the tilt series. You can specify multiple NSRs, as they use    the same tilt series prepared in the previous steps</p> Why the maximum intensity? <p>The maximum intensity is used to normalize the noise level for consistency between different type of input densities. You may think of using the mean intensity of the input density, but it will be affected by the size of the image; if you padded the image with zeros, the resulting tilt series is exactly the same but the noise level will be different.</p> </li> <li> <p>Simulate CTF correction (optional): In the daily cryo-ET analysis, CTF    correction is usually performed on the tilt series images. You can simulate this step    by setting the <code>correct</code> parameter.</p> </li> <li>Back-projection: The tilt series images are back-projected to generate a    tomogram. The height of the tomogram is automatically determined by the molecule    coordinates and the size of the input densities.</li> <li>Save as image files: The simulated tomograms are saved as image files. The    molecules used for simulation will also be saved as a project.</li> </ol>"},{"location":"simulate/#2-simulate-a-tomogram-and-open-it-in-the-viewer","title":"2. Simulate a tomogram and open it in the viewer","text":"<p> API: <code>simulate_tomogram_and_open</code></p> <p> GUI: <code>Simulator widget &gt; Simulate &gt; Simulate tomogram and open</code></p> <p>This method is similar to the previous one, but the simulated tomogram is immediately opened in the viewer. Because only one tomogram can be opened at a time, only one NSR can be specified.</p>"},{"location":"simulate/#3-simulate-tilt-series","title":"3. Simulate tilt series","text":"<p> API: <code>simulate_tilt_series</code></p> <p> GUI: <code>Simulator widget &gt; Simulate &gt; Simulate tilt series</code></p> <p>This method is used to simulate tilt series images from the registered densities, without back-projection. The simulated tilt series will be saved as an image stack.</p> <p>This method is usually combined with the next reconstruction method to repetitively generate multiple tomograms with different settings.</p>"},{"location":"simulate/#4-simulate-tomogram-from-a-tilt-series","title":"4. Simulate tomogram from a tilt series","text":"<p> API: <code>simulate_tomogram_from_tilt_series</code></p> <p> GUI: <code>Simulator widget &gt; Simulate &gt; Simulate tomogram from tilt series</code></p> <p>This method simply back-projects the tilt series images to generate a tomogram. The tilt axis is always the y-axis. If the tilt series is generated by the previous method, you can directly pass the file to this method. If you want to use the tilt series generated outside <code>cylindra</code>, it must be correctly aligned.</p>"},{"location":"workflows/","title":"Custom Workflows","text":"<p>Once you decided how to process your data, you may want to automate the workflow and repetitively apply the same operations to many images. Of course, everything is Python, so you can copy &amp; paste the macro script to somewhere.</p> <p>In <code>cylindra</code>, we provide a more elegant way to do this. You can define your own workflows, browse and edit them in the GUI, and run them manually or programmatically.</p>"},{"location":"workflows/#define-a-workflow","title":"Define a Workflow","text":"<p> GUI: <code>Others &gt; Workflows &gt; Define workflow</code> or Ctrl+K \u2192 Ctrl+Shift+D</p> <p></p> <p>In this dialog, you can define a workflow by writing a Python script. The script will be saved in the user directory as a file of the given \"file name\". Since <code>cylindra</code> is aware of all the files in the user directory, you don't have to keep them by yourself.</p>"},{"location":"workflows/#a-simple-example","title":"A simple example","text":"<p>The <code>main</code> function defined in the workflow will be called when the workflow is run. The first argument is always <code>ui</code>, the GUI object.</p> <p>Following workflow is a simple example that measure the local properties of all the splines and summarize the results in a histogram.</p> <pre><code>from cylindra.widgets import CylindraMainWidget\nimport matplotlib.pyplot as plt\n\ndef main(ui: \"CylindraMainWidget\"):\n    # fit and measure\n    ui.fit_splines(splines=\"all\")\n    ui.measure_radius(splines=\"all\", bin_size=2)\n    ui.local_cft_analysis(splines=\"all\", bin_size=2)\n\n    # plot histograms of lattice spacings\n    for spl in ui.splines:\n        plt.hist(spl.props.get_loc(\"spacing\"))\n    plt.show()\n</code></pre> <p>This workflow can be called at any time \u2192 Run Workflows.</p>"},{"location":"workflows/#workflow-with-input-parameters","title":"Workflow with input parameters","text":"<p>The main function accepts more input arguments. The function signature will be automatically interpreted by <code>magicgui</code> and converted into a dialog.</p> <p>Following workflow is a completely redundant function as it does no more than the <code>open_image</code> method, but it shows how to define a workflow with input parameters.</p> <pre><code>from pathlib import Path\nfrom cylindra.widgets import CylindraMainWidget\n\ndef main(\n    ui: \"CylindraMainWidget\",\n    path: Path,\n    tilt_range: tuple[float, float] = (-60, 60),\n):\n    ui.open_image(path, tilt_range=tilt_range)\n</code></pre> <p>The resulting dialog will be like this.</p> <p></p> <p>The <code>path</code> argument, which is annotated with <code>Path</code> type, will be converted into a file input box. The <code>tilt_range</code> argument, which is annotated with <code>tuple[float, float]</code> type, will be converted into two float input boxes.</p>"},{"location":"workflows/#view-edit-workflows","title":"View &amp; Edit Workflows","text":"<p> GUI: <code>Others &gt; Workflows &gt; View/Edit workflows</code> or Ctrl+K \u2192 Ctrl+Shift+E</p> <p></p> <p>Here you can see all the workflows defined in the user directory. You can also edit and overwrite them here. The workflows will be updated immediately, without restarting the application.</p>"},{"location":"workflows/#run-workflows","title":"Run Workflows","text":"<p> API: <code>run_workflow</code></p> <p> GUI: <code>Others &gt; Workflows &gt; Run workflow</code> or Ctrl+K \u2192 Ctrl+Shift+R</p> <p>Defined workflows show up in the <code>Others &gt; Workflows</code> menu. You can also open the dialog at <code>Others &gt; Workflows &gt; Run workflow</code> and select the workflow to run. If the workflow does not have any input arguments, it will be run immediately. If it has, a new dialog will be opened to ask for the input arguments.</p> <p>Note</p> <p>The defined workflows can also be found in the command palette (Ctrl+P) labeled as the file name.</p>"},{"location":"alignment/","title":"Subtomogram Alignment and Averaging","text":"<p>The subtomogram alignment and the subsequent averaging is the important part of the cryo-ET analysis workflows. <code>cylindra</code> provides methods to perform the analyses. In the GUI, these methods are all in a separate dock widget titled \"STA widget\". You can open via <code>Analysis &gt; Open STA widget</code> (Ctrl+K \u2192 S).</p> <p></p> <p>Since many methods share the same parameters, the STA widget uses the same widget for these parameters.</p> <ul> <li>Template: The template image. This parameter can be a path to an image file, a   list of paths for multi-template alignment, or use the last average image. Template   images don't have to be the same scale as the subtomogram images. They will be   rescaled to the same scale as the (binned) tomogram image.</li> <li>Mask: The mask image. You can create a mask by blurring the template, or supply   a mask image. To blur the template, you need to specify the \"dilate radius\" and   \"sigma\" parameters. These parameters are used to dilate the binarized template image   and soften the edges by Gaussian blurring.</li> </ul>"},{"location":"alignment/#index","title":"Index","text":"<ul> <li>Conventional Methods in Cryo-ET Studies</li> <li>Build Correlation Landscapes</li> <li>Viterbi Alignment</li> <li>Restricted Mesh Annealing (RMA)</li> </ul>"},{"location":"alignment/conventional/","title":"Conventional Methods in Cryo-ET Studies","text":"<p><code>cylindra</code> provides several common methods used in cryo-ET studies.</p>"},{"location":"alignment/conventional/#subtomogram-averaging","title":"Subtomogram Averaging","text":"<p> API: <code>average_all</code></p> <p> GUI: <code>STA widget &gt; Averaging &gt; Average all molecules</code></p> <p>This method uses one or more molecules-layer to calculate the subtomogram average.</p> <p></p> List of parameters <ol> <li>Select the template image in the \"template\" combobox of STA widget.</li> <li>\"layers\" is the molecules layer(s) that will be averaged. If you selected    multiple layers, all the molecules will be averaged to a single image.</li> <li>\"size (nm)\" is the size of the output image. If not given, it tries to use the    size of the template image. It will raise an error if the size cannot be    unambiguously determined.</li> <li>\"interpolation\" is the interpolation method used for resampling the sub-    volumes.</li> <li>\"bin size\" is the binning factor for resampling.</li> </ol> <p>After running the method, a new <code>napari</code> viewer will be opened to show the average image. This viewer can be accessed via <code>ui.sta.sub_viewer</code>.</p> <p></p> <p>Note</p> <p>There are more options for averaging molecules in the <code>Averaging</code> menu:</p> <ul> <li> <p><code>average_subset</code></p> </li> <li> <p><code>average_groups</code></p> </li> <li> <p><code>average_filtered</code></p> </li> </ul>"},{"location":"alignment/conventional/#subtomogram-alignment","title":"Subtomogram Alignment","text":"<p> API: <code>align_all</code></p> <p> GUI: <code>STA widget &gt; Alignment &gt; Align all molecules</code></p> <p></p> <p>Alignment is a step in which each coordinate of a molecules layer is updated to maximize the correlation score between the subtomogram around the molecule and the template image. New molecules layer will be suffixed with \"ALN1\", \"ALN2\", etc.</p> List of parameters <ol> <li>Set the template image and mask parameters in the STA widget.</li> <li>\"layers\" is the molecules layer(s) that will be averaged. If you selected    multiple layers, all the molecules will be averaged to a single image.</li> <li>\"Max shifts (nm)\" is the maximum allowed shift in (z, y, x) direction.</li> <li>\"rotations\" is the maximum allowed rotation angles in degree around each axis.    Two <code>float</code> values are expected for each axis. <code>(a, b)</code> means the rotation    angle will be between <code>-a</code> and <code>a</code> with step <code>b</code>. For example, <code>(4, 2)</code> means    the rotation angles will be <code>-4</code>, <code>-2</code>, <code>0</code>, <code>2</code>, <code>4</code>.</li> <li>\"cutoff\" is the relative cutoff frequency of the low-pass filter.</li> <li>\"interpolation\" is the interpolation method used for resampling the sub-    volumes.</li> <li>\"method\" is the method used to calculate cross correlation.</li> <li>\"bin size\" is the binning factor for resampling.</li> </ol>"},{"location":"alignment/conventional/#align-averaged-image","title":"Align Averaged Image","text":"<p> API: <code>align_averaged</code></p> <p> GUI: <code>STA widget &gt; Alignment &gt; Align average to template</code></p> <p>This method is mostly used after molecules are initialized by <code>map_monomers</code>. It first calculates the average, then fit the average to the template image. The optimal fitting parameters are then used to shift and rotate all the molecules. It means that if you run <code>average_all</code> on the aligned molecules, the average image should be almost well fitted to the template image.</p> <p></p> List of parameters <ol> <li>Select the template image and mask parameters in the STA widget. The mask is    usually not needed, as the average image does not have much noise outside.</li> <li>\"layers\" is the molecules layer(s) that will be averaged. If you selected    multiple layers, all the molecules will be averaged to a single image.</li> <li>\"Max shifts (nm)\" is the maximum allowed shift in (z, y, x) direction. If not    lattice parameters will be used to infer the maximum shift, so you don't have    to set this parameter in most cases.</li> <li>\"rotations\" is the maximum allowed rotation angles in degree around each axis.    Two <code>float</code> values are expected for each axis. <code>(a, b)</code> means the rotation    angle will be between <code>-a</code> and <code>a</code> with step <code>b</code>. For example, <code>(4, 2)</code> means    the rotation angles will be <code>-4</code>, <code>-2</code>, <code>0</code>, <code>2</code>, <code>4</code>.</li> <li>\"bin size\" is the binning factor for resampling.</li> <li>\"method\" is the method used to calculate cross correlation.</li> </ol>"},{"location":"alignment/conventional/#template-free-alignment","title":"Template-free Alignment","text":"<p> API: <code>align_all_template_free</code></p> <p> GUI: <code>STA widget &gt; Alignment &gt; Align all molecules (template-free)</code></p> <p>This method iteratively align molecules to the current average image, and validate the alignment by FSC.</p> <p></p>"},{"location":"alignment/conventional/#fourier-shell-correlation-fsc","title":"Fourier Shell Correlation (FSC)","text":"<p> API: <code>calculate_fsc</code></p> <p> GUI: <code>STA widget &gt; Analysis &gt; Calculate FSC</code></p> <p>This method automatically split the selected molecules into two groups, and calculate the Fourier Shell Correlation (FSC) between the two groups. The FSC curve will be shown in the logger widget. Since the average image can easily be calculated after FSC, this method also adds the average image to the sub-viewer as <code>average_all</code> does. The FSC results will also be stored in the <code>metadata</code> attribute of the image layer for the average image.</p> <p></p> List of parameters <ol> <li>Set the mask parameters (and the template image if you are going to create the    mask from the template) in the STA widget.</li> <li>\"layers\" is the molecules layer(s) that will be averaged. If you selected    multiple layers, all the molecules will be averaged to a single image.</li> <li>\"size (nm)\" is the size of the output image. If not given, it tries to use the    size of the template image. It will raise an error if the size cannot be    unambiguously determined.</li> <li>\"seed\" is the random seed value used to split the molecules into two groups.</li> <li>\"interpolation\" is the interpolation method used for resampling the sub-    volumes.</li> <li>You can set \"number of image pairs\" if you want to split molecules many times to    get a more accurate FSC curve.</li> <li>Uncheck \"show average\" if it is not needed.</li> <li>\"Frequency precision\" will be automatically determined but you can set it    manually.</li> </ol> <p>Note</p> <p>Half maps can be found in <code>\"fsc_halfmaps\"</code> attribute of the average image layer.</p> <pre><code>    ui.sub_viewer.layers[\"layer-name\"].metadata[\"fsc_halfmaps\"]\n</code></pre>"},{"location":"alignment/conventional/#pcak-means-classification","title":"PCA/K-means Classification","text":"<p> API: <code>classify_pca</code></p> <p> GUI: <code>STA widget &gt; Analysis &gt; PCA/K-means classification</code></p> <p></p>"},{"location":"alignment/landscape/","title":"Build Correlation Landscapes","text":"<p>Subtomogram alignment algorithms are usually implemented by maximizing the cross- correlation between the subtomograms and a template image. Instead of searching for the optimal parameter, we can calculate the correlation for all possible parameters and visualize the correlation as a n-dimensional heatmap. This heatmap is reminiscent of the \"energy landscape\" so we'll call it \"correlation landscape\".</p>"},{"location":"alignment/landscape/#construct-a-correlation-landscape","title":"Construct a Correlation Landscape","text":"<p> API: <code>construct_landscape</code></p> <p> GUI: <code>Subtomogram Averaging &gt; Landscape &gt; Construct landscape</code></p> <p>This method will calculate the correlation landscape around selected molecules.</p> <p></p> List of parameters <ol> <li>Set the template image and mask parameters in the STA widget.</li> <li>\"layer\" is the molecules layer that will be used to construct the landscape.</li> <li>\"Max shifts (nm)\" is the maximum allowed shift in (z, y, x) direction.</li> <li>\"rotations\" is the maximum allowed rotation angles in degree around each axis.    Two <code>float</code> values are expected for each axis. <code>(a, b)</code> means the rotation    angle will be between <code>-a</code> and <code>a</code> with step <code>b</code>. For example, <code>(4, 2)</code> means    the rotation angles will be <code>-4</code>, <code>-2</code>, <code>0</code>, <code>2</code>, <code>4</code>.</li> <li>\"cutoff\" is the relative cutoff frequency of the low-pass filter.</li> <li>\"interpolation\" is the interpolation method used for resampling the sub-    volumes.</li> <li>\"upsample factor\" defines how many times the correlation landscape will be    upsampled. <code>5</code> means that the voxel size of the resulting landscape will be 1/5    of the original image.</li> </ol>"},{"location":"alignment/landscape/#visualizing-the-landscape","title":"Visualizing the Landscape","text":"<p>After the landscape construction, a <code>Landscape</code> layer, a subclass of <code>Surface</code> layer will be added to the viewer. A <code>Landscape</code> layer shows the surface of an arbitrary threshold. You can adjust the threshold value in the layer control.</p>"},{"location":"alignment/rma/","title":"Restricted Mesh Annealing (RMA)","text":"<p>Restricted Mesh Annealing (RMA) is a constrained subtomogram alignment algorithm that was introduced in our work. It imposes longitudinal and lateral constraints between molecules and optimize the alignment score using simulated annealing.</p> <p>As an example of using RMA, see the case study.</p>"},{"location":"alignment/rma/#run-rma-on-a-landscape","title":"Run RMA on a Landscape","text":"<p> API: <code>run_rma_on_landscape</code></p> <p> GUI: <code>Subtomogram Averaging &gt; Landscape &gt; Run annealing (RMA)</code></p> <p></p> List of Parameters <ol> <li>Select the landscape in the \"landscape layer\" combobox.</li> <li>\"Longitudinal range (nm)\" is the constrant of the longitudinal distance between    neighboring molecules.</li> <li>\"Lateral range (nm)\" is the constrant of the lateral distance between    neighboring molecules.</li> <li>\"Maximum angle (deg)\" is the another constraint. It is the maximum allowed    angle between the spline tangent and the vector connecting the two molecules.</li> <li>\"temperature time const\" is the time constant of the simulated annealing. Larger    value means slower annealing. <code>1.0</code> is usually a good value.</li> <li>\"random seeds\" is the seed values for the random number generator. The \"Add\"    button will randomly add a new seed value.</li> <li>You can preview the distribution of the longitudinal/lateral distances by    clicking the \"Preview molecule network\" button.</li> </ol>"},{"location":"alignment/rma/#run-rma-without-constructing-a-landscape","title":"Run RMA without Constructing a Landscape","text":"<p> API: <code>align_all_rma</code></p> <p> GUI: <code>Subtomogram Averaging &gt; Alignment &gt; Simulated Annealing</code></p> <p></p>"},{"location":"alignment/rma/#template-free-rma","title":"Template-free RMA","text":"<p> API: <code>align_all_rma_template_free</code></p> <p> GUI: <code>Subtomogram Averaging &gt; Alignment &gt; Simulated annealing (RMA, template free)</code></p> <p>This method will iteratively construct landscape, align molecules by RMA, and validate the result by FSC. This method is useful when you know that the structure of interest is a cylindrical structure, but you do not know the monomer structure.</p>"},{"location":"alignment/viterbi/","title":"Viterbi Alignment","text":"<p>Viterbi Alignment is a constrained subtomogram alignment algorithm that was introduced in our work. It imposes longitudinal constraints between neighboring molecules and optimize the alignment score using the Viterbi algorithm.</p> <p>Since Viterbi Alignment only consider the longitudinal constraints, all the molecules are split into each protofilament and aligned independently in parallel.</p>"},{"location":"alignment/viterbi/#run-viterbi-alignment-on-a-landscape","title":"Run Viterbi Alignment on a Landscape","text":"<p> API: <code>run_viterbi_on_landscape</code></p> <p> GUI: <code>Subtomogram Averaging &gt; Landscape &gt; Run Viterbi alignment on landscape</code></p> <p></p> List of Parameters <ol> <li>Select the landscape in the \"landscape layer\" combobox.</li> <li>\"Longitudinal range (nm)\" is the constrant of the longitudinal distance between    neighboring molecules.</li> <li>\"Maximum angle (deg)\" is the another constraint. It is the maximum allowed    angle between the spline tangent and the vector connecting the two molecules.</li> </ol>"},{"location":"alignment/viterbi/#run-viterbi-alignment-without-constructing-a-landscape","title":"Run Viterbi Alignment without Constructing a Landscape","text":"<p> API: <code>align_all_viterbi</code></p> <p> GUI: <code>Subtomogram Averaging &gt; Alignment &gt; Viterbi Alignment</code></p> <p></p>"},{"location":"api/","title":"API Reference","text":"<p>This section includes the API references of <code>cylindra</code>.</p>"},{"location":"api/components/","title":"cylindra.components","text":""},{"location":"api/components/#cylindra.components.spline.CylSpline","title":"<code>CylSpline</code>","text":"<p>               Bases: <code>Spline</code></p> <p>A spline object with cylindrical structure.</p> Source code in <code>cylindra/components/spline/_cyl_spline.py</code> <pre><code>class CylSpline(Spline):\n    \"\"\"A spline object with cylindrical structure.\"\"\"\n\n    @property\n    def radius(self) -&gt; nm | None:\n        \"\"\"Average radius of the cylinder.\"\"\"\n        return self.props.get_glob(H.radius, None)\n\n    @radius.setter\n    def radius(self, value: nm | None):\n        if value is None:\n            if H.radius in self.props.glob.columns:\n                self.props.drop_glob(H.radius)\n            return None\n        value = float(value)\n        if value &lt;= 0:\n            raise ValueError(\"Radius must be positive.\")\n        elif value != value:\n            raise ValueError(\"Radius got NaN value.\")\n        self.props.update_glob([pl.Series(H.radius, [value], dtype=pl.Float32)])\n        return None\n\n    def radius_range(self, rc: nm | None = None) -&gt; tuple[nm, nm]:\n        \"\"\"Return the range of the radius used for the cylindric coordinate.\"\"\"\n        if rc is None:\n            if self.radius is None:\n                raise ValueError(\"Radius is not set.\")\n            rc = self.radius\n        cfg = self.config\n        return (max(rc - cfg.thickness_inner, 0.0), rc + cfg.thickness_outer)\n\n    @property\n    def orientation(self) -&gt; Ori:\n        \"\"\"Orientation of the spline.\"\"\"\n        return Ori(str(self.props.get_glob(H.orientation, \"none\")))\n\n    @orientation.setter\n    def orientation(self, value: Ori | str | None):\n        if value is None:\n            value = Ori.none\n        else:\n            value = Ori(value)\n        self.props.update_glob([pl.Series(H.orientation, [str(value)])])\n        return None\n\n    def invert(self) -&gt; CylSpline:\n        \"\"\"\n        Invert the direction of spline. Also invert orientation if exists.\n\n        Returns\n        -------\n        CylSpline\n            Inverted object\n        \"\"\"\n        # NOTE: invert() calls clip() internally.\n        # We don't have to invert the orientation here.\n        new = super().invert()\n        new.props.update_loc(self.props.loc[::-1], self.props.window_size)\n        return new\n\n    def clip(self, start: float, stop: float) -&gt; CylSpline:\n        \"\"\"\n        Clip spline and generate a new one.\n\n        This method does not convert spline bases. ``_lims`` is updated instead.\n        For instance, if you want to clip spline at 20% to 80% position, call\n        ``spl.clip(0.2, 0.8)``. If ``stop &lt; start``, the orientation of spline\n        will be inverted, thus the ``orientation`` attribute will also be inverted.\n\n        Parameters\n        ----------\n        start : float\n            New starting position.\n        stop : float\n            New stopping position.\n\n        Returns\n        -------\n        CylSpline\n            Clipped spline.\n        \"\"\"\n        clipped = super().clip(start, stop)\n\n        clipped.props.glob = self.props.glob.clone()\n        clipped.props._binsize_glob = self.props._binsize_glob.copy()\n        if start &gt; stop:\n            clipped.orientation = Ori.invert(self.orientation)\n        else:\n            clipped.orientation = self.orientation\n        return clipped\n\n    def restore(self) -&gt; CylSpline:\n        \"\"\"\n        Restore the original, not-clipped spline.\n\n        Returns\n        -------\n        Spline\n            Copy of the original spline.\n        \"\"\"\n        original = super().restore()\n        start, stop = self._lims\n        if start &gt; stop:\n            original.orientation = Ori.invert(self.orientation)\n        else:\n            original.orientation = self.orientation\n        return original\n\n    def nrise(self, **kwargs) -&gt; int:\n        \"\"\"Raw start number (minus for microtubule)\"\"\"\n        if H.start in kwargs:\n            start = kwargs[H.start]\n        elif H.start in self.props.glob.columns:\n            start = self.props.get_glob(H.start)\n        else:\n            start = self.cylinder_params(**kwargs).start\n        return start * self.config.rise_sign\n\n    def cylinder_params(self, **kwargs) -&gt; CylinderParameters:\n        \"\"\"Get the cylinder parameters of the spline.\"\"\"\n        radius = _get_globalprops(self, kwargs, H.radius)\n        if radius is None:\n            raise ValueError(\"Radius is not known.\")\n        radius += (self.config.thickness_outer - self.config.thickness_inner) / 2\n        return CylinderParameters.solve(\n            spacing=_get_globalprops(self, kwargs, H.spacing),\n            pitch=_get_globalprops(self, kwargs, H.pitch),\n            twist=_get_globalprops(self, kwargs, H.twist),\n            skew=_get_globalprops(self, kwargs, H.skew),\n            rise_angle=_get_globalprops(self, kwargs, H.rise),\n            radius=radius,\n            npf=_get_globalprops(self, kwargs, H.npf),\n            start=_get_globalprops(self, kwargs, H.start),\n            allow_duplicate=True,\n            rise_sign=self.config.rise_sign,\n        )\n\n    def cylinder_model(\n        self,\n        offsets: tuple[float, float] = (0.0, 0.0),\n        **kwargs,\n    ) -&gt; CylinderModel:\n        \"\"\"\n        Return the cylinder model of the spline.\n\n        Parameters\n        ----------\n        offsets : tuple of float, optional\n            Offset of the model. See :meth:`map_monomers` for details.\n\n        Returns\n        -------\n        CylinderModel\n            The cylinder model.\n        \"\"\"\n        length = self.length()\n        cp = self.cylinder_params(**kwargs)\n        ly = cp.spacing_proj\n        la = cp.lat_spacing_proj\n        factor = ly / la\n        ny = roundint(length / ly) + 1  # number of monomers in y-direction\n\n        if offsets is None:\n            offsets = (0.0, 0.0)\n\n        return CylinderModel(\n            shape=(ny, cp.npf),\n            tilts=(\n                cp.tan_skew * factor,\n                cp.tan_rise_raw / factor,\n            ),\n            intervals=(ly, la / cp.perimeter * 2 * np.pi),\n            radius=cp.radius,\n            offsets=offsets,\n        )\n\n    def update_props(\n        self,\n        *,\n        npf: int | None = None,\n        start: int | None = None,\n        orientation: Ori | str | None = None,\n    ) -&gt; CylSpline:\n        \"\"\"Update the npf or orientation parameters in place.\"\"\"\n\n        loc = list[pl.Expr]()\n        glob = list[pl.Series]()\n        if npf is not None:\n            loc.append(pl.repeat(npf, pl.len()).cast(pl.UInt8).alias(H.npf))\n            glob.append(pl.Series([npf]).cast(pl.UInt8).alias(H.npf))\n        if start is not None:\n            loc.append(pl.repeat(start, pl.len()).cast(pl.Int8).alias(H.start))\n            glob.append(pl.Series([start]).cast(pl.Int8).alias(H.start))\n        if orientation is not None:\n            glob.append(\n                pl.Series([str(orientation)]).cast(pl.String).alias(H.orientation)\n            )\n\n        self.props.loc = with_columns(self.props.loc, loc)\n        self.props.glob = with_columns(self.props.glob, glob)\n\n        if start is not None:\n            # because rises are dependent on start, they need to be recalculated\n            self.props.drop_loc([H.rise, H.rise_length], strict=False)\n            self.props.drop_glob([H.rise, H.rise_length], strict=False)\n            try:\n                cp = self.cylinder_params()\n            except ValueError:\n                pass  # not enouph properties to calculate cylinder parameters\n            else:\n                self.props.loc = with_columns(\n                    self.props.loc,\n                    [pl.repeat(cp.rise_angle, pl.len()).cast(pl.Float32).alias(H.rise)],\n                )\n                self.props.glob = with_columns(\n                    self.props.glob,\n                    [pl.Series([cp.rise_angle]).cast(pl.Float32).alias(H.rise)],\n                )\n                self.props.loc = with_columns(\n                    self.props.loc,\n                    [\n                        pl.repeat(cp.rise_length, pl.len())\n                        .cast(pl.Float32)\n                        .alias(H.rise_length)\n                    ],\n                )\n                self.props.glob = with_columns(\n                    self.props.glob,\n                    [pl.Series([cp.rise_length]).cast(pl.Float32).alias(H.rise_length)],\n                )\n        return self\n\n    def update_glob_by_cylinder_params(self, cparams: CylinderParameters) -&gt; CylSpline:\n        \"\"\"Update the global properties using a CylinderParameters object.\"\"\"\n        props = {\n            H.rise: cparams.rise_angle,\n            H.rise_length: cparams.rise_length,\n            H.pitch: cparams.pitch,\n            H.spacing: cparams.spacing,\n            H.skew: cparams.skew,\n            H.twist: cparams.twist,\n            H.npf: cparams.npf,\n            H.start: cparams.start,\n            H.radius: cparams.radius,\n        }\n        self.props.update_glob(props)\n        return self\n\n    def _need_rotation(self, orientation: Ori | str | None) -&gt; bool:\n        if orientation is not None:\n            orientation = Ori(orientation)\n            if orientation is Ori.none or self.orientation is Ori.none:\n                raise ValueError(\n                    \"Unknown orientation. Set the spline orientation or explicitly set \"\n                    \" the orientation input.\"\n                )\n            if orientation is not self.orientation:\n                return True\n        return False\n</code></pre>"},{"location":"api/components/#cylindra.components.spline.CylSpline.orientation","title":"<code>orientation</code>  <code>property</code> <code>writable</code>","text":"<p>Orientation of the spline.</p>"},{"location":"api/components/#cylindra.components.spline.CylSpline.radius","title":"<code>radius</code>  <code>property</code> <code>writable</code>","text":"<p>Average radius of the cylinder.</p>"},{"location":"api/components/#cylindra.components.spline.CylSpline.clip","title":"<code>clip(start, stop)</code>","text":"<p>Clip spline and generate a new one.</p> <p>This method does not convert spline bases. <code>_lims</code> is updated instead. For instance, if you want to clip spline at 20% to 80% position, call <code>spl.clip(0.2, 0.8)</code>. If <code>stop &lt; start</code>, the orientation of spline will be inverted, thus the <code>orientation</code> attribute will also be inverted.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>float</code> <p>New starting position.</p> required <code>stop</code> <code>float</code> <p>New stopping position.</p> required <p>Returns:</p> Type Description <code>CylSpline</code> <p>Clipped spline.</p> Source code in <code>cylindra/components/spline/_cyl_spline.py</code> <pre><code>def clip(self, start: float, stop: float) -&gt; CylSpline:\n    \"\"\"\n    Clip spline and generate a new one.\n\n    This method does not convert spline bases. ``_lims`` is updated instead.\n    For instance, if you want to clip spline at 20% to 80% position, call\n    ``spl.clip(0.2, 0.8)``. If ``stop &lt; start``, the orientation of spline\n    will be inverted, thus the ``orientation`` attribute will also be inverted.\n\n    Parameters\n    ----------\n    start : float\n        New starting position.\n    stop : float\n        New stopping position.\n\n    Returns\n    -------\n    CylSpline\n        Clipped spline.\n    \"\"\"\n    clipped = super().clip(start, stop)\n\n    clipped.props.glob = self.props.glob.clone()\n    clipped.props._binsize_glob = self.props._binsize_glob.copy()\n    if start &gt; stop:\n        clipped.orientation = Ori.invert(self.orientation)\n    else:\n        clipped.orientation = self.orientation\n    return clipped\n</code></pre>"},{"location":"api/components/#cylindra.components.spline.CylSpline.cylinder_model","title":"<code>cylinder_model(offsets=(0.0, 0.0), **kwargs)</code>","text":"<p>Return the cylinder model of the spline.</p> <p>Parameters:</p> Name Type Description Default <code>offsets</code> <code>tuple of float</code> <p>Offset of the model. See :meth:<code>map_monomers</code> for details.</p> <code>(0.0, 0.0)</code> <p>Returns:</p> Type Description <code>CylinderModel</code> <p>The cylinder model.</p> Source code in <code>cylindra/components/spline/_cyl_spline.py</code> <pre><code>def cylinder_model(\n    self,\n    offsets: tuple[float, float] = (0.0, 0.0),\n    **kwargs,\n) -&gt; CylinderModel:\n    \"\"\"\n    Return the cylinder model of the spline.\n\n    Parameters\n    ----------\n    offsets : tuple of float, optional\n        Offset of the model. See :meth:`map_monomers` for details.\n\n    Returns\n    -------\n    CylinderModel\n        The cylinder model.\n    \"\"\"\n    length = self.length()\n    cp = self.cylinder_params(**kwargs)\n    ly = cp.spacing_proj\n    la = cp.lat_spacing_proj\n    factor = ly / la\n    ny = roundint(length / ly) + 1  # number of monomers in y-direction\n\n    if offsets is None:\n        offsets = (0.0, 0.0)\n\n    return CylinderModel(\n        shape=(ny, cp.npf),\n        tilts=(\n            cp.tan_skew * factor,\n            cp.tan_rise_raw / factor,\n        ),\n        intervals=(ly, la / cp.perimeter * 2 * np.pi),\n        radius=cp.radius,\n        offsets=offsets,\n    )\n</code></pre>"},{"location":"api/components/#cylindra.components.spline.CylSpline.cylinder_params","title":"<code>cylinder_params(**kwargs)</code>","text":"<p>Get the cylinder parameters of the spline.</p> Source code in <code>cylindra/components/spline/_cyl_spline.py</code> <pre><code>def cylinder_params(self, **kwargs) -&gt; CylinderParameters:\n    \"\"\"Get the cylinder parameters of the spline.\"\"\"\n    radius = _get_globalprops(self, kwargs, H.radius)\n    if radius is None:\n        raise ValueError(\"Radius is not known.\")\n    radius += (self.config.thickness_outer - self.config.thickness_inner) / 2\n    return CylinderParameters.solve(\n        spacing=_get_globalprops(self, kwargs, H.spacing),\n        pitch=_get_globalprops(self, kwargs, H.pitch),\n        twist=_get_globalprops(self, kwargs, H.twist),\n        skew=_get_globalprops(self, kwargs, H.skew),\n        rise_angle=_get_globalprops(self, kwargs, H.rise),\n        radius=radius,\n        npf=_get_globalprops(self, kwargs, H.npf),\n        start=_get_globalprops(self, kwargs, H.start),\n        allow_duplicate=True,\n        rise_sign=self.config.rise_sign,\n    )\n</code></pre>"},{"location":"api/components/#cylindra.components.spline.CylSpline.invert","title":"<code>invert()</code>","text":"<p>Invert the direction of spline. Also invert orientation if exists.</p> <p>Returns:</p> Type Description <code>CylSpline</code> <p>Inverted object</p> Source code in <code>cylindra/components/spline/_cyl_spline.py</code> <pre><code>def invert(self) -&gt; CylSpline:\n    \"\"\"\n    Invert the direction of spline. Also invert orientation if exists.\n\n    Returns\n    -------\n    CylSpline\n        Inverted object\n    \"\"\"\n    # NOTE: invert() calls clip() internally.\n    # We don't have to invert the orientation here.\n    new = super().invert()\n    new.props.update_loc(self.props.loc[::-1], self.props.window_size)\n    return new\n</code></pre>"},{"location":"api/components/#cylindra.components.spline.CylSpline.nrise","title":"<code>nrise(**kwargs)</code>","text":"<p>Raw start number (minus for microtubule)</p> Source code in <code>cylindra/components/spline/_cyl_spline.py</code> <pre><code>def nrise(self, **kwargs) -&gt; int:\n    \"\"\"Raw start number (minus for microtubule)\"\"\"\n    if H.start in kwargs:\n        start = kwargs[H.start]\n    elif H.start in self.props.glob.columns:\n        start = self.props.get_glob(H.start)\n    else:\n        start = self.cylinder_params(**kwargs).start\n    return start * self.config.rise_sign\n</code></pre>"},{"location":"api/components/#cylindra.components.spline.CylSpline.radius_range","title":"<code>radius_range(rc=None)</code>","text":"<p>Return the range of the radius used for the cylindric coordinate.</p> Source code in <code>cylindra/components/spline/_cyl_spline.py</code> <pre><code>def radius_range(self, rc: nm | None = None) -&gt; tuple[nm, nm]:\n    \"\"\"Return the range of the radius used for the cylindric coordinate.\"\"\"\n    if rc is None:\n        if self.radius is None:\n            raise ValueError(\"Radius is not set.\")\n        rc = self.radius\n    cfg = self.config\n    return (max(rc - cfg.thickness_inner, 0.0), rc + cfg.thickness_outer)\n</code></pre>"},{"location":"api/components/#cylindra.components.spline.CylSpline.restore","title":"<code>restore()</code>","text":"<p>Restore the original, not-clipped spline.</p> <p>Returns:</p> Type Description <code>Spline</code> <p>Copy of the original spline.</p> Source code in <code>cylindra/components/spline/_cyl_spline.py</code> <pre><code>def restore(self) -&gt; CylSpline:\n    \"\"\"\n    Restore the original, not-clipped spline.\n\n    Returns\n    -------\n    Spline\n        Copy of the original spline.\n    \"\"\"\n    original = super().restore()\n    start, stop = self._lims\n    if start &gt; stop:\n        original.orientation = Ori.invert(self.orientation)\n    else:\n        original.orientation = self.orientation\n    return original\n</code></pre>"},{"location":"api/components/#cylindra.components.spline.CylSpline.update_glob_by_cylinder_params","title":"<code>update_glob_by_cylinder_params(cparams)</code>","text":"<p>Update the global properties using a CylinderParameters object.</p> Source code in <code>cylindra/components/spline/_cyl_spline.py</code> <pre><code>def update_glob_by_cylinder_params(self, cparams: CylinderParameters) -&gt; CylSpline:\n    \"\"\"Update the global properties using a CylinderParameters object.\"\"\"\n    props = {\n        H.rise: cparams.rise_angle,\n        H.rise_length: cparams.rise_length,\n        H.pitch: cparams.pitch,\n        H.spacing: cparams.spacing,\n        H.skew: cparams.skew,\n        H.twist: cparams.twist,\n        H.npf: cparams.npf,\n        H.start: cparams.start,\n        H.radius: cparams.radius,\n    }\n    self.props.update_glob(props)\n    return self\n</code></pre>"},{"location":"api/components/#cylindra.components.spline.CylSpline.update_props","title":"<code>update_props(*, npf=None, start=None, orientation=None)</code>","text":"<p>Update the npf or orientation parameters in place.</p> Source code in <code>cylindra/components/spline/_cyl_spline.py</code> <pre><code>def update_props(\n    self,\n    *,\n    npf: int | None = None,\n    start: int | None = None,\n    orientation: Ori | str | None = None,\n) -&gt; CylSpline:\n    \"\"\"Update the npf or orientation parameters in place.\"\"\"\n\n    loc = list[pl.Expr]()\n    glob = list[pl.Series]()\n    if npf is not None:\n        loc.append(pl.repeat(npf, pl.len()).cast(pl.UInt8).alias(H.npf))\n        glob.append(pl.Series([npf]).cast(pl.UInt8).alias(H.npf))\n    if start is not None:\n        loc.append(pl.repeat(start, pl.len()).cast(pl.Int8).alias(H.start))\n        glob.append(pl.Series([start]).cast(pl.Int8).alias(H.start))\n    if orientation is not None:\n        glob.append(\n            pl.Series([str(orientation)]).cast(pl.String).alias(H.orientation)\n        )\n\n    self.props.loc = with_columns(self.props.loc, loc)\n    self.props.glob = with_columns(self.props.glob, glob)\n\n    if start is not None:\n        # because rises are dependent on start, they need to be recalculated\n        self.props.drop_loc([H.rise, H.rise_length], strict=False)\n        self.props.drop_glob([H.rise, H.rise_length], strict=False)\n        try:\n            cp = self.cylinder_params()\n        except ValueError:\n            pass  # not enouph properties to calculate cylinder parameters\n        else:\n            self.props.loc = with_columns(\n                self.props.loc,\n                [pl.repeat(cp.rise_angle, pl.len()).cast(pl.Float32).alias(H.rise)],\n            )\n            self.props.glob = with_columns(\n                self.props.glob,\n                [pl.Series([cp.rise_angle]).cast(pl.Float32).alias(H.rise)],\n            )\n            self.props.loc = with_columns(\n                self.props.loc,\n                [\n                    pl.repeat(cp.rise_length, pl.len())\n                    .cast(pl.Float32)\n                    .alias(H.rise_length)\n                ],\n            )\n            self.props.glob = with_columns(\n                self.props.glob,\n                [pl.Series([cp.rise_length]).cast(pl.Float32).alias(H.rise_length)],\n            )\n    return self\n</code></pre>"},{"location":"api/components/#cylindra.components.spline.Spline","title":"<code>Spline</code>","text":"<p>               Bases: <code>BaseComponent</code></p> <p>3D spline curve model with coordinate system.</p> <p>Anchor points can be set via <code>anchor</code> property. A spline object is semi-immutable. Different spline curves are always of different objects, but the anchors and properties can be dynamically changed.</p> References <ul> <li>Scipy document   https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.splprep.html</li> </ul> Source code in <code>cylindra/components/spline/_spline_base.py</code> <pre><code>class Spline(BaseComponent):\n    \"\"\"3D spline curve model with coordinate system.\n\n    Anchor points can be set via `anchor` property. A spline object is semi-immutable.\n    Different spline curves are always of different objects, but the anchors and\n    properties can be dynamically changed.\n\n    References\n    ----------\n    - Scipy document\n      https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.splprep.html\n    \"\"\"\n\n    def __init__(\n        self,\n        order: int = 3,\n        *,\n        lims: tuple[float, float] = (0.0, 1.0),\n        extrapolate: ExtrapolationMode | str = ExtrapolationMode.linear,\n        config: dict[str, Any] | SplineConfig = {},\n    ):\n        self._tck: TCKType = (None, None, order)\n        self._u: NDArray[np.float32] | None = None\n        self._anchors: NDArray[np.float32] | None = None\n        self._extrapolate = ExtrapolationMode(extrapolate)\n\n        self._lims = lims\n        self._props = SplineProps()\n        if isinstance(config, SplineConfig):\n            self._config = config\n        else:\n            self._config = SplineConfig.construct(**config)\n\n    @property\n    def props(self) -&gt; SplineProps:\n        \"\"\"Return the spline properties\"\"\"\n        return self._props\n\n    @property\n    def config(self) -&gt; SplineConfig:\n        \"\"\"Return the spline configuration\"\"\"\n        return self._config\n\n    def has_props(self) -&gt; bool:\n        \"\"\"True if there are any properties.\"\"\"\n        return len(self.props.loc) &gt; 0 or len(self.props.glob) &gt; 0\n\n    def copy(self, copy_props: bool = True, copy_config: bool = True) -&gt; Self:\n        \"\"\"Copy Spline object.\n\n        Parameters\n        ----------\n        copy_props : bool, default True\n            Also copy local/global properties if true.\n\n        Returns\n        -------\n        Spline\n            Copied object.\n        \"\"\"\n        new = self.__class__(\n            order=self.order, lims=self._lims, extrapolate=self.extrapolate\n        )\n        new._tck = self._tck\n        new._u = self._u\n        new._anchors = self._anchors\n\n        if copy_props:\n            new._props = self.props.copy()\n        if copy_config:\n            new._config = self.config.copy()\n        return new\n\n    __copy__ = copy\n\n    def with_extrapolation(self, extrapolate: ExtrapolationMode | str) -&gt; Self:\n        \"\"\"Return a copy of the spline with a new extrapolation mode.\"\"\"\n        new = self.copy()\n        new._extrapolate = ExtrapolationMode(extrapolate)\n        return new\n\n    def with_config(\n        self,\n        config: dict[str, Any] | SplineConfig,\n        copy_props: bool = False,\n    ) -&gt; Self:\n        \"\"\"Return a copy of the spline with a new config.\"\"\"\n        new = self.copy(copy_props=copy_props, copy_config=False)\n        if not isinstance(config, SplineConfig):\n            config = SplineConfig.construct(**config)\n        new._config = config\n        return new\n\n    @property\n    def knots(self) -&gt; np.ndarray:\n        \"\"\"Spline knots.\"\"\"\n        return self._tck[0]\n\n    @property\n    def coeff(self) -&gt; list[np.ndarray]:\n        \"\"\"Spline coefficient.\"\"\"\n        return self._tck[1]\n\n    @property\n    def order(self) -&gt; int:\n        \"\"\"Spline order.\"\"\"\n        return self._tck[2]\n\n    @property\n    def extrapolate(self) -&gt; ExtrapolationMode:\n        \"\"\"Extrapolation mode of the spline.\"\"\"\n        return self._extrapolate\n\n    @property\n    def params(self) -&gt; np.ndarray:\n        \"\"\"Spline parameters.\"\"\"\n        return self._u\n\n    @classmethod\n    def line(\n        cls,\n        start: ArrayLike,\n        end: ArrayLike,\n        extrapolate: ExtrapolationMode | str = ExtrapolationMode.linear,\n    ) -&gt; Self:\n        \"\"\"Create a linear spline.\n\n        Parameters\n        ----------\n        start : array_like\n            Start point of the line.\n        end : array_like\n            End point of the line.\n        extrapolate : ExtrapolationMode or str, default 'linear'\n            Extrapolation mode.\n\n        Returns\n        -------\n        Spline\n            Line spline.\n        \"\"\"\n        spl = cls(extrapolate=extrapolate)\n        coords = np.stack([start, end], axis=0)\n        return spl.fit(coords, err_max=0.0)\n\n    def translate(self, shift: tuple[nm, nm, nm]):\n        \"\"\"Translate the spline by given shift vectors.\"\"\"\n        new = self.copy()\n        c = [x + s for x, s in zip(self.coeff, shift, strict=True)]\n        new._tck = (self.knots, c, self.order)\n        return new\n\n    @property\n    def has_anchors(self) -&gt; bool:\n        \"\"\"True if there are any anchors.\"\"\"\n        return self._anchors is not None\n\n    @property\n    def anchors(self) -&gt; NDArray[np.float32]:\n        \"\"\"Local anchors along spline.\"\"\"\n        if self._anchors is None:\n            raise ValueError(\"Anchor has not been set yet.\")\n        return self._anchors\n\n    @anchors.setter\n    def anchors(self, positions: float | Sequence[float]) -&gt; None:\n        _anc = np.atleast_1d(np.asarray(positions, dtype=np.float32))\n        if _anc.ndim != 1:\n            raise TypeError(\"Could not convert positions into 1D array.\")\n        elif _anc.min() &lt; 0 or _anc.max() &gt; 1:\n            msg = (\n                \"Anchor positions should be set between 0 and 1. Otherwise spline \"\n                \"curve does not fit well.\"\n            )\n            warnings.warn(msg, UserWarning, stacklevel=2)\n        _old = self._anchors\n        if (\n            _old is None\n            or _anc.size != _old.size\n            or not np.allclose(_anc, _old, rtol=1e-4, atol=1e-4)\n        ):\n            self.props.clear_loc()\n        self._anchors = _anc\n        return None\n\n    @anchors.deleter\n    def anchors(self) -&gt; None:\n        self._anchors = None\n        self.props.clear_loc()\n        return None\n\n    def is_inverted(self) -&gt; bool:\n        \"\"\"Return true if spline is inverted.\"\"\"\n        return self._lims[0] &gt; self._lims[1]\n\n    @property\n    def lims(self) -&gt; tuple[float, float]:\n        \"\"\"Return spline limit positions.\"\"\"\n        return self._lims\n\n    def _set_params(self, tck, u) -&gt; Self:\n        self._tck = tck\n        self._u = u\n        return self\n\n    def prep_anchor_positions(\n        self,\n        interval: nm | None = None,\n        n: int | None = None,\n        max_interval: nm | None = None,\n    ) -&gt; NDArray[np.float32]:\n        length = self.length()\n        if interval is not None:\n            stop, n_segs = interval_divmod(length, interval)\n            n = n_segs + 1\n        elif n is not None:\n            stop = length\n        elif max_interval is not None:\n            n = max(ceilint(length / max_interval), self.order) + 1\n            stop = length\n        else:\n            raise ValueError(\"Either 'interval' or 'n' must be specified.\")\n        y = np.linspace(0, stop, n)\n        return self.y_to_position(y)\n\n    def make_anchors(\n        self,\n        interval: nm | None = None,\n        n: int | None = None,\n        max_interval: nm | None = None,\n    ) -&gt; Self:\n        \"\"\"Make anchor points at constant intervals.\n\n        Either interval, number of anchor or the maximum interval between anchors can be\n        specified.\n\n        Parameters\n        ----------\n        interval : nm, optional\n            Interval between anchor points.\n        n : int, optional\n            Number of anchor points, including both ends.\n        max_interval: nm, optional\n            Spline will be split by as little anchors as possible but interval between\n            anchors will not be larger than this. The number of anchors are also\n            guaranteed to be larger than spline order.\n        \"\"\"\n        self.anchors = self.prep_anchor_positions(interval, n, max_interval)\n        return self\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Use start/end points to describe a spline.\"\"\"\n        start, end = self.map(self._lims)\n        start = \"({:.1f}, {:.1f}, {:.1f})\".format(*start)\n        end = \"({:.1f}, {:.1f}, {:.1f})\".format(*end)\n        return f\"Spline[{start}:{end}]\"\n\n    def close_to(self: Self, other: Self) -&gt; bool:\n        \"\"\"True if two objects draws the same curve.\"\"\"\n        if not isinstance(other, self.__class__):\n            return False\n        t0, c0, k0 = self._tck\n        t1, c1, k1 = other._tck\n        return (\n            np.allclose(t0, t1)\n            and all(np.allclose(x, y) for x, y in zip(c0, c1, strict=True))\n            and k0 == k1\n            and np.allclose(self._u, other._u)\n            and np.allclose(self._lims, other._lims)\n        )\n\n    def clip(self, start: float, stop: float) -&gt; Self:\n        \"\"\"Clip spline and generate a new one.\n\n        This method does not convert spline bases. `_lims` is updated instead.\n\n        Parameters\n        ----------\n        start : float\n            New starting position.\n        stop : float\n            New stopping position.\n\n        Returns\n        -------\n        Spline\n            Clipped spline.\n        \"\"\"\n        u0 = _linear_conversion(start, *self._lims)\n        u1 = _linear_conversion(stop, *self._lims)\n        return self.__class__(\n            order=self.order,\n            lims=(u0, u1),\n            extrapolate=self.extrapolate,\n            config=self.config,\n        )._set_params(self._tck, self._u)\n\n    def restore(self) -&gt; Self:\n        \"\"\"Restore the original, not-clipped spline.\n\n        Returns\n        -------\n        Spline\n            Copy of the original spline.\n        \"\"\"\n        return self.__class__(\n            order=self.order,\n            lims=(0, 1),\n            extrapolate=self.extrapolate,\n            config=self.config,\n        )._set_params(self._tck, self._u)\n\n    def resample(self, max_interval: nm = 1.0, err_max: nm = 0.1) -&gt; Self:\n        \"\"\"Resample a new spline along the original spline.\n\n        Parameters\n        ----------\n        max_interval : nm, default 1.0\n            Maximum interval between resampling points.\n        err_max : float, default 0.1\n            Spline fitting maximum error.\n\n        Returns\n        -------\n        Spline\n            Resampled spline object.\n        \"\"\"\n        l = self.length()\n        points = self.map(np.linspace(0, 1, ceilint(l / max_interval)))\n        return self.fit(points, err_max=err_max)\n\n    def fit(\n        self,\n        coords: ArrayLike,\n        *,\n        err_max: nm = 1.0,\n    ) -&gt; Self:\n        \"\"\"Fit spline model to coordinates.\n\n        This method uses `scipy.interpolate.splprep` to fit given coordinates to a\n        spline.\n\n        Parameters\n        ----------\n        coords : np.ndarray\n            Coordinates. Must be (N, 3).\n        err_max : float, default 1.0\n            Error allowed for fitting. Several upper limit of residual values will be\n            used and the fit that results in error lower than this value and minimize\n            the maximum curvature will be chosen.\n\n        Returns\n        -------\n        Spline\n            New spline fit to given coordinates.\n        \"\"\"\n        crds = np.asarray(coords)\n        npoints = crds.shape[0]\n        if npoints &lt; 2:\n            raise ValueError(\"Number of input coordinates must be &gt; 1.\")\n        if npoints &lt;= self.order:\n            k = npoints - 1\n        else:\n            k = self.order\n\n        if self.is_inverted():\n            crds = crds[::-1]\n\n        if err_max &gt; 4.0:\n            raise ValueError(\"std_max must be smaller than 4.0.\")\n        if err_max &lt; 1e-3:\n            std_list = [err_max]\n        else:\n            ntrial = max(int(err_max / 0.02), 2)\n            std_list = np.linspace(0, err_max, ntrial)[1:]\n\n        fit_results = list[SplineFitResult]()\n        new = self.__class__(order=k, extrapolate=self.extrapolate, config=self.config)\n        with warnings.catch_warnings():\n            # fitting may fail for some std\n            warnings.simplefilter(\"ignore\", RuntimeWarning)\n            for std in std_list:\n                _tck, _u = splprep(crds.T, k=k, s=std**2 * npoints)\n                new._set_params(_tck, _u)\n                _crds_at_u = new.map(_u)\n                res: NDArray[np.float32] = np.sqrt(\n                    np.sum((_crds_at_u - crds) ** 2, axis=1)\n                )\n                _knots = _tck[0][new.order : -new.order]\n                nedge = _knots.size - 1\n                assert nedge &gt; 0\n                nanc = nedge * 20 + 1\n                anc = np.interp(\n                    np.linspace(0, 1, nanc), np.linspace(0, 1, nedge + 1), _knots\n                )\n                max_curvature = new.curvature(anc).max()\n                success = res.max() &lt;= err_max\n                fit_results.append(\n                    SplineFitResult((_tck, _u), max_curvature, res, success)\n                )\n\n        fit_results_filt = list(filter(lambda x: x.success, fit_results))\n        if len(fit_results_filt) == 0:\n            fit_results_filt = fit_results\n\n        reult_opt = min(fit_results_filt, key=lambda x: x.curvature)\n        return new._set_params(*reult_opt.params)\n\n    def shift(\n        self,\n        positions: Sequence[float] | None = None,\n        shifts: NDArray[np.floating] | None = None,\n        *,\n        err_max: nm = 1.0,\n    ) -&gt; Self:\n        \"\"\"Fit spline model using a list of shifts in XZ-plane.\n\n        Parameters\n        ----------\n        positions : sequence of float, optional\n            Positions. Between 0 and 1. If not given, anchors are used instead.\n        shifts : np.ndarray\n            Shift from center in nm. Must be (N, 2).\n        err_max : float, default 1.0\n            Error allowed for fitting. See `Spline.fit`.\n\n        Returns\n        -------\n        Spline\n            Spline shifted by fitting to given coordinates.\n        \"\"\"\n        if shifts is None:\n            raise ValueError(\"Shifts must be given.\")\n        coords = self.map(positions)\n        rot = self.get_rotator(positions)\n        # insert 0 in y coordinates.\n        shifts = np.stack([shifts[:, 0], np.zeros(len(rot)), shifts[:, 1]], axis=1)\n        coords += rot.apply(shifts)\n        return self.fit(coords, err_max=err_max)\n\n    def distances(\n        self,\n        positions: Sequence[float] | None = None,\n        nknots: int = 512,\n    ) -&gt; NDArray[np.float32]:\n        \"\"\"Get the distances from u=0.\n\n        Parameters\n        ----------\n        positions : sequence of float, optional\n            Positions. Between 0 and 1. If not given, anchors are used instead.\n\n        Returns\n        -------\n        np.ndarray\n            Distances for each `u`.\n        \"\"\"\n        if positions is None:\n            _u = self.anchors\n        else:\n            _u = np.asarray(positions, dtype=np.float32)\n            if _u.ndim != 1:\n                raise ValueError(\"Positions must be 1D array.\")\n        u = np.linspace(0, 1, nknots)\n        u_tr = _linear_conversion(u, *self._lims)\n        dz, dy, dx = map(np.diff, splev(u_tr, self._tck, der=0))\n        dist = np.concatenate([[0], np.sqrt(dx**2 + dy**2 + dz**2)]).cumsum()\n        tck = splrep(u, dist, k=1)\n        out = splev(_u, tck)\n        return out\n\n    def map(\n        self,\n        positions: float | NDArray[np.number] | None = None,\n        der: int = 0,\n    ) -&gt; NDArray[np.float32]:\n        \"\"\"Calculate coordinates (or n-th derivative) at points on the spline.\n\n        Parameters\n        ----------\n        positions : np.ndarray or float, optional\n            Positions. Between 0 and 1. If not given, anchors are used instead.\n        der : int, default 0\n            `der`-th derivative will be calculated.\n\n        Returns\n        -------\n        np.ndarray\n            Positions or vectors in (3,) or (N, 3) shape.\n        \"\"\"\n        _assert_fitted(self)\n        if positions is None:\n            positions = self.anchors\n        u0, u1 = self._lims\n        if np.isscalar(positions):\n            if self.order &lt; der:\n                return np.zeros(3, dtype=np.float32)\n            u_tr = _linear_conversion(float(positions), u0, u1)\n            if 0 &lt;= u_tr &lt;= 1 or self.extrapolate is ExtrapolationMode.default:\n                coord = splev([u_tr], self._tck, der=der)\n            elif self.extrapolate is ExtrapolationMode.linear:\n                if der == 0:\n                    if u_tr &lt; 0:\n                        der0 = splev([0], self._tck, der=0)\n                        der1 = splev([0], self._tck, der=1)\n                        dr = u_tr\n                    else:\n                        der0 = splev([1], self._tck, der=0)\n                        der1 = splev([1], self._tck, der=1)\n                        dr = u_tr - 1\n                    coord = [a0 + a1 * dr for a0, a1 in zip(der0, der1, strict=True)]\n                elif der == 1:\n                    if u_tr &lt; 0:\n                        coord = splev([0], self._tck, der=1)\n                    else:\n                        coord = splev([1], self._tck, der=1)\n                else:\n                    coord = [[0], [0], [0]]\n            else:\n                raise ValueError(f\"Invalid extrapolation mode: {self.extrapolate!r}.\")\n            out = np.concatenate(coord).astype(np.float32)\n\n        else:\n            u_tr = _linear_conversion(np.asarray(positions, dtype=np.float32), u0, u1)\n            if self.order &lt; der:\n                return np.zeros((u_tr.size, 3), dtype=np.float32)\n            if self.extrapolate is ExtrapolationMode.default:\n                out = np.stack(splev(u_tr, self._tck, der=der), axis=1).astype(\n                    np.float32\n                )\n            elif self.extrapolate is ExtrapolationMode.linear:\n                sl_small = u_tr &lt; 0\n                sl_large = u_tr &gt; 1\n                n_small = np.count_nonzero(sl_small)\n                n_large = np.count_nonzero(sl_large)\n                out = np.stack(splev(u_tr, self._tck, der=der), axis=1).astype(\n                    np.float32\n                )\n                if der == 0:\n                    if n_small &gt; 0:\n                        der0 = np.array(splev(0, self._tck, der=0), dtype=np.float32)\n                        der1 = np.array(splev(0, self._tck, der=1), dtype=np.float32)\n                        dr = u_tr[sl_small]\n                        coords_new = der0 + der1 * dr[:, np.newaxis]\n                        out[sl_small] = coords_new\n\n                    if n_large &gt; 0:\n                        der0 = splev(1, self._tck, der=0)\n                        der1 = splev(1, self._tck, der=1)\n                        dr = u_tr[sl_large] - 1\n                        coords_new = der0 + der1 * dr[:, np.newaxis]\n                        out[sl_large] = coords_new\n\n                elif der == 1:\n                    if n_small &gt; 0:\n                        out[sl_small] = splev(0, self._tck, der=1)\n                    if n_large &gt; 0:\n                        out[sl_large] = splev(1, self._tck, der=1)\n                else:\n                    if n_small &gt; 0:\n                        out[sl_small] = 0\n                    if n_large &gt; 0:\n                        out[sl_large] = 0\n            else:\n                raise ValueError(f\"Invalid extrapolation mode: {self.extrapolate!r}.\")\n\n        if u0 &gt; u1 and der % 2 == 1:\n            out = -out\n        return out\n\n    __call__ = map  # scipy-style alias\n\n    def partition(self, n: int, der: int = 0) -&gt; NDArray[np.float32]:\n        \"\"\"Return the n-partitioning coordinates of the spline.\"\"\"\n        u = np.linspace(0, 1, n)\n        return self.map(u, der)\n\n    def length(self, start: float = 0, stop: float = 1, nknots: int = 512) -&gt; nm:\n        \"\"\"Length of the spline.\n\n        Approximate the length of B-spline between [start, stop] by partitioning\n        the spline with 'nknots' knots. nknots=256 is large enough for most cases.\n        \"\"\"\n        _assert_fitted(self)\n        u = np.linspace(start, stop, nknots)\n        u_tr = _linear_conversion(u, *self._lims)\n        dz, dy, dx = map(np.diff, splev(u_tr, self._tck, der=0))\n        return np.sum(np.sqrt(dx**2 + dy**2 + dz**2))\n\n    def invert(self) -&gt; Self:\n        \"\"\"Invert the direction of spline.\n\n        Returns\n        -------\n        Spline\n            Inverted object\n        \"\"\"\n        anchors = self._anchors\n        inverted = self.clip(1.0, 0.0)\n        if anchors is not None:\n            inverted.anchors = 1 - anchors[::-1]\n        return inverted\n\n    def split(\n        self,\n        at: nm,\n        from_start: bool = True,\n        trim: nm = 0.0,\n        allow_discard: bool = False,\n    ) -&gt; list[Self]:\n        \"\"\"Split the spline at the given position.\"\"\"\n        spl_len = self.length()\n        if not from_start:\n            at = spl_len - at\n        at_rel_0 = (at - trim) / spl_len\n        at_rel_1 = (at + trim) / spl_len\n        out = list[\"Self\"]()\n        if at_rel_0 &gt;= 0:\n            out.append(self.clip(0.0, at_rel_0))\n        elif not allow_discard:\n            raise ValueError(\n                \"Split position must be over `trim` if allow_discard is False, but \"\n                f\"tried to split at {at:.1f} nm.\"\n            )\n        if at_rel_1 &lt;= 1.0:\n            out.append(self.clip(at_rel_1, 1.0))\n        elif not allow_discard:\n            raise ValueError(\n                \"Split position must be under `length - trim` if allow_discard is \"\n                f\"False, but tried to split at {at:.1f} nm (length = {spl_len:.1f}).\"\n            )\n        return out\n\n    def curvature(\n        self,\n        positions: Sequence[float] | None = None,\n    ) -&gt; NDArray[np.float32]:\n        \"\"\"Calculate curvature of spline curve.\n\n        Parameters\n        ----------\n        positions : sequence of float, optional\n            Positions. Between 0 and 1. If not given, anchors are used instead.\n\n        Returns\n        -------\n        np.ndarray\n            Array of curvature.\n\n        References\n        ----------\n        - https://en.wikipedia.org/wiki/Curvature#Space_curves\n        \"\"\"\n\n        if positions is None:\n            positions = self.anchors\n\n        dz, dy, dx = self.map(positions, der=1).T\n        ddz, ddy, ddx = self.map(positions, der=2).T\n        a = (\n            (ddz * dy - ddy * dz) ** 2\n            + (ddx * dz - ddz * dx) ** 2\n            + (ddy * dx - ddx * dy) ** 2\n        )\n        return np.sqrt(a) / (dx**2 + dy**2 + dz**2) ** 1.5\n\n    def curvature_radii(self, positions: Sequence[float] = None) -&gt; NDArray[np.float32]:\n        \"\"\"Inverse of curvature.\"\"\"\n        return 1.0 / self.curvature(positions)\n\n    def to_dict(self) -&gt; SplineInfo:\n        \"\"\"Convert spline info into a dict.\"\"\"\n        t, c, k = self._tck\n        u = self._u\n        return {\n            \"t\": t.tolist(),\n            \"c\": {\"z\": c[0].tolist(), \"y\": c[1].tolist(), \"x\": c[2].tolist()},\n            \"k\": k,\n            \"u\": u.tolist(),\n            \"lims\": self._lims,\n            \"localprops_window_size\": dict(self.props.window_size),\n            \"binsize_loc\": dict(self.props.binsize_loc),\n            \"binsize_glob\": dict(self.props.binsize_glob),\n            \"extrapolate\": self._extrapolate.name,\n            \"config\": self.config.asdict(),\n        }\n\n    @classmethod\n    def from_dict(cls: type[Self], d: SplineInfo) -&gt; Self:\n        \"\"\"Construct a spline model from a dictionary.\n\n        Parameters\n        ----------\n        d: dict\n            Dictionary with keys \"t\", \"c\", \"k\", \"u\" and \"lims\".\n\n        Returns\n        -------\n        Spline\n            Spline object constructed from the dictionary.\n        \"\"\"\n        self = cls(\n            order=d.get(\"k\", 3),\n            lims=d.get(\"lims\", (0, 1)),\n            extrapolate=d.get(\"extrapolate\", \"linear\"),\n        )\n        t = np.asarray(d[\"t\"])\n        c = [np.asarray(d[\"c\"][k]) for k in \"zyx\"]\n        k = roundint(d[\"k\"])\n        self._tck = (t, c, k)\n        self._u = np.asarray(d[\"u\"])\n        self.props._window_size = d.get(\"localprops_window_size\", {})\n        self.props._binsize_loc = d.get(\"binsize_loc\", {})\n        self.props._binsize_glob = d.get(\"binsize_glob\", {})\n        if cfg := d.get(\"config\", None):\n            self._config = SplineConfig.from_dict(cfg)\n        return self\n\n    def get_rotator(\n        self,\n        positions: Sequence[float] | None = None,\n        inverse: bool = False,\n    ) -&gt; Rotation:\n        \"\"\"Calculate list of Affine transformation matrix along spline.\n\n        The matrices correspond to the orientation of spline curve.\n\n        Parameters\n        ----------\n        positions : array-like, (N,)\n            Positions. Between 0 and 1.\n        inverse : bool, default False\n            If True, rotation matrix will be inversed.\n\n        Returns\n        -------\n        Rotation\n            Rotation object at each anchor.\n        \"\"\"\n        if positions is None:\n            positions = self.anchors\n        ds = self.map(positions, der=1)\n        out = axes_to_rotator(None, -ds)\n\n        if inverse:\n            out = out.inv()\n\n        return out\n\n    def local_cartesian(\n        self,\n        shape: tuple[nm, nm],\n        depth: nm,\n        u: float | Sequence[float] = None,\n        scale: nm = 1.0,\n    ) -&gt; NDArray[np.float32]:\n        \"\"\"Generate local Cartesian coordinate systems.\n\n        The generated array can be used for `ndi.map_coordinates`. The result coordinate\n        systems are flat, i.e., not distorted by the curvature of spline.\n\n        Parameters\n        ----------\n        shape : (float, float)\n            Vertical and horizontal length of Cartesian coordinates. Corresponds to zx\n            axes.\n        depth : float\n            Length of y axis in nm.\n        u : float, optional\n            Position on the spline at which local Cartesian coordinates will be built.\n        scale: nm, default 1.0\n            Scale of coordinates, i.e. spacing of the grid.\n\n        Returns\n        -------\n        np.ndarray\n            (D, V, S, H) shape. Each cooresponds to dimensional vertical, longitudinal\n            and horizontal axis, which is ready to be used in `ndi.map_coordinates`.\n        \"\"\"\n\n        mole = self.anchors_to_molecules(u)\n        nz = roundint(shape[0] / scale)\n        ny = roundint(depth / scale)\n        nx = roundint(shape[1] / scale)\n        return mole.local_coordinates(shape=(nz, ny, nx), scale=scale)\n\n    def local_cylindrical(\n        self,\n        r_range: tuple[nm, nm],\n        depth: nm,\n        u: float | None = None,\n        scale: nm = 1.0,\n    ) -&gt; NDArray[np.float32]:\n        \"\"\"Generate local cylindrical coordinate systems.\n\n        The generated array can be used for `ndi.map_coordinates`. The result coordinate\n        systems are flat, i.e., not distorted by the curvature of spline.\n\n        Parameters\n        ----------\n        r_range : (float, float)\n            Lower and upper bound of radius in nm.\n        depth : nm\n            Length of y axis in nm.\n        u : float\n            Position on the spline at which local cylindrical coordinates will be built.\n        scale: nm, default 1.0\n            Scale of coordinates, i.e. spacing of the grid.\n\n        Returns\n        -------\n        np.ndarray\n            (D, V, S, H) shape. Each cooresponds to dimensional, radius, longitudinal\n            and angle axis, which is ready to be used in `ndi.map_coordinates`.\n        \"\"\"\n        if u is None:\n            u = self.anchors\n        rmin, rmax = r_range\n        ds = self.map(u, der=1)\n        ds_norm: NDArray[np.float32] = ds.reshape(-1, 1) / np.sqrt(sum(ds**2))\n        depth_px = roundint(depth / scale)\n        grid = np.linspace(-depth_px / 2 + 0.5, depth_px / 2 - 0.5, depth_px)\n        dy = ds_norm * grid\n        y_ax_coords = (self.map(u) / scale).reshape(1, -1) + dy.T\n        dslist = np.stack([ds] * depth_px, axis=0)\n        map_ = polar_coords_2d(rmin / scale, rmax / scale)\n        map_slice = _stack_coords(map_)\n        out = _rot_with_vector(map_slice, y_ax_coords, dslist)\n        return np.moveaxis(out, -1, 0)\n\n    def cartesian(\n        self,\n        shape: tuple[nm, nm],\n        s_range: tuple[float, float] = (0, 1),\n        scale: nm = 1.0,\n    ) -&gt; NDArray[np.float32]:\n        \"\"\"Generate a Cartesian coordinate system along spline.\n\n        Generated coordinates can be used for `ndi.map_coordinate`. Note that this\n        coordinate system is distorted, thus does not reflect real geometry (such as\n        distance and derivatives).\n\n        Parameters\n        ----------\n        shape : (float, float)\n            The ZX-shape of output coordinate system. Center of the array will be\n            spline curve itself after coodinate transformation.\n        s_range : tuple[float, float], default (0, 1)\n            Range of spline. Spline coordinate system will be built between\n            `spl[s_range[0]]` and `spl[s_range[1]]`.\n        scale: nm, default 1.0\n            Scale of coordinates, i.e. spacing of the grid.\n\n        Returns\n        -------\n        np.ndarray\n            (V, S, H, D) shape. Each cooresponds to vertical, longitudinal, horizontal\n            and dimensional axis.\n        \"\"\"\n        dz = roundint(shape[0] / scale)\n        dx = roundint(shape[1] / scale)\n        return self._get_coords(_cartesian_coords_2d, (dz, dx), s_range, scale)\n\n    def cylindrical(\n        self,\n        r_range: tuple[nm, nm],\n        s_range: tuple[float, float] = (0, 1),\n        scale: nm = 1.0,\n    ) -&gt; NDArray[np.float32]:\n        \"\"\"Generate a cylindrical coordinate system along spline.\n\n        Generated coordinate can be used for `ndi.map_coordinate`. Note that this\n        coordinate system is distorted, thus does not reflect real geometry (such as\n        distance and derivatives).\n\n        Parameters\n        ----------\n        r_range : (nm, nm)\n            Range of radius in nm. r=0 will be spline curve itself after coodinate\n            transformation.\n        s_range : tuple[float, float], default (0, 1)\n            Range of spline. Spline coordinate system will be built between\n            `spl[s_range[0]]` and `spl[s_range[1]]`.\n        scale: nm, default 1.0\n            Scale of coordinates, i.e. spacing of the grid.\n\n        Returns\n        -------\n        np.ndarray\n            (V, S, H, D) shape. Each cooresponds to radius, longitudinal, angle and\n            dimensional axis.\n        \"\"\"\n        rmin = r_range[0] / scale\n        rmax = r_range[1] / scale\n        return self._get_coords(polar_coords_2d, (rmin, rmax), s_range, scale)\n\n    def y_to_position(\n        self, y: NDArray[np.float32], nknots: int = 512\n    ) -&gt; NDArray[np.float32]:\n        \"\"\"Convert y-coordinate to spline position parameter.\n\n        Parameters\n        ----------\n        y : array-like\n            Y coordinates.\n        nknots : int, optional\n            Number of knots. Increasing the number of knots will increase the accuracy.\n        \"\"\"\n        # almost equal to y / self.length()\n        u = np.linspace(0, 1, nknots)\n        u_tr = _linear_conversion(u, *self._lims)\n        dz, dy, dx = map(np.diff, splev(u_tr, self._tck, der=0))\n        dist = np.concatenate([[0], np.sqrt(dx**2 + dy**2 + dz**2)]).cumsum()\n        tck = splrep(dist, u, k=1)\n        out = splev(y, tck)\n        return out\n\n    def cartesian_to_world(\n        self,\n        coords: NDArray[np.float32],\n        nknots: int = 512,\n    ) -&gt; NDArray[np.float32]:\n        \"\"\"Inverse Cartesian coordinate mapping, (z', y', x') to world coordinate.\n\n        Parameters\n        ----------\n        coords : np.ndarray\n            Spline Cartesian coordinates. All the coordinates must be in nm unit.\n\n        Returns\n        -------\n        np.ndarray\n            World coordinates.\n        \"\"\"\n        ncoords = coords.shape[0]\n        _zs = coords[:, 0]\n        _us = self.y_to_position(coords[:, 1], nknots=nknots)\n        _xs = coords[:, 2]\n        _zeros = np.zeros(ncoords, dtype=np.float32)\n        coords_ext = np.stack([_zs, _zeros, _xs], axis=1)\n        rot = self.get_rotator(_us)\n        out = rot.apply(coords_ext) + self.map(_us)\n\n        return out\n\n    def cylindrical_to_world(self, coords: NDArray[np.float32]) -&gt; NDArray[np.float32]:\n        \"\"\"Inverse cylindrical coordinate mapping, (r, y, angle) to world coordinate.\n\n        Parameters\n        ----------\n        coords : np.ndarray\n            Cylindrical coordinates. \"r\" and \"y\" must be in scale of \"nm\", while angle\n            must be in radian.\n\n        Returns\n        -------\n        np.ndarray\n            World coordinates.\n        \"\"\"\n        radius = coords[:, 0]\n        y = coords[:, 1]\n        theta = coords[:, 2]\n        cart_coords = np.stack(\n            [radius * np.sin(theta), y, radius * np.cos(theta)], axis=1\n        )\n        return self.cartesian_to_world(cart_coords)\n\n    def anchors_to_molecules(\n        self,\n        positions: float | Sequence[float] | None = None,\n        rotation: Sequence[float] | None = None,\n    ) -&gt; Molecules:\n        \"\"\"Convert coordinates of anchors to `Molecules` instance.\n\n        Coordinates of anchors must be in range from 0 to 1. The y-direction of\n        `Molecules` always points at the direction of spline and the z- direction always\n        in the plane orthogonal to YX-plane.\n\n        Parameters\n        ----------\n        positions : iterable of float, optional\n            Positions. Between 0 and 1. If not given, anchors are used instead.\n\n        Returns\n        -------\n        Molecules\n            Molecules object of points.\n        \"\"\"\n        if positions is None:\n            positions = self.anchors\n        elif np.isscalar(positions):\n            positions = [positions]\n        pos = self.map(positions)\n        yvec = self.map(positions, der=1)\n        rot = axes_to_rotator(None, yvec)\n        if rotation is not None:\n            rotvec = np.zeros((len(rot), 3), dtype=np.float32)\n            rotvec[:, 1] = rotation\n            rot = rot * Rotation.from_rotvec(rotvec)\n        return Molecules(pos=pos, rot=rot, features={Mole.nth: np.arange(len(pos))})\n\n    def cylindrical_to_molecules(\n        self,\n        coords: NDArray[np.float32],\n    ) -&gt; Molecules:\n        \"\"\"Convert coordinates of points near the spline to `Molecules` instance.\n\n        Coordinates of points must be those in spline cylindrical coordinate system.\n\n        Parameters\n        ----------\n        coords : (N, 3) array\n            Spline cylindrical coordinates of points.\n\n        Returns\n        -------\n        Molecules\n            Molecules object of points.\n        \"\"\"\n        world_coords = self.cylindrical_to_world(coords)\n\n        # world coordinates of the projection point of coords onto the spline\n        u = self.y_to_position(coords[:, 1])\n        ycoords = self.map(u)\n        zvec = world_coords - ycoords\n        yvec = self.map(u, der=1)\n        return Molecules.from_axes(pos=world_coords, z=zvec, y=yvec)\n\n    def rescale(self, factor: float) -&gt; Self:\n        _t, _c, _k = self._tck\n        _c = [c * factor for c in _c]\n        new = self.copy()\n        new._tck = (_t, _c, _k)\n        return new\n\n    def _get_coords(\n        self,\n        map_func: Callable[[tuple], NDArray[np.float32]],\n        map_params: tuple,\n        s_range: tuple[float, float],\n        scale: nm,\n    ):\n        \"\"\"\n        Make coordinate system using function `map_func` and stack the same point cloud\n        in the direction of the spline, in the range of `s_range`.\n        \"\"\"\n        u, y_ax_coords = self._get_y_ax_coords(s_range, scale)\n        dslist = self.map(u, 1).astype(np.float32)\n        map_ = map_func(*map_params)\n        map_slice = _stack_coords(map_)\n        out = _rot_with_vector(map_slice, y_ax_coords, dslist)\n        return np.moveaxis(out, -1, 0)\n\n    def _get_y_ax_coords(self, s_range: tuple[float, float], scale: nm):\n        s0, s1 = s_range\n        length = self.length(start=s0, stop=s1)\n        stop_length, n_segs = interval_divmod(length, scale)\n        n_pixels = n_segs + 1\n        s2 = (s1 - s0) * stop_length / length + s0\n        if n_pixels &lt; 2:\n            raise ValueError(\"Too short. Change 's_range'.\")\n        d0, d2 = self.distances([s0, s2])\n        u = self.y_to_position(np.linspace(d0, d2, n_pixels))\n        y = self.map(u) / scale  # world coordinates of y-axis in spline coords system\n        return u, y\n</code></pre>"},{"location":"api/components/#cylindra.components.spline.Spline.anchors","title":"<code>anchors</code>  <code>deletable</code> <code>property</code> <code>writable</code>","text":"<p>Local anchors along spline.</p>"},{"location":"api/components/#cylindra.components.spline.Spline.coeff","title":"<code>coeff</code>  <code>property</code>","text":"<p>Spline coefficient.</p>"},{"location":"api/components/#cylindra.components.spline.Spline.config","title":"<code>config</code>  <code>property</code>","text":"<p>Return the spline configuration</p>"},{"location":"api/components/#cylindra.components.spline.Spline.extrapolate","title":"<code>extrapolate</code>  <code>property</code>","text":"<p>Extrapolation mode of the spline.</p>"},{"location":"api/components/#cylindra.components.spline.Spline.has_anchors","title":"<code>has_anchors</code>  <code>property</code>","text":"<p>True if there are any anchors.</p>"},{"location":"api/components/#cylindra.components.spline.Spline.knots","title":"<code>knots</code>  <code>property</code>","text":"<p>Spline knots.</p>"},{"location":"api/components/#cylindra.components.spline.Spline.lims","title":"<code>lims</code>  <code>property</code>","text":"<p>Return spline limit positions.</p>"},{"location":"api/components/#cylindra.components.spline.Spline.order","title":"<code>order</code>  <code>property</code>","text":"<p>Spline order.</p>"},{"location":"api/components/#cylindra.components.spline.Spline.params","title":"<code>params</code>  <code>property</code>","text":"<p>Spline parameters.</p>"},{"location":"api/components/#cylindra.components.spline.Spline.props","title":"<code>props</code>  <code>property</code>","text":"<p>Return the spline properties</p>"},{"location":"api/components/#cylindra.components.spline.Spline.__repr__","title":"<code>__repr__()</code>","text":"<p>Use start/end points to describe a spline.</p> Source code in <code>cylindra/components/spline/_spline_base.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Use start/end points to describe a spline.\"\"\"\n    start, end = self.map(self._lims)\n    start = \"({:.1f}, {:.1f}, {:.1f})\".format(*start)\n    end = \"({:.1f}, {:.1f}, {:.1f})\".format(*end)\n    return f\"Spline[{start}:{end}]\"\n</code></pre>"},{"location":"api/components/#cylindra.components.spline.Spline.anchors_to_molecules","title":"<code>anchors_to_molecules(positions=None, rotation=None)</code>","text":"<p>Convert coordinates of anchors to <code>Molecules</code> instance.</p> <p>Coordinates of anchors must be in range from 0 to 1. The y-direction of <code>Molecules</code> always points at the direction of spline and the z- direction always in the plane orthogonal to YX-plane.</p> <p>Parameters:</p> Name Type Description Default <code>positions</code> <code>iterable of float</code> <p>Positions. Between 0 and 1. If not given, anchors are used instead.</p> <code>None</code> <p>Returns:</p> Type Description <code>Molecules</code> <p>Molecules object of points.</p> Source code in <code>cylindra/components/spline/_spline_base.py</code> <pre><code>def anchors_to_molecules(\n    self,\n    positions: float | Sequence[float] | None = None,\n    rotation: Sequence[float] | None = None,\n) -&gt; Molecules:\n    \"\"\"Convert coordinates of anchors to `Molecules` instance.\n\n    Coordinates of anchors must be in range from 0 to 1. The y-direction of\n    `Molecules` always points at the direction of spline and the z- direction always\n    in the plane orthogonal to YX-plane.\n\n    Parameters\n    ----------\n    positions : iterable of float, optional\n        Positions. Between 0 and 1. If not given, anchors are used instead.\n\n    Returns\n    -------\n    Molecules\n        Molecules object of points.\n    \"\"\"\n    if positions is None:\n        positions = self.anchors\n    elif np.isscalar(positions):\n        positions = [positions]\n    pos = self.map(positions)\n    yvec = self.map(positions, der=1)\n    rot = axes_to_rotator(None, yvec)\n    if rotation is not None:\n        rotvec = np.zeros((len(rot), 3), dtype=np.float32)\n        rotvec[:, 1] = rotation\n        rot = rot * Rotation.from_rotvec(rotvec)\n    return Molecules(pos=pos, rot=rot, features={Mole.nth: np.arange(len(pos))})\n</code></pre>"},{"location":"api/components/#cylindra.components.spline.Spline.cartesian","title":"<code>cartesian(shape, s_range=(0, 1), scale=1.0)</code>","text":"<p>Generate a Cartesian coordinate system along spline.</p> <p>Generated coordinates can be used for <code>ndi.map_coordinate</code>. Note that this coordinate system is distorted, thus does not reflect real geometry (such as distance and derivatives).</p> <p>Parameters:</p> Name Type Description Default <code>shape</code> <code>(float, float)</code> <p>The ZX-shape of output coordinate system. Center of the array will be spline curve itself after coodinate transformation.</p> required <code>s_range</code> <code>tuple[float, float]</code> <p>Range of spline. Spline coordinate system will be built between <code>spl[s_range[0]]</code> and <code>spl[s_range[1]]</code>.</p> <code>(0, 1)</code> <code>scale</code> <code>nm</code> <p>Scale of coordinates, i.e. spacing of the grid.</p> <code>1.0</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>(V, S, H, D) shape. Each cooresponds to vertical, longitudinal, horizontal and dimensional axis.</p> Source code in <code>cylindra/components/spline/_spline_base.py</code> <pre><code>def cartesian(\n    self,\n    shape: tuple[nm, nm],\n    s_range: tuple[float, float] = (0, 1),\n    scale: nm = 1.0,\n) -&gt; NDArray[np.float32]:\n    \"\"\"Generate a Cartesian coordinate system along spline.\n\n    Generated coordinates can be used for `ndi.map_coordinate`. Note that this\n    coordinate system is distorted, thus does not reflect real geometry (such as\n    distance and derivatives).\n\n    Parameters\n    ----------\n    shape : (float, float)\n        The ZX-shape of output coordinate system. Center of the array will be\n        spline curve itself after coodinate transformation.\n    s_range : tuple[float, float], default (0, 1)\n        Range of spline. Spline coordinate system will be built between\n        `spl[s_range[0]]` and `spl[s_range[1]]`.\n    scale: nm, default 1.0\n        Scale of coordinates, i.e. spacing of the grid.\n\n    Returns\n    -------\n    np.ndarray\n        (V, S, H, D) shape. Each cooresponds to vertical, longitudinal, horizontal\n        and dimensional axis.\n    \"\"\"\n    dz = roundint(shape[0] / scale)\n    dx = roundint(shape[1] / scale)\n    return self._get_coords(_cartesian_coords_2d, (dz, dx), s_range, scale)\n</code></pre>"},{"location":"api/components/#cylindra.components.spline.Spline.cartesian_to_world","title":"<code>cartesian_to_world(coords, nknots=512)</code>","text":"<p>Inverse Cartesian coordinate mapping, (z', y', x') to world coordinate.</p> <p>Parameters:</p> Name Type Description Default <code>coords</code> <code>ndarray</code> <p>Spline Cartesian coordinates. All the coordinates must be in nm unit.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>World coordinates.</p> Source code in <code>cylindra/components/spline/_spline_base.py</code> <pre><code>def cartesian_to_world(\n    self,\n    coords: NDArray[np.float32],\n    nknots: int = 512,\n) -&gt; NDArray[np.float32]:\n    \"\"\"Inverse Cartesian coordinate mapping, (z', y', x') to world coordinate.\n\n    Parameters\n    ----------\n    coords : np.ndarray\n        Spline Cartesian coordinates. All the coordinates must be in nm unit.\n\n    Returns\n    -------\n    np.ndarray\n        World coordinates.\n    \"\"\"\n    ncoords = coords.shape[0]\n    _zs = coords[:, 0]\n    _us = self.y_to_position(coords[:, 1], nknots=nknots)\n    _xs = coords[:, 2]\n    _zeros = np.zeros(ncoords, dtype=np.float32)\n    coords_ext = np.stack([_zs, _zeros, _xs], axis=1)\n    rot = self.get_rotator(_us)\n    out = rot.apply(coords_ext) + self.map(_us)\n\n    return out\n</code></pre>"},{"location":"api/components/#cylindra.components.spline.Spline.clip","title":"<code>clip(start, stop)</code>","text":"<p>Clip spline and generate a new one.</p> <p>This method does not convert spline bases. <code>_lims</code> is updated instead.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>float</code> <p>New starting position.</p> required <code>stop</code> <code>float</code> <p>New stopping position.</p> required <p>Returns:</p> Type Description <code>Spline</code> <p>Clipped spline.</p> Source code in <code>cylindra/components/spline/_spline_base.py</code> <pre><code>def clip(self, start: float, stop: float) -&gt; Self:\n    \"\"\"Clip spline and generate a new one.\n\n    This method does not convert spline bases. `_lims` is updated instead.\n\n    Parameters\n    ----------\n    start : float\n        New starting position.\n    stop : float\n        New stopping position.\n\n    Returns\n    -------\n    Spline\n        Clipped spline.\n    \"\"\"\n    u0 = _linear_conversion(start, *self._lims)\n    u1 = _linear_conversion(stop, *self._lims)\n    return self.__class__(\n        order=self.order,\n        lims=(u0, u1),\n        extrapolate=self.extrapolate,\n        config=self.config,\n    )._set_params(self._tck, self._u)\n</code></pre>"},{"location":"api/components/#cylindra.components.spline.Spline.close_to","title":"<code>close_to(other)</code>","text":"<p>True if two objects draws the same curve.</p> Source code in <code>cylindra/components/spline/_spline_base.py</code> <pre><code>def close_to(self: Self, other: Self) -&gt; bool:\n    \"\"\"True if two objects draws the same curve.\"\"\"\n    if not isinstance(other, self.__class__):\n        return False\n    t0, c0, k0 = self._tck\n    t1, c1, k1 = other._tck\n    return (\n        np.allclose(t0, t1)\n        and all(np.allclose(x, y) for x, y in zip(c0, c1, strict=True))\n        and k0 == k1\n        and np.allclose(self._u, other._u)\n        and np.allclose(self._lims, other._lims)\n    )\n</code></pre>"},{"location":"api/components/#cylindra.components.spline.Spline.copy","title":"<code>copy(copy_props=True, copy_config=True)</code>","text":"<p>Copy Spline object.</p> <p>Parameters:</p> Name Type Description Default <code>copy_props</code> <code>bool</code> <p>Also copy local/global properties if true.</p> <code>True</code> <p>Returns:</p> Type Description <code>Spline</code> <p>Copied object.</p> Source code in <code>cylindra/components/spline/_spline_base.py</code> <pre><code>def copy(self, copy_props: bool = True, copy_config: bool = True) -&gt; Self:\n    \"\"\"Copy Spline object.\n\n    Parameters\n    ----------\n    copy_props : bool, default True\n        Also copy local/global properties if true.\n\n    Returns\n    -------\n    Spline\n        Copied object.\n    \"\"\"\n    new = self.__class__(\n        order=self.order, lims=self._lims, extrapolate=self.extrapolate\n    )\n    new._tck = self._tck\n    new._u = self._u\n    new._anchors = self._anchors\n\n    if copy_props:\n        new._props = self.props.copy()\n    if copy_config:\n        new._config = self.config.copy()\n    return new\n</code></pre>"},{"location":"api/components/#cylindra.components.spline.Spline.curvature","title":"<code>curvature(positions=None)</code>","text":"<p>Calculate curvature of spline curve.</p> <p>Parameters:</p> Name Type Description Default <code>positions</code> <code>sequence of float</code> <p>Positions. Between 0 and 1. If not given, anchors are used instead.</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Array of curvature.</p> References <ul> <li>https://en.wikipedia.org/wiki/Curvature#Space_curves</li> </ul> Source code in <code>cylindra/components/spline/_spline_base.py</code> <pre><code>def curvature(\n    self,\n    positions: Sequence[float] | None = None,\n) -&gt; NDArray[np.float32]:\n    \"\"\"Calculate curvature of spline curve.\n\n    Parameters\n    ----------\n    positions : sequence of float, optional\n        Positions. Between 0 and 1. If not given, anchors are used instead.\n\n    Returns\n    -------\n    np.ndarray\n        Array of curvature.\n\n    References\n    ----------\n    - https://en.wikipedia.org/wiki/Curvature#Space_curves\n    \"\"\"\n\n    if positions is None:\n        positions = self.anchors\n\n    dz, dy, dx = self.map(positions, der=1).T\n    ddz, ddy, ddx = self.map(positions, der=2).T\n    a = (\n        (ddz * dy - ddy * dz) ** 2\n        + (ddx * dz - ddz * dx) ** 2\n        + (ddy * dx - ddx * dy) ** 2\n    )\n    return np.sqrt(a) / (dx**2 + dy**2 + dz**2) ** 1.5\n</code></pre>"},{"location":"api/components/#cylindra.components.spline.Spline.curvature_radii","title":"<code>curvature_radii(positions=None)</code>","text":"<p>Inverse of curvature.</p> Source code in <code>cylindra/components/spline/_spline_base.py</code> <pre><code>def curvature_radii(self, positions: Sequence[float] = None) -&gt; NDArray[np.float32]:\n    \"\"\"Inverse of curvature.\"\"\"\n    return 1.0 / self.curvature(positions)\n</code></pre>"},{"location":"api/components/#cylindra.components.spline.Spline.cylindrical","title":"<code>cylindrical(r_range, s_range=(0, 1), scale=1.0)</code>","text":"<p>Generate a cylindrical coordinate system along spline.</p> <p>Generated coordinate can be used for <code>ndi.map_coordinate</code>. Note that this coordinate system is distorted, thus does not reflect real geometry (such as distance and derivatives).</p> <p>Parameters:</p> Name Type Description Default <code>r_range</code> <code>(nm, nm)</code> <p>Range of radius in nm. r=0 will be spline curve itself after coodinate transformation.</p> required <code>s_range</code> <code>tuple[float, float]</code> <p>Range of spline. Spline coordinate system will be built between <code>spl[s_range[0]]</code> and <code>spl[s_range[1]]</code>.</p> <code>(0, 1)</code> <code>scale</code> <code>nm</code> <p>Scale of coordinates, i.e. spacing of the grid.</p> <code>1.0</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>(V, S, H, D) shape. Each cooresponds to radius, longitudinal, angle and dimensional axis.</p> Source code in <code>cylindra/components/spline/_spline_base.py</code> <pre><code>def cylindrical(\n    self,\n    r_range: tuple[nm, nm],\n    s_range: tuple[float, float] = (0, 1),\n    scale: nm = 1.0,\n) -&gt; NDArray[np.float32]:\n    \"\"\"Generate a cylindrical coordinate system along spline.\n\n    Generated coordinate can be used for `ndi.map_coordinate`. Note that this\n    coordinate system is distorted, thus does not reflect real geometry (such as\n    distance and derivatives).\n\n    Parameters\n    ----------\n    r_range : (nm, nm)\n        Range of radius in nm. r=0 will be spline curve itself after coodinate\n        transformation.\n    s_range : tuple[float, float], default (0, 1)\n        Range of spline. Spline coordinate system will be built between\n        `spl[s_range[0]]` and `spl[s_range[1]]`.\n    scale: nm, default 1.0\n        Scale of coordinates, i.e. spacing of the grid.\n\n    Returns\n    -------\n    np.ndarray\n        (V, S, H, D) shape. Each cooresponds to radius, longitudinal, angle and\n        dimensional axis.\n    \"\"\"\n    rmin = r_range[0] / scale\n    rmax = r_range[1] / scale\n    return self._get_coords(polar_coords_2d, (rmin, rmax), s_range, scale)\n</code></pre>"},{"location":"api/components/#cylindra.components.spline.Spline.cylindrical_to_molecules","title":"<code>cylindrical_to_molecules(coords)</code>","text":"<p>Convert coordinates of points near the spline to <code>Molecules</code> instance.</p> <p>Coordinates of points must be those in spline cylindrical coordinate system.</p> <p>Parameters:</p> Name Type Description Default <code>coords</code> <code>(N, 3) array</code> <p>Spline cylindrical coordinates of points.</p> required <p>Returns:</p> Type Description <code>Molecules</code> <p>Molecules object of points.</p> Source code in <code>cylindra/components/spline/_spline_base.py</code> <pre><code>def cylindrical_to_molecules(\n    self,\n    coords: NDArray[np.float32],\n) -&gt; Molecules:\n    \"\"\"Convert coordinates of points near the spline to `Molecules` instance.\n\n    Coordinates of points must be those in spline cylindrical coordinate system.\n\n    Parameters\n    ----------\n    coords : (N, 3) array\n        Spline cylindrical coordinates of points.\n\n    Returns\n    -------\n    Molecules\n        Molecules object of points.\n    \"\"\"\n    world_coords = self.cylindrical_to_world(coords)\n\n    # world coordinates of the projection point of coords onto the spline\n    u = self.y_to_position(coords[:, 1])\n    ycoords = self.map(u)\n    zvec = world_coords - ycoords\n    yvec = self.map(u, der=1)\n    return Molecules.from_axes(pos=world_coords, z=zvec, y=yvec)\n</code></pre>"},{"location":"api/components/#cylindra.components.spline.Spline.cylindrical_to_world","title":"<code>cylindrical_to_world(coords)</code>","text":"<p>Inverse cylindrical coordinate mapping, (r, y, angle) to world coordinate.</p> <p>Parameters:</p> Name Type Description Default <code>coords</code> <code>ndarray</code> <p>Cylindrical coordinates. \"r\" and \"y\" must be in scale of \"nm\", while angle must be in radian.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>World coordinates.</p> Source code in <code>cylindra/components/spline/_spline_base.py</code> <pre><code>def cylindrical_to_world(self, coords: NDArray[np.float32]) -&gt; NDArray[np.float32]:\n    \"\"\"Inverse cylindrical coordinate mapping, (r, y, angle) to world coordinate.\n\n    Parameters\n    ----------\n    coords : np.ndarray\n        Cylindrical coordinates. \"r\" and \"y\" must be in scale of \"nm\", while angle\n        must be in radian.\n\n    Returns\n    -------\n    np.ndarray\n        World coordinates.\n    \"\"\"\n    radius = coords[:, 0]\n    y = coords[:, 1]\n    theta = coords[:, 2]\n    cart_coords = np.stack(\n        [radius * np.sin(theta), y, radius * np.cos(theta)], axis=1\n    )\n    return self.cartesian_to_world(cart_coords)\n</code></pre>"},{"location":"api/components/#cylindra.components.spline.Spline.distances","title":"<code>distances(positions=None, nknots=512)</code>","text":"<p>Get the distances from u=0.</p> <p>Parameters:</p> Name Type Description Default <code>positions</code> <code>sequence of float</code> <p>Positions. Between 0 and 1. If not given, anchors are used instead.</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Distances for each <code>u</code>.</p> Source code in <code>cylindra/components/spline/_spline_base.py</code> <pre><code>def distances(\n    self,\n    positions: Sequence[float] | None = None,\n    nknots: int = 512,\n) -&gt; NDArray[np.float32]:\n    \"\"\"Get the distances from u=0.\n\n    Parameters\n    ----------\n    positions : sequence of float, optional\n        Positions. Between 0 and 1. If not given, anchors are used instead.\n\n    Returns\n    -------\n    np.ndarray\n        Distances for each `u`.\n    \"\"\"\n    if positions is None:\n        _u = self.anchors\n    else:\n        _u = np.asarray(positions, dtype=np.float32)\n        if _u.ndim != 1:\n            raise ValueError(\"Positions must be 1D array.\")\n    u = np.linspace(0, 1, nknots)\n    u_tr = _linear_conversion(u, *self._lims)\n    dz, dy, dx = map(np.diff, splev(u_tr, self._tck, der=0))\n    dist = np.concatenate([[0], np.sqrt(dx**2 + dy**2 + dz**2)]).cumsum()\n    tck = splrep(u, dist, k=1)\n    out = splev(_u, tck)\n    return out\n</code></pre>"},{"location":"api/components/#cylindra.components.spline.Spline.fit","title":"<code>fit(coords, *, err_max=1.0)</code>","text":"<p>Fit spline model to coordinates.</p> <p>This method uses <code>scipy.interpolate.splprep</code> to fit given coordinates to a spline.</p> <p>Parameters:</p> Name Type Description Default <code>coords</code> <code>ndarray</code> <p>Coordinates. Must be (N, 3).</p> required <code>err_max</code> <code>float</code> <p>Error allowed for fitting. Several upper limit of residual values will be used and the fit that results in error lower than this value and minimize the maximum curvature will be chosen.</p> <code>1.0</code> <p>Returns:</p> Type Description <code>Spline</code> <p>New spline fit to given coordinates.</p> Source code in <code>cylindra/components/spline/_spline_base.py</code> <pre><code>def fit(\n    self,\n    coords: ArrayLike,\n    *,\n    err_max: nm = 1.0,\n) -&gt; Self:\n    \"\"\"Fit spline model to coordinates.\n\n    This method uses `scipy.interpolate.splprep` to fit given coordinates to a\n    spline.\n\n    Parameters\n    ----------\n    coords : np.ndarray\n        Coordinates. Must be (N, 3).\n    err_max : float, default 1.0\n        Error allowed for fitting. Several upper limit of residual values will be\n        used and the fit that results in error lower than this value and minimize\n        the maximum curvature will be chosen.\n\n    Returns\n    -------\n    Spline\n        New spline fit to given coordinates.\n    \"\"\"\n    crds = np.asarray(coords)\n    npoints = crds.shape[0]\n    if npoints &lt; 2:\n        raise ValueError(\"Number of input coordinates must be &gt; 1.\")\n    if npoints &lt;= self.order:\n        k = npoints - 1\n    else:\n        k = self.order\n\n    if self.is_inverted():\n        crds = crds[::-1]\n\n    if err_max &gt; 4.0:\n        raise ValueError(\"std_max must be smaller than 4.0.\")\n    if err_max &lt; 1e-3:\n        std_list = [err_max]\n    else:\n        ntrial = max(int(err_max / 0.02), 2)\n        std_list = np.linspace(0, err_max, ntrial)[1:]\n\n    fit_results = list[SplineFitResult]()\n    new = self.__class__(order=k, extrapolate=self.extrapolate, config=self.config)\n    with warnings.catch_warnings():\n        # fitting may fail for some std\n        warnings.simplefilter(\"ignore\", RuntimeWarning)\n        for std in std_list:\n            _tck, _u = splprep(crds.T, k=k, s=std**2 * npoints)\n            new._set_params(_tck, _u)\n            _crds_at_u = new.map(_u)\n            res: NDArray[np.float32] = np.sqrt(\n                np.sum((_crds_at_u - crds) ** 2, axis=1)\n            )\n            _knots = _tck[0][new.order : -new.order]\n            nedge = _knots.size - 1\n            assert nedge &gt; 0\n            nanc = nedge * 20 + 1\n            anc = np.interp(\n                np.linspace(0, 1, nanc), np.linspace(0, 1, nedge + 1), _knots\n            )\n            max_curvature = new.curvature(anc).max()\n            success = res.max() &lt;= err_max\n            fit_results.append(\n                SplineFitResult((_tck, _u), max_curvature, res, success)\n            )\n\n    fit_results_filt = list(filter(lambda x: x.success, fit_results))\n    if len(fit_results_filt) == 0:\n        fit_results_filt = fit_results\n\n    reult_opt = min(fit_results_filt, key=lambda x: x.curvature)\n    return new._set_params(*reult_opt.params)\n</code></pre>"},{"location":"api/components/#cylindra.components.spline.Spline.from_dict","title":"<code>from_dict(d)</code>  <code>classmethod</code>","text":"<p>Construct a spline model from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>SplineInfo</code> <p>Dictionary with keys \"t\", \"c\", \"k\", \"u\" and \"lims\".</p> required <p>Returns:</p> Type Description <code>Spline</code> <p>Spline object constructed from the dictionary.</p> Source code in <code>cylindra/components/spline/_spline_base.py</code> <pre><code>@classmethod\ndef from_dict(cls: type[Self], d: SplineInfo) -&gt; Self:\n    \"\"\"Construct a spline model from a dictionary.\n\n    Parameters\n    ----------\n    d: dict\n        Dictionary with keys \"t\", \"c\", \"k\", \"u\" and \"lims\".\n\n    Returns\n    -------\n    Spline\n        Spline object constructed from the dictionary.\n    \"\"\"\n    self = cls(\n        order=d.get(\"k\", 3),\n        lims=d.get(\"lims\", (0, 1)),\n        extrapolate=d.get(\"extrapolate\", \"linear\"),\n    )\n    t = np.asarray(d[\"t\"])\n    c = [np.asarray(d[\"c\"][k]) for k in \"zyx\"]\n    k = roundint(d[\"k\"])\n    self._tck = (t, c, k)\n    self._u = np.asarray(d[\"u\"])\n    self.props._window_size = d.get(\"localprops_window_size\", {})\n    self.props._binsize_loc = d.get(\"binsize_loc\", {})\n    self.props._binsize_glob = d.get(\"binsize_glob\", {})\n    if cfg := d.get(\"config\", None):\n        self._config = SplineConfig.from_dict(cfg)\n    return self\n</code></pre>"},{"location":"api/components/#cylindra.components.spline.Spline.get_rotator","title":"<code>get_rotator(positions=None, inverse=False)</code>","text":"<p>Calculate list of Affine transformation matrix along spline.</p> <p>The matrices correspond to the orientation of spline curve.</p> <p>Parameters:</p> Name Type Description Default <code>positions</code> <code>(array - like, (N,))</code> <p>Positions. Between 0 and 1.</p> <code>None</code> <code>inverse</code> <code>bool</code> <p>If True, rotation matrix will be inversed.</p> <code>False</code> <p>Returns:</p> Type Description <code>Rotation</code> <p>Rotation object at each anchor.</p> Source code in <code>cylindra/components/spline/_spline_base.py</code> <pre><code>def get_rotator(\n    self,\n    positions: Sequence[float] | None = None,\n    inverse: bool = False,\n) -&gt; Rotation:\n    \"\"\"Calculate list of Affine transformation matrix along spline.\n\n    The matrices correspond to the orientation of spline curve.\n\n    Parameters\n    ----------\n    positions : array-like, (N,)\n        Positions. Between 0 and 1.\n    inverse : bool, default False\n        If True, rotation matrix will be inversed.\n\n    Returns\n    -------\n    Rotation\n        Rotation object at each anchor.\n    \"\"\"\n    if positions is None:\n        positions = self.anchors\n    ds = self.map(positions, der=1)\n    out = axes_to_rotator(None, -ds)\n\n    if inverse:\n        out = out.inv()\n\n    return out\n</code></pre>"},{"location":"api/components/#cylindra.components.spline.Spline.has_props","title":"<code>has_props()</code>","text":"<p>True if there are any properties.</p> Source code in <code>cylindra/components/spline/_spline_base.py</code> <pre><code>def has_props(self) -&gt; bool:\n    \"\"\"True if there are any properties.\"\"\"\n    return len(self.props.loc) &gt; 0 or len(self.props.glob) &gt; 0\n</code></pre>"},{"location":"api/components/#cylindra.components.spline.Spline.invert","title":"<code>invert()</code>","text":"<p>Invert the direction of spline.</p> <p>Returns:</p> Type Description <code>Spline</code> <p>Inverted object</p> Source code in <code>cylindra/components/spline/_spline_base.py</code> <pre><code>def invert(self) -&gt; Self:\n    \"\"\"Invert the direction of spline.\n\n    Returns\n    -------\n    Spline\n        Inverted object\n    \"\"\"\n    anchors = self._anchors\n    inverted = self.clip(1.0, 0.0)\n    if anchors is not None:\n        inverted.anchors = 1 - anchors[::-1]\n    return inverted\n</code></pre>"},{"location":"api/components/#cylindra.components.spline.Spline.is_inverted","title":"<code>is_inverted()</code>","text":"<p>Return true if spline is inverted.</p> Source code in <code>cylindra/components/spline/_spline_base.py</code> <pre><code>def is_inverted(self) -&gt; bool:\n    \"\"\"Return true if spline is inverted.\"\"\"\n    return self._lims[0] &gt; self._lims[1]\n</code></pre>"},{"location":"api/components/#cylindra.components.spline.Spline.length","title":"<code>length(start=0, stop=1, nknots=512)</code>","text":"<p>Length of the spline.</p> <p>Approximate the length of B-spline between [start, stop] by partitioning the spline with 'nknots' knots. nknots=256 is large enough for most cases.</p> Source code in <code>cylindra/components/spline/_spline_base.py</code> <pre><code>def length(self, start: float = 0, stop: float = 1, nknots: int = 512) -&gt; nm:\n    \"\"\"Length of the spline.\n\n    Approximate the length of B-spline between [start, stop] by partitioning\n    the spline with 'nknots' knots. nknots=256 is large enough for most cases.\n    \"\"\"\n    _assert_fitted(self)\n    u = np.linspace(start, stop, nknots)\n    u_tr = _linear_conversion(u, *self._lims)\n    dz, dy, dx = map(np.diff, splev(u_tr, self._tck, der=0))\n    return np.sum(np.sqrt(dx**2 + dy**2 + dz**2))\n</code></pre>"},{"location":"api/components/#cylindra.components.spline.Spline.line","title":"<code>line(start, end, extrapolate=ExtrapolationMode.linear)</code>  <code>classmethod</code>","text":"<p>Create a linear spline.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>array_like</code> <p>Start point of the line.</p> required <code>end</code> <code>array_like</code> <p>End point of the line.</p> required <code>extrapolate</code> <code>ExtrapolationMode or str</code> <p>Extrapolation mode.</p> <code>'linear'</code> <p>Returns:</p> Type Description <code>Spline</code> <p>Line spline.</p> Source code in <code>cylindra/components/spline/_spline_base.py</code> <pre><code>@classmethod\ndef line(\n    cls,\n    start: ArrayLike,\n    end: ArrayLike,\n    extrapolate: ExtrapolationMode | str = ExtrapolationMode.linear,\n) -&gt; Self:\n    \"\"\"Create a linear spline.\n\n    Parameters\n    ----------\n    start : array_like\n        Start point of the line.\n    end : array_like\n        End point of the line.\n    extrapolate : ExtrapolationMode or str, default 'linear'\n        Extrapolation mode.\n\n    Returns\n    -------\n    Spline\n        Line spline.\n    \"\"\"\n    spl = cls(extrapolate=extrapolate)\n    coords = np.stack([start, end], axis=0)\n    return spl.fit(coords, err_max=0.0)\n</code></pre>"},{"location":"api/components/#cylindra.components.spline.Spline.local_cartesian","title":"<code>local_cartesian(shape, depth, u=None, scale=1.0)</code>","text":"<p>Generate local Cartesian coordinate systems.</p> <p>The generated array can be used for <code>ndi.map_coordinates</code>. The result coordinate systems are flat, i.e., not distorted by the curvature of spline.</p> <p>Parameters:</p> Name Type Description Default <code>shape</code> <code>(float, float)</code> <p>Vertical and horizontal length of Cartesian coordinates. Corresponds to zx axes.</p> required <code>depth</code> <code>float</code> <p>Length of y axis in nm.</p> required <code>u</code> <code>float</code> <p>Position on the spline at which local Cartesian coordinates will be built.</p> <code>None</code> <code>scale</code> <code>nm</code> <p>Scale of coordinates, i.e. spacing of the grid.</p> <code>1.0</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>(D, V, S, H) shape. Each cooresponds to dimensional vertical, longitudinal and horizontal axis, which is ready to be used in <code>ndi.map_coordinates</code>.</p> Source code in <code>cylindra/components/spline/_spline_base.py</code> <pre><code>def local_cartesian(\n    self,\n    shape: tuple[nm, nm],\n    depth: nm,\n    u: float | Sequence[float] = None,\n    scale: nm = 1.0,\n) -&gt; NDArray[np.float32]:\n    \"\"\"Generate local Cartesian coordinate systems.\n\n    The generated array can be used for `ndi.map_coordinates`. The result coordinate\n    systems are flat, i.e., not distorted by the curvature of spline.\n\n    Parameters\n    ----------\n    shape : (float, float)\n        Vertical and horizontal length of Cartesian coordinates. Corresponds to zx\n        axes.\n    depth : float\n        Length of y axis in nm.\n    u : float, optional\n        Position on the spline at which local Cartesian coordinates will be built.\n    scale: nm, default 1.0\n        Scale of coordinates, i.e. spacing of the grid.\n\n    Returns\n    -------\n    np.ndarray\n        (D, V, S, H) shape. Each cooresponds to dimensional vertical, longitudinal\n        and horizontal axis, which is ready to be used in `ndi.map_coordinates`.\n    \"\"\"\n\n    mole = self.anchors_to_molecules(u)\n    nz = roundint(shape[0] / scale)\n    ny = roundint(depth / scale)\n    nx = roundint(shape[1] / scale)\n    return mole.local_coordinates(shape=(nz, ny, nx), scale=scale)\n</code></pre>"},{"location":"api/components/#cylindra.components.spline.Spline.local_cylindrical","title":"<code>local_cylindrical(r_range, depth, u=None, scale=1.0)</code>","text":"<p>Generate local cylindrical coordinate systems.</p> <p>The generated array can be used for <code>ndi.map_coordinates</code>. The result coordinate systems are flat, i.e., not distorted by the curvature of spline.</p> <p>Parameters:</p> Name Type Description Default <code>r_range</code> <code>(float, float)</code> <p>Lower and upper bound of radius in nm.</p> required <code>depth</code> <code>nm</code> <p>Length of y axis in nm.</p> required <code>u</code> <code>float</code> <p>Position on the spline at which local cylindrical coordinates will be built.</p> <code>None</code> <code>scale</code> <code>nm</code> <p>Scale of coordinates, i.e. spacing of the grid.</p> <code>1.0</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>(D, V, S, H) shape. Each cooresponds to dimensional, radius, longitudinal and angle axis, which is ready to be used in <code>ndi.map_coordinates</code>.</p> Source code in <code>cylindra/components/spline/_spline_base.py</code> <pre><code>def local_cylindrical(\n    self,\n    r_range: tuple[nm, nm],\n    depth: nm,\n    u: float | None = None,\n    scale: nm = 1.0,\n) -&gt; NDArray[np.float32]:\n    \"\"\"Generate local cylindrical coordinate systems.\n\n    The generated array can be used for `ndi.map_coordinates`. The result coordinate\n    systems are flat, i.e., not distorted by the curvature of spline.\n\n    Parameters\n    ----------\n    r_range : (float, float)\n        Lower and upper bound of radius in nm.\n    depth : nm\n        Length of y axis in nm.\n    u : float\n        Position on the spline at which local cylindrical coordinates will be built.\n    scale: nm, default 1.0\n        Scale of coordinates, i.e. spacing of the grid.\n\n    Returns\n    -------\n    np.ndarray\n        (D, V, S, H) shape. Each cooresponds to dimensional, radius, longitudinal\n        and angle axis, which is ready to be used in `ndi.map_coordinates`.\n    \"\"\"\n    if u is None:\n        u = self.anchors\n    rmin, rmax = r_range\n    ds = self.map(u, der=1)\n    ds_norm: NDArray[np.float32] = ds.reshape(-1, 1) / np.sqrt(sum(ds**2))\n    depth_px = roundint(depth / scale)\n    grid = np.linspace(-depth_px / 2 + 0.5, depth_px / 2 - 0.5, depth_px)\n    dy = ds_norm * grid\n    y_ax_coords = (self.map(u) / scale).reshape(1, -1) + dy.T\n    dslist = np.stack([ds] * depth_px, axis=0)\n    map_ = polar_coords_2d(rmin / scale, rmax / scale)\n    map_slice = _stack_coords(map_)\n    out = _rot_with_vector(map_slice, y_ax_coords, dslist)\n    return np.moveaxis(out, -1, 0)\n</code></pre>"},{"location":"api/components/#cylindra.components.spline.Spline.make_anchors","title":"<code>make_anchors(interval=None, n=None, max_interval=None)</code>","text":"<p>Make anchor points at constant intervals.</p> <p>Either interval, number of anchor or the maximum interval between anchors can be specified.</p> <p>Parameters:</p> Name Type Description Default <code>interval</code> <code>nm</code> <p>Interval between anchor points.</p> <code>None</code> <code>n</code> <code>int</code> <p>Number of anchor points, including both ends.</p> <code>None</code> <code>max_interval</code> <code>nm | None</code> <p>Spline will be split by as little anchors as possible but interval between anchors will not be larger than this. The number of anchors are also guaranteed to be larger than spline order.</p> <code>None</code> Source code in <code>cylindra/components/spline/_spline_base.py</code> <pre><code>def make_anchors(\n    self,\n    interval: nm | None = None,\n    n: int | None = None,\n    max_interval: nm | None = None,\n) -&gt; Self:\n    \"\"\"Make anchor points at constant intervals.\n\n    Either interval, number of anchor or the maximum interval between anchors can be\n    specified.\n\n    Parameters\n    ----------\n    interval : nm, optional\n        Interval between anchor points.\n    n : int, optional\n        Number of anchor points, including both ends.\n    max_interval: nm, optional\n        Spline will be split by as little anchors as possible but interval between\n        anchors will not be larger than this. The number of anchors are also\n        guaranteed to be larger than spline order.\n    \"\"\"\n    self.anchors = self.prep_anchor_positions(interval, n, max_interval)\n    return self\n</code></pre>"},{"location":"api/components/#cylindra.components.spline.Spline.map","title":"<code>map(positions=None, der=0)</code>","text":"<p>Calculate coordinates (or n-th derivative) at points on the spline.</p> <p>Parameters:</p> Name Type Description Default <code>positions</code> <code>ndarray or float</code> <p>Positions. Between 0 and 1. If not given, anchors are used instead.</p> <code>None</code> <code>der</code> <code>int</code> <p><code>der</code>-th derivative will be calculated.</p> <code>0</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Positions or vectors in (3,) or (N, 3) shape.</p> Source code in <code>cylindra/components/spline/_spline_base.py</code> <pre><code>def map(\n    self,\n    positions: float | NDArray[np.number] | None = None,\n    der: int = 0,\n) -&gt; NDArray[np.float32]:\n    \"\"\"Calculate coordinates (or n-th derivative) at points on the spline.\n\n    Parameters\n    ----------\n    positions : np.ndarray or float, optional\n        Positions. Between 0 and 1. If not given, anchors are used instead.\n    der : int, default 0\n        `der`-th derivative will be calculated.\n\n    Returns\n    -------\n    np.ndarray\n        Positions or vectors in (3,) or (N, 3) shape.\n    \"\"\"\n    _assert_fitted(self)\n    if positions is None:\n        positions = self.anchors\n    u0, u1 = self._lims\n    if np.isscalar(positions):\n        if self.order &lt; der:\n            return np.zeros(3, dtype=np.float32)\n        u_tr = _linear_conversion(float(positions), u0, u1)\n        if 0 &lt;= u_tr &lt;= 1 or self.extrapolate is ExtrapolationMode.default:\n            coord = splev([u_tr], self._tck, der=der)\n        elif self.extrapolate is ExtrapolationMode.linear:\n            if der == 0:\n                if u_tr &lt; 0:\n                    der0 = splev([0], self._tck, der=0)\n                    der1 = splev([0], self._tck, der=1)\n                    dr = u_tr\n                else:\n                    der0 = splev([1], self._tck, der=0)\n                    der1 = splev([1], self._tck, der=1)\n                    dr = u_tr - 1\n                coord = [a0 + a1 * dr for a0, a1 in zip(der0, der1, strict=True)]\n            elif der == 1:\n                if u_tr &lt; 0:\n                    coord = splev([0], self._tck, der=1)\n                else:\n                    coord = splev([1], self._tck, der=1)\n            else:\n                coord = [[0], [0], [0]]\n        else:\n            raise ValueError(f\"Invalid extrapolation mode: {self.extrapolate!r}.\")\n        out = np.concatenate(coord).astype(np.float32)\n\n    else:\n        u_tr = _linear_conversion(np.asarray(positions, dtype=np.float32), u0, u1)\n        if self.order &lt; der:\n            return np.zeros((u_tr.size, 3), dtype=np.float32)\n        if self.extrapolate is ExtrapolationMode.default:\n            out = np.stack(splev(u_tr, self._tck, der=der), axis=1).astype(\n                np.float32\n            )\n        elif self.extrapolate is ExtrapolationMode.linear:\n            sl_small = u_tr &lt; 0\n            sl_large = u_tr &gt; 1\n            n_small = np.count_nonzero(sl_small)\n            n_large = np.count_nonzero(sl_large)\n            out = np.stack(splev(u_tr, self._tck, der=der), axis=1).astype(\n                np.float32\n            )\n            if der == 0:\n                if n_small &gt; 0:\n                    der0 = np.array(splev(0, self._tck, der=0), dtype=np.float32)\n                    der1 = np.array(splev(0, self._tck, der=1), dtype=np.float32)\n                    dr = u_tr[sl_small]\n                    coords_new = der0 + der1 * dr[:, np.newaxis]\n                    out[sl_small] = coords_new\n\n                if n_large &gt; 0:\n                    der0 = splev(1, self._tck, der=0)\n                    der1 = splev(1, self._tck, der=1)\n                    dr = u_tr[sl_large] - 1\n                    coords_new = der0 + der1 * dr[:, np.newaxis]\n                    out[sl_large] = coords_new\n\n            elif der == 1:\n                if n_small &gt; 0:\n                    out[sl_small] = splev(0, self._tck, der=1)\n                if n_large &gt; 0:\n                    out[sl_large] = splev(1, self._tck, der=1)\n            else:\n                if n_small &gt; 0:\n                    out[sl_small] = 0\n                if n_large &gt; 0:\n                    out[sl_large] = 0\n        else:\n            raise ValueError(f\"Invalid extrapolation mode: {self.extrapolate!r}.\")\n\n    if u0 &gt; u1 and der % 2 == 1:\n        out = -out\n    return out\n</code></pre>"},{"location":"api/components/#cylindra.components.spline.Spline.partition","title":"<code>partition(n, der=0)</code>","text":"<p>Return the n-partitioning coordinates of the spline.</p> Source code in <code>cylindra/components/spline/_spline_base.py</code> <pre><code>def partition(self, n: int, der: int = 0) -&gt; NDArray[np.float32]:\n    \"\"\"Return the n-partitioning coordinates of the spline.\"\"\"\n    u = np.linspace(0, 1, n)\n    return self.map(u, der)\n</code></pre>"},{"location":"api/components/#cylindra.components.spline.Spline.resample","title":"<code>resample(max_interval=1.0, err_max=0.1)</code>","text":"<p>Resample a new spline along the original spline.</p> <p>Parameters:</p> Name Type Description Default <code>max_interval</code> <code>nm</code> <p>Maximum interval between resampling points.</p> <code>1.0</code> <code>err_max</code> <code>float</code> <p>Spline fitting maximum error.</p> <code>0.1</code> <p>Returns:</p> Type Description <code>Spline</code> <p>Resampled spline object.</p> Source code in <code>cylindra/components/spline/_spline_base.py</code> <pre><code>def resample(self, max_interval: nm = 1.0, err_max: nm = 0.1) -&gt; Self:\n    \"\"\"Resample a new spline along the original spline.\n\n    Parameters\n    ----------\n    max_interval : nm, default 1.0\n        Maximum interval between resampling points.\n    err_max : float, default 0.1\n        Spline fitting maximum error.\n\n    Returns\n    -------\n    Spline\n        Resampled spline object.\n    \"\"\"\n    l = self.length()\n    points = self.map(np.linspace(0, 1, ceilint(l / max_interval)))\n    return self.fit(points, err_max=err_max)\n</code></pre>"},{"location":"api/components/#cylindra.components.spline.Spline.restore","title":"<code>restore()</code>","text":"<p>Restore the original, not-clipped spline.</p> <p>Returns:</p> Type Description <code>Spline</code> <p>Copy of the original spline.</p> Source code in <code>cylindra/components/spline/_spline_base.py</code> <pre><code>def restore(self) -&gt; Self:\n    \"\"\"Restore the original, not-clipped spline.\n\n    Returns\n    -------\n    Spline\n        Copy of the original spline.\n    \"\"\"\n    return self.__class__(\n        order=self.order,\n        lims=(0, 1),\n        extrapolate=self.extrapolate,\n        config=self.config,\n    )._set_params(self._tck, self._u)\n</code></pre>"},{"location":"api/components/#cylindra.components.spline.Spline.shift","title":"<code>shift(positions=None, shifts=None, *, err_max=1.0)</code>","text":"<p>Fit spline model using a list of shifts in XZ-plane.</p> <p>Parameters:</p> Name Type Description Default <code>positions</code> <code>sequence of float</code> <p>Positions. Between 0 and 1. If not given, anchors are used instead.</p> <code>None</code> <code>shifts</code> <code>ndarray</code> <p>Shift from center in nm. Must be (N, 2).</p> <code>None</code> <code>err_max</code> <code>float</code> <p>Error allowed for fitting. See <code>Spline.fit</code>.</p> <code>1.0</code> <p>Returns:</p> Type Description <code>Spline</code> <p>Spline shifted by fitting to given coordinates.</p> Source code in <code>cylindra/components/spline/_spline_base.py</code> <pre><code>def shift(\n    self,\n    positions: Sequence[float] | None = None,\n    shifts: NDArray[np.floating] | None = None,\n    *,\n    err_max: nm = 1.0,\n) -&gt; Self:\n    \"\"\"Fit spline model using a list of shifts in XZ-plane.\n\n    Parameters\n    ----------\n    positions : sequence of float, optional\n        Positions. Between 0 and 1. If not given, anchors are used instead.\n    shifts : np.ndarray\n        Shift from center in nm. Must be (N, 2).\n    err_max : float, default 1.0\n        Error allowed for fitting. See `Spline.fit`.\n\n    Returns\n    -------\n    Spline\n        Spline shifted by fitting to given coordinates.\n    \"\"\"\n    if shifts is None:\n        raise ValueError(\"Shifts must be given.\")\n    coords = self.map(positions)\n    rot = self.get_rotator(positions)\n    # insert 0 in y coordinates.\n    shifts = np.stack([shifts[:, 0], np.zeros(len(rot)), shifts[:, 1]], axis=1)\n    coords += rot.apply(shifts)\n    return self.fit(coords, err_max=err_max)\n</code></pre>"},{"location":"api/components/#cylindra.components.spline.Spline.split","title":"<code>split(at, from_start=True, trim=0.0, allow_discard=False)</code>","text":"<p>Split the spline at the given position.</p> Source code in <code>cylindra/components/spline/_spline_base.py</code> <pre><code>def split(\n    self,\n    at: nm,\n    from_start: bool = True,\n    trim: nm = 0.0,\n    allow_discard: bool = False,\n) -&gt; list[Self]:\n    \"\"\"Split the spline at the given position.\"\"\"\n    spl_len = self.length()\n    if not from_start:\n        at = spl_len - at\n    at_rel_0 = (at - trim) / spl_len\n    at_rel_1 = (at + trim) / spl_len\n    out = list[\"Self\"]()\n    if at_rel_0 &gt;= 0:\n        out.append(self.clip(0.0, at_rel_0))\n    elif not allow_discard:\n        raise ValueError(\n            \"Split position must be over `trim` if allow_discard is False, but \"\n            f\"tried to split at {at:.1f} nm.\"\n        )\n    if at_rel_1 &lt;= 1.0:\n        out.append(self.clip(at_rel_1, 1.0))\n    elif not allow_discard:\n        raise ValueError(\n            \"Split position must be under `length - trim` if allow_discard is \"\n            f\"False, but tried to split at {at:.1f} nm (length = {spl_len:.1f}).\"\n        )\n    return out\n</code></pre>"},{"location":"api/components/#cylindra.components.spline.Spline.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert spline info into a dict.</p> Source code in <code>cylindra/components/spline/_spline_base.py</code> <pre><code>def to_dict(self) -&gt; SplineInfo:\n    \"\"\"Convert spline info into a dict.\"\"\"\n    t, c, k = self._tck\n    u = self._u\n    return {\n        \"t\": t.tolist(),\n        \"c\": {\"z\": c[0].tolist(), \"y\": c[1].tolist(), \"x\": c[2].tolist()},\n        \"k\": k,\n        \"u\": u.tolist(),\n        \"lims\": self._lims,\n        \"localprops_window_size\": dict(self.props.window_size),\n        \"binsize_loc\": dict(self.props.binsize_loc),\n        \"binsize_glob\": dict(self.props.binsize_glob),\n        \"extrapolate\": self._extrapolate.name,\n        \"config\": self.config.asdict(),\n    }\n</code></pre>"},{"location":"api/components/#cylindra.components.spline.Spline.translate","title":"<code>translate(shift)</code>","text":"<p>Translate the spline by given shift vectors.</p> Source code in <code>cylindra/components/spline/_spline_base.py</code> <pre><code>def translate(self, shift: tuple[nm, nm, nm]):\n    \"\"\"Translate the spline by given shift vectors.\"\"\"\n    new = self.copy()\n    c = [x + s for x, s in zip(self.coeff, shift, strict=True)]\n    new._tck = (self.knots, c, self.order)\n    return new\n</code></pre>"},{"location":"api/components/#cylindra.components.spline.Spline.with_config","title":"<code>with_config(config, copy_props=False)</code>","text":"<p>Return a copy of the spline with a new config.</p> Source code in <code>cylindra/components/spline/_spline_base.py</code> <pre><code>def with_config(\n    self,\n    config: dict[str, Any] | SplineConfig,\n    copy_props: bool = False,\n) -&gt; Self:\n    \"\"\"Return a copy of the spline with a new config.\"\"\"\n    new = self.copy(copy_props=copy_props, copy_config=False)\n    if not isinstance(config, SplineConfig):\n        config = SplineConfig.construct(**config)\n    new._config = config\n    return new\n</code></pre>"},{"location":"api/components/#cylindra.components.spline.Spline.with_extrapolation","title":"<code>with_extrapolation(extrapolate)</code>","text":"<p>Return a copy of the spline with a new extrapolation mode.</p> Source code in <code>cylindra/components/spline/_spline_base.py</code> <pre><code>def with_extrapolation(self, extrapolate: ExtrapolationMode | str) -&gt; Self:\n    \"\"\"Return a copy of the spline with a new extrapolation mode.\"\"\"\n    new = self.copy()\n    new._extrapolate = ExtrapolationMode(extrapolate)\n    return new\n</code></pre>"},{"location":"api/components/#cylindra.components.spline.Spline.y_to_position","title":"<code>y_to_position(y, nknots=512)</code>","text":"<p>Convert y-coordinate to spline position parameter.</p> <p>Parameters:</p> Name Type Description Default <code>y</code> <code>array - like</code> <p>Y coordinates.</p> required <code>nknots</code> <code>int</code> <p>Number of knots. Increasing the number of knots will increase the accuracy.</p> <code>512</code> Source code in <code>cylindra/components/spline/_spline_base.py</code> <pre><code>def y_to_position(\n    self, y: NDArray[np.float32], nknots: int = 512\n) -&gt; NDArray[np.float32]:\n    \"\"\"Convert y-coordinate to spline position parameter.\n\n    Parameters\n    ----------\n    y : array-like\n        Y coordinates.\n    nknots : int, optional\n        Number of knots. Increasing the number of knots will increase the accuracy.\n    \"\"\"\n    # almost equal to y / self.length()\n    u = np.linspace(0, 1, nknots)\n    u_tr = _linear_conversion(u, *self._lims)\n    dz, dy, dx = map(np.diff, splev(u_tr, self._tck, der=0))\n    dist = np.concatenate([[0], np.sqrt(dx**2 + dy**2 + dz**2)]).cumsum()\n    tck = splrep(dist, u, k=1)\n    out = splev(y, tck)\n    return out\n</code></pre>"},{"location":"api/components/#cylindra.components.spline.SplineConfig","title":"<code>SplineConfig</code>  <code>dataclass</code>","text":"<p>Class for spline configuration.</p> Source code in <code>cylindra/components/spline/_config.py</code> <pre><code>@dataclass(frozen=True)\nclass SplineConfig:\n    \"\"\"Class for spline configuration.\"\"\"\n\n    npf_range: Range[int] = Range(11, 17)\n    spacing_range: Range[nm] = Range(3.9, 4.3)\n    twist_range: Range[float] = Range(-1.0, 1.0)\n    rise_range: Range[float] = Range(0.0, 45.0)\n    rise_sign: Literal[-1, 1] = -1\n    clockwise: Literal[\"PlusToMinus\", \"MinusToPlus\"] = \"MinusToPlus\"\n    thickness_inner: nm = 2.0\n    thickness_outer: nm = 3.0\n    fit_depth: nm = 48.0\n    fit_width: nm = 44.0\n\n    def _repr_pretty_(self, p, cycle: bool):\n        if cycle:\n            p.text(repr(self))\n        parts = list[str]()\n        for k in self.__dataclass_fields__:\n            v = getattr(self, k)\n            parts.append(f\"{k}={v!r}\")\n        cont = \",\\n\\t\".join(parts)\n        p.text(f\"SplineConfig(\\n\\t{cont}\\n)\")\n\n    def copy(self) -&gt; SplineConfig:\n        return SplineConfig(\n            npf_range=self.npf_range.copy(),\n            spacing_range=self.spacing_range.copy(),\n            twist_range=self.twist_range.copy(),\n            rise_range=self.rise_range.copy(),\n            rise_sign=self.rise_sign,\n            clockwise=self.clockwise,\n            thickness_inner=self.thickness_inner,\n            thickness_outer=self.thickness_outer,\n            fit_depth=self.fit_depth,\n            fit_width=self.fit_width,\n        )\n\n    def asdict(self) -&gt; dict[str, Any]:\n        return {\n            \"npf_range\": self.npf_range.astuple(),\n            \"spacing_range\": self.spacing_range.astuple_rounded(),\n            \"twist_range\": self.twist_range.astuple_rounded(),\n            \"rise_range\": self.rise_range.astuple_rounded(),\n            \"rise_sign\": self.rise_sign,\n            \"clockwise\": self.clockwise,\n            \"thickness_inner\": self.thickness_inner,\n            \"thickness_outer\": self.thickness_outer,\n            \"fit_depth\": self.fit_depth,\n            \"fit_width\": self.fit_width,\n        }\n\n    def json_dumps(self) -&gt; str:\n        strings = list[str]()\n        for k, v in self.asdict().items():\n            if isinstance(v, tuple):\n                strings.append(f'\"{k}\": {list(v)!r}'.replace(\"'\", '\"'))\n            else:\n                strings.append(f'\"{k}\": {v!r}'.replace(\"'\", '\"'))\n        return \"{\\n    \" + \",\\n    \".join(strings) + \"\\n}\"\n\n    @classmethod\n    def construct(cls, **kwargs) -&gt; SplineConfig:\n        \"\"\"Construct a SplineConfig with argument check.\"\"\"\n        return SplineConfig().updated(**kwargs)\n\n    @classmethod\n    def from_dict(\n        cls,\n        cfg: dict[str, Any],\n        unknown: Literal[\"warn\", \"error\", \"ignore\"] = \"warn\",\n    ) -&gt; SplineConfig:\n        # for version compatibility\n        _undef = {}\n        cfg_input = {}\n        for k, v in cfg.items():\n            if k not in SplineConfig.__annotations__:\n                _undef[k] = v\n            else:\n                cfg_input[k] = v\n\n        if _undef:\n            msg = f\"Unknown keys, maybe due to version incompatibility: {_undef!r}\"\n            match unknown:\n                case \"error\":\n                    raise ValueError(msg)\n                case \"warn\":\n                    warnings.warn(msg, RuntimeWarning, stacklevel=2)\n                case \"ignore\":\n                    pass\n                case other:  # pragma: no cover\n                    raise ValueError(f\"Got invalid case {other!r}\")\n        return SplineConfig().updated(**cfg_input)\n\n    @classmethod\n    def from_file(\n        cls,\n        path: str,\n        unknown: Literal[\"warn\", \"error\", \"ignore\"] = \"warn\",\n    ) -&gt; SplineConfig:\n        with open(path) as f:\n            cfg: dict = json.load(f)\n        return SplineConfig.from_dict(cfg, unknown=unknown)\n\n    def to_file(self, path: str):\n        with open(path, mode=\"w\") as f:\n            json.dump(self.asdict(), f)\n        return None\n\n    def updated(\n        self,\n        npf_range: tuple[int, int] | None = None,\n        spacing_range: tuple[nm, nm] | None = None,\n        twist_range: tuple[float, float] | None = None,\n        rise_range: tuple[float, float] | None = None,\n        rise_sign: Literal[-1, 1] | None = None,\n        clockwise: Literal[\"PlusToMinus\", \"MinusToPlus\"] | None = None,\n        thickness_inner: nm | None = None,\n        thickness_outer: nm | None = None,\n        fit_depth: nm | None = None,\n        fit_width: nm | None = None,\n    ) -&gt; SplineConfig:\n        kwargs = locals()\n        kwargs.pop(\"self\")\n        for k, v in kwargs.items():\n            if v is None:\n                kwargs[k] = getattr(self, k)\n        for rng in [\"npf_range\", \"spacing_range\", \"twist_range\", \"rise_range\"]:\n            kwargs[rng] = _norm_range(kwargs[rng])\n        if kwargs[\"rise_sign\"] not in [-1, 1]:\n            raise ValueError(\"rise_sign must be -1 or 1\")\n        if kwargs[\"clockwise\"] not in [\"PlusToMinus\", \"MinusToPlus\"]:\n            raise ValueError(\"clockwise must be PlusToMinus or MinusToPlus\")\n        for n in [\"thickness_inner\", \"thickness_outer\", \"fit_depth\", \"fit_width\"]:\n            if kwargs[n] &lt; 0:\n                raise ValueError(f\"{n} must be non-negative\")\n        return SplineConfig(**kwargs)\n</code></pre>"},{"location":"api/components/#cylindra.components.spline.SplineConfig.construct","title":"<code>construct(**kwargs)</code>  <code>classmethod</code>","text":"<p>Construct a SplineConfig with argument check.</p> Source code in <code>cylindra/components/spline/_config.py</code> <pre><code>@classmethod\ndef construct(cls, **kwargs) -&gt; SplineConfig:\n    \"\"\"Construct a SplineConfig with argument check.\"\"\"\n    return SplineConfig().updated(**kwargs)\n</code></pre>"},{"location":"api/components/#cylindra.components.tomogram.CylTomogram","title":"<code>CylTomogram</code>","text":"<p>               Bases: <code>Tomogram</code></p> <p>Tomogram with cylindrical splines.</p> Source code in <code>cylindra/components/tomogram/_cyl_tomo.py</code> <pre><code>class CylTomogram(Tomogram):\n    \"\"\"Tomogram with cylindrical splines.\"\"\"\n\n    def __init__(self):\n        super().__init__()\n        self._splines = SplineList()\n\n    @property\n    def splines(self) -&gt; SplineList:\n        \"\"\"List of splines.\"\"\"\n        return self._splines\n\n    def add_spline(\n        self,\n        coords: ArrayLike,\n        *,\n        order: int = 3,\n        err_max: nm = 0.5,\n        extrapolate: ExtrapolationMode | str = ExtrapolationMode.linear,\n        config: SplineConfig | dict[str, Any] = {},\n    ) -&gt; None:\n        \"\"\"Add spline path to tomogram.\n\n        Parameters\n        ----------\n        coords : array-like\n            (N, 3) array of coordinates. A spline curve that fit it well is added.\n        order : int, optional\n            Order of spline curve.\n        extrapolate : str, optional\n            Extrapolation mode of the spline.\n        config : SplineConfig or dict, optional\n            Configuration for spline fitting.\n        \"\"\"\n        _coords = np.asarray(coords)\n        ncoords = _coords.shape[0]\n        spl = CylSpline(\n            order=order,\n            config=config,\n            extrapolate=extrapolate,\n        ).fit(_coords, err_max=err_max)\n        interval: nm = 30.0\n        length = spl.length()\n\n        n = int(length / interval) + 1\n        fit = spl.map(np.linspace(0, 1, n))\n        if ncoords &lt;= spl.order and ncoords &lt; fit.shape[0]:\n            return self.add_spline(\n                fit,\n                order=order,\n                err_max=err_max,\n                extrapolate=extrapolate,\n                config=config,\n            )\n\n        self.splines.append(spl)\n        return None\n\n    @_misc.batch_process\n    def make_anchors(\n        self,\n        i: int = None,\n        *,\n        interval: nm | None = None,\n        n: int | None = None,\n        max_interval: nm | None = None,\n    ):\n        \"\"\"Make anchors on spline object(s).\n\n        Parameters\n        ----------\n        interval : nm, optional\n            Anchor intervals.\n        n : int, optional\n            Number of anchors\n        max_interval : nm, optional\n            Maximum interval between anchors.\n\n        \"\"\"\n        self.splines[i].make_anchors(interval=interval, n=n, max_interval=max_interval)\n        return None\n\n    def align_to_polarity(self, orientation: Ori | str = Ori.MinusToPlus) -&gt; Self:\n        \"\"\"Align all the splines in the direction parallel to the given polarity.\n\n        Parameters\n        ----------\n        orientation : Ori or str, default Ori.MinusToPlus\n            To which direction splines will be aligned.\n\n        Returns\n        -------\n        Tomogram object\n            Same object with updated splines.\n        \"\"\"\n        orientation = Ori(orientation)\n        if orientation is Ori.none:\n            raise ValueError(\"Must be PlusToMinus or MinusToPlus.\")\n        for i, spl in enumerate(self.splines):\n            if spl.orientation is Ori.none:\n                raise ValueError(f\"Spline-{i} has no orientation.\")\n            if spl.orientation != orientation:\n                try:\n                    self.splines[i] = spl.invert()\n                except Exception as e:\n                    raise type(e)(f\"Cannot invert spline-{i}: {e}\")\n        return self\n\n    @_misc.batch_process\n    def fit(\n        self,\n        i: int = None,\n        *,\n        max_interval: nm = 30.0,\n        degree_precision: float = 0.5,\n        binsize: int = 1,\n        err_max: nm = 1.0,\n        edge_sigma: nm = 2.0,\n        max_shift: nm = 5.0,\n        n_rotations: int = 5,\n    ) -&gt; _misc.FitResult:\n        \"\"\"Roughly fit splines to cylindrical structures.\n\n        Subtomograms will be sampled at every `max_interval` nm. In dense mode,\n        Subtomograms will be masked relative to XY-plane, using sigmoid function.\n        Sharpness of the sigmoid function is determined by `dense_mode_sigma`\n        (`dense_mode_sigma=0` corresponds to a step function).\n\n        Parameters\n        ----------\n        i : int or iterable of int, optional\n            Spline ID that you want to fit.\n        max_interval : nm, default 30.0\n            Maximum interval of sampling points in nm unit.\n        degree_precision : float, default 0.5\n            Precision of xy-tilt degree in angular correlation.\n        binsize : int, default 1\n            Multiscale bin size used for fitting.\n        edge_sigma : nm, default 2.0\n            Sharpness of mask at the edges. If not None, fitting will be executed after regions\n            outside the cylinder are masked. Soft mask is important for precision because sharp\n            changes in intensity cause strong correlation at the edges.\n        max_shift: nm, default 5.0\n            Maximum shift from the true center of the cylinder. This parameter is used in phase\n            cross correlation.\n        n_rotations : int, default 5\n            Number of rotations to be tested during finding the cylinder center.\n\n        Returns\n        -------\n        FitResult\n            Result of fitting.\n        \"\"\"\n        LOGGER.info(f\"Running: {self.__class__.__name__}.fit, i={i}\")\n        spl = self.splines[i]\n        anc = spl.prep_anchor_positions(max_interval=max_interval)\n        subtomograms, interval, scale = self._prep_fit_spline(spl, anc, binsize)\n\n        with set_gpu():\n            subtomograms = _misc.soft_mask_edges(\n                subtomograms, spl, anc, scale, edge_sigma\n            )\n            ds = spl.map(anc, der=1)\n            yx_tilt = np.rad2deg(np.arctan2(-ds[:, 2], ds[:, 1]))\n            degree_max = 14.0\n            nrots = roundint(degree_max / degree_precision) + 1\n\n            # Angular correlation\n            out = _misc.dask_angle_corr(subtomograms, yx_tilt, nrots=nrots)\n            refined_tilt_deg = np.array(out)\n            refined_tilt_rad = np.deg2rad(refined_tilt_deg)\n\n            # If subtomograms are sampled at short intervals, angles should be smoothened to\n            # avoid overfitting.\n            size = 2 * roundint(48.0 / interval) + 1\n            if size &gt; 1:\n                # Mirror-mode padding is \"a b c d | c b a\".\n                refined_tilt_rad = _misc.angle_uniform_filter(\n                    refined_tilt_rad, size=size, mode=Mode.mirror\n                )\n                refined_tilt_deg = np.rad2deg(refined_tilt_rad)\n\n            # Rotate subtomograms in YX plane\n            for _j, img in enumerate(subtomograms):\n                img: ip.ImgArray\n                angle = refined_tilt_deg[_j]\n                img.rotate(-angle, cval=0, update=True)\n\n            # zx-shift correction by self-ZNCC\n            subtomo_proj = subtomograms.mean(axis=\"y\")\n\n            if edge_sigma is not None:\n                # Regions outside the mask don't need to be considered.\n                xc = int(subtomo_proj.shape.x / 2)\n                w = int(spl.config.fit_width / scale / 2)\n                subtomo_proj = subtomo_proj[ip.slicer.x[xc - w : xc + w + 1]]\n\n            max_shift_px = max_shift / scale * 2\n            pf_ang = 360 / spl.config.npf_range.center\n            degrees = np.linspace(-pf_ang / 2, pf_ang / 2, n_rotations) + 180\n            shifts = _misc.multi_rotated_auto_zncc(subtomo_proj, degrees, max_shift_px)\n\n        # Update spline coordinates.\n        # Because centers of subtomogram are on lattice points of pixel coordinate,\n        # coordinates that will be shifted should be converted to integers.\n        coords_px = self.nm2pixel(spl.map(anc), binsize=binsize).astype(np.float32)\n        coords_px_new = _misc.shift_coords(coords_px, shifts, refined_tilt_rad)\n        coords = coords_px_new * scale + self.multiscale_translation(binsize)\n\n        # Update spline parameters\n        self.splines[i] = spl.fit(coords, err_max=err_max)\n        result = _misc.FitResult(shifts * scale)\n        LOGGER.info(f\" &gt;&gt; Shift RMSD = {result.rmsd:.3f} nm\")\n        return result\n\n    @_misc.batch_process\n    def fit_centroid(\n        self,\n        i: int = None,\n        *,\n        max_interval: nm = 30.0,\n        binsize: int = 1,\n        err_max: nm = 1.0,\n        max_shift: nm = 5.0,\n    ) -&gt; _misc.FitResult:\n        LOGGER.info(f\"Running: {self.__class__.__name__}.fit_centroid, i={i}\")\n        spl = self.splines[i]\n        anc = spl.prep_anchor_positions(max_interval=max_interval)\n        scale = self.scale * binsize\n\n        # sample subtomograms\n        loader = _misc.prep_loader_for_refine(self, spl, anc, binsize)\n        subtomograms = ip.asarray(loader.asnumpy(), axes=\"pzyx\").mean(axis=\"y\")[\n            ip.slicer.x[::-1]\n        ]\n        num, lz, lx = subtomograms.shape\n        dpx = ceilint(max_shift / scale)\n        sl_z = slice(max((lz - 1) // 2 - dpx, 0), min(lz // 2 + dpx + 1, lz))\n        sl_x = slice(max((lx - 1) // 2 - dpx, 0), min(lx // 2 + dpx + 1, lx))\n        centers = np.stack(\n            [centroid_2d(patch, sl_z, sl_x) for patch in subtomograms], axis=0\n        )\n        shifts = centers - np.column_stack(\n            [\n                np.full(num, (sl_z.start + sl_z.stop - 1) / 2),\n                np.full(num, (sl_x.start + sl_x.stop - 1) / 2),\n            ]\n        )\n        self.splines[i] = spl.shift(anc, shifts=shifts * scale, err_max=err_max)\n        result = _misc.FitResult(shifts * scale)\n        LOGGER.info(f\" &gt;&gt; Shift RMSD = {result.rmsd:.3f} nm\")\n        return result\n\n    @_misc.batch_process\n    def refine(\n        self,\n        i: int = None,\n        *,\n        max_interval: nm = 30.0,\n        binsize: int = 1,\n        err_max: nm = 1.0,\n        corr_allowed: float = 0.9,\n        max_shift: nm = 2.0,\n        n_rotations: int = 3,\n    ) -&gt; _misc.FitResult:\n        \"\"\"Spline refinement using global lattice structural parameters.\n\n        Refine spline using the result of previous fit and the global structural parameters.\n        During refinement, Y-projection of XZ cross section of cylinder is rotated with the\n        twist angles, thus is much more precise than the coarse fitting.\n\n        Parameters\n        ----------\n        i : int or iterable of int, optional\n            Spline ID that you want to fit.\n        max_interval : nm, default 24.0\n            Maximum interval of sampling points in nm unit.\n        binsize : int, default 1\n            Multiscale bin size used for refining.\n        corr_allowed : float, defaul is 0.9\n            How many images will be used to make template for alignment. If 0.9, then top\n            90% will be used.\n        max_shift: nm, default 2.0\n            Maximum shift from the true center of the cylinder. This parameter is used in\n            phase cross correlation.\n        n_rotations : int, default 3\n            Number of rotations to be tested during finding the cylinder center.\n\n        Returns\n        -------\n        FitResult\n            Result of fitting.\n        \"\"\"\n        LOGGER.info(f\"Running: {self.__class__.__name__}.refine, i={i}\")\n        spl = self.splines[i]\n        _required = [H.spacing, H.twist, H.npf]\n        if not spl.props.has_glob(_required):\n            if (radius := spl.radius) is None:\n                radius = self.measure_radius(\n                    i=i,\n                    binsize=binsize,\n                    positions=\"auto\",\n                    update=False,\n                )\n            with spl.props.temp_glob(radius=radius):\n                gprops = self.global_cft_params(\n                    i=i, binsize=binsize, nsamples=1, update=False\n                )\n        else:\n            gprops = spl.props.glob.select(_required)\n        gdict = {k: float(gprops[k][0]) for k in _required}\n        ancs = spl.prep_anchor_positions(max_interval=max_interval)\n\n        # Calculate Fourier parameters by cylindrical transformation along spline.\n        # Skew angles are divided by the angle of single protofilament and the residual\n        # angles are used, considering missing wedge effect.\n        space = gdict[H.spacing]\n        twist = gdict[H.twist]\n        npf = roundint(gdict[H.npf])\n\n        LOGGER.info(f\" &gt;&gt; Parameters: spacing = {space:.2f} nm, twist = {twist:.3f} deg, PF = {npf}\")  # fmt: skip\n\n        # complement twisting\n        pf_ang = 360 / npf\n        twists = _misc.get_twists(spl.length(), ancs.size, space, twist, npf)\n        scale = self.scale * binsize\n        loader = _misc.prep_loader_for_refine(self, spl, ancs, binsize, twists)\n        subtomograms = ip.asarray(loader.asnumpy(), axes=\"pzyx\", dtype=np.float32)\n        subtomograms[:] -= subtomograms.mean()  # normalize\n        subtomograms.set_scale(zyx=scale)\n\n        degrees = np.linspace(-pf_ang / 2, pf_ang / 2, n_rotations) + 180\n        max_shift_px = max_shift / scale\n        with set_gpu():\n            inputs = subtomograms.mean(axis=\"y\")[ip.slicer.x[::-1]]\n\n            # Align twist-corrected images\n            shifts_loc = _misc.multi_rotated_auto_zncc(inputs, degrees, max_shift_px)\n            tasks = [\n                _misc.delayed_translate(inputs[_j], shifts_loc[_j])\n                for _j in range(ancs.size)\n            ]\n            imgs_aligned = _filter_by_corr(\n                np.stack(compute(*tasks), axis=\"p\"),\n                corr_allowed,\n            )\n\n            # Make 2D template using coarse aligned images.\n            imgcory = imgs_aligned.mean(axis=\"p\")\n            shift = rotated_auto_zncc(\n                imgcory, degrees=degrees, max_shifts=max_shift_px * 2\n            )\n            template = imgcory.affine(translation=shift, mode=Mode.constant, cval=0.0)\n\n            # Align twist-corrected images to the template\n            quat = loader.molecules.quaternion()\n            tasks = [\n                _misc.delayed_zncc_maximum(\n                    inputs[_j],\n                    _misc.mask_missing_wedge(template, self.tilt_model, quat[_j]),\n                    max_shift_px,\n                    twists[_j],\n                )\n                for _j in range(ancs.size)\n            ]\n            shifts = np.stack(compute(*tasks), axis=0)\n\n        # Update spline parameters\n        self.splines[i] = spl.shift(ancs, shifts=shifts * scale, err_max=err_max)\n        result = _misc.FitResult(shifts * scale)\n        LOGGER.info(f\" &gt;&gt; Shift RMSD = {result.rmsd:.3f} nm\")\n        return result\n\n    @_misc.batch_process\n    def measure_radius(\n        self,\n        i: int = None,\n        *,\n        binsize: int = 1,\n        positions: NDArray[np.float32] | Literal[\"auto\", \"anchor\"] = \"auto\",\n        min_radius: nm = 1.0,\n        max_radius: nm = 100.0,\n        update: bool = True,\n    ) -&gt; nm:\n        \"\"\"Measure radius using radial profile from the center.\n\n        Parameters\n        ----------\n        i : int or iterable of int, optional\n            Spline ID that you want to measure.\n        binsize : int, default 1\n            Multiscale bin size used for radius calculation.\n        positions : array-like or \"auto\" or \"anchor\", default \"auto\"\n            Sampling positions (between 0 and 1) to calculate radius. If \"anchor\"\n            is given, anchors of the spline will be used. If \"auto\" is given,\n            three positions along the spline will be used.\n        min_radius : nm, default 1.0\n            Minimum radius of the cylinder.\n        max_radius : nm, default 100.0\n            Maximum radius of the cylinder.\n        update : bool, default True\n            If True, global radius property will be updated.\n\n        Returns\n        -------\n        float (nm)\n            Cylinder radius.\n        \"\"\"\n        LOGGER.info(f\"Running: {self.__class__.__name__}.measure_radius, i={i}\")\n        spl = self.splines[i]\n\n        if isinstance(positions, str) and positions == \"auto\":\n            nanchor = 3\n            pos = 1 / nanchor * np.arange(nanchor) + 0.5 / nanchor\n        elif isinstance(positions, str) and positions == \"anchor\":\n            pos = spl.anchors\n        else:\n            pos = np.asarray(positions, dtype=np.float32)\n\n        input_img = self._get_multiscale_or_original(binsize)\n\n        depth = spl.config.fit_depth\n        _scale = input_img.scale.x\n        min_radius_px = min_radius / _scale\n        max_radius = min(max_radius, spl.config.fit_width / 2)\n        max_radius_px = max_radius / _scale\n        spl_trans = spl.translate([-self.multiscale_translation(binsize)] * 3)\n        tasks = [\n            _misc.get_radial_prof(\n                input_img, spl_trans, anc, (min_radius, max_radius), depth\n            )\n            for anc in pos\n        ]\n        profs: list[NDArray[np.float32]] = compute(*tasks)\n        prof = np.stack(profs, axis=0).mean(axis=0)\n        imax_sub = find_centroid_peak(prof, *_misc.get_thickness(spl, _scale))\n        offset_px = _misc.get_radius_offset(min_radius_px, max_radius_px)\n        radius = (imax_sub + offset_px) * _scale\n        if update:\n            spl.props.update_glob(\n                [pl.Series(H.radius, [radius], dtype=pl.Float32)],\n                bin_size=binsize,\n            )\n        LOGGER.info(f\" &gt;&gt; Radius = {radius:.3f} nm\")\n        return radius\n\n    @_misc.batch_process\n    def local_radii(\n        self,\n        *,\n        i: int = None,\n        depth: nm = 50.0,\n        binsize: int = 1,\n        min_radius: nm = 1.0,\n        max_radius: nm = 100.0,\n        update: bool = True,\n        update_glob: bool = True,\n    ) -&gt; pl.Series:\n        \"\"\"Measure the local radii along the splines.\n\n        Parameters\n        ----------\n        i : int or iterable of int, optional\n            Spline ID that you want to analyze.\n        depth : nm, default 50.0\n            Longitudinal length of subtomograms for calculation.\n        binsize : int, default 1\n            Multiscale binsize to be used.\n        min_radius : nm, default 1.0\n            Minimum radius of the cylinder.\n        max_radius : nm, default 100.0\n            Maximum radius of the cylinder.\n        update : bool, default True\n            If True, spline properties will be updated.\n        update_glob : bool, default True\n            If True, global properties will be updated using the mean of the local\n            radii.\n\n        Returns\n        -------\n        pl.Series\n            Radii along the spline.\n        \"\"\"\n        LOGGER.info(f\"Running: {self.__class__.__name__}.local_radii, i={i}\")\n        spl = self.splines[i]\n\n        input_img = self._get_multiscale_or_original(binsize)\n\n        depth = spl.config.fit_depth\n        _scale = input_img.scale.x\n        thickness = _misc.get_thickness(spl, _scale)\n        min_radius_px = min_radius / _scale\n        max_radius = min(max_radius, spl.config.fit_width / 2)\n        max_radius_px = max_radius / _scale\n        offset_px = _misc.get_radius_offset(min_radius_px, max_radius_px)\n        spl_trans = spl.translate([-self.multiscale_translation(binsize)] * 3)\n        tasks = []\n        for anc in spl_trans.anchors:\n            task = _misc.get_radial_prof(\n                input_img, spl_trans, anc, (min_radius, max_radius), depth\n            )\n            tasks.append(task)\n        profs: list[NDArray[np.float32]] = compute(*tasks)\n        radii = list[float]()\n        for prof in profs:\n            imax_sub = find_centroid_peak(prof, *thickness)\n            radii.append((imax_sub + offset_px) * _scale)\n\n        out = pl.Series(H.radius, radii, dtype=pl.Float32)\n        if update:\n            spl.props.update_loc([out], depth, bin_size=binsize)\n        if update_glob:\n            spl.props.update_glob([pl.Series(H.radius, [out.mean()])], bin_size=binsize)\n        return out\n\n    @_misc.batch_process\n    def local_cft_params(\n        self,\n        *,\n        i: int = None,\n        depth: nm = 50.0,\n        binsize: int = 1,\n        radius: nm | Literal[\"local\", \"global\"] = \"global\",\n        nsamples: int = 8,\n        update: bool = True,\n        update_glob: bool = False,\n    ) -&gt; pl.DataFrame:\n        \"\"\"Calculate local lattice parameters from cylindrical Fourier space.\n\n        To determine the peaks upsampled discrete Fourier transformation is used\n        for every subtomogram.\n\n        Parameters\n        ----------\n        i : int or iterable of int, optional\n            Spline ID that you want to analyze.\n        depth : nm, default 50.0\n            Length of subtomogram for calculation of local parameters.\n        binsize : int, default 1\n            Multiscale bin size used for calculation.\n        radius : str, default \"global\"\n            If \"local\", use the local radius for the analysis. If \"global\", use the\n            global radius. If a float, use the given radius.\n        nsamples : int, default 8\n            Number of cylindrical coordinate samplings for Fourier transformation. Multiple\n            samplings are needed because up-sampled discrete Fourier transformation does not\n            return exactly the same power spectra with shifted inputs, unlike FFT. Larger\n            ``nsamples`` reduces the error but is slower.\n        update : bool, default True\n            If True, spline properties will be updated.\n        update_glob : bool, default False\n            If True, global properties will be updated using the mean or mode of the local\n            properties.\n\n        Returns\n        -------\n        polars.DataFrame\n            Local properties.\n        \"\"\"\n        LOGGER.info(f\"Running: {self.__class__.__name__}.local_cft_params, i={i}\")\n        spl = self.splines[i]\n        radii = _misc.prepare_radii(spl, radius)\n        input_img = self._get_multiscale_or_original(binsize)\n        _scale = input_img.scale.x\n        tasks: list[Delayed[LatticeParams]] = []\n        spl_trans = spl.translate([-self.multiscale_translation(binsize)] * 3)\n        _analyze_fn = LatticeAnalyzer(spl.config).estimate_lattice_params_task\n        for anc, r0 in zip(spl_trans.anchors, radii, strict=True):\n            rmin, rmax = spl.radius_range(r0)\n            rc = (rmin + rmax) / 2\n            coords = spl_trans.local_cylindrical((rmin, rmax), depth, anc, scale=_scale)\n            tasks.append(_analyze_fn(input_img, coords, rc, nsamples=nsamples))\n\n        lprops = pl.DataFrame(\n            compute(*tasks),\n            schema=LatticeParams.polars_schema(),\n        )\n        if update:\n            spl.props.update_loc(lprops, depth, bin_size=binsize)\n        if update_glob:\n            gprops = lprops.select(\n                pl.col(H.spacing).mean(),\n                pl.col(H.pitch).mean(),\n                pl.col(H.twist).mean(),\n                pl.col(H.skew).mean(),\n                pl.col(H.rise).mean(),\n                pl.col(H.rise_length).mean(),\n                pl.col(H.npf).mode().first(),\n                pl.col(H.start).mode().first(),\n            )\n            spl.props.update_glob(gprops, bin_size=binsize)\n\n        return lprops\n\n    def iter_local_image(\n        self,\n        i: int,\n        depth: nm = 50.0,\n        pos: int | None = None,\n        binsize: int = 1,\n    ) -&gt; Iterable[ip.ImgArray]:\n        spl = self.splines[i]\n        if spl.radius is None:\n            raise ValueError(\"Radius has not been determined yet.\")\n\n        input_img = self._get_multiscale_or_original(binsize)\n        _scale = input_img.scale.x\n        rmin, rmax = spl.radius_range()\n        rc = (rmin + rmax) / 2\n        if pos is None:\n            anchors = spl.anchors\n        else:\n            anchors = [spl.anchors[pos]]\n        spl_trans = spl.translate([-self.multiscale_translation(binsize)] * 3)\n        for anc in anchors:\n            coords = spl_trans.local_cylindrical((rmin, rmax), depth, anc, scale=_scale)\n            polar = get_polar_image(input_img, coords, rc)\n            polar[:] -= np.mean(polar)\n            yield polar\n\n    @_misc.batch_process\n    def local_cft(\n        self,\n        *,\n        i: int = None,\n        depth: nm = 50.0,\n        pos: int | None = None,\n        binsize: int = 1,\n    ) -&gt; ip.ImgArray:\n        \"\"\"Calculate non-upsampled local cylindric Fourier transormation along spline.\n\n        This function does not up-sample.\n\n        Parameters\n        ----------\n        i : int or iterable of int, optional\n            Spline ID that you want to analyze.\n        depth : nm, default 50.0\n            Length of subtomogram for calculation of local parameters.\n        pos : int, optional\n            Only calculate at ``pos``-th anchor if given.\n        binsize : int, default 1\n            Multiscale bin size used for calculation.\n\n        Returns\n        -------\n        ip.ImgArray\n            FT images stacked along \"p\" axis.\n        \"\"\"\n        out = list[ip.ImgArray]()\n        with set_gpu():\n            for polar in self.iter_local_image(i, depth, pos, binsize):\n                out.append(polar.fft(dims=\"rya\"))\n        return np.stack(out, axis=\"p\")\n\n    @_misc.batch_process\n    def local_cps(\n        self,\n        *,\n        i: int = None,\n        depth: nm = 50.0,\n        pos: int | None = None,\n        binsize: int = 1,\n    ) -&gt; ip.ImgArray:\n        \"\"\"Calculate non-upsampled local cylindric power spectra along spline.\n\n        Parameters\n        ----------\n        i : int or iterable of int, optional\n            Spline ID that you want to analyze.\n        depth : nm, default 50.0\n            Length of subtomogram for calculation of local parameters.\n        pos : int, optional\n            Only calculate at ``pos``-th anchor if given.\n        binsize : int, default 1\n            Multiscale bin size used for calculation.\n\n        Returns\n        -------\n        ip.ImgArray\n            FT images stacked along \"p\" axis.\n        \"\"\"\n        cft = self.local_cft(i=i, depth=depth, pos=pos, binsize=binsize)\n        return cft.real**2 + cft.imag**2\n\n    @_misc.batch_process\n    def local_image_with_peaks(\n        self,\n        *,\n        i: int = None,\n        binsize: int | None = None,\n    ) -&gt; list[_misc.ImageWithPeak]:\n        \"\"\"Recalculate local images and peaks.\n\n        This method reuses the existing spline properties to get the peaks. To measure\n        local lattice parameters, use `local_cft_params` method beforehand.\n        \"\"\"\n        spl = self.splines[i]\n        depth = spl.props.window_size[H.twist]\n        if binsize is None:\n            binsize = spl.props.binsize_loc[H.twist]\n        df_loc = spl.props.loc\n        out = list[_misc.ImageWithPeak]()\n        for j, polar_img in enumerate(self.iter_local_image(i, depth, binsize=binsize)):\n            try:\n                cparams = spl.cylinder_params(\n                    spacing=_misc.get_component(df_loc, H.spacing, j),\n                    pitch=_misc.get_component(df_loc, H.pitch, j),\n                    twist=_misc.get_component(df_loc, H.twist, j),\n                    skew=_misc.get_component(df_loc, H.skew, j),\n                    rise_angle=_misc.get_component(df_loc, H.rise, j),\n                    start=_misc.get_component(df_loc, H.start, j),\n                    npf=_misc.get_component(df_loc, H.npf, j),\n                )\n            except ValueError:\n                out.append(_misc.ImageWithPeak(polar_img, []))\n            else:\n                analyzer = LatticeAnalyzer(spl.config)\n                peakv, peakh = analyzer.params_to_peaks(polar_img[0], cparams)\n                peakv = peakv.shift_to_center()\n                peakh = peakh.shift_to_center()\n                out.append(_misc.ImageWithPeak(polar_img, [peakv, peakh]))\n        return out\n\n    @_misc.batch_process\n    def global_cps(\n        self,\n        *,\n        i: int = None,\n        binsize: int = 1,\n    ) -&gt; ip.ImgArray:\n        \"\"\"Calculate global cylindrical power spectra.\n\n        Parameters\n        ----------\n        i : int or iterable of int, optional\n            Spline ID that you want to analyze.\n        binsize : int, default 1\n            Multiscale bin size used for calculation.\n\n        Returns\n        -------\n        ip.ImgArray\n            Complex image.\n        \"\"\"\n        cft = self.global_cft(i=i, binsize=binsize)\n        return cft.real**2 + cft.imag**2\n\n    @_misc.batch_process\n    def global_image_with_peaks(\n        self,\n        *,\n        i: int = None,\n        binsize: int | None = None,\n    ) -&gt; _misc.ImageWithPeak:\n        \"\"\"Recalculate global image and peaks.\n\n        This method reuses the existing spline properties to get the peaks. To measure\n        global lattice parameters, use `global_cft_params` method beforehand.\n        \"\"\"\n        spl = self.splines[i]\n        if binsize is None:\n            binsize = spl.props.binsize_glob[H.twist]\n        img_st = self.straighten_cylindric(i, binsize=binsize)\n        img_st -= np.mean(img_st)\n        try:\n            cparams = spl.cylinder_params(\n                spacing=spl.props.get_glob(H.spacing, default=None),\n                pitch=spl.props.get_glob(H.pitch, default=None),\n                twist=spl.props.get_glob(H.twist, default=None),\n                skew=spl.props.get_glob(H.skew, default=None),\n                rise_angle=spl.props.get_glob(H.rise, default=None),\n                start=spl.props.get_glob(H.start, default=None),\n                npf=spl.props.get_glob(H.npf, default=None),\n            )\n        except ValueError:\n            return _misc.ImageWithPeak(img_st, [])\n        else:\n            analyzer = LatticeAnalyzer(spl.config)\n            peakv, peakh = analyzer.params_to_peaks(img_st[0], cparams)\n            peakv = peakv.shift_to_center()\n            peakh = peakh.shift_to_center()\n            return _misc.ImageWithPeak(img_st, [peakv, peakh])\n\n    @_misc.batch_process\n    def global_cft_params(\n        self,\n        *,\n        i: int = None,\n        binsize: int = 1,\n        nsamples: int = 8,\n        update: bool = True,\n    ) -&gt; pl.DataFrame:\n        \"\"\"Calculate global lattice parameters.\n\n        This function transforms tomogram using cylindrical coordinate system along\n        spline. This function calls ``straighten`` beforehand, so that Fourier space is\n        distorted if the cylindrical structure is curved.\n\n        Parameters\n        ----------\n        i : int or iterable of int, optional\n            Spline ID that you want to analyze.\n        binsize : int, default 1\n            Multiscale bin size used for calculation.\n        nsamples : int, default 8\n            Number of cylindrical coordinate samplings for Fourier transformation.\n            Multiple samplings are needed because up-sampled discrete Fourier\n            transformation does not return exactly the same power spectra with shifted\n            inputs, unlike FFT. Larger `nsamples` reduces the error but is slower.\n        update : bool, default True\n            If True, spline properties will be updated.\n\n        Returns\n        -------\n        pl.DataFrame\n            Global properties.\n        \"\"\"\n        LOGGER.info(f\"Running: {self.__class__.__name__}.global_cft_params, i={i}\")\n        spl = self.splines[i]\n        rmin, rmax = spl.radius_range()\n        img_st = self.straighten_cylindric(i, radii=(rmin, rmax), binsize=binsize)\n        rc = (rmin + rmax) / 2\n        analyzer = LatticeAnalyzer(spl.config)\n        lparams = analyzer.estimate_lattice_params_polar(img_st, rc, nsamples=nsamples)\n        out = lparams.to_polars()\n        if update:\n            spl.props.update_glob(spl.props.glob.with_columns(out), bin_size=binsize)\n        return out\n\n    @_misc.batch_process\n    def global_cft(self, i: int = None, binsize: int = 1) -&gt; ip.ImgArray:\n        \"\"\"Calculate global cylindrical fast Fourier tranformation.\n\n        Parameters\n        ----------\n        i : int or iterable of int, optional\n            Spline ID that you want to analyze.\n        binsize : int, default 1\n            Multiscale bin size used for calculation.\n\n        Returns\n        -------\n        ip.ImgArray\n            Complex image.\n        \"\"\"\n        img_st = self.straighten_cylindric(i, binsize=binsize)\n        img_st -= np.mean(img_st)\n        return img_st.fft(dims=\"rya\")\n\n    @_misc.batch_process\n    def infer_polarity(\n        self,\n        i: int = None,\n        *,\n        binsize: int = 1,\n        depth: nm = 40,\n        mask_freq: bool = True,\n        update: bool = True,\n    ) -&gt; Ori:\n        \"\"\"Infer spline polarities using polar 2D image.\n\n        Parameters\n        ----------\n        i : int or iterable of int, optional\n            Spline ID that you want to analyze.\n        binsize : int, default 1\n            Multiscale bin size used for calculation.\n        depth : nm, default 40.0\n            Depth of images used to infer polarities.\n\n        Returns\n        -------\n        Ori\n            Orientation of corresponding splines.\n        \"\"\"\n        LOGGER.info(f\"Running: {self.__class__.__name__}.infer_polarity, i={i}\")\n        current_scale = self.scale * binsize\n\n        if binsize &gt; 1:\n            imgb = self.get_multiscale(binsize)\n        else:\n            try:\n                imgb = self.get_multiscale(1)\n            except ValueError:\n                imgb = self.image\n\n        spl = self.splines[i]\n        cfg = spl.config\n        ori_clockwise = Ori(cfg.clockwise)\n        ori_counterclockwise = Ori.invert(ori_clockwise, allow_none=False)\n        r_range = spl.radius_range()\n        point = 0.5  # the sampling point\n        coords = spl.local_cylindrical(r_range, depth, point, scale=current_scale)\n        polar = get_polar_image(imgb, coords, spl.radius, order=1)\n        clkwise = is_clockwise(\n            cfg,\n            polar,\n            mask_freq=mask_freq,\n            npf=spl.props.get_glob(H.npf, None),\n            logger=LOGGER,\n        )\n        ori = ori_clockwise if clkwise else ori_counterclockwise\n        if update:\n            spl.orientation = ori\n        return ori\n\n    @_misc.batch_process\n    def straighten(\n        self,\n        i: int = None,\n        *,\n        size: nm | tuple[nm, nm] = None,\n        range_: tuple[float, float] = (0.0, 1.0),\n        chunk_length: nm | None = None,\n        binsize: int = 1,\n    ) -&gt; ip.ImgArray:\n        \"\"\"Straightening by building curved coordinate system around splines.\n\n        Parameters\n        ----------\n        i : int or iterable of int, optional\n            Spline ID that you want to straighten.\n        size : float (nm), optional\n            Vertical/horizontal box size.\n        range_ : tuple[float, float], default (0.0, 1.0)\n            Range of spline domain.\n        chunk_length : nm, optional\n            If spline is longer than this, it will be first split into chunks,\n            straightened respectively and all the straightened images are concatenated\n            afterward, to avoid loading entire image into memory.\n        binsize : int, default 1\n            Multiscale bin size used for calculation.\n\n        Returns\n        -------\n        ip.ImgArray\n            Straightened image. If Cartesian coordinate system is used, it will have \"zyx\".\n        \"\"\"\n        spl = self.splines[i]\n        input_img = self._get_multiscale_or_original(binsize)\n        chunk_length = _misc.normalize_chunk_length(input_img, chunk_length)\n        return _straighten.straighten(input_img, spl, range_, size)\n\n    @_misc.batch_process\n    def straighten_cylindric(\n        self,\n        i: int = None,\n        *,\n        radii: tuple[nm, nm] | None = None,\n        range_: tuple[float, float] = (0.0, 1.0),\n        chunk_length: nm | None = None,\n        binsize: int = 1,\n    ) -&gt; ip.ImgArray:\n        \"\"\"Straightening by building curved coordinate system around splines.\n\n        Parameters\n        ----------\n        i : int or iterable of int, optional\n            Spline ID that you want to straighten.\n        radii : tuple of float (nm), optional\n            Lower/upper limit of radius.\n        range_ : tuple[float, float], default (0.0, 1.0)\n            Range of spline domain.\n        chunk_length : nm, optional\n            If spline is longer than this, it will be first split into chunks,\n            straightened respectively and all the straightened images are concatenated\n            afterward, to avoid loading entire image into memory.\n        binsize : int, default 1\n            Multiscale bin size used for calculation.\n\n        Returns\n        -------\n        ip.ImgArray\n            Straightened image. If Cartesian coordinate system is used, it will have \"zyx\".\n        \"\"\"\n        spl = self.splines[i]\n        input_img = self._get_multiscale_or_original(binsize)\n        chunk_length = _misc.normalize_chunk_length(input_img, chunk_length)\n        return _straighten.straighten_cylindric(input_img, spl, range_, radii)\n\n    @_misc.batch_process\n    def map_centers(\n        self,\n        i: int = None,\n        *,\n        interval: nm = 1.0,\n        orientation: Ori | str | None = None,\n        rotate_molecules: bool = True,\n    ) -&gt; Molecules:\n        \"\"\"Mapping molecules along the center of a cylinder.\n\n        Parameters\n        ----------\n        i : int or iterable of int, optional\n            Spline ID that mapping will be calculated.\n        interval : float (nm), optional\n            Interval of molecules.\n        rotate_molecules : bool, default True\n            If True, twist the molecule orientations according to the spline twist.\n\n        Returns\n        -------\n        Molecules\n            Molecules object with mapped coordinates and angles.\n        \"\"\"\n        spl = self.splines[i]\n        u = spl.prep_anchor_positions(interval=interval)\n        if rotate_molecules:\n            spacing = spl.props.get_glob(H.spacing)\n            twist = spl.props.get_glob(H.twist)\n            degrees = spl.distances(u) / spacing * twist\n            deg_round = np.round(degrees, 2)\n            if len(degrees) &lt; 11:\n                degrees_for_log = str(deg_round)\n            else:\n                degrees_for_log = (\n                    str(deg_round[:5])[:-1] + \" ... \" + str(deg_round[-5:])[1:]\n                )\n            LOGGER.info(f\"Rotation in degree = {degrees_for_log}\")\n            rotation = np.deg2rad(degrees)\n        else:\n            rotation = None\n        mole = spl.anchors_to_molecules(u, rotation=rotation)\n        if spl._need_rotation(orientation):\n            mole = mole.rotate_by_rotvec_internal([np.pi, 0, 0])\n        return mole\n\n    @_misc.batch_process\n    def map_centers_helical_symmetry(\n        self,\n        i: int = None,\n        *,\n        orientation: Ori | str | None = None,\n        clip_extension: bool = True,\n        sort: bool = True,\n    ) -&gt; Molecules:\n        \"\"\"Mapping molecules along the center considering helical symmetry.\n\n        Parameters\n        ----------\n        i : int or iterable of int, optional\n            Spline ID that mapping will be calculated.\n        orientation : Ori or str, optional\n            Orientation of the y-axis of each molecule.\n\n        Returns\n        -------\n        Molecules\n            Molecules object with mapped coordinates and angles.\n        \"\"\"\n        spl = self.splines[i]\n        mole = self.map_monomers(i=i, orientation=orientation)\n        if clip_extension:\n            length = spl.length()\n            mole = mole.filter(pl.col(Mole.position).is_between(0, length))\n        if sort:\n            mole = mole.sort(Mole.position)\n        radius = spl.cylinder_params().radius\n        return mole.translate_internal([-radius, 0, 0])\n\n    def get_cylinder_model(\n        self,\n        i: int,\n        offsets: tuple[float, float] = (0.0, 0.0),\n        **kwargs,\n    ) -&gt; CylinderModel:  # fmt: skip\n        \"\"\"Return the cylinder model at the given spline ID.\n\n        Parameters\n        ----------\n        i : int\n            Spline ID from which model will be created.\n        offsets : tuple of float, optional\n            Offset of the model. See :meth:`map_monomers` for details.\n\n        Returns\n        -------\n        CylinderModel\n            The cylinder model.\n        \"\"\"\n        return self.splines[i].cylinder_model(offsets=offsets, **kwargs)\n\n    @_misc.batch_process\n    def map_monomers(\n        self,\n        i: int = None,\n        *,\n        offsets: tuple[nm, float] | None = None,\n        orientation: Ori | str | None = None,\n        extensions: tuple[int, int] = (0, 0),\n        **kwargs,\n    ) -&gt; Molecules:\n        \"\"\"Map monomers in a regular cylinder shape.\n\n        Parameters\n        ----------\n        i : int or iterable of int, optional\n            Spline ID that mapping will be calculated.\n        offsets : tuple of float, optional\n            The offset of origin of oblique coordinate system to map monomers.\n        orientation : Ori or str, optional\n            Orientation of the y-axis of each molecule.\n\n        Returns\n        -------\n        Molecules\n            Object that represents monomer positions and angles.\n        \"\"\"\n        model = self.get_cylinder_model(i, offsets=offsets, **kwargs)\n        ny, na = model.shape\n        ext0, ext1 = extensions\n        if ny + ext0 + ext1 &lt; 0:\n            raise ValueError(\"The number of monomers is negative.\")\n        yy, aa = np.indices((ny + ext0 + ext1, na), dtype=np.int32)\n        yy -= ext0\n        coords = np.stack([yy.ravel(), aa.ravel()], axis=1)\n        spl = self.splines[i]\n        mole = model.locate_molecules(spl, coords)\n        if spl._need_rotation(orientation):\n            mole = mole.rotate_by_rotvec_internal([np.pi, 0, 0])\n        return mole\n\n    @_misc.batch_process\n    def map_on_grid(\n        self,\n        i: int = None,\n        coords: NDArray[np.int32] = (),\n        *,\n        offsets: tuple[nm, float] | None = None,\n        orientation: Ori | str | None = None,\n        **kwargs,\n    ) -&gt; Molecules:\n        \"\"\"Map monomers in a regular cylinder shape.\n\n        Parameters\n        ----------\n        i : int or iterable of int, optional\n            Spline ID that mapping will be calculated.\n        coords : ndarray\n            Integer coordinates on the cylinder surface.\n        offsets : tuple of float, optional\n            The offset of origin of oblique coordinate system to map monomers.\n        orientation : Ori or str, optional\n            Orientation of the y-axis of each molecule.\n\n        Returns\n        -------\n        Molecules\n            Object that represents monomer positions and angles.\n        \"\"\"\n        model = self.get_cylinder_model(i, offsets=offsets, **kwargs)\n        coords = np.asarray(coords, dtype=np.int32)\n        spl = self.splines[i]\n        mole = model.locate_molecules(spl, coords)\n        if spl._need_rotation(orientation):\n            mole = mole.rotate_by_rotvec_internal([np.pi, 0, 0])\n        return mole\n\n    @_misc.batch_process\n    def map_pf_line(\n        self,\n        i: int = None,\n        *,\n        interval: nm = 1.0,\n        offsets: tuple[nm, float] = (0.0, 0.0),\n        orientation: Ori | str | None = None,\n    ) -&gt; Molecules:\n        \"\"\"Mapping molecules along a protofilament line.\n\n        This method is useful when you want to visualize seam or protofilament, or\n        assign molecules for subtomogram averaging of seam binding protein or doublet\n        microtubule.\n\n        Parameters\n        ----------\n        i : int or iterable of int, optional\n            Spline ID that mapping will be calculated.\n        offsets : (float, float), default (0.0, 0.0)\n            Axial offset in nm and angular offset in degree.\n\n        Returns\n        -------\n        Molecules\n            Object that represents protofilament positions and angles.\n        \"\"\"\n        spl = self.splines[i]\n        spacing = spl.props.get_glob(H.spacing)\n        twist = spl.props.get_glob(H.twist)\n\n        ny = roundint(spl.length() / interval)\n        skew_rad = np.deg2rad(twist) * interval / spacing\n\n        yoffset, aoffset = offsets\n        rcoords = np.full(ny, spl.radius)\n        ycoords = np.arange(ny) * interval + yoffset\n        acoords = np.arange(ny) * skew_rad + np.deg2rad(aoffset)\n        coords = np.stack([rcoords, ycoords, acoords], axis=1)\n        mole = spl.cylindrical_to_molecules(coords)\n        if spl._need_rotation(orientation):\n            mole = mole.rotate_by_rotvec_internal([np.pi, 0, 0])\n        return mole\n\n    def _prep_fit_spline(self, spl: CylSpline, anc: NDArray[np.float32], binsize: int):\n        npoints = anc.size\n        interval = spl.length() / (npoints - 1)\n        depth_px = self.nm2pixel(spl.config.fit_depth, binsize=binsize)\n        width_px = self.nm2pixel(spl.config.fit_width, binsize=binsize)\n\n        # If subtomogram region is rotated by 45 degree, its XY-width will be\n        # (length + width) / sqrt(2)\n        if binsize &gt; 1:\n            centers = spl.map(anc) - self.multiscale_translation(binsize)\n        else:\n            centers = spl.map(anc)\n        center_px = self.nm2pixel(centers, binsize=binsize)\n        size_px = (width_px,) + (roundint((width_px + depth_px) / 1.414),) * 2\n        input_img = self._get_multiscale_or_original(binsize)\n\n        subtomograms = crop_tomograms(input_img, center_px, size_px)\n        subtomograms[:] -= subtomograms.mean()\n        scale = self.scale * binsize\n        return subtomograms, interval, scale\n</code></pre>"},{"location":"api/components/#cylindra.components.tomogram.CylTomogram.splines","title":"<code>splines</code>  <code>property</code>","text":"<p>List of splines.</p>"},{"location":"api/components/#cylindra.components.tomogram.CylTomogram.add_spline","title":"<code>add_spline(coords, *, order=3, err_max=0.5, extrapolate=ExtrapolationMode.linear, config={})</code>","text":"<p>Add spline path to tomogram.</p> <p>Parameters:</p> Name Type Description Default <code>coords</code> <code>array - like</code> <p>(N, 3) array of coordinates. A spline curve that fit it well is added.</p> required <code>order</code> <code>int</code> <p>Order of spline curve.</p> <code>3</code> <code>extrapolate</code> <code>str</code> <p>Extrapolation mode of the spline.</p> <code>linear</code> <code>config</code> <code>SplineConfig or dict</code> <p>Configuration for spline fitting.</p> <code>{}</code> Source code in <code>cylindra/components/tomogram/_cyl_tomo.py</code> <pre><code>def add_spline(\n    self,\n    coords: ArrayLike,\n    *,\n    order: int = 3,\n    err_max: nm = 0.5,\n    extrapolate: ExtrapolationMode | str = ExtrapolationMode.linear,\n    config: SplineConfig | dict[str, Any] = {},\n) -&gt; None:\n    \"\"\"Add spline path to tomogram.\n\n    Parameters\n    ----------\n    coords : array-like\n        (N, 3) array of coordinates. A spline curve that fit it well is added.\n    order : int, optional\n        Order of spline curve.\n    extrapolate : str, optional\n        Extrapolation mode of the spline.\n    config : SplineConfig or dict, optional\n        Configuration for spline fitting.\n    \"\"\"\n    _coords = np.asarray(coords)\n    ncoords = _coords.shape[0]\n    spl = CylSpline(\n        order=order,\n        config=config,\n        extrapolate=extrapolate,\n    ).fit(_coords, err_max=err_max)\n    interval: nm = 30.0\n    length = spl.length()\n\n    n = int(length / interval) + 1\n    fit = spl.map(np.linspace(0, 1, n))\n    if ncoords &lt;= spl.order and ncoords &lt; fit.shape[0]:\n        return self.add_spline(\n            fit,\n            order=order,\n            err_max=err_max,\n            extrapolate=extrapolate,\n            config=config,\n        )\n\n    self.splines.append(spl)\n    return None\n</code></pre>"},{"location":"api/components/#cylindra.components.tomogram.CylTomogram.align_to_polarity","title":"<code>align_to_polarity(orientation=Ori.MinusToPlus)</code>","text":"<p>Align all the splines in the direction parallel to the given polarity.</p> <p>Parameters:</p> Name Type Description Default <code>orientation</code> <code>Ori or str</code> <p>To which direction splines will be aligned.</p> <code>Ori.MinusToPlus</code> <p>Returns:</p> Type Description <code>Tomogram object</code> <p>Same object with updated splines.</p> Source code in <code>cylindra/components/tomogram/_cyl_tomo.py</code> <pre><code>def align_to_polarity(self, orientation: Ori | str = Ori.MinusToPlus) -&gt; Self:\n    \"\"\"Align all the splines in the direction parallel to the given polarity.\n\n    Parameters\n    ----------\n    orientation : Ori or str, default Ori.MinusToPlus\n        To which direction splines will be aligned.\n\n    Returns\n    -------\n    Tomogram object\n        Same object with updated splines.\n    \"\"\"\n    orientation = Ori(orientation)\n    if orientation is Ori.none:\n        raise ValueError(\"Must be PlusToMinus or MinusToPlus.\")\n    for i, spl in enumerate(self.splines):\n        if spl.orientation is Ori.none:\n            raise ValueError(f\"Spline-{i} has no orientation.\")\n        if spl.orientation != orientation:\n            try:\n                self.splines[i] = spl.invert()\n            except Exception as e:\n                raise type(e)(f\"Cannot invert spline-{i}: {e}\")\n    return self\n</code></pre>"},{"location":"api/components/#cylindra.components.tomogram.CylTomogram.fit","title":"<code>fit(i=None, *, max_interval=30.0, degree_precision=0.5, binsize=1, err_max=1.0, edge_sigma=2.0, max_shift=5.0, n_rotations=5)</code>","text":"<p>Roughly fit splines to cylindrical structures.</p> <p>Subtomograms will be sampled at every <code>max_interval</code> nm. In dense mode, Subtomograms will be masked relative to XY-plane, using sigmoid function. Sharpness of the sigmoid function is determined by <code>dense_mode_sigma</code> (<code>dense_mode_sigma=0</code> corresponds to a step function).</p> <p>Parameters:</p> Name Type Description Default <code>i</code> <code>int or iterable of int</code> <p>Spline ID that you want to fit.</p> <code>None</code> <code>max_interval</code> <code>nm</code> <p>Maximum interval of sampling points in nm unit.</p> <code>30.0</code> <code>degree_precision</code> <code>float</code> <p>Precision of xy-tilt degree in angular correlation.</p> <code>0.5</code> <code>binsize</code> <code>int</code> <p>Multiscale bin size used for fitting.</p> <code>1</code> <code>edge_sigma</code> <code>nm</code> <p>Sharpness of mask at the edges. If not None, fitting will be executed after regions outside the cylinder are masked. Soft mask is important for precision because sharp changes in intensity cause strong correlation at the edges.</p> <code>2.0</code> <code>max_shift</code> <code>nm</code> <p>Maximum shift from the true center of the cylinder. This parameter is used in phase cross correlation.</p> <code>5.0</code> <code>n_rotations</code> <code>int</code> <p>Number of rotations to be tested during finding the cylinder center.</p> <code>5</code> <p>Returns:</p> Type Description <code>FitResult</code> <p>Result of fitting.</p> Source code in <code>cylindra/components/tomogram/_cyl_tomo.py</code> <pre><code>@_misc.batch_process\ndef fit(\n    self,\n    i: int = None,\n    *,\n    max_interval: nm = 30.0,\n    degree_precision: float = 0.5,\n    binsize: int = 1,\n    err_max: nm = 1.0,\n    edge_sigma: nm = 2.0,\n    max_shift: nm = 5.0,\n    n_rotations: int = 5,\n) -&gt; _misc.FitResult:\n    \"\"\"Roughly fit splines to cylindrical structures.\n\n    Subtomograms will be sampled at every `max_interval` nm. In dense mode,\n    Subtomograms will be masked relative to XY-plane, using sigmoid function.\n    Sharpness of the sigmoid function is determined by `dense_mode_sigma`\n    (`dense_mode_sigma=0` corresponds to a step function).\n\n    Parameters\n    ----------\n    i : int or iterable of int, optional\n        Spline ID that you want to fit.\n    max_interval : nm, default 30.0\n        Maximum interval of sampling points in nm unit.\n    degree_precision : float, default 0.5\n        Precision of xy-tilt degree in angular correlation.\n    binsize : int, default 1\n        Multiscale bin size used for fitting.\n    edge_sigma : nm, default 2.0\n        Sharpness of mask at the edges. If not None, fitting will be executed after regions\n        outside the cylinder are masked. Soft mask is important for precision because sharp\n        changes in intensity cause strong correlation at the edges.\n    max_shift: nm, default 5.0\n        Maximum shift from the true center of the cylinder. This parameter is used in phase\n        cross correlation.\n    n_rotations : int, default 5\n        Number of rotations to be tested during finding the cylinder center.\n\n    Returns\n    -------\n    FitResult\n        Result of fitting.\n    \"\"\"\n    LOGGER.info(f\"Running: {self.__class__.__name__}.fit, i={i}\")\n    spl = self.splines[i]\n    anc = spl.prep_anchor_positions(max_interval=max_interval)\n    subtomograms, interval, scale = self._prep_fit_spline(spl, anc, binsize)\n\n    with set_gpu():\n        subtomograms = _misc.soft_mask_edges(\n            subtomograms, spl, anc, scale, edge_sigma\n        )\n        ds = spl.map(anc, der=1)\n        yx_tilt = np.rad2deg(np.arctan2(-ds[:, 2], ds[:, 1]))\n        degree_max = 14.0\n        nrots = roundint(degree_max / degree_precision) + 1\n\n        # Angular correlation\n        out = _misc.dask_angle_corr(subtomograms, yx_tilt, nrots=nrots)\n        refined_tilt_deg = np.array(out)\n        refined_tilt_rad = np.deg2rad(refined_tilt_deg)\n\n        # If subtomograms are sampled at short intervals, angles should be smoothened to\n        # avoid overfitting.\n        size = 2 * roundint(48.0 / interval) + 1\n        if size &gt; 1:\n            # Mirror-mode padding is \"a b c d | c b a\".\n            refined_tilt_rad = _misc.angle_uniform_filter(\n                refined_tilt_rad, size=size, mode=Mode.mirror\n            )\n            refined_tilt_deg = np.rad2deg(refined_tilt_rad)\n\n        # Rotate subtomograms in YX plane\n        for _j, img in enumerate(subtomograms):\n            img: ip.ImgArray\n            angle = refined_tilt_deg[_j]\n            img.rotate(-angle, cval=0, update=True)\n\n        # zx-shift correction by self-ZNCC\n        subtomo_proj = subtomograms.mean(axis=\"y\")\n\n        if edge_sigma is not None:\n            # Regions outside the mask don't need to be considered.\n            xc = int(subtomo_proj.shape.x / 2)\n            w = int(spl.config.fit_width / scale / 2)\n            subtomo_proj = subtomo_proj[ip.slicer.x[xc - w : xc + w + 1]]\n\n        max_shift_px = max_shift / scale * 2\n        pf_ang = 360 / spl.config.npf_range.center\n        degrees = np.linspace(-pf_ang / 2, pf_ang / 2, n_rotations) + 180\n        shifts = _misc.multi_rotated_auto_zncc(subtomo_proj, degrees, max_shift_px)\n\n    # Update spline coordinates.\n    # Because centers of subtomogram are on lattice points of pixel coordinate,\n    # coordinates that will be shifted should be converted to integers.\n    coords_px = self.nm2pixel(spl.map(anc), binsize=binsize).astype(np.float32)\n    coords_px_new = _misc.shift_coords(coords_px, shifts, refined_tilt_rad)\n    coords = coords_px_new * scale + self.multiscale_translation(binsize)\n\n    # Update spline parameters\n    self.splines[i] = spl.fit(coords, err_max=err_max)\n    result = _misc.FitResult(shifts * scale)\n    LOGGER.info(f\" &gt;&gt; Shift RMSD = {result.rmsd:.3f} nm\")\n    return result\n</code></pre>"},{"location":"api/components/#cylindra.components.tomogram.CylTomogram.get_cylinder_model","title":"<code>get_cylinder_model(i, offsets=(0.0, 0.0), **kwargs)</code>","text":"<p>Return the cylinder model at the given spline ID.</p> <p>Parameters:</p> Name Type Description Default <code>i</code> <code>int</code> <p>Spline ID from which model will be created.</p> required <code>offsets</code> <code>tuple of float</code> <p>Offset of the model. See :meth:<code>map_monomers</code> for details.</p> <code>(0.0, 0.0)</code> <p>Returns:</p> Type Description <code>CylinderModel</code> <p>The cylinder model.</p> Source code in <code>cylindra/components/tomogram/_cyl_tomo.py</code> <pre><code>def get_cylinder_model(\n    self,\n    i: int,\n    offsets: tuple[float, float] = (0.0, 0.0),\n    **kwargs,\n) -&gt; CylinderModel:  # fmt: skip\n    \"\"\"Return the cylinder model at the given spline ID.\n\n    Parameters\n    ----------\n    i : int\n        Spline ID from which model will be created.\n    offsets : tuple of float, optional\n        Offset of the model. See :meth:`map_monomers` for details.\n\n    Returns\n    -------\n    CylinderModel\n        The cylinder model.\n    \"\"\"\n    return self.splines[i].cylinder_model(offsets=offsets, **kwargs)\n</code></pre>"},{"location":"api/components/#cylindra.components.tomogram.CylTomogram.global_cft","title":"<code>global_cft(i=None, binsize=1)</code>","text":"<p>Calculate global cylindrical fast Fourier tranformation.</p> <p>Parameters:</p> Name Type Description Default <code>i</code> <code>int or iterable of int</code> <p>Spline ID that you want to analyze.</p> <code>None</code> <code>binsize</code> <code>int</code> <p>Multiscale bin size used for calculation.</p> <code>1</code> <p>Returns:</p> Type Description <code>ImgArray</code> <p>Complex image.</p> Source code in <code>cylindra/components/tomogram/_cyl_tomo.py</code> <pre><code>@_misc.batch_process\ndef global_cft(self, i: int = None, binsize: int = 1) -&gt; ip.ImgArray:\n    \"\"\"Calculate global cylindrical fast Fourier tranformation.\n\n    Parameters\n    ----------\n    i : int or iterable of int, optional\n        Spline ID that you want to analyze.\n    binsize : int, default 1\n        Multiscale bin size used for calculation.\n\n    Returns\n    -------\n    ip.ImgArray\n        Complex image.\n    \"\"\"\n    img_st = self.straighten_cylindric(i, binsize=binsize)\n    img_st -= np.mean(img_st)\n    return img_st.fft(dims=\"rya\")\n</code></pre>"},{"location":"api/components/#cylindra.components.tomogram.CylTomogram.global_cft_params","title":"<code>global_cft_params(*, i=None, binsize=1, nsamples=8, update=True)</code>","text":"<p>Calculate global lattice parameters.</p> <p>This function transforms tomogram using cylindrical coordinate system along spline. This function calls <code>straighten</code> beforehand, so that Fourier space is distorted if the cylindrical structure is curved.</p> <p>Parameters:</p> Name Type Description Default <code>i</code> <code>int or iterable of int</code> <p>Spline ID that you want to analyze.</p> <code>None</code> <code>binsize</code> <code>int</code> <p>Multiscale bin size used for calculation.</p> <code>1</code> <code>nsamples</code> <code>int</code> <p>Number of cylindrical coordinate samplings for Fourier transformation. Multiple samplings are needed because up-sampled discrete Fourier transformation does not return exactly the same power spectra with shifted inputs, unlike FFT. Larger <code>nsamples</code> reduces the error but is slower.</p> <code>8</code> <code>update</code> <code>bool</code> <p>If True, spline properties will be updated.</p> <code>True</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Global properties.</p> Source code in <code>cylindra/components/tomogram/_cyl_tomo.py</code> <pre><code>@_misc.batch_process\ndef global_cft_params(\n    self,\n    *,\n    i: int = None,\n    binsize: int = 1,\n    nsamples: int = 8,\n    update: bool = True,\n) -&gt; pl.DataFrame:\n    \"\"\"Calculate global lattice parameters.\n\n    This function transforms tomogram using cylindrical coordinate system along\n    spline. This function calls ``straighten`` beforehand, so that Fourier space is\n    distorted if the cylindrical structure is curved.\n\n    Parameters\n    ----------\n    i : int or iterable of int, optional\n        Spline ID that you want to analyze.\n    binsize : int, default 1\n        Multiscale bin size used for calculation.\n    nsamples : int, default 8\n        Number of cylindrical coordinate samplings for Fourier transformation.\n        Multiple samplings are needed because up-sampled discrete Fourier\n        transformation does not return exactly the same power spectra with shifted\n        inputs, unlike FFT. Larger `nsamples` reduces the error but is slower.\n    update : bool, default True\n        If True, spline properties will be updated.\n\n    Returns\n    -------\n    pl.DataFrame\n        Global properties.\n    \"\"\"\n    LOGGER.info(f\"Running: {self.__class__.__name__}.global_cft_params, i={i}\")\n    spl = self.splines[i]\n    rmin, rmax = spl.radius_range()\n    img_st = self.straighten_cylindric(i, radii=(rmin, rmax), binsize=binsize)\n    rc = (rmin + rmax) / 2\n    analyzer = LatticeAnalyzer(spl.config)\n    lparams = analyzer.estimate_lattice_params_polar(img_st, rc, nsamples=nsamples)\n    out = lparams.to_polars()\n    if update:\n        spl.props.update_glob(spl.props.glob.with_columns(out), bin_size=binsize)\n    return out\n</code></pre>"},{"location":"api/components/#cylindra.components.tomogram.CylTomogram.global_cps","title":"<code>global_cps(*, i=None, binsize=1)</code>","text":"<p>Calculate global cylindrical power spectra.</p> <p>Parameters:</p> Name Type Description Default <code>i</code> <code>int or iterable of int</code> <p>Spline ID that you want to analyze.</p> <code>None</code> <code>binsize</code> <code>int</code> <p>Multiscale bin size used for calculation.</p> <code>1</code> <p>Returns:</p> Type Description <code>ImgArray</code> <p>Complex image.</p> Source code in <code>cylindra/components/tomogram/_cyl_tomo.py</code> <pre><code>@_misc.batch_process\ndef global_cps(\n    self,\n    *,\n    i: int = None,\n    binsize: int = 1,\n) -&gt; ip.ImgArray:\n    \"\"\"Calculate global cylindrical power spectra.\n\n    Parameters\n    ----------\n    i : int or iterable of int, optional\n        Spline ID that you want to analyze.\n    binsize : int, default 1\n        Multiscale bin size used for calculation.\n\n    Returns\n    -------\n    ip.ImgArray\n        Complex image.\n    \"\"\"\n    cft = self.global_cft(i=i, binsize=binsize)\n    return cft.real**2 + cft.imag**2\n</code></pre>"},{"location":"api/components/#cylindra.components.tomogram.CylTomogram.global_image_with_peaks","title":"<code>global_image_with_peaks(*, i=None, binsize=None)</code>","text":"<p>Recalculate global image and peaks.</p> <p>This method reuses the existing spline properties to get the peaks. To measure global lattice parameters, use <code>global_cft_params</code> method beforehand.</p> Source code in <code>cylindra/components/tomogram/_cyl_tomo.py</code> <pre><code>@_misc.batch_process\ndef global_image_with_peaks(\n    self,\n    *,\n    i: int = None,\n    binsize: int | None = None,\n) -&gt; _misc.ImageWithPeak:\n    \"\"\"Recalculate global image and peaks.\n\n    This method reuses the existing spline properties to get the peaks. To measure\n    global lattice parameters, use `global_cft_params` method beforehand.\n    \"\"\"\n    spl = self.splines[i]\n    if binsize is None:\n        binsize = spl.props.binsize_glob[H.twist]\n    img_st = self.straighten_cylindric(i, binsize=binsize)\n    img_st -= np.mean(img_st)\n    try:\n        cparams = spl.cylinder_params(\n            spacing=spl.props.get_glob(H.spacing, default=None),\n            pitch=spl.props.get_glob(H.pitch, default=None),\n            twist=spl.props.get_glob(H.twist, default=None),\n            skew=spl.props.get_glob(H.skew, default=None),\n            rise_angle=spl.props.get_glob(H.rise, default=None),\n            start=spl.props.get_glob(H.start, default=None),\n            npf=spl.props.get_glob(H.npf, default=None),\n        )\n    except ValueError:\n        return _misc.ImageWithPeak(img_st, [])\n    else:\n        analyzer = LatticeAnalyzer(spl.config)\n        peakv, peakh = analyzer.params_to_peaks(img_st[0], cparams)\n        peakv = peakv.shift_to_center()\n        peakh = peakh.shift_to_center()\n        return _misc.ImageWithPeak(img_st, [peakv, peakh])\n</code></pre>"},{"location":"api/components/#cylindra.components.tomogram.CylTomogram.infer_polarity","title":"<code>infer_polarity(i=None, *, binsize=1, depth=40, mask_freq=True, update=True)</code>","text":"<p>Infer spline polarities using polar 2D image.</p> <p>Parameters:</p> Name Type Description Default <code>i</code> <code>int or iterable of int</code> <p>Spline ID that you want to analyze.</p> <code>None</code> <code>binsize</code> <code>int</code> <p>Multiscale bin size used for calculation.</p> <code>1</code> <code>depth</code> <code>nm</code> <p>Depth of images used to infer polarities.</p> <code>40.0</code> <p>Returns:</p> Type Description <code>Ori</code> <p>Orientation of corresponding splines.</p> Source code in <code>cylindra/components/tomogram/_cyl_tomo.py</code> <pre><code>@_misc.batch_process\ndef infer_polarity(\n    self,\n    i: int = None,\n    *,\n    binsize: int = 1,\n    depth: nm = 40,\n    mask_freq: bool = True,\n    update: bool = True,\n) -&gt; Ori:\n    \"\"\"Infer spline polarities using polar 2D image.\n\n    Parameters\n    ----------\n    i : int or iterable of int, optional\n        Spline ID that you want to analyze.\n    binsize : int, default 1\n        Multiscale bin size used for calculation.\n    depth : nm, default 40.0\n        Depth of images used to infer polarities.\n\n    Returns\n    -------\n    Ori\n        Orientation of corresponding splines.\n    \"\"\"\n    LOGGER.info(f\"Running: {self.__class__.__name__}.infer_polarity, i={i}\")\n    current_scale = self.scale * binsize\n\n    if binsize &gt; 1:\n        imgb = self.get_multiscale(binsize)\n    else:\n        try:\n            imgb = self.get_multiscale(1)\n        except ValueError:\n            imgb = self.image\n\n    spl = self.splines[i]\n    cfg = spl.config\n    ori_clockwise = Ori(cfg.clockwise)\n    ori_counterclockwise = Ori.invert(ori_clockwise, allow_none=False)\n    r_range = spl.radius_range()\n    point = 0.5  # the sampling point\n    coords = spl.local_cylindrical(r_range, depth, point, scale=current_scale)\n    polar = get_polar_image(imgb, coords, spl.radius, order=1)\n    clkwise = is_clockwise(\n        cfg,\n        polar,\n        mask_freq=mask_freq,\n        npf=spl.props.get_glob(H.npf, None),\n        logger=LOGGER,\n    )\n    ori = ori_clockwise if clkwise else ori_counterclockwise\n    if update:\n        spl.orientation = ori\n    return ori\n</code></pre>"},{"location":"api/components/#cylindra.components.tomogram.CylTomogram.local_cft","title":"<code>local_cft(*, i=None, depth=50.0, pos=None, binsize=1)</code>","text":"<p>Calculate non-upsampled local cylindric Fourier transormation along spline.</p> <p>This function does not up-sample.</p> <p>Parameters:</p> Name Type Description Default <code>i</code> <code>int or iterable of int</code> <p>Spline ID that you want to analyze.</p> <code>None</code> <code>depth</code> <code>nm</code> <p>Length of subtomogram for calculation of local parameters.</p> <code>50.0</code> <code>pos</code> <code>int</code> <p>Only calculate at <code>pos</code>-th anchor if given.</p> <code>None</code> <code>binsize</code> <code>int</code> <p>Multiscale bin size used for calculation.</p> <code>1</code> <p>Returns:</p> Type Description <code>ImgArray</code> <p>FT images stacked along \"p\" axis.</p> Source code in <code>cylindra/components/tomogram/_cyl_tomo.py</code> <pre><code>@_misc.batch_process\ndef local_cft(\n    self,\n    *,\n    i: int = None,\n    depth: nm = 50.0,\n    pos: int | None = None,\n    binsize: int = 1,\n) -&gt; ip.ImgArray:\n    \"\"\"Calculate non-upsampled local cylindric Fourier transormation along spline.\n\n    This function does not up-sample.\n\n    Parameters\n    ----------\n    i : int or iterable of int, optional\n        Spline ID that you want to analyze.\n    depth : nm, default 50.0\n        Length of subtomogram for calculation of local parameters.\n    pos : int, optional\n        Only calculate at ``pos``-th anchor if given.\n    binsize : int, default 1\n        Multiscale bin size used for calculation.\n\n    Returns\n    -------\n    ip.ImgArray\n        FT images stacked along \"p\" axis.\n    \"\"\"\n    out = list[ip.ImgArray]()\n    with set_gpu():\n        for polar in self.iter_local_image(i, depth, pos, binsize):\n            out.append(polar.fft(dims=\"rya\"))\n    return np.stack(out, axis=\"p\")\n</code></pre>"},{"location":"api/components/#cylindra.components.tomogram.CylTomogram.local_cft_params","title":"<code>local_cft_params(*, i=None, depth=50.0, binsize=1, radius='global', nsamples=8, update=True, update_glob=False)</code>","text":"<p>Calculate local lattice parameters from cylindrical Fourier space.</p> <p>To determine the peaks upsampled discrete Fourier transformation is used for every subtomogram.</p> <p>Parameters:</p> Name Type Description Default <code>i</code> <code>int or iterable of int</code> <p>Spline ID that you want to analyze.</p> <code>None</code> <code>depth</code> <code>nm</code> <p>Length of subtomogram for calculation of local parameters.</p> <code>50.0</code> <code>binsize</code> <code>int</code> <p>Multiscale bin size used for calculation.</p> <code>1</code> <code>radius</code> <code>str</code> <p>If \"local\", use the local radius for the analysis. If \"global\", use the global radius. If a float, use the given radius.</p> <code>\"global\"</code> <code>nsamples</code> <code>int</code> <p>Number of cylindrical coordinate samplings for Fourier transformation. Multiple samplings are needed because up-sampled discrete Fourier transformation does not return exactly the same power spectra with shifted inputs, unlike FFT. Larger <code>nsamples</code> reduces the error but is slower.</p> <code>8</code> <code>update</code> <code>bool</code> <p>If True, spline properties will be updated.</p> <code>True</code> <code>update_glob</code> <code>bool</code> <p>If True, global properties will be updated using the mean or mode of the local properties.</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Local properties.</p> Source code in <code>cylindra/components/tomogram/_cyl_tomo.py</code> <pre><code>@_misc.batch_process\ndef local_cft_params(\n    self,\n    *,\n    i: int = None,\n    depth: nm = 50.0,\n    binsize: int = 1,\n    radius: nm | Literal[\"local\", \"global\"] = \"global\",\n    nsamples: int = 8,\n    update: bool = True,\n    update_glob: bool = False,\n) -&gt; pl.DataFrame:\n    \"\"\"Calculate local lattice parameters from cylindrical Fourier space.\n\n    To determine the peaks upsampled discrete Fourier transformation is used\n    for every subtomogram.\n\n    Parameters\n    ----------\n    i : int or iterable of int, optional\n        Spline ID that you want to analyze.\n    depth : nm, default 50.0\n        Length of subtomogram for calculation of local parameters.\n    binsize : int, default 1\n        Multiscale bin size used for calculation.\n    radius : str, default \"global\"\n        If \"local\", use the local radius for the analysis. If \"global\", use the\n        global radius. If a float, use the given radius.\n    nsamples : int, default 8\n        Number of cylindrical coordinate samplings for Fourier transformation. Multiple\n        samplings are needed because up-sampled discrete Fourier transformation does not\n        return exactly the same power spectra with shifted inputs, unlike FFT. Larger\n        ``nsamples`` reduces the error but is slower.\n    update : bool, default True\n        If True, spline properties will be updated.\n    update_glob : bool, default False\n        If True, global properties will be updated using the mean or mode of the local\n        properties.\n\n    Returns\n    -------\n    polars.DataFrame\n        Local properties.\n    \"\"\"\n    LOGGER.info(f\"Running: {self.__class__.__name__}.local_cft_params, i={i}\")\n    spl = self.splines[i]\n    radii = _misc.prepare_radii(spl, radius)\n    input_img = self._get_multiscale_or_original(binsize)\n    _scale = input_img.scale.x\n    tasks: list[Delayed[LatticeParams]] = []\n    spl_trans = spl.translate([-self.multiscale_translation(binsize)] * 3)\n    _analyze_fn = LatticeAnalyzer(spl.config).estimate_lattice_params_task\n    for anc, r0 in zip(spl_trans.anchors, radii, strict=True):\n        rmin, rmax = spl.radius_range(r0)\n        rc = (rmin + rmax) / 2\n        coords = spl_trans.local_cylindrical((rmin, rmax), depth, anc, scale=_scale)\n        tasks.append(_analyze_fn(input_img, coords, rc, nsamples=nsamples))\n\n    lprops = pl.DataFrame(\n        compute(*tasks),\n        schema=LatticeParams.polars_schema(),\n    )\n    if update:\n        spl.props.update_loc(lprops, depth, bin_size=binsize)\n    if update_glob:\n        gprops = lprops.select(\n            pl.col(H.spacing).mean(),\n            pl.col(H.pitch).mean(),\n            pl.col(H.twist).mean(),\n            pl.col(H.skew).mean(),\n            pl.col(H.rise).mean(),\n            pl.col(H.rise_length).mean(),\n            pl.col(H.npf).mode().first(),\n            pl.col(H.start).mode().first(),\n        )\n        spl.props.update_glob(gprops, bin_size=binsize)\n\n    return lprops\n</code></pre>"},{"location":"api/components/#cylindra.components.tomogram.CylTomogram.local_cps","title":"<code>local_cps(*, i=None, depth=50.0, pos=None, binsize=1)</code>","text":"<p>Calculate non-upsampled local cylindric power spectra along spline.</p> <p>Parameters:</p> Name Type Description Default <code>i</code> <code>int or iterable of int</code> <p>Spline ID that you want to analyze.</p> <code>None</code> <code>depth</code> <code>nm</code> <p>Length of subtomogram for calculation of local parameters.</p> <code>50.0</code> <code>pos</code> <code>int</code> <p>Only calculate at <code>pos</code>-th anchor if given.</p> <code>None</code> <code>binsize</code> <code>int</code> <p>Multiscale bin size used for calculation.</p> <code>1</code> <p>Returns:</p> Type Description <code>ImgArray</code> <p>FT images stacked along \"p\" axis.</p> Source code in <code>cylindra/components/tomogram/_cyl_tomo.py</code> <pre><code>@_misc.batch_process\ndef local_cps(\n    self,\n    *,\n    i: int = None,\n    depth: nm = 50.0,\n    pos: int | None = None,\n    binsize: int = 1,\n) -&gt; ip.ImgArray:\n    \"\"\"Calculate non-upsampled local cylindric power spectra along spline.\n\n    Parameters\n    ----------\n    i : int or iterable of int, optional\n        Spline ID that you want to analyze.\n    depth : nm, default 50.0\n        Length of subtomogram for calculation of local parameters.\n    pos : int, optional\n        Only calculate at ``pos``-th anchor if given.\n    binsize : int, default 1\n        Multiscale bin size used for calculation.\n\n    Returns\n    -------\n    ip.ImgArray\n        FT images stacked along \"p\" axis.\n    \"\"\"\n    cft = self.local_cft(i=i, depth=depth, pos=pos, binsize=binsize)\n    return cft.real**2 + cft.imag**2\n</code></pre>"},{"location":"api/components/#cylindra.components.tomogram.CylTomogram.local_image_with_peaks","title":"<code>local_image_with_peaks(*, i=None, binsize=None)</code>","text":"<p>Recalculate local images and peaks.</p> <p>This method reuses the existing spline properties to get the peaks. To measure local lattice parameters, use <code>local_cft_params</code> method beforehand.</p> Source code in <code>cylindra/components/tomogram/_cyl_tomo.py</code> <pre><code>@_misc.batch_process\ndef local_image_with_peaks(\n    self,\n    *,\n    i: int = None,\n    binsize: int | None = None,\n) -&gt; list[_misc.ImageWithPeak]:\n    \"\"\"Recalculate local images and peaks.\n\n    This method reuses the existing spline properties to get the peaks. To measure\n    local lattice parameters, use `local_cft_params` method beforehand.\n    \"\"\"\n    spl = self.splines[i]\n    depth = spl.props.window_size[H.twist]\n    if binsize is None:\n        binsize = spl.props.binsize_loc[H.twist]\n    df_loc = spl.props.loc\n    out = list[_misc.ImageWithPeak]()\n    for j, polar_img in enumerate(self.iter_local_image(i, depth, binsize=binsize)):\n        try:\n            cparams = spl.cylinder_params(\n                spacing=_misc.get_component(df_loc, H.spacing, j),\n                pitch=_misc.get_component(df_loc, H.pitch, j),\n                twist=_misc.get_component(df_loc, H.twist, j),\n                skew=_misc.get_component(df_loc, H.skew, j),\n                rise_angle=_misc.get_component(df_loc, H.rise, j),\n                start=_misc.get_component(df_loc, H.start, j),\n                npf=_misc.get_component(df_loc, H.npf, j),\n            )\n        except ValueError:\n            out.append(_misc.ImageWithPeak(polar_img, []))\n        else:\n            analyzer = LatticeAnalyzer(spl.config)\n            peakv, peakh = analyzer.params_to_peaks(polar_img[0], cparams)\n            peakv = peakv.shift_to_center()\n            peakh = peakh.shift_to_center()\n            out.append(_misc.ImageWithPeak(polar_img, [peakv, peakh]))\n    return out\n</code></pre>"},{"location":"api/components/#cylindra.components.tomogram.CylTomogram.local_radii","title":"<code>local_radii(*, i=None, depth=50.0, binsize=1, min_radius=1.0, max_radius=100.0, update=True, update_glob=True)</code>","text":"<p>Measure the local radii along the splines.</p> <p>Parameters:</p> Name Type Description Default <code>i</code> <code>int or iterable of int</code> <p>Spline ID that you want to analyze.</p> <code>None</code> <code>depth</code> <code>nm</code> <p>Longitudinal length of subtomograms for calculation.</p> <code>50.0</code> <code>binsize</code> <code>int</code> <p>Multiscale binsize to be used.</p> <code>1</code> <code>min_radius</code> <code>nm</code> <p>Minimum radius of the cylinder.</p> <code>1.0</code> <code>max_radius</code> <code>nm</code> <p>Maximum radius of the cylinder.</p> <code>100.0</code> <code>update</code> <code>bool</code> <p>If True, spline properties will be updated.</p> <code>True</code> <code>update_glob</code> <code>bool</code> <p>If True, global properties will be updated using the mean of the local radii.</p> <code>True</code> <p>Returns:</p> Type Description <code>Series</code> <p>Radii along the spline.</p> Source code in <code>cylindra/components/tomogram/_cyl_tomo.py</code> <pre><code>@_misc.batch_process\ndef local_radii(\n    self,\n    *,\n    i: int = None,\n    depth: nm = 50.0,\n    binsize: int = 1,\n    min_radius: nm = 1.0,\n    max_radius: nm = 100.0,\n    update: bool = True,\n    update_glob: bool = True,\n) -&gt; pl.Series:\n    \"\"\"Measure the local radii along the splines.\n\n    Parameters\n    ----------\n    i : int or iterable of int, optional\n        Spline ID that you want to analyze.\n    depth : nm, default 50.0\n        Longitudinal length of subtomograms for calculation.\n    binsize : int, default 1\n        Multiscale binsize to be used.\n    min_radius : nm, default 1.0\n        Minimum radius of the cylinder.\n    max_radius : nm, default 100.0\n        Maximum radius of the cylinder.\n    update : bool, default True\n        If True, spline properties will be updated.\n    update_glob : bool, default True\n        If True, global properties will be updated using the mean of the local\n        radii.\n\n    Returns\n    -------\n    pl.Series\n        Radii along the spline.\n    \"\"\"\n    LOGGER.info(f\"Running: {self.__class__.__name__}.local_radii, i={i}\")\n    spl = self.splines[i]\n\n    input_img = self._get_multiscale_or_original(binsize)\n\n    depth = spl.config.fit_depth\n    _scale = input_img.scale.x\n    thickness = _misc.get_thickness(spl, _scale)\n    min_radius_px = min_radius / _scale\n    max_radius = min(max_radius, spl.config.fit_width / 2)\n    max_radius_px = max_radius / _scale\n    offset_px = _misc.get_radius_offset(min_radius_px, max_radius_px)\n    spl_trans = spl.translate([-self.multiscale_translation(binsize)] * 3)\n    tasks = []\n    for anc in spl_trans.anchors:\n        task = _misc.get_radial_prof(\n            input_img, spl_trans, anc, (min_radius, max_radius), depth\n        )\n        tasks.append(task)\n    profs: list[NDArray[np.float32]] = compute(*tasks)\n    radii = list[float]()\n    for prof in profs:\n        imax_sub = find_centroid_peak(prof, *thickness)\n        radii.append((imax_sub + offset_px) * _scale)\n\n    out = pl.Series(H.radius, radii, dtype=pl.Float32)\n    if update:\n        spl.props.update_loc([out], depth, bin_size=binsize)\n    if update_glob:\n        spl.props.update_glob([pl.Series(H.radius, [out.mean()])], bin_size=binsize)\n    return out\n</code></pre>"},{"location":"api/components/#cylindra.components.tomogram.CylTomogram.make_anchors","title":"<code>make_anchors(i=None, *, interval=None, n=None, max_interval=None)</code>","text":"<p>Make anchors on spline object(s).</p> <p>Parameters:</p> Name Type Description Default <code>interval</code> <code>nm</code> <p>Anchor intervals.</p> <code>None</code> <code>n</code> <code>int</code> <p>Number of anchors</p> <code>None</code> <code>max_interval</code> <code>nm</code> <p>Maximum interval between anchors.</p> <code>None</code> Source code in <code>cylindra/components/tomogram/_cyl_tomo.py</code> <pre><code>@_misc.batch_process\ndef make_anchors(\n    self,\n    i: int = None,\n    *,\n    interval: nm | None = None,\n    n: int | None = None,\n    max_interval: nm | None = None,\n):\n    \"\"\"Make anchors on spline object(s).\n\n    Parameters\n    ----------\n    interval : nm, optional\n        Anchor intervals.\n    n : int, optional\n        Number of anchors\n    max_interval : nm, optional\n        Maximum interval between anchors.\n\n    \"\"\"\n    self.splines[i].make_anchors(interval=interval, n=n, max_interval=max_interval)\n    return None\n</code></pre>"},{"location":"api/components/#cylindra.components.tomogram.CylTomogram.map_centers","title":"<code>map_centers(i=None, *, interval=1.0, orientation=None, rotate_molecules=True)</code>","text":"<p>Mapping molecules along the center of a cylinder.</p> <p>Parameters:</p> Name Type Description Default <code>i</code> <code>int or iterable of int</code> <p>Spline ID that mapping will be calculated.</p> <code>None</code> <code>interval</code> <code>float(nm)</code> <p>Interval of molecules.</p> <code>1.0</code> <code>rotate_molecules</code> <code>bool</code> <p>If True, twist the molecule orientations according to the spline twist.</p> <code>True</code> <p>Returns:</p> Type Description <code>Molecules</code> <p>Molecules object with mapped coordinates and angles.</p> Source code in <code>cylindra/components/tomogram/_cyl_tomo.py</code> <pre><code>@_misc.batch_process\ndef map_centers(\n    self,\n    i: int = None,\n    *,\n    interval: nm = 1.0,\n    orientation: Ori | str | None = None,\n    rotate_molecules: bool = True,\n) -&gt; Molecules:\n    \"\"\"Mapping molecules along the center of a cylinder.\n\n    Parameters\n    ----------\n    i : int or iterable of int, optional\n        Spline ID that mapping will be calculated.\n    interval : float (nm), optional\n        Interval of molecules.\n    rotate_molecules : bool, default True\n        If True, twist the molecule orientations according to the spline twist.\n\n    Returns\n    -------\n    Molecules\n        Molecules object with mapped coordinates and angles.\n    \"\"\"\n    spl = self.splines[i]\n    u = spl.prep_anchor_positions(interval=interval)\n    if rotate_molecules:\n        spacing = spl.props.get_glob(H.spacing)\n        twist = spl.props.get_glob(H.twist)\n        degrees = spl.distances(u) / spacing * twist\n        deg_round = np.round(degrees, 2)\n        if len(degrees) &lt; 11:\n            degrees_for_log = str(deg_round)\n        else:\n            degrees_for_log = (\n                str(deg_round[:5])[:-1] + \" ... \" + str(deg_round[-5:])[1:]\n            )\n        LOGGER.info(f\"Rotation in degree = {degrees_for_log}\")\n        rotation = np.deg2rad(degrees)\n    else:\n        rotation = None\n    mole = spl.anchors_to_molecules(u, rotation=rotation)\n    if spl._need_rotation(orientation):\n        mole = mole.rotate_by_rotvec_internal([np.pi, 0, 0])\n    return mole\n</code></pre>"},{"location":"api/components/#cylindra.components.tomogram.CylTomogram.map_centers_helical_symmetry","title":"<code>map_centers_helical_symmetry(i=None, *, orientation=None, clip_extension=True, sort=True)</code>","text":"<p>Mapping molecules along the center considering helical symmetry.</p> <p>Parameters:</p> Name Type Description Default <code>i</code> <code>int or iterable of int</code> <p>Spline ID that mapping will be calculated.</p> <code>None</code> <code>orientation</code> <code>Ori or str</code> <p>Orientation of the y-axis of each molecule.</p> <code>None</code> <p>Returns:</p> Type Description <code>Molecules</code> <p>Molecules object with mapped coordinates and angles.</p> Source code in <code>cylindra/components/tomogram/_cyl_tomo.py</code> <pre><code>@_misc.batch_process\ndef map_centers_helical_symmetry(\n    self,\n    i: int = None,\n    *,\n    orientation: Ori | str | None = None,\n    clip_extension: bool = True,\n    sort: bool = True,\n) -&gt; Molecules:\n    \"\"\"Mapping molecules along the center considering helical symmetry.\n\n    Parameters\n    ----------\n    i : int or iterable of int, optional\n        Spline ID that mapping will be calculated.\n    orientation : Ori or str, optional\n        Orientation of the y-axis of each molecule.\n\n    Returns\n    -------\n    Molecules\n        Molecules object with mapped coordinates and angles.\n    \"\"\"\n    spl = self.splines[i]\n    mole = self.map_monomers(i=i, orientation=orientation)\n    if clip_extension:\n        length = spl.length()\n        mole = mole.filter(pl.col(Mole.position).is_between(0, length))\n    if sort:\n        mole = mole.sort(Mole.position)\n    radius = spl.cylinder_params().radius\n    return mole.translate_internal([-radius, 0, 0])\n</code></pre>"},{"location":"api/components/#cylindra.components.tomogram.CylTomogram.map_monomers","title":"<code>map_monomers(i=None, *, offsets=None, orientation=None, extensions=(0, 0), **kwargs)</code>","text":"<p>Map monomers in a regular cylinder shape.</p> <p>Parameters:</p> Name Type Description Default <code>i</code> <code>int or iterable of int</code> <p>Spline ID that mapping will be calculated.</p> <code>None</code> <code>offsets</code> <code>tuple of float</code> <p>The offset of origin of oblique coordinate system to map monomers.</p> <code>None</code> <code>orientation</code> <code>Ori or str</code> <p>Orientation of the y-axis of each molecule.</p> <code>None</code> <p>Returns:</p> Type Description <code>Molecules</code> <p>Object that represents monomer positions and angles.</p> Source code in <code>cylindra/components/tomogram/_cyl_tomo.py</code> <pre><code>@_misc.batch_process\ndef map_monomers(\n    self,\n    i: int = None,\n    *,\n    offsets: tuple[nm, float] | None = None,\n    orientation: Ori | str | None = None,\n    extensions: tuple[int, int] = (0, 0),\n    **kwargs,\n) -&gt; Molecules:\n    \"\"\"Map monomers in a regular cylinder shape.\n\n    Parameters\n    ----------\n    i : int or iterable of int, optional\n        Spline ID that mapping will be calculated.\n    offsets : tuple of float, optional\n        The offset of origin of oblique coordinate system to map monomers.\n    orientation : Ori or str, optional\n        Orientation of the y-axis of each molecule.\n\n    Returns\n    -------\n    Molecules\n        Object that represents monomer positions and angles.\n    \"\"\"\n    model = self.get_cylinder_model(i, offsets=offsets, **kwargs)\n    ny, na = model.shape\n    ext0, ext1 = extensions\n    if ny + ext0 + ext1 &lt; 0:\n        raise ValueError(\"The number of monomers is negative.\")\n    yy, aa = np.indices((ny + ext0 + ext1, na), dtype=np.int32)\n    yy -= ext0\n    coords = np.stack([yy.ravel(), aa.ravel()], axis=1)\n    spl = self.splines[i]\n    mole = model.locate_molecules(spl, coords)\n    if spl._need_rotation(orientation):\n        mole = mole.rotate_by_rotvec_internal([np.pi, 0, 0])\n    return mole\n</code></pre>"},{"location":"api/components/#cylindra.components.tomogram.CylTomogram.map_on_grid","title":"<code>map_on_grid(i=None, coords=(), *, offsets=None, orientation=None, **kwargs)</code>","text":"<p>Map monomers in a regular cylinder shape.</p> <p>Parameters:</p> Name Type Description Default <code>i</code> <code>int or iterable of int</code> <p>Spline ID that mapping will be calculated.</p> <code>None</code> <code>coords</code> <code>ndarray</code> <p>Integer coordinates on the cylinder surface.</p> <code>()</code> <code>offsets</code> <code>tuple of float</code> <p>The offset of origin of oblique coordinate system to map monomers.</p> <code>None</code> <code>orientation</code> <code>Ori or str</code> <p>Orientation of the y-axis of each molecule.</p> <code>None</code> <p>Returns:</p> Type Description <code>Molecules</code> <p>Object that represents monomer positions and angles.</p> Source code in <code>cylindra/components/tomogram/_cyl_tomo.py</code> <pre><code>@_misc.batch_process\ndef map_on_grid(\n    self,\n    i: int = None,\n    coords: NDArray[np.int32] = (),\n    *,\n    offsets: tuple[nm, float] | None = None,\n    orientation: Ori | str | None = None,\n    **kwargs,\n) -&gt; Molecules:\n    \"\"\"Map monomers in a regular cylinder shape.\n\n    Parameters\n    ----------\n    i : int or iterable of int, optional\n        Spline ID that mapping will be calculated.\n    coords : ndarray\n        Integer coordinates on the cylinder surface.\n    offsets : tuple of float, optional\n        The offset of origin of oblique coordinate system to map monomers.\n    orientation : Ori or str, optional\n        Orientation of the y-axis of each molecule.\n\n    Returns\n    -------\n    Molecules\n        Object that represents monomer positions and angles.\n    \"\"\"\n    model = self.get_cylinder_model(i, offsets=offsets, **kwargs)\n    coords = np.asarray(coords, dtype=np.int32)\n    spl = self.splines[i]\n    mole = model.locate_molecules(spl, coords)\n    if spl._need_rotation(orientation):\n        mole = mole.rotate_by_rotvec_internal([np.pi, 0, 0])\n    return mole\n</code></pre>"},{"location":"api/components/#cylindra.components.tomogram.CylTomogram.map_pf_line","title":"<code>map_pf_line(i=None, *, interval=1.0, offsets=(0.0, 0.0), orientation=None)</code>","text":"<p>Mapping molecules along a protofilament line.</p> <p>This method is useful when you want to visualize seam or protofilament, or assign molecules for subtomogram averaging of seam binding protein or doublet microtubule.</p> <p>Parameters:</p> Name Type Description Default <code>i</code> <code>int or iterable of int</code> <p>Spline ID that mapping will be calculated.</p> <code>None</code> <code>offsets</code> <code>(float, float)</code> <p>Axial offset in nm and angular offset in degree.</p> <code>(0.0, 0.0)</code> <p>Returns:</p> Type Description <code>Molecules</code> <p>Object that represents protofilament positions and angles.</p> Source code in <code>cylindra/components/tomogram/_cyl_tomo.py</code> <pre><code>@_misc.batch_process\ndef map_pf_line(\n    self,\n    i: int = None,\n    *,\n    interval: nm = 1.0,\n    offsets: tuple[nm, float] = (0.0, 0.0),\n    orientation: Ori | str | None = None,\n) -&gt; Molecules:\n    \"\"\"Mapping molecules along a protofilament line.\n\n    This method is useful when you want to visualize seam or protofilament, or\n    assign molecules for subtomogram averaging of seam binding protein or doublet\n    microtubule.\n\n    Parameters\n    ----------\n    i : int or iterable of int, optional\n        Spline ID that mapping will be calculated.\n    offsets : (float, float), default (0.0, 0.0)\n        Axial offset in nm and angular offset in degree.\n\n    Returns\n    -------\n    Molecules\n        Object that represents protofilament positions and angles.\n    \"\"\"\n    spl = self.splines[i]\n    spacing = spl.props.get_glob(H.spacing)\n    twist = spl.props.get_glob(H.twist)\n\n    ny = roundint(spl.length() / interval)\n    skew_rad = np.deg2rad(twist) * interval / spacing\n\n    yoffset, aoffset = offsets\n    rcoords = np.full(ny, spl.radius)\n    ycoords = np.arange(ny) * interval + yoffset\n    acoords = np.arange(ny) * skew_rad + np.deg2rad(aoffset)\n    coords = np.stack([rcoords, ycoords, acoords], axis=1)\n    mole = spl.cylindrical_to_molecules(coords)\n    if spl._need_rotation(orientation):\n        mole = mole.rotate_by_rotvec_internal([np.pi, 0, 0])\n    return mole\n</code></pre>"},{"location":"api/components/#cylindra.components.tomogram.CylTomogram.measure_radius","title":"<code>measure_radius(i=None, *, binsize=1, positions='auto', min_radius=1.0, max_radius=100.0, update=True)</code>","text":"<p>Measure radius using radial profile from the center.</p> <p>Parameters:</p> Name Type Description Default <code>i</code> <code>int or iterable of int</code> <p>Spline ID that you want to measure.</p> <code>None</code> <code>binsize</code> <code>int</code> <p>Multiscale bin size used for radius calculation.</p> <code>1</code> <code>positions</code> <code>array - like or 'auto' or 'anchor'</code> <p>Sampling positions (between 0 and 1) to calculate radius. If \"anchor\" is given, anchors of the spline will be used. If \"auto\" is given, three positions along the spline will be used.</p> <code>\"auto\"</code> <code>min_radius</code> <code>nm</code> <p>Minimum radius of the cylinder.</p> <code>1.0</code> <code>max_radius</code> <code>nm</code> <p>Maximum radius of the cylinder.</p> <code>100.0</code> <code>update</code> <code>bool</code> <p>If True, global radius property will be updated.</p> <code>True</code> <p>Returns:</p> Type Description <code>float(nm)</code> <p>Cylinder radius.</p> Source code in <code>cylindra/components/tomogram/_cyl_tomo.py</code> <pre><code>@_misc.batch_process\ndef measure_radius(\n    self,\n    i: int = None,\n    *,\n    binsize: int = 1,\n    positions: NDArray[np.float32] | Literal[\"auto\", \"anchor\"] = \"auto\",\n    min_radius: nm = 1.0,\n    max_radius: nm = 100.0,\n    update: bool = True,\n) -&gt; nm:\n    \"\"\"Measure radius using radial profile from the center.\n\n    Parameters\n    ----------\n    i : int or iterable of int, optional\n        Spline ID that you want to measure.\n    binsize : int, default 1\n        Multiscale bin size used for radius calculation.\n    positions : array-like or \"auto\" or \"anchor\", default \"auto\"\n        Sampling positions (between 0 and 1) to calculate radius. If \"anchor\"\n        is given, anchors of the spline will be used. If \"auto\" is given,\n        three positions along the spline will be used.\n    min_radius : nm, default 1.0\n        Minimum radius of the cylinder.\n    max_radius : nm, default 100.0\n        Maximum radius of the cylinder.\n    update : bool, default True\n        If True, global radius property will be updated.\n\n    Returns\n    -------\n    float (nm)\n        Cylinder radius.\n    \"\"\"\n    LOGGER.info(f\"Running: {self.__class__.__name__}.measure_radius, i={i}\")\n    spl = self.splines[i]\n\n    if isinstance(positions, str) and positions == \"auto\":\n        nanchor = 3\n        pos = 1 / nanchor * np.arange(nanchor) + 0.5 / nanchor\n    elif isinstance(positions, str) and positions == \"anchor\":\n        pos = spl.anchors\n    else:\n        pos = np.asarray(positions, dtype=np.float32)\n\n    input_img = self._get_multiscale_or_original(binsize)\n\n    depth = spl.config.fit_depth\n    _scale = input_img.scale.x\n    min_radius_px = min_radius / _scale\n    max_radius = min(max_radius, spl.config.fit_width / 2)\n    max_radius_px = max_radius / _scale\n    spl_trans = spl.translate([-self.multiscale_translation(binsize)] * 3)\n    tasks = [\n        _misc.get_radial_prof(\n            input_img, spl_trans, anc, (min_radius, max_radius), depth\n        )\n        for anc in pos\n    ]\n    profs: list[NDArray[np.float32]] = compute(*tasks)\n    prof = np.stack(profs, axis=0).mean(axis=0)\n    imax_sub = find_centroid_peak(prof, *_misc.get_thickness(spl, _scale))\n    offset_px = _misc.get_radius_offset(min_radius_px, max_radius_px)\n    radius = (imax_sub + offset_px) * _scale\n    if update:\n        spl.props.update_glob(\n            [pl.Series(H.radius, [radius], dtype=pl.Float32)],\n            bin_size=binsize,\n        )\n    LOGGER.info(f\" &gt;&gt; Radius = {radius:.3f} nm\")\n    return radius\n</code></pre>"},{"location":"api/components/#cylindra.components.tomogram.CylTomogram.refine","title":"<code>refine(i=None, *, max_interval=30.0, binsize=1, err_max=1.0, corr_allowed=0.9, max_shift=2.0, n_rotations=3)</code>","text":"<p>Spline refinement using global lattice structural parameters.</p> <p>Refine spline using the result of previous fit and the global structural parameters. During refinement, Y-projection of XZ cross section of cylinder is rotated with the twist angles, thus is much more precise than the coarse fitting.</p> <p>Parameters:</p> Name Type Description Default <code>i</code> <code>int or iterable of int</code> <p>Spline ID that you want to fit.</p> <code>None</code> <code>max_interval</code> <code>nm</code> <p>Maximum interval of sampling points in nm unit.</p> <code>24.0</code> <code>binsize</code> <code>int</code> <p>Multiscale bin size used for refining.</p> <code>1</code> <code>corr_allowed</code> <code>(float, defaul is 0.9)</code> <p>How many images will be used to make template for alignment. If 0.9, then top 90% will be used.</p> <code>0.9</code> <code>max_shift</code> <code>nm</code> <p>Maximum shift from the true center of the cylinder. This parameter is used in phase cross correlation.</p> <code>2.0</code> <code>n_rotations</code> <code>int</code> <p>Number of rotations to be tested during finding the cylinder center.</p> <code>3</code> <p>Returns:</p> Type Description <code>FitResult</code> <p>Result of fitting.</p> Source code in <code>cylindra/components/tomogram/_cyl_tomo.py</code> <pre><code>@_misc.batch_process\ndef refine(\n    self,\n    i: int = None,\n    *,\n    max_interval: nm = 30.0,\n    binsize: int = 1,\n    err_max: nm = 1.0,\n    corr_allowed: float = 0.9,\n    max_shift: nm = 2.0,\n    n_rotations: int = 3,\n) -&gt; _misc.FitResult:\n    \"\"\"Spline refinement using global lattice structural parameters.\n\n    Refine spline using the result of previous fit and the global structural parameters.\n    During refinement, Y-projection of XZ cross section of cylinder is rotated with the\n    twist angles, thus is much more precise than the coarse fitting.\n\n    Parameters\n    ----------\n    i : int or iterable of int, optional\n        Spline ID that you want to fit.\n    max_interval : nm, default 24.0\n        Maximum interval of sampling points in nm unit.\n    binsize : int, default 1\n        Multiscale bin size used for refining.\n    corr_allowed : float, defaul is 0.9\n        How many images will be used to make template for alignment. If 0.9, then top\n        90% will be used.\n    max_shift: nm, default 2.0\n        Maximum shift from the true center of the cylinder. This parameter is used in\n        phase cross correlation.\n    n_rotations : int, default 3\n        Number of rotations to be tested during finding the cylinder center.\n\n    Returns\n    -------\n    FitResult\n        Result of fitting.\n    \"\"\"\n    LOGGER.info(f\"Running: {self.__class__.__name__}.refine, i={i}\")\n    spl = self.splines[i]\n    _required = [H.spacing, H.twist, H.npf]\n    if not spl.props.has_glob(_required):\n        if (radius := spl.radius) is None:\n            radius = self.measure_radius(\n                i=i,\n                binsize=binsize,\n                positions=\"auto\",\n                update=False,\n            )\n        with spl.props.temp_glob(radius=radius):\n            gprops = self.global_cft_params(\n                i=i, binsize=binsize, nsamples=1, update=False\n            )\n    else:\n        gprops = spl.props.glob.select(_required)\n    gdict = {k: float(gprops[k][0]) for k in _required}\n    ancs = spl.prep_anchor_positions(max_interval=max_interval)\n\n    # Calculate Fourier parameters by cylindrical transformation along spline.\n    # Skew angles are divided by the angle of single protofilament and the residual\n    # angles are used, considering missing wedge effect.\n    space = gdict[H.spacing]\n    twist = gdict[H.twist]\n    npf = roundint(gdict[H.npf])\n\n    LOGGER.info(f\" &gt;&gt; Parameters: spacing = {space:.2f} nm, twist = {twist:.3f} deg, PF = {npf}\")  # fmt: skip\n\n    # complement twisting\n    pf_ang = 360 / npf\n    twists = _misc.get_twists(spl.length(), ancs.size, space, twist, npf)\n    scale = self.scale * binsize\n    loader = _misc.prep_loader_for_refine(self, spl, ancs, binsize, twists)\n    subtomograms = ip.asarray(loader.asnumpy(), axes=\"pzyx\", dtype=np.float32)\n    subtomograms[:] -= subtomograms.mean()  # normalize\n    subtomograms.set_scale(zyx=scale)\n\n    degrees = np.linspace(-pf_ang / 2, pf_ang / 2, n_rotations) + 180\n    max_shift_px = max_shift / scale\n    with set_gpu():\n        inputs = subtomograms.mean(axis=\"y\")[ip.slicer.x[::-1]]\n\n        # Align twist-corrected images\n        shifts_loc = _misc.multi_rotated_auto_zncc(inputs, degrees, max_shift_px)\n        tasks = [\n            _misc.delayed_translate(inputs[_j], shifts_loc[_j])\n            for _j in range(ancs.size)\n        ]\n        imgs_aligned = _filter_by_corr(\n            np.stack(compute(*tasks), axis=\"p\"),\n            corr_allowed,\n        )\n\n        # Make 2D template using coarse aligned images.\n        imgcory = imgs_aligned.mean(axis=\"p\")\n        shift = rotated_auto_zncc(\n            imgcory, degrees=degrees, max_shifts=max_shift_px * 2\n        )\n        template = imgcory.affine(translation=shift, mode=Mode.constant, cval=0.0)\n\n        # Align twist-corrected images to the template\n        quat = loader.molecules.quaternion()\n        tasks = [\n            _misc.delayed_zncc_maximum(\n                inputs[_j],\n                _misc.mask_missing_wedge(template, self.tilt_model, quat[_j]),\n                max_shift_px,\n                twists[_j],\n            )\n            for _j in range(ancs.size)\n        ]\n        shifts = np.stack(compute(*tasks), axis=0)\n\n    # Update spline parameters\n    self.splines[i] = spl.shift(ancs, shifts=shifts * scale, err_max=err_max)\n    result = _misc.FitResult(shifts * scale)\n    LOGGER.info(f\" &gt;&gt; Shift RMSD = {result.rmsd:.3f} nm\")\n    return result\n</code></pre>"},{"location":"api/components/#cylindra.components.tomogram.CylTomogram.straighten","title":"<code>straighten(i=None, *, size=None, range_=(0.0, 1.0), chunk_length=None, binsize=1)</code>","text":"<p>Straightening by building curved coordinate system around splines.</p> <p>Parameters:</p> Name Type Description Default <code>i</code> <code>int or iterable of int</code> <p>Spline ID that you want to straighten.</p> <code>None</code> <code>size</code> <code>float(nm)</code> <p>Vertical/horizontal box size.</p> <code>None</code> <code>range_</code> <code>tuple[float, float]</code> <p>Range of spline domain.</p> <code>(0.0, 1.0)</code> <code>chunk_length</code> <code>nm</code> <p>If spline is longer than this, it will be first split into chunks, straightened respectively and all the straightened images are concatenated afterward, to avoid loading entire image into memory.</p> <code>None</code> <code>binsize</code> <code>int</code> <p>Multiscale bin size used for calculation.</p> <code>1</code> <p>Returns:</p> Type Description <code>ImgArray</code> <p>Straightened image. If Cartesian coordinate system is used, it will have \"zyx\".</p> Source code in <code>cylindra/components/tomogram/_cyl_tomo.py</code> <pre><code>@_misc.batch_process\ndef straighten(\n    self,\n    i: int = None,\n    *,\n    size: nm | tuple[nm, nm] = None,\n    range_: tuple[float, float] = (0.0, 1.0),\n    chunk_length: nm | None = None,\n    binsize: int = 1,\n) -&gt; ip.ImgArray:\n    \"\"\"Straightening by building curved coordinate system around splines.\n\n    Parameters\n    ----------\n    i : int or iterable of int, optional\n        Spline ID that you want to straighten.\n    size : float (nm), optional\n        Vertical/horizontal box size.\n    range_ : tuple[float, float], default (0.0, 1.0)\n        Range of spline domain.\n    chunk_length : nm, optional\n        If spline is longer than this, it will be first split into chunks,\n        straightened respectively and all the straightened images are concatenated\n        afterward, to avoid loading entire image into memory.\n    binsize : int, default 1\n        Multiscale bin size used for calculation.\n\n    Returns\n    -------\n    ip.ImgArray\n        Straightened image. If Cartesian coordinate system is used, it will have \"zyx\".\n    \"\"\"\n    spl = self.splines[i]\n    input_img = self._get_multiscale_or_original(binsize)\n    chunk_length = _misc.normalize_chunk_length(input_img, chunk_length)\n    return _straighten.straighten(input_img, spl, range_, size)\n</code></pre>"},{"location":"api/components/#cylindra.components.tomogram.CylTomogram.straighten_cylindric","title":"<code>straighten_cylindric(i=None, *, radii=None, range_=(0.0, 1.0), chunk_length=None, binsize=1)</code>","text":"<p>Straightening by building curved coordinate system around splines.</p> <p>Parameters:</p> Name Type Description Default <code>i</code> <code>int or iterable of int</code> <p>Spline ID that you want to straighten.</p> <code>None</code> <code>radii</code> <code>tuple of float (nm)</code> <p>Lower/upper limit of radius.</p> <code>None</code> <code>range_</code> <code>tuple[float, float]</code> <p>Range of spline domain.</p> <code>(0.0, 1.0)</code> <code>chunk_length</code> <code>nm</code> <p>If spline is longer than this, it will be first split into chunks, straightened respectively and all the straightened images are concatenated afterward, to avoid loading entire image into memory.</p> <code>None</code> <code>binsize</code> <code>int</code> <p>Multiscale bin size used for calculation.</p> <code>1</code> <p>Returns:</p> Type Description <code>ImgArray</code> <p>Straightened image. If Cartesian coordinate system is used, it will have \"zyx\".</p> Source code in <code>cylindra/components/tomogram/_cyl_tomo.py</code> <pre><code>@_misc.batch_process\ndef straighten_cylindric(\n    self,\n    i: int = None,\n    *,\n    radii: tuple[nm, nm] | None = None,\n    range_: tuple[float, float] = (0.0, 1.0),\n    chunk_length: nm | None = None,\n    binsize: int = 1,\n) -&gt; ip.ImgArray:\n    \"\"\"Straightening by building curved coordinate system around splines.\n\n    Parameters\n    ----------\n    i : int or iterable of int, optional\n        Spline ID that you want to straighten.\n    radii : tuple of float (nm), optional\n        Lower/upper limit of radius.\n    range_ : tuple[float, float], default (0.0, 1.0)\n        Range of spline domain.\n    chunk_length : nm, optional\n        If spline is longer than this, it will be first split into chunks,\n        straightened respectively and all the straightened images are concatenated\n        afterward, to avoid loading entire image into memory.\n    binsize : int, default 1\n        Multiscale bin size used for calculation.\n\n    Returns\n    -------\n    ip.ImgArray\n        Straightened image. If Cartesian coordinate system is used, it will have \"zyx\".\n    \"\"\"\n    spl = self.splines[i]\n    input_img = self._get_multiscale_or_original(binsize)\n    chunk_length = _misc.normalize_chunk_length(input_img, chunk_length)\n    return _straighten.straighten_cylindric(input_img, spl, range_, radii)\n</code></pre>"},{"location":"api/components/#cylindra.components.tomogram.Tomogram","title":"<code>Tomogram</code>","text":"<p>Lazy-loading/multi-scale tomogram object.</p> <p>It is always connected to a 3D image but processed lazily. Thus you can create a lot of Tomogram objects without MemoryError. Subtomograms are temporarily loaded into memory via cache map. Once memory usage exceed certain amount, the subtomogram cache will automatically deleted from the old ones.</p> Source code in <code>cylindra/components/tomogram/_tomo_base.py</code> <pre><code>class Tomogram:\n    \"\"\"Lazy-loading/multi-scale tomogram object.\n\n    It is always connected to a 3D image but processed lazily. Thus you can create\n    a lot of Tomogram objects without MemoryError. Subtomograms are temporarily\n    loaded into memory via cache map. Once memory usage exceed certain amount, the\n    subtomogram cache will automatically deleted from the old ones.\n    \"\"\"\n\n    def __init__(self):\n        self._metadata: dict[str, Any] = {}\n        self._image: ip.ImgArray | ip.LazyImgArray | None = None\n        self._multiscaled = list[tuple[int, ip.ImgArray]]()\n        self._tilt_model: TiltSeriesModel = single_axis(None)\n        self._scale = 1.0\n\n    def __hash__(self) -&gt; int:\n        \"\"\"Use unsafe hash.\"\"\"\n        return id(self)\n\n    def __repr__(self) -&gt; str:\n        return str(self)\n\n    def __str__(self) -&gt; str:\n        shape = str(self._image.shape) if self._image is not None else \"unknown\"\n        scale = f\"{self.scale:.4f}\" if self._image is not None else \"unknown\"\n        if source := self.metadata.get(\"source\", None):\n            source = Path(source).as_posix()\n        return (\n            f\"{self.__class__.__name__}(shape={shape}, scale={scale}, source={source})\"\n        )\n\n    @property\n    def scale(self) -&gt; nm:\n        \"\"\"Scale (nm/pixel) of the tomogram.\"\"\"\n        return self._scale\n\n    @property\n    def origin(self) -&gt; OriginTuple:\n        \"\"\"Origin of the tomogram in nm.\"\"\"\n        if self._image is None:\n            return OriginTuple(z=0.0, y=0.0, x=0.0)\n        return OriginTuple(*self._image.metadata.get(\"origin_nm\", [0, 0, 0]))\n\n    def update_scale(self, new_scale: nm) -&gt; None:\n        self._scale = new_scale\n        self._image.set_scale(xyz=new_scale)\n        for _b, _img in self._multiscaled:\n            _img.set_scale(xyz=new_scale * _b)\n\n    @property\n    def metadata(self) -&gt; dict[str, Any]:\n        \"\"\"Metadata relevant to the tomogram.\"\"\"\n        return self._metadata\n\n    @metadata.setter\n    def metadata(self, v: dict[str, Any]):\n        if not isinstance(v, dict):\n            raise TypeError(f\"Cannot set type {type(v)} as a metadata.\")\n        self._metadata = v\n\n    @property\n    def source(self) -&gt; Path:\n        \"\"\"Path to the source file.\"\"\"\n        source = self.metadata.get(\"source\", None)\n        if source is None:\n            raise ValueError(\"Source file is unknown.\")\n        return Path(source)\n\n    def _orig_or_read_path(self) -&gt; Path | None:\n        if path := self.metadata.get(\"orig_path\", None):\n            return path\n        if path := self.metadata.get(\"source\", None):\n            return Path(path)\n        return None\n\n    @property\n    def tilt_model(self):\n        \"\"\"Tilt model of the tomogram.\"\"\"\n        return self._tilt_model\n\n    @property\n    def tilt(self) -&gt; dict[str, Any]:\n        \"\"\"Tilt model as a dictionary.\"\"\"\n        if isinstance(self._tilt_model, SingleAxisX):\n            return {\"kind\": \"x\", \"range\": self._tilt_model.tilt_range}\n        elif isinstance(self._tilt_model, SingleAxisY):\n            return {\"kind\": \"y\", \"range\": self._tilt_model.tilt_range}\n        elif isinstance(self._tilt_model, NoWedge):\n            return {\"kind\": \"none\"}\n        elif isinstance(self._tilt_model, UnionAxes):\n            return {\n                \"kind\": \"dual\",\n                \"xrange\": self._tilt_model._wedges[1].tilt_range,\n                \"yrange\": self._tilt_model._wedges[0].tilt_range,\n            }\n        else:\n            raise ValueError(\"Tilt model is not correctly set.\")\n\n    @property\n    def is_inverted(self) -&gt; bool:\n        \"\"\"True if this image is inverted\"\"\"\n        return self.metadata.get(\"is_inverted\", False)\n\n    @classmethod\n    def dummy(\n        cls,\n        *,\n        scale: float = 1.0,\n        tilt: tuple[float, float] | None = None,\n        binsize: int | Iterable[int] = (),\n        source: str | None = None,\n        shape: tuple[int, int, int] = (24, 24, 24),\n        name: str | None = None,\n    ) -&gt; Self:\n        \"\"\"Create a dummy tomogram.\"\"\"\n        dummy = ip.zeros(shape, name=name, dtype=np.float32, axes=\"zyx\")\n        dummy.source = source\n        tomo = cls.from_image(\n            dummy,\n            scale=scale,\n            tilt=tilt,\n            binsize=binsize,\n        )\n        tomo.metadata = {\"is_dummy\": True}\n        return tomo\n\n    @property\n    def is_dummy(self) -&gt; bool:\n        \"\"\"True if this tomogram object does not have a real image.\"\"\"\n        return self.metadata.get(\"is_dummy\", False)\n\n    @classmethod\n    def from_image(\n        cls,\n        img: ip.ImgArray | ip.LazyImgArray,\n        *,\n        scale: float | None = None,\n        tilt: TiltSeriesModel | dict[str, Any] | None = None,\n        binsize: int | Iterable[int] = (),\n        compute: bool = True,\n    ):\n        \"\"\"Construct a Tomogram object from a image array.\n\n        Parameters\n        ----------\n        img : array-like\n            Input image.\n        scale : float, optional\n            Pixel size in nm. If not given, will try to read from image header.\n        tilt : tuple of float, optional\n            Tilt model.\n        binsize : int or iterable of int, optional\n            Binsize to generate multiscale images. If not given, will not generate.\n        compute : bool, default True\n            Whether to compute the binned images.\n\n        Returns\n        -------\n        Tomogram\n            Tomogram object with the image that has just been read and multi-scales.\n        \"\"\"\n        self = cls()\n        if type(img) is np.ndarray:\n            img = ip.asarray(img, axes=\"zyx\")\n\n        if scale is not None:\n            img.set_scale(xyz=scale)\n        else:\n            if (\n                abs(img.scale.z - img.scale.x) &gt; 1e-3\n                or abs(img.scale.z - img.scale.y) &gt; 1e-3\n            ):\n                raise ValueError(f\"Uneven scale: {img.scale}.\")\n\n        self._set_image(img)\n        if source := img.source:\n            self._metadata[\"source\"] = source.resolve()\n        self._metadata[\"scale\"] = scale\n        self._tilt_model = parse_tilt_model(tilt)\n\n        if isinstance(binsize, int):\n            binsize = [binsize]\n        for b in sorted(binsize):\n            self.add_multiscale(b, compute=compute)\n        return self\n\n    @classmethod\n    def imread(\n        cls,\n        path: str | Path,\n        *,\n        scale: float = None,\n        tilt: tuple[float, float] | None = None,\n        binsize: int | Iterable[int] = (),\n        eager: bool = False,\n        compute: bool = True,\n    ) -&gt; Self:\n        \"\"\"Read a image as a dask array.\n\n        Parameters\n        ----------\n        path : path-like\n            Path to the image file.\n        scale : float, optional\n            Pixel size in nm. If not given, will try to read from image header.\n        tilt : tuple of float, optional\n            Tilt model.\n        binsize : int or iterable of int, optional\n            Binsize to generate multiscale images. If not given, will not generate.\n        eager : bool, default False\n            Whether to read the image lazily. If True, the entire image will be read\n            into the memory.\n\n        Returns\n        -------\n        Tomogram\n            Tomogram object with the image that has just been read and multi-scales.\n        \"\"\"\n        chunks = get_config().dask_chunk\n        img = ip.lazy.imread(path, chunks=chunks)\n        if eager:\n            img = img.compute()\n        return cls.from_image(\n            _norm_dtype(img),\n            scale=scale,\n            tilt=tilt,\n            binsize=binsize,\n            compute=compute,\n        )\n\n    def with_cache_info(self, orig_path: Path, cached: bool = False) -&gt; Self:\n        \"\"\"Set cache path.\"\"\"\n        orig_path = Path(orig_path)\n        self.metadata[\"orig_path\"] = orig_path\n        self.metadata[\"cache_image\"] = cached\n        self._image.name = orig_path.name\n        for _, img in self._multiscaled:\n            img.name = orig_path.name\n        return self\n\n    @property\n    def image(self) -&gt; ip.ImgArray | ip.LazyImgArray:\n        \"\"\"Tomogram image data.\"\"\"\n        if self._image is None:\n            raise ValueError(\"Image is not set.\")\n        return self._image\n\n    @property\n    def multiscaled(self) -&gt; list[tuple[int, ip.ImgArray]]:\n        \"\"\"Get all multi-scale factor and the corresponding multiscaled images.\"\"\"\n        return self._multiscaled\n\n    def _set_image(self, img: ip.LazyImgArray | np.ndarray) -&gt; None:\n        if isinstance(img, ip.LazyImgArray):\n            _img = _norm_dtype(img)\n        elif isinstance(img, np.ndarray):\n            if img.ndim != 3:\n                raise ValueError(\"Can only set 3-D image.\")\n            _img = ip.lazy.asarray(\n                img, dtype=np.float32, axes=\"zyx\", chunks=get_config().dask_chunk\n            )\n            if isinstance(img, ip.ImgArray):\n                _img.set_scale(img)\n        else:  # pragma: no cover\n            raise TypeError(f\"Cannot set type {type(img)} as an image.\")\n        if (\n            abs(_img.scale.z - _img.scale.x) &gt; 1e-4\n            or abs(_img.scale.z - _img.scale.y) &gt; 1e-4\n        ):\n            raise ValueError(\"Uneven scale.\")\n        self._scale = _img.scale.x\n        self._image = _img\n        return None\n\n    @overload\n    def nm2pixel(self, value: nm, binsize: float = 1) -&gt; int: ...\n\n    @overload\n    def nm2pixel(\n        self, value: Iterable[nm] | NDArray[np.number], binsize: float = 1\n    ) -&gt; NDArray[np.intp]: ...\n\n    def nm2pixel(self, value, binsize: float = 1):\n        \"\"\"Convert nm float value into pixel value. Useful for conversion from\n        coordinate to pixel position.\n\n        Returns\n        -------\n        np.ndarray or int\n            Pixel position.\n        \"\"\"\n        pix = np.round(np.asarray(value) / self.scale / binsize).astype(np.int16)\n        if np.isscalar(value):\n            pix = int(pix)\n        return pix\n\n    def add_multiscale(self, binsize: int, compute: bool = True) -&gt; ip.ImgArray:\n        \"\"\"Add new multiscaled image of given binsize.\"\"\"\n        # iterate from the larger bin size\n        for _b, _img in reversed(self._multiscaled):\n            if binsize == _b:\n                warnings.warn(\n                    f\"Binsize {binsize} already exists in multiscale images. \"\n                    \"Skip binning process.\",\n                    UserWarning,\n                    stacklevel=2,\n                )\n                return _img\n            if binsize % _b == 0:\n                imgb = _img.binning(binsize // _b, check_edges=False)\n                break\n        else:\n            imgb = self.image.binning(binsize, check_edges=False)\n            if isinstance(imgb, ip.LazyImgArray) and compute:\n                imgb = imgb.compute()\n        self._multiscaled.append((binsize, imgb))\n        self._multiscaled.sort(key=lambda x: x[0])\n        return imgb\n\n    def get_multiscale(self, binsize: int, add: bool = False) -&gt; ip.ImgArray:\n        \"\"\"Get multiscaled image of given binsize.\"\"\"\n        for _b, _img in self._multiscaled:\n            if _b == binsize:\n                return _img\n        if add:\n            return self.add_multiscale(binsize)\n        raise ValueError(f\"Multiscale = {binsize} not found.\")\n\n    def _get_multiscale_or_original(\n        self, binsize: int\n    ) -&gt; ip.ImgArray | ip.LazyImgArray:\n        \"\"\"Get multiscaled image of given binsize but use original one if needed.\"\"\"\n        if binsize &gt; 1:\n            out = self.get_multiscale(binsize)\n        else:\n            try:\n                out = self.get_multiscale(1)\n            except ValueError:\n                out = self.image\n        return out\n\n    def multiscale_translation(self, binsize: float) -&gt; nm:\n        \"\"\"Get lateral translation of binned image in nm.\"\"\"\n        return (binsize - 1) / 2 * self.scale\n\n    def invert(self, cache: bool = False) -&gt; Self:\n        \"\"\"Invert tomogram intensities **in-place**.\"\"\"\n        img_inv = -self.image\n        if cache:\n            img_inv.release()\n        self._set_image(img_inv)\n        self.metadata[\"is_inverted\"] = True\n        for i, (_b, _img) in enumerate(self._multiscaled):\n            self._multiscaled[i] = (_b, -_img)\n        return self\n\n    def get_subtomogram_loader(\n        self,\n        mole: Molecules,\n        output_shape: tuple[nm, nm, nm] | None = None,\n        binsize: int = 1,\n        order: int = 1,\n    ) -&gt; SubtomogramLoader:\n        \"\"\"Create a subtomogram loader from molecules.\"\"\"\n        from acryo import SubtomogramLoader\n\n        if binsize == 1:\n            try:\n                img = self.get_multiscale(1)\n            except ValueError:\n                img = self.image\n        else:\n            tr = -self.multiscale_translation(binsize)\n            mole = mole.translate([tr, tr, tr])\n            img = self.get_multiscale(binsize)\n\n        kwargs = {\n            \"order\": order,\n            \"scale\": self.scale * binsize,\n            \"tilt_model\": self.tilt_model,\n        }\n        if output_shape is not None:\n            kwargs[\"output_shape\"] = tuple(self.nm2pixel(output_shape, binsize=binsize))\n        return SubtomogramLoader(img.value, mole, **kwargs)\n</code></pre>"},{"location":"api/components/#cylindra.components.tomogram.Tomogram.image","title":"<code>image</code>  <code>property</code>","text":"<p>Tomogram image data.</p>"},{"location":"api/components/#cylindra.components.tomogram.Tomogram.is_dummy","title":"<code>is_dummy</code>  <code>property</code>","text":"<p>True if this tomogram object does not have a real image.</p>"},{"location":"api/components/#cylindra.components.tomogram.Tomogram.is_inverted","title":"<code>is_inverted</code>  <code>property</code>","text":"<p>True if this image is inverted</p>"},{"location":"api/components/#cylindra.components.tomogram.Tomogram.metadata","title":"<code>metadata</code>  <code>property</code> <code>writable</code>","text":"<p>Metadata relevant to the tomogram.</p>"},{"location":"api/components/#cylindra.components.tomogram.Tomogram.multiscaled","title":"<code>multiscaled</code>  <code>property</code>","text":"<p>Get all multi-scale factor and the corresponding multiscaled images.</p>"},{"location":"api/components/#cylindra.components.tomogram.Tomogram.origin","title":"<code>origin</code>  <code>property</code>","text":"<p>Origin of the tomogram in nm.</p>"},{"location":"api/components/#cylindra.components.tomogram.Tomogram.scale","title":"<code>scale</code>  <code>property</code>","text":"<p>Scale (nm/pixel) of the tomogram.</p>"},{"location":"api/components/#cylindra.components.tomogram.Tomogram.source","title":"<code>source</code>  <code>property</code>","text":"<p>Path to the source file.</p>"},{"location":"api/components/#cylindra.components.tomogram.Tomogram.tilt","title":"<code>tilt</code>  <code>property</code>","text":"<p>Tilt model as a dictionary.</p>"},{"location":"api/components/#cylindra.components.tomogram.Tomogram.tilt_model","title":"<code>tilt_model</code>  <code>property</code>","text":"<p>Tilt model of the tomogram.</p>"},{"location":"api/components/#cylindra.components.tomogram.Tomogram.__hash__","title":"<code>__hash__()</code>","text":"<p>Use unsafe hash.</p> Source code in <code>cylindra/components/tomogram/_tomo_base.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Use unsafe hash.\"\"\"\n    return id(self)\n</code></pre>"},{"location":"api/components/#cylindra.components.tomogram.Tomogram.add_multiscale","title":"<code>add_multiscale(binsize, compute=True)</code>","text":"<p>Add new multiscaled image of given binsize.</p> Source code in <code>cylindra/components/tomogram/_tomo_base.py</code> <pre><code>def add_multiscale(self, binsize: int, compute: bool = True) -&gt; ip.ImgArray:\n    \"\"\"Add new multiscaled image of given binsize.\"\"\"\n    # iterate from the larger bin size\n    for _b, _img in reversed(self._multiscaled):\n        if binsize == _b:\n            warnings.warn(\n                f\"Binsize {binsize} already exists in multiscale images. \"\n                \"Skip binning process.\",\n                UserWarning,\n                stacklevel=2,\n            )\n            return _img\n        if binsize % _b == 0:\n            imgb = _img.binning(binsize // _b, check_edges=False)\n            break\n    else:\n        imgb = self.image.binning(binsize, check_edges=False)\n        if isinstance(imgb, ip.LazyImgArray) and compute:\n            imgb = imgb.compute()\n    self._multiscaled.append((binsize, imgb))\n    self._multiscaled.sort(key=lambda x: x[0])\n    return imgb\n</code></pre>"},{"location":"api/components/#cylindra.components.tomogram.Tomogram.dummy","title":"<code>dummy(*, scale=1.0, tilt=None, binsize=(), source=None, shape=(24, 24, 24), name=None)</code>  <code>classmethod</code>","text":"<p>Create a dummy tomogram.</p> Source code in <code>cylindra/components/tomogram/_tomo_base.py</code> <pre><code>@classmethod\ndef dummy(\n    cls,\n    *,\n    scale: float = 1.0,\n    tilt: tuple[float, float] | None = None,\n    binsize: int | Iterable[int] = (),\n    source: str | None = None,\n    shape: tuple[int, int, int] = (24, 24, 24),\n    name: str | None = None,\n) -&gt; Self:\n    \"\"\"Create a dummy tomogram.\"\"\"\n    dummy = ip.zeros(shape, name=name, dtype=np.float32, axes=\"zyx\")\n    dummy.source = source\n    tomo = cls.from_image(\n        dummy,\n        scale=scale,\n        tilt=tilt,\n        binsize=binsize,\n    )\n    tomo.metadata = {\"is_dummy\": True}\n    return tomo\n</code></pre>"},{"location":"api/components/#cylindra.components.tomogram.Tomogram.from_image","title":"<code>from_image(img, *, scale=None, tilt=None, binsize=(), compute=True)</code>  <code>classmethod</code>","text":"<p>Construct a Tomogram object from a image array.</p> <p>Parameters:</p> Name Type Description Default <code>img</code> <code>array - like</code> <p>Input image.</p> required <code>scale</code> <code>float</code> <p>Pixel size in nm. If not given, will try to read from image header.</p> <code>None</code> <code>tilt</code> <code>tuple of float</code> <p>Tilt model.</p> <code>None</code> <code>binsize</code> <code>int or iterable of int</code> <p>Binsize to generate multiscale images. If not given, will not generate.</p> <code>()</code> <code>compute</code> <code>bool</code> <p>Whether to compute the binned images.</p> <code>True</code> <p>Returns:</p> Type Description <code>Tomogram</code> <p>Tomogram object with the image that has just been read and multi-scales.</p> Source code in <code>cylindra/components/tomogram/_tomo_base.py</code> <pre><code>@classmethod\ndef from_image(\n    cls,\n    img: ip.ImgArray | ip.LazyImgArray,\n    *,\n    scale: float | None = None,\n    tilt: TiltSeriesModel | dict[str, Any] | None = None,\n    binsize: int | Iterable[int] = (),\n    compute: bool = True,\n):\n    \"\"\"Construct a Tomogram object from a image array.\n\n    Parameters\n    ----------\n    img : array-like\n        Input image.\n    scale : float, optional\n        Pixel size in nm. If not given, will try to read from image header.\n    tilt : tuple of float, optional\n        Tilt model.\n    binsize : int or iterable of int, optional\n        Binsize to generate multiscale images. If not given, will not generate.\n    compute : bool, default True\n        Whether to compute the binned images.\n\n    Returns\n    -------\n    Tomogram\n        Tomogram object with the image that has just been read and multi-scales.\n    \"\"\"\n    self = cls()\n    if type(img) is np.ndarray:\n        img = ip.asarray(img, axes=\"zyx\")\n\n    if scale is not None:\n        img.set_scale(xyz=scale)\n    else:\n        if (\n            abs(img.scale.z - img.scale.x) &gt; 1e-3\n            or abs(img.scale.z - img.scale.y) &gt; 1e-3\n        ):\n            raise ValueError(f\"Uneven scale: {img.scale}.\")\n\n    self._set_image(img)\n    if source := img.source:\n        self._metadata[\"source\"] = source.resolve()\n    self._metadata[\"scale\"] = scale\n    self._tilt_model = parse_tilt_model(tilt)\n\n    if isinstance(binsize, int):\n        binsize = [binsize]\n    for b in sorted(binsize):\n        self.add_multiscale(b, compute=compute)\n    return self\n</code></pre>"},{"location":"api/components/#cylindra.components.tomogram.Tomogram.get_multiscale","title":"<code>get_multiscale(binsize, add=False)</code>","text":"<p>Get multiscaled image of given binsize.</p> Source code in <code>cylindra/components/tomogram/_tomo_base.py</code> <pre><code>def get_multiscale(self, binsize: int, add: bool = False) -&gt; ip.ImgArray:\n    \"\"\"Get multiscaled image of given binsize.\"\"\"\n    for _b, _img in self._multiscaled:\n        if _b == binsize:\n            return _img\n    if add:\n        return self.add_multiscale(binsize)\n    raise ValueError(f\"Multiscale = {binsize} not found.\")\n</code></pre>"},{"location":"api/components/#cylindra.components.tomogram.Tomogram.get_subtomogram_loader","title":"<code>get_subtomogram_loader(mole, output_shape=None, binsize=1, order=1)</code>","text":"<p>Create a subtomogram loader from molecules.</p> Source code in <code>cylindra/components/tomogram/_tomo_base.py</code> <pre><code>def get_subtomogram_loader(\n    self,\n    mole: Molecules,\n    output_shape: tuple[nm, nm, nm] | None = None,\n    binsize: int = 1,\n    order: int = 1,\n) -&gt; SubtomogramLoader:\n    \"\"\"Create a subtomogram loader from molecules.\"\"\"\n    from acryo import SubtomogramLoader\n\n    if binsize == 1:\n        try:\n            img = self.get_multiscale(1)\n        except ValueError:\n            img = self.image\n    else:\n        tr = -self.multiscale_translation(binsize)\n        mole = mole.translate([tr, tr, tr])\n        img = self.get_multiscale(binsize)\n\n    kwargs = {\n        \"order\": order,\n        \"scale\": self.scale * binsize,\n        \"tilt_model\": self.tilt_model,\n    }\n    if output_shape is not None:\n        kwargs[\"output_shape\"] = tuple(self.nm2pixel(output_shape, binsize=binsize))\n    return SubtomogramLoader(img.value, mole, **kwargs)\n</code></pre>"},{"location":"api/components/#cylindra.components.tomogram.Tomogram.imread","title":"<code>imread(path, *, scale=None, tilt=None, binsize=(), eager=False, compute=True)</code>  <code>classmethod</code>","text":"<p>Read a image as a dask array.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>path - like</code> <p>Path to the image file.</p> required <code>scale</code> <code>float</code> <p>Pixel size in nm. If not given, will try to read from image header.</p> <code>None</code> <code>tilt</code> <code>tuple of float</code> <p>Tilt model.</p> <code>None</code> <code>binsize</code> <code>int or iterable of int</code> <p>Binsize to generate multiscale images. If not given, will not generate.</p> <code>()</code> <code>eager</code> <code>bool</code> <p>Whether to read the image lazily. If True, the entire image will be read into the memory.</p> <code>False</code> <p>Returns:</p> Type Description <code>Tomogram</code> <p>Tomogram object with the image that has just been read and multi-scales.</p> Source code in <code>cylindra/components/tomogram/_tomo_base.py</code> <pre><code>@classmethod\ndef imread(\n    cls,\n    path: str | Path,\n    *,\n    scale: float = None,\n    tilt: tuple[float, float] | None = None,\n    binsize: int | Iterable[int] = (),\n    eager: bool = False,\n    compute: bool = True,\n) -&gt; Self:\n    \"\"\"Read a image as a dask array.\n\n    Parameters\n    ----------\n    path : path-like\n        Path to the image file.\n    scale : float, optional\n        Pixel size in nm. If not given, will try to read from image header.\n    tilt : tuple of float, optional\n        Tilt model.\n    binsize : int or iterable of int, optional\n        Binsize to generate multiscale images. If not given, will not generate.\n    eager : bool, default False\n        Whether to read the image lazily. If True, the entire image will be read\n        into the memory.\n\n    Returns\n    -------\n    Tomogram\n        Tomogram object with the image that has just been read and multi-scales.\n    \"\"\"\n    chunks = get_config().dask_chunk\n    img = ip.lazy.imread(path, chunks=chunks)\n    if eager:\n        img = img.compute()\n    return cls.from_image(\n        _norm_dtype(img),\n        scale=scale,\n        tilt=tilt,\n        binsize=binsize,\n        compute=compute,\n    )\n</code></pre>"},{"location":"api/components/#cylindra.components.tomogram.Tomogram.invert","title":"<code>invert(cache=False)</code>","text":"<p>Invert tomogram intensities in-place.</p> Source code in <code>cylindra/components/tomogram/_tomo_base.py</code> <pre><code>def invert(self, cache: bool = False) -&gt; Self:\n    \"\"\"Invert tomogram intensities **in-place**.\"\"\"\n    img_inv = -self.image\n    if cache:\n        img_inv.release()\n    self._set_image(img_inv)\n    self.metadata[\"is_inverted\"] = True\n    for i, (_b, _img) in enumerate(self._multiscaled):\n        self._multiscaled[i] = (_b, -_img)\n    return self\n</code></pre>"},{"location":"api/components/#cylindra.components.tomogram.Tomogram.multiscale_translation","title":"<code>multiscale_translation(binsize)</code>","text":"<p>Get lateral translation of binned image in nm.</p> Source code in <code>cylindra/components/tomogram/_tomo_base.py</code> <pre><code>def multiscale_translation(self, binsize: float) -&gt; nm:\n    \"\"\"Get lateral translation of binned image in nm.\"\"\"\n    return (binsize - 1) / 2 * self.scale\n</code></pre>"},{"location":"api/components/#cylindra.components.tomogram.Tomogram.nm2pixel","title":"<code>nm2pixel(value, binsize=1)</code>","text":"<pre><code>nm2pixel(value: nm, binsize: float = 1) -&gt; int\n</code></pre><pre><code>nm2pixel(value: Iterable[nm] | NDArray[np.number], binsize: float = 1) -&gt; NDArray[np.intp]\n</code></pre> <p>Convert nm float value into pixel value. Useful for conversion from coordinate to pixel position.</p> <p>Returns:</p> Type Description <code>ndarray or int</code> <p>Pixel position.</p> Source code in <code>cylindra/components/tomogram/_tomo_base.py</code> <pre><code>def nm2pixel(self, value, binsize: float = 1):\n    \"\"\"Convert nm float value into pixel value. Useful for conversion from\n    coordinate to pixel position.\n\n    Returns\n    -------\n    np.ndarray or int\n        Pixel position.\n    \"\"\"\n    pix = np.round(np.asarray(value) / self.scale / binsize).astype(np.int16)\n    if np.isscalar(value):\n        pix = int(pix)\n    return pix\n</code></pre>"},{"location":"api/components/#cylindra.components.tomogram.Tomogram.with_cache_info","title":"<code>with_cache_info(orig_path, cached=False)</code>","text":"<p>Set cache path.</p> Source code in <code>cylindra/components/tomogram/_tomo_base.py</code> <pre><code>def with_cache_info(self, orig_path: Path, cached: bool = False) -&gt; Self:\n    \"\"\"Set cache path.\"\"\"\n    orig_path = Path(orig_path)\n    self.metadata[\"orig_path\"] = orig_path\n    self.metadata[\"cache_image\"] = cached\n    self._image.name = orig_path.name\n    for _, img in self._multiscaled:\n        img.name = orig_path.name\n    return self\n</code></pre>"},{"location":"api/components/#cylindra.components._base.BaseComponent","title":"<code>BaseComponent</code>","text":"<p>Base class for all tomographic components.</p> Source code in <code>cylindra/components/_base.py</code> <pre><code>class BaseComponent(ABC):\n    \"\"\"Base class for all tomographic components.\"\"\"\n\n    @classmethod\n    @abstractmethod\n    def from_dict(cls, js: dict[str, Any]) -&gt; Self:\n        \"\"\"Construct a component from a dictionary.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def to_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Convert a component to a dictionary.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def rescale(self, factor: float) -&gt; Self:\n        \"\"\"Rescale the component by the factor.\"\"\"\n        raise NotImplementedError\n\n    def to_json(self, file_path: str | Path | io.IOBase, *, cls=None) -&gt; None:\n        \"\"\"\n        Save the model in a json format.\n\n        Parameters\n        ----------\n        file_path : str\n            Path to the file.\n        cls : JSONEncoder, optional\n            Custom JSON encoder, by default None\n        \"\"\"\n        if isinstance(file_path, io.IOBase):\n            return self._dump(file_path, cls)\n        with open(str(file_path).strip(\"'\").strip('\"'), mode=\"w\") as f:\n            self._dump(f, cls)\n        return None\n\n    def _dump(self, f: io.IOBase, cls) -&gt; None:\n        \"\"\"Dump the project to a file.\"\"\"\n        return json.dump(self.to_dict(), f, indent=4, separators=(\",\", \": \"), cls=cls)\n\n    @classmethod\n    def from_json(cls, file_path: str | Path | io.IOBase) -&gt; Self:\n        \"\"\"\n        Construct a spline model from a json file.\n\n        Parameters\n        ----------\n        file_path : str\n            Path to json file.\n\n        Returns\n        -------\n        BaseComponent\n            Object constructed from the json file.\n        \"\"\"\n        if isinstance(file_path, io.IOBase):\n            return cls.from_dict(json.load(file_path))\n        with open(str(file_path).strip(\"'\").strip('\"')) as f:\n            js = json.load(f)\n        return cls.from_dict(js)\n</code></pre>"},{"location":"api/components/#cylindra.components._base.BaseComponent.from_dict","title":"<code>from_dict(js)</code>  <code>abstractmethod</code> <code>classmethod</code>","text":"<p>Construct a component from a dictionary.</p> Source code in <code>cylindra/components/_base.py</code> <pre><code>@classmethod\n@abstractmethod\ndef from_dict(cls, js: dict[str, Any]) -&gt; Self:\n    \"\"\"Construct a component from a dictionary.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api/components/#cylindra.components._base.BaseComponent.from_json","title":"<code>from_json(file_path)</code>  <code>classmethod</code>","text":"<p>Construct a spline model from a json file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>Path to json file.</p> required <p>Returns:</p> Type Description <code>BaseComponent</code> <p>Object constructed from the json file.</p> Source code in <code>cylindra/components/_base.py</code> <pre><code>@classmethod\ndef from_json(cls, file_path: str | Path | io.IOBase) -&gt; Self:\n    \"\"\"\n    Construct a spline model from a json file.\n\n    Parameters\n    ----------\n    file_path : str\n        Path to json file.\n\n    Returns\n    -------\n    BaseComponent\n        Object constructed from the json file.\n    \"\"\"\n    if isinstance(file_path, io.IOBase):\n        return cls.from_dict(json.load(file_path))\n    with open(str(file_path).strip(\"'\").strip('\"')) as f:\n        js = json.load(f)\n    return cls.from_dict(js)\n</code></pre>"},{"location":"api/components/#cylindra.components._base.BaseComponent.rescale","title":"<code>rescale(factor)</code>  <code>abstractmethod</code>","text":"<p>Rescale the component by the factor.</p> Source code in <code>cylindra/components/_base.py</code> <pre><code>@abstractmethod\ndef rescale(self, factor: float) -&gt; Self:\n    \"\"\"Rescale the component by the factor.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api/components/#cylindra.components._base.BaseComponent.to_dict","title":"<code>to_dict()</code>  <code>abstractmethod</code>","text":"<p>Convert a component to a dictionary.</p> Source code in <code>cylindra/components/_base.py</code> <pre><code>@abstractmethod\ndef to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Convert a component to a dictionary.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api/components/#cylindra.components._base.BaseComponent.to_json","title":"<code>to_json(file_path, *, cls=None)</code>","text":"<p>Save the model in a json format.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>Path to the file.</p> required <code>cls</code> <code>JSONEncoder</code> <p>Custom JSON encoder, by default None</p> <code>None</code> Source code in <code>cylindra/components/_base.py</code> <pre><code>def to_json(self, file_path: str | Path | io.IOBase, *, cls=None) -&gt; None:\n    \"\"\"\n    Save the model in a json format.\n\n    Parameters\n    ----------\n    file_path : str\n        Path to the file.\n    cls : JSONEncoder, optional\n        Custom JSON encoder, by default None\n    \"\"\"\n    if isinstance(file_path, io.IOBase):\n        return self._dump(file_path, cls)\n    with open(str(file_path).strip(\"'\").strip('\"'), mode=\"w\") as f:\n        self._dump(f, cls)\n    return None\n</code></pre>"},{"location":"api/components/#cylindra.components.landscape.AnnealingResult","title":"<code>AnnealingResult</code>  <code>dataclass</code>","text":"<p>Dataclass for storing the annealing results.</p> <p>Parameters:</p> Name Type Description Default <code>energies</code> <code>ndarray</code> <p>History of energies of the annealing process.</p> required <code>batch_size</code> <code>int</code> <p>Batch size used in the annealing process.</p> required <code>time_const</code> <code>float</code> <p>Time constant used for cooling.</p> required <code>indices</code> <code>ndarray</code> <p>The optimized indices of the molecules.</p> required <code>niter</code> <code>int</code> <p>Number of iterations.</p> required <code>state</code> <code>str</code> <p>Optimization state.</p> required Source code in <code>cylindra/components/landscape.py</code> <pre><code>@dataclass\nclass AnnealingResult:\n    \"\"\"Dataclass for storing the annealing results.\n\n    Parameters\n    ----------\n    energies : np.ndarray\n        History of energies of the annealing process.\n    batch_size : int\n        Batch size used in the annealing process.\n    time_const : float\n        Time constant used for cooling.\n    indices : np.ndarray\n        The optimized indices of the molecules.\n    niter : int\n        Number of iterations.\n    state : str\n        Optimization state.\n    \"\"\"\n\n    energies: NDArray[np.float32]\n    batch_size: int\n    time_const: float\n    indices: NDArray[np.int32]\n    niter: int\n    state: str\n</code></pre>"},{"location":"api/components/#cylindra.components.landscape.Landscape","title":"<code>Landscape</code>  <code>dataclass</code>","text":"<p>Energy landscape array.</p> <p>Parameters:</p> Name Type Description Default <code>energies</code> <code>NDArray[float32]</code> <p>4D array of energy values.</p> required <code>molecules</code> <code>Molecules</code> <p>Molecules object.</p> required <code>argmax</code> <code>NDArray[int32]</code> <p>Argmax indices to track which rotation resulted in the best alignment.</p> required <code>quaternions</code> <code>NDArray[float32]</code> <p>Quaternions used for template rotation.</p> required <code>num_templates</code> <code>NDArray[int32]</code> <p>Number of templates used.</p> <code>1</code> <code>scale_factor</code> <code>float</code> <p>Scale factor to convert from pixels to nanometers (upsampling considered). <code>scale / upsample_factor</code> will be passed to this parameter from the GUI.</p> required Source code in <code>cylindra/components/landscape.py</code> <pre><code>@dataclass\nclass Landscape:\n    \"\"\"Energy landscape array.\n\n    Parameters\n    ----------\n    energies : NDArray[np.float32]\n        4D array of energy values.\n    molecules : Molecules\n        Molecules object.\n    argmax : NDArray[np.int32], optional\n        Argmax indices to track which rotation resulted in the best alignment.\n    quaternions : NDArray[np.float32]\n        Quaternions used for template rotation.\n    num_templates : NDArray[np.int32]\n        Number of templates used.\n    scale_factor : float\n        Scale factor to convert from pixels to nanometers (upsampling considered).\n        `scale / upsample_factor` will be passed to this parameter from the GUI.\n    \"\"\"\n\n    energies: NDArray[np.float32]\n    molecules: Molecules\n    argmax: NDArray[np.int32] | None\n    quaternions: NDArray[np.float32]\n    scale_factor: float\n    num_templates: int = 1\n\n    def __getitem__(\n        self, key: slice | list[SupportsIndex] | NDArray[np.integer]\n    ) -&gt; Landscape:\n        \"\"\"Subset of the landscape.\"\"\"\n        if not isinstance(key, (slice, list, np.ndarray)):\n            raise TypeError(f\"Invalid type of key: {type(key)}\")\n        energy = self.energies[key]\n        mole = self.molecules.subset(key)\n        argmax = self.argmax[key] if self.argmax is not None else None\n        return Landscape(\n            energies=energy,\n            molecules=mole,\n            argmax=argmax,\n            quaternions=self.quaternions,\n            scale_factor=self.scale_factor,\n            num_templates=self.num_templates,\n        )\n\n    def __repr__(self) -&gt; str:\n        eng_repr = f\"&lt;{self.energies.shape!r} array&gt;\"\n        mole_repr = f\"&lt;{self.molecules.count()} molecules&gt;\"\n        argmax_repr = (\n            f\"&lt;{self.argmax.shape!r} array&gt;\" if self.argmax is not None else None\n        )\n        return (\n            f\"Landscape(energies={eng_repr}, molecules={mole_repr}, \"\n            f\"argmax={argmax_repr}, quaternion={self.quaternions!r}, \"\n            f\"scale_factor={self.scale_factor:.3g}, num_templates={self.num_templates})\"\n        )\n\n    @property\n    def offset(self) -&gt; NDArray[np.int32]:\n        \"\"\"Shift from the corner (0, 0, 0) to the center.\"\"\"\n        shift = (np.array(self.energies.shape[1:], dtype=np.float32) - 1) / 2\n        return shift.astype(np.int32)\n\n    @property\n    def offset_nm(self) -&gt; NDArray[np.float32]:\n        \"\"\"Offset in nm.\"\"\"\n        return self.offset * self.scale_factor\n\n    @classmethod\n    def from_loader(\n        cls,\n        loader: LoaderBase,\n        template: TemplateInputType,\n        mask: MaskInputType = None,\n        max_shifts: tuple[nm, nm, nm] = (0.8, 0.8, 0.8),\n        upsample_factor: int = 5,\n        alignment_model: alignment.TomographyInput = alignment.ZNCCAlignment,\n    ) -&gt; Landscape:\n        \"\"\"Construct a landscape from a loader object.\n\n        Parameters\n        ----------\n        loader : LoaderBase\n            Any loader object from ``acryo``.\n        template : template input type\n            Template image or a list of template images to be used.\n        mask : mask input type, optional\n            Mask image to be used, by default None\n        max_shifts : (float, float, float), optional\n            Maximum shifts in nm, in (Z, Y, X) order.\n        upsample_factor : int\n            Upsampling factor for landscape construction.\n        alignment_model : alignment model object\n            Alignment model to be used to evaluate correlation score.\n        \"\"\"\n        if isinstance(template, (str, Path)):\n            template = pipe.from_file(template)\n            num_templates = 1\n        elif isinstance(template, (list, tuple)):\n            if all(isinstance(t, (str, Path)) for t in template):\n                num_templates = len(template)\n                template = pipe.from_files(template)\n            else:\n                template = list(template)\n                num_templates = len(template)\n        elif isinstance(template, np.ndarray):\n            if template.ndim == 4:\n                num_templates = template.shape[0]\n            else:\n                num_templates = 1\n        else:\n            raise TypeError(f\"Invalid type of template: {type(template)}\")\n\n        _Logger.print(f\"Using {num_templates} template(s) for landscape construction.\")\n        _Logger.print(f\"Landscape resolution: {loader.scale / upsample_factor:.3f} nm\")\n\n        score_dsk = loader.construct_landscape(\n            template,\n            mask=mask,\n            max_shifts=max_shifts,\n            upsample=upsample_factor,\n            alignment_model=alignment_model,\n        )\n        score, argmax = _calc_landscape(\n            alignment_model, score_dsk, multi_templates=num_templates &gt; 1\n        )\n        mole = loader.molecules\n        to_drop = set(mole.features.columns) - {Mole.nth, Mole.pf, Mole.position}\n        if to_drop:\n            mole = mole.drop_features(*to_drop)\n        return cls(\n            energies=-np.ascontiguousarray(score),\n            molecules=mole,\n            argmax=argmax,\n            quaternions=alignment_model.quaternions,\n            scale_factor=loader.scale / upsample_factor,\n            num_templates=num_templates,\n        )\n\n    def transform_molecules(\n        self,\n        molecules: Molecules,\n        indices: NDArray[np.int32],\n        detect_peak: bool = False,\n    ) -&gt; Molecules:\n        \"\"\"Transform the input molecules based on the landscape.\n\n        Parameters\n        ----------\n        molecules : Molecules\n            Molecules object to be transformed.\n        indices : integer array\n            Indices in the landscape to be used for transformation.\n        detect_peak : bool, default False\n            If True, landscape will be sub-sampled to detect the peak in higher\n            precision. This should be false for constrained alignment, as the detected\n            peak usually does not represent the optimal result.\n\n        Returns\n        -------\n        Molecules\n            Transformed molecules.\n        \"\"\"\n        offset = self.offset\n        indices_sub = indices.astype(np.float32)\n        nmole = self.energies.shape[0]\n        opt_energy = np.zeros(nmole, dtype=np.float32)\n        nrepeat = 3 if detect_peak else 0\n        for i in range(nmole):\n            eng = self.energies[i]\n            indices_sub[i], opt_energy[i] = find_peak(eng, indices[i], nrepeat=nrepeat)\n        opt_score = -opt_energy\n        shifts = ((indices_sub - offset) * self.scale_factor).astype(np.float32)\n        molecules_opt = molecules.translate_internal(shifts)\n        dr_feat = _as_n_series(\"align-d{}\", shifts)\n        if (nrots := self.quaternions.shape[0]) &gt; 1:\n            quats = np.stack(\n                [\n                    self.quaternions[self.argmax[(i, *ind)] % nrots]\n                    for i, ind in enumerate(indices)\n                ],\n                axis=0,\n            )\n            rotator = Rotation.from_quat(quats).inv()\n            molecules_opt = molecules_opt.rotate_by(rotator)\n            rotvec = rotator.as_rotvec().astype(np.float32)\n            rotvec_feat = _as_n_series(\"align-d{}rot\", rotvec)\n            molecules_opt = molecules_opt.with_features(*rotvec_feat)\n        if self.num_templates &gt; 1:\n            template_id = np.stack(\n                [self.argmax[(i, *ind)] // nrots for i, ind in enumerate(indices)]\n            )\n            molecules_opt = molecules_opt.with_features(\n                pl.Series(Mole.template, template_id)\n            )\n        return molecules_opt.with_features(*dr_feat, pl.Series(Mole.score, opt_score))\n\n    def run_min_energy(\n        self, spl: CylSpline | None = None\n    ) -&gt; tuple[Molecules, MinEnergyResult]:\n        \"\"\"Minimize energy for each local landscape independently.\"\"\"\n        shape = self.energies.shape[1:]\n        indices = list[NDArray[np.int32]]()\n        engs = list[float]()\n        for i in range(self.energies.shape[0]):\n            eng = self.energies[i]\n            pos = np.unravel_index(np.argmin(eng), shape)\n            indices.append(np.array(pos, dtype=np.int32))\n            engs.append(eng[pos])\n        indices = np.stack(indices, axis=0)\n        engs = np.array(engs, dtype=np.float32)\n        result = MinEnergyResult(indices, engs)\n\n        mole_opt = self.transform_molecules(\n            self.molecules, result.indices, detect_peak=True\n        )\n        if spl is not None:\n            mole_opt = _update_mole_pos(mole_opt, self.molecules, spl)\n        return mole_opt, result\n\n    def run_viterbi(\n        self, dist_range: tuple[_DistLike, _DistLike], angle_max: float | None = None\n    ):\n        \"\"\"Run Viterbi alignment.\"\"\"\n        dist_min, dist_max = self._norm_dist(dist_range)\n        if angle_max is not None:\n            angle_max = np.deg2rad(angle_max)\n        grid = self._prep_viterbi_grid()\n        return ViterbiResult(*grid.viterbi(dist_min, dist_max, angle_max))\n\n    def run_viterbi_along_spline(\n        self,\n        spl: CylSpline | None,\n        range_long: tuple[nm, nm] = (4.0, 4.28),\n        angle_max: float | None = 5.0,\n    ):\n        mole = self.molecules\n        if Mole.pf in mole.features.columns:\n            npfs: Sequence[int] = mole.features[Mole.pf].unique(maintain_order=True)\n            slices = [(mole.features[Mole.pf] == i).to_numpy() for i in npfs]\n            viterbi_tasks = [\n                delayed(self[sl].run_viterbi)(range_long, angle_max) for sl in slices\n            ]\n        else:\n            slices = [slice(None)]\n            viterbi_tasks = [delayed(self.run_viterbi)(range_long, angle_max)]\n        _Logger.info(\"Running Viterbi alignment\")\n        _Logger.info(f\"  shape: {self.energies.shape[1:]!r}\")\n        _Logger.info(f\"  tasks: {len(viterbi_tasks)}\")\n        vit_out = compute(*viterbi_tasks)\n\n        inds = np.empty((mole.count(), 3), dtype=np.int32)\n        max_shifts_px = (np.array(self.energies.shape[1:]) - 1) // 2\n        for i, result in enumerate(vit_out):\n            inds[slices[i], :] = _check_viterbi_shift(result.indices, max_shifts_px, i)\n        molecules_opt = self.transform_molecules(mole, inds)\n        if spl is not None:\n            molecules_opt = _update_mole_pos(molecules_opt, mole, spl)\n        return molecules_opt\n\n    def run_viterbi_fixed_start(\n        self,\n        first: NDArray[np.float32],\n        range_long: tuple[_DistLike, _DistLike] = (4.0, 4.28),\n        angle_max: float | None = 5.0,\n    ):\n        \"\"\"Run Viterbi alignment with a fixed start edge.\"\"\"\n        mole = self.molecules\n        dist_min, dist_max = self._norm_dist(range_long)\n        if angle_max is not None:\n            angle_max = np.deg2rad(angle_max)\n        grid = self._prep_viterbi_grid()\n        mole0 = Molecules(first, mole.rotator[:1]).translate_internal(-self.offset_nm)\n        origin = (mole0.pos[0] / self.scale_factor).astype(np.float32)\n        res = ViterbiResult(\n            *grid.viterbi_fixed_start(\n                dist_min, dist_max, first / self.scale_factor, origin, angle_max\n            )\n        )\n        max_shifts_px = (np.array(self.energies.shape[1:]) - 1) // 2\n        inds = _check_viterbi_shift(res.indices, max_shifts_px, 0)\n        molecules_opt = self.transform_molecules(mole, inds)\n        return molecules_opt\n\n    def _prep_annealing_model(\n        self,\n        cls: type[_ANN],\n        spl: CylSpline,\n        distance_range_long: tuple[_DistLike, _DistLike],\n        distance_range_lat: tuple[_DistLike, _DistLike],\n        angle_max: float | None = None,\n        temperature_time_const: float = 1.0,\n        temperature: float | None = None,\n        cooling_rate: float | None = None,\n        reject_limit: int | None = None,\n    ) -&gt; _ANN:\n        cyl = spl.cylinder_model()\n        _nrise, _npf = cyl.nrise, cyl.shape[1]\n        molecules = self.molecules\n        mole = molecules.translate_internal(-self.offset_nm)\n        if angle_max is None:\n            angle_max = 90.0\n\n        time_const, temperature, cooling_rate, reject_limit = self._normalize_args(\n            temperature_time_const, temperature, cooling_rate, reject_limit\n        )\n        ind = molecules.features.select([Mole.nth, Mole.pf]).to_numpy().astype(np.int32)\n        ind[:, 0] -= ind[:, 0].min()\n        ind[:, 1] -= ind[:, 1].min()\n        model = cls().construct_graph(indices=ind, npf=_npf, nrise=_nrise)\n        return (\n            model.set_graph_coordinates(\n                origin=mole.pos,\n                zvec=(mole.z * self.scale_factor).astype(np.float32),\n                yvec=(mole.y * self.scale_factor).astype(np.float32),\n                xvec=(mole.x * self.scale_factor).astype(np.float32),\n            )\n            .set_energy_landscape(self.energies)\n            .set_reservoir(\n                temperature=temperature,\n                time_constant=time_const,\n            )\n            .set_box_potential(\n                *self._norm_distance_range_long(distance_range_long, model),\n                *self._norm_distance_range_lat(distance_range_lat, model),\n                float(np.deg2rad(angle_max)),\n                cooling_rate=cooling_rate,\n            )\n            .with_reject_limit(reject_limit)\n        )\n\n    def filamentous_annealing_model(\n        self,\n        distance_range: tuple[_DistLike, _DistLike],\n        angle_max: float | None = None,\n        temperature_time_const: float = 1.0,\n        temperature: float | None = None,\n        cooling_rate: float | None = None,\n        reject_limit: int | None = None,\n    ) -&gt; FilamentousAnnealingModel:\n        from cylindra._cylindra_ext import FilamentousAnnealingModel\n\n        molecules = self.molecules\n        if molecules.count() &lt; 3:\n            raise ValueError(\"At least 3 molecules are required for RFA.\")\n        mole = molecules.translate_internal(-self.offset_nm)\n        if angle_max is None:\n            angle_max = 90.0\n\n        time_const, temperature, cooling_rate, reject_limit = self._normalize_args(\n            temperature_time_const, temperature, cooling_rate, reject_limit\n        )\n\n        model = FilamentousAnnealingModel().construct_graph(mole.count())\n\n        return (\n            model.set_graph_coordinates(\n                origin=mole.pos,\n                zvec=(mole.z * self.scale_factor).astype(np.float32),\n                yvec=(mole.y * self.scale_factor).astype(np.float32),\n                xvec=(mole.x * self.scale_factor).astype(np.float32),\n            )\n            .set_energy_landscape(self.energies)\n            .set_reservoir(\n                temperature=temperature,\n                time_constant=time_const,\n            )\n            .set_box_potential(\n                *self._norm_distance_range_long(distance_range, model),\n                float(np.deg2rad(angle_max)),\n                cooling_rate=cooling_rate,\n            )\n            .with_reject_limit(reject_limit)\n        )\n\n    def cylindric_annealing_model(\n        self,\n        spl: CylSpline,\n        distance_range_long: tuple[_DistLike, _DistLike],\n        distance_range_lat: tuple[_DistLike, _DistLike],\n        angle_max: float | None = None,\n        temperature_time_const: float = 1.0,\n        temperature: float | None = None,\n        cooling_rate: float | None = None,\n        reject_limit: int | None = None,\n    ) -&gt; CylindricAnnealingModel:\n        \"\"\"Get an annealing model using the landscape.\"\"\"\n        from cylindra._cylindra_ext import CylindricAnnealingModel\n\n        return self._prep_annealing_model(\n            CylindricAnnealingModel,\n            spl, distance_range_long, distance_range_lat, angle_max,\n            temperature_time_const, temperature, cooling_rate, reject_limit,\n        )  # fmt: skip\n\n    def run_annealing(\n        self,\n        spl: CylSpline,\n        distance_range_long: tuple[_DistLike, _DistLike],\n        distance_range_lat: tuple[_DistLike, _DistLike],\n        angle_max: float | None = None,\n        temperature_time_const: float = 1.0,\n        temperature: float | None = None,\n        cooling_rate: float | None = None,\n        reject_limit: int | None = None,\n        random_seeds: list[int] = [0],\n    ) -&gt; list[AnnealingResult]:\n        \"\"\"Run simulated mesh annealing.\"\"\"\n\n        if angle_max is None:\n            angle_max = 90.0\n        random_seeds = _normalize_random_seeds(random_seeds)\n        annealing = self.cylindric_annealing_model(\n            spl,\n            distance_range_long=distance_range_long,\n            distance_range_lat=distance_range_lat,\n            angle_max=angle_max,\n            temperature_time_const=temperature_time_const,\n            temperature=temperature,\n            cooling_rate=cooling_rate,\n            reject_limit=reject_limit,\n        )\n\n        batch_size = _to_batch_size(annealing.time_constant())\n        temp0 = annealing.temperature()\n        _Logger.info(\"Running annealing\")\n        _Logger.info(f\"  shape: {self.energies.shape[1:]!r}\")\n        tasks = [\n            _run_annealing(annealing.with_seed(s), batch_size, temp0)\n            for s in random_seeds\n        ]\n        return compute(*tasks)\n\n    def run_annealing_along_spline(\n        self,\n        spl: CylSpline,\n        range_long: tuple[_DistLike, _DistLike],\n        range_lat: tuple[_DistLike, _DistLike],\n        angle_max: float,\n        temperature_time_const: float = 1.0,\n        random_seeds: Sequence[int] = (0, 1, 2, 3, 4),\n    ):\n        results = self.run_annealing(\n            spl,\n            range_long,\n            range_lat,\n            angle_max,\n            temperature_time_const=temperature_time_const,\n            random_seeds=random_seeds,\n        )\n        if all(result.state == \"failed\" for result in results):\n            raise RuntimeError(\n                \"Failed to optimize for all trials. You may check the distance range.\"\n            )\n        elif not any(result.state == \"converged\" for result in results):\n            _Logger.print(\"Optimization did not converge for any trial.\")\n\n        _Logger.print_table(\n            {\n                \"Iteration\": [r.niter for r in results],\n                \"Score\": [f\"{-float(r.energies[-1]):.5g}\" for r in results],\n                \"State\": [r.state for r in results],\n            }\n        )\n        results = sorted(results, key=lambda r: r.energies[-1])\n        mole_opt = self.transform_molecules(self.molecules, results[0].indices)\n        mole_opt = _update_mole_pos(mole_opt, self.molecules, spl)\n        return mole_opt, results\n\n    def run_filamentous_annealing(\n        self,\n        range: tuple[float | str, float | str],\n        angle_max: float | None = None,\n        temperature_time_const: float = 1.0,\n        random_seeds: Sequence[int] = (0, 1, 2, 3, 4),\n    ) -&gt; tuple[Molecules, list[AnnealingResult]]:\n        mole = self.molecules\n        if angle_max is None:\n            angle_max = 90.0\n        random_seeds = _normalize_random_seeds(random_seeds)\n        annealing = self.filamentous_annealing_model(\n            distance_range=range,\n            angle_max=angle_max,\n            temperature_time_const=temperature_time_const,\n        )\n\n        batch_size = _to_batch_size(annealing.time_constant())\n        temp0 = annealing.temperature()\n        _Logger.info(\"Running annealing\")\n        _Logger.info(f\"  shape: {self.energies.shape[1:]!r}\")\n        tasks = [\n            _run_annealing(annealing.with_seed(s), batch_size, temp0)\n            for s in random_seeds\n        ]\n        results = compute(*tasks)\n        if all(result.state == \"failed\" for result in results):\n            raise RuntimeError(\n                \"Failed to optimize for all trials. You may check the distance range.\"\n            )\n        elif not any(result.state == \"converged\" for result in results):\n            _Logger.print(\"Optimization did not converge for any trial.\")\n\n        _Logger.print_table(\n            {\n                \"Iteration\": [r.niter for r in results],\n                \"Score\": [f\"{-float(r.energies[-1]):.5g}\" for r in results],\n                \"State\": [r.state for r in results],\n            }\n        )\n        results = sorted(results, key=lambda r: r.energies[-1])\n        mole_opt = self.transform_molecules(mole, results[0].indices)\n        return mole_opt, results\n\n    def normed(self, sd: bool = True) -&gt; Landscape:\n        \"\"\"Return a landscape with normalized mean energy.\"\"\"\n        each_mean: NDArray[np.float32] = self.energies.mean(axis=(1, 2, 3))\n        all_mean = each_mean.mean()\n        sl = (slice(None), np.newaxis, np.newaxis, np.newaxis)\n        if sd:\n            each_sd: NDArray[np.float32] = self.energies.std(axis=(1, 2, 3))\n            all_sd = each_sd.mean()\n            dif = self.energies - each_mean[sl]\n            new_array = dif * all_sd / each_sd[sl] + all_mean\n        else:\n            new_array = self.energies + all_mean - each_mean[sl]\n        return self.replace_energies(new_array)\n\n    def clip_energies(\n        self,\n        low: float | None = None,\n        high: float | None = None,\n    ) -&gt; Landscape:\n        low = np.float32(low) if low is not None else None\n        high = np.float32(high) if high is not None else None\n        energy = np.clip(self.energies, a_min=low, a_max=high)\n        return self.replace_energies(energy)\n\n    def replace_energies(self, energies: NDArray[np.float32]) -&gt; Landscape:\n        if energies.dtype != self.energies.dtype:\n            raise ValueError(\n                f\"The dtype of energies must be float32, got {energies.dtype}\"\n            )\n        if energies.shape != self.energies.shape:\n            raise ValueError(\n                f\"The shape of energies must be {self.energies.shape}, got \"\n                f\"{energies.shape}\"\n            )\n        return Landscape(\n            energies=energies,\n            molecules=self.molecules,\n            argmax=self.argmax,\n            quaternions=self.quaternions,\n            scale_factor=self.scale_factor,\n            num_templates=self.num_templates,\n        )\n\n    def create_surface(\n        self,\n        level: float | None = None,\n        resolution: nm | None = None,\n        show_min: bool = True,\n    ) -&gt; SurfaceData:\n        \"\"\"Create a isosurface data from the landscape\"\"\"\n        if level is None:\n            level = self.energies.mean()\n        if show_min:\n            intensity = -self.energies\n            level = -level\n        else:\n            intensity = self.energies\n        if resolution is None:\n            resolution = np.min(self.energies.shape[1:]) * self.scale_factor / 4\n\n        step_size = max(int(resolution / self.scale_factor), 1)\n        spacing = (self.scale_factor,) * 3\n        center = np.array(intensity.shape[1:]) / 2 + 0.5\n        offset = center * spacing\n        n_verts = 0\n        tasks = list[Delayed[SurfaceData]]()\n        for i in range(intensity.shape[0]):\n            arr: NDArray[np.float32] = intensity[i]\n            tasks.append(delayed_isosurface(arr, level, spacing, step_size=step_size))\n        surfs = compute(*tasks)\n        for i in range(intensity.shape[0]):\n            mole = self.molecules[i]\n            surf = surfs[i]\n            surf = SurfaceData(\n                mole.rotator.apply(surf.vertices - offset) + mole.pos,\n                surf.faces + n_verts,\n                surf.values,\n            )\n            surfs[i] = surf  # update\n            n_verts += len(surf.vertices)\n        vertices = np.concatenate([s.vertices for s in surfs], axis=0)\n        faces = np.concatenate([s.faces for s in surfs], axis=0)\n        values = np.concatenate([s.values for s in surfs], axis=0)\n        return SurfaceData(vertices, faces, values)\n\n    ### IO ###\n\n    @classmethod\n    def from_dir(cls, path: str | Path) -&gt; Landscape:\n        \"\"\"Load a landscape from a directory.\"\"\"\n        path = Path(path)\n        if path.suffix != \"\":\n            raise ValueError(f\"Must be a directory, got {path}\")\n        energies = ip.imread(path / \"landscape.tif\")\n        molecules = Molecules.from_parquet(path / \"molecules.parquet\")\n        argmax = None\n        if (fp := path / \"argmax.parquet\").exists():\n            argmax = pl.read_parquet(fp).to_series().to_numpy()\n        if (landscape_json_path := path / \"landscape.json\").exists():\n            with landscape_json_path.open() as f:\n                js = json.load(f)\n                quaternions = np.array(js[\"quaternions\"], dtype=np.float32)\n                num_templates = js[\"num_templates\"]\n        elif (quat_path := path / \"quaternions.txt\").exists():\n            quaternions = np.atleast_2d(\n                np.loadtxt(quat_path, delimiter=\",\", dtype=np.float32)\n            )\n            num_templates = 1\n        else:\n            quaternions = np.array([[1, 0, 0, 0]], dtype=np.float32)\n            num_templates = 1\n        scale_factor = energies.scale[\"x\"]\n        return cls(\n            energies=energies.value,\n            molecules=molecules,\n            argmax=argmax,\n            quaternions=quaternions,\n            scale_factor=scale_factor,\n            num_templates=num_templates,\n        )\n\n    def save(self, path: str | Path) -&gt; None:\n        \"\"\"Save the landscape to a directory.\"\"\"\n        path = Path(path)\n        if path.suffix != \"\":\n            raise ValueError(f\"Must be a directory, got {path}\")\n        path.mkdir(exist_ok=False)\n        arr = ip.asarray(self.energies, axes=\"tzyx\").set_scale(\n            xyz=self.scale_factor, unit=\"nm\"\n        )\n        arr.imsave(path / \"landscape.tif\")\n        self.molecules.to_parquet(path / \"molecules.parquet\")\n        if self.argmax is not None:\n            pl.DataFrame({\"argmax\": self.argmax}).write_parquet(\n                path / \"argmax.parquet\", compression_level=10\n            )\n        with open(path / \"landscape.json\", \"w\") as f:\n            js = {\n                \"quaternions\": self.quaternions.tolist(),\n                \"num_templates\": self.num_templates,\n            }\n            json.dump(js, f, indent=2)\n        return None\n\n    def _norm_distance_range_long(\n        self,\n        rng: tuple[nm | str, nm | str],\n        model: CylindricAnnealingModel,\n    ) -&gt; tuple[nm, nm]:\n        rng0, rng1 = rng\n        if isinstance(rng0, str) or isinstance(rng1, str):\n            long_dist_arr = model.longitudinal_distances()\n            if isinstance(rng0, str):\n                rng0 = _norm_distance(rng0, long_dist_arr)\n            if isinstance(rng1, str):\n                rng1 = _norm_distance(rng1, long_dist_arr)\n        if not rng0 &lt; rng1:\n            raise ValueError(f\"Lower is larger than the upper: {(rng0, rng1)}\")\n        return rng0, rng1\n\n    def _norm_distance_range_lat(\n        self,\n        rng: tuple[nm | str, nm | str],\n        model: CylindricAnnealingModel,\n    ) -&gt; tuple[nm, nm]:\n        rng0, rng1 = rng\n        if isinstance(rng0, str) or isinstance(rng1, str):\n            lat_dist_arr = model.lateral_distances()\n            if isinstance(rng0, str):\n                rng0 = _norm_distance(rng0, lat_dist_arr)\n            if isinstance(rng1, str):\n                rng1 = _norm_distance(rng1, lat_dist_arr)\n        if not rng0 &lt; rng1:\n            raise ValueError(f\"Lower is larger than the upper: {(rng0, rng1)}\")\n        return rng0, rng1\n\n    def _normalize_args(\n        self, temperature_time_const, temperature, cooling_rate, reject_limit\n    ):\n        nmole = self.molecules.count()\n        time_const = nmole * np.prod(self.energies.shape[1:]) * temperature_time_const\n        _energy_std = np.std(self.energies)\n        if temperature is None:\n            temperature = _energy_std * 2\n        if cooling_rate is None:\n            cooling_rate = _energy_std / time_const * 8\n        if reject_limit is None:\n            reject_limit = nmole * 50\n        return time_const, temperature, cooling_rate, reject_limit\n\n    def _norm_dist(self, dist_range: tuple[_DistLike, _DistLike]) -&gt; tuple[nm, nm]:\n        dist_min, dist_max = dist_range\n        # normalize distance limits\n        dist_arr = np.sqrt(np.sum(np.diff(self.molecules.pos, axis=0) ** 2, axis=1))\n        dist_min = _norm_distance(dist_min, dist_arr)\n        dist_max = _norm_distance(dist_max, dist_arr)\n        return dist_min / self.scale_factor, dist_max / self.scale_factor\n\n    def _prep_viterbi_grid(self):\n        from cylindra._cylindra_ext import ViterbiGrid\n\n        mole = self.molecules.translate_internal(-self.offset_nm)\n        origin = (mole.pos / self.scale_factor).astype(np.float32)\n        zvec = mole.z.astype(np.float32)\n        yvec = mole.y.astype(np.float32)\n        xvec = mole.x.astype(np.float32)\n        return ViterbiGrid(-self.energies, origin, zvec, yvec, xvec)\n</code></pre>"},{"location":"api/components/#cylindra.components.landscape.Landscape.offset","title":"<code>offset</code>  <code>property</code>","text":"<p>Shift from the corner (0, 0, 0) to the center.</p>"},{"location":"api/components/#cylindra.components.landscape.Landscape.offset_nm","title":"<code>offset_nm</code>  <code>property</code>","text":"<p>Offset in nm.</p>"},{"location":"api/components/#cylindra.components.landscape.Landscape.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Subset of the landscape.</p> Source code in <code>cylindra/components/landscape.py</code> <pre><code>def __getitem__(\n    self, key: slice | list[SupportsIndex] | NDArray[np.integer]\n) -&gt; Landscape:\n    \"\"\"Subset of the landscape.\"\"\"\n    if not isinstance(key, (slice, list, np.ndarray)):\n        raise TypeError(f\"Invalid type of key: {type(key)}\")\n    energy = self.energies[key]\n    mole = self.molecules.subset(key)\n    argmax = self.argmax[key] if self.argmax is not None else None\n    return Landscape(\n        energies=energy,\n        molecules=mole,\n        argmax=argmax,\n        quaternions=self.quaternions,\n        scale_factor=self.scale_factor,\n        num_templates=self.num_templates,\n    )\n</code></pre>"},{"location":"api/components/#cylindra.components.landscape.Landscape.create_surface","title":"<code>create_surface(level=None, resolution=None, show_min=True)</code>","text":"<p>Create a isosurface data from the landscape</p> Source code in <code>cylindra/components/landscape.py</code> <pre><code>def create_surface(\n    self,\n    level: float | None = None,\n    resolution: nm | None = None,\n    show_min: bool = True,\n) -&gt; SurfaceData:\n    \"\"\"Create a isosurface data from the landscape\"\"\"\n    if level is None:\n        level = self.energies.mean()\n    if show_min:\n        intensity = -self.energies\n        level = -level\n    else:\n        intensity = self.energies\n    if resolution is None:\n        resolution = np.min(self.energies.shape[1:]) * self.scale_factor / 4\n\n    step_size = max(int(resolution / self.scale_factor), 1)\n    spacing = (self.scale_factor,) * 3\n    center = np.array(intensity.shape[1:]) / 2 + 0.5\n    offset = center * spacing\n    n_verts = 0\n    tasks = list[Delayed[SurfaceData]]()\n    for i in range(intensity.shape[0]):\n        arr: NDArray[np.float32] = intensity[i]\n        tasks.append(delayed_isosurface(arr, level, spacing, step_size=step_size))\n    surfs = compute(*tasks)\n    for i in range(intensity.shape[0]):\n        mole = self.molecules[i]\n        surf = surfs[i]\n        surf = SurfaceData(\n            mole.rotator.apply(surf.vertices - offset) + mole.pos,\n            surf.faces + n_verts,\n            surf.values,\n        )\n        surfs[i] = surf  # update\n        n_verts += len(surf.vertices)\n    vertices = np.concatenate([s.vertices for s in surfs], axis=0)\n    faces = np.concatenate([s.faces for s in surfs], axis=0)\n    values = np.concatenate([s.values for s in surfs], axis=0)\n    return SurfaceData(vertices, faces, values)\n</code></pre>"},{"location":"api/components/#cylindra.components.landscape.Landscape.cylindric_annealing_model","title":"<code>cylindric_annealing_model(spl, distance_range_long, distance_range_lat, angle_max=None, temperature_time_const=1.0, temperature=None, cooling_rate=None, reject_limit=None)</code>","text":"<p>Get an annealing model using the landscape.</p> Source code in <code>cylindra/components/landscape.py</code> <pre><code>def cylindric_annealing_model(\n    self,\n    spl: CylSpline,\n    distance_range_long: tuple[_DistLike, _DistLike],\n    distance_range_lat: tuple[_DistLike, _DistLike],\n    angle_max: float | None = None,\n    temperature_time_const: float = 1.0,\n    temperature: float | None = None,\n    cooling_rate: float | None = None,\n    reject_limit: int | None = None,\n) -&gt; CylindricAnnealingModel:\n    \"\"\"Get an annealing model using the landscape.\"\"\"\n    from cylindra._cylindra_ext import CylindricAnnealingModel\n\n    return self._prep_annealing_model(\n        CylindricAnnealingModel,\n        spl, distance_range_long, distance_range_lat, angle_max,\n        temperature_time_const, temperature, cooling_rate, reject_limit,\n    )  # fmt: skip\n</code></pre>"},{"location":"api/components/#cylindra.components.landscape.Landscape.from_dir","title":"<code>from_dir(path)</code>  <code>classmethod</code>","text":"<p>Load a landscape from a directory.</p> Source code in <code>cylindra/components/landscape.py</code> <pre><code>@classmethod\ndef from_dir(cls, path: str | Path) -&gt; Landscape:\n    \"\"\"Load a landscape from a directory.\"\"\"\n    path = Path(path)\n    if path.suffix != \"\":\n        raise ValueError(f\"Must be a directory, got {path}\")\n    energies = ip.imread(path / \"landscape.tif\")\n    molecules = Molecules.from_parquet(path / \"molecules.parquet\")\n    argmax = None\n    if (fp := path / \"argmax.parquet\").exists():\n        argmax = pl.read_parquet(fp).to_series().to_numpy()\n    if (landscape_json_path := path / \"landscape.json\").exists():\n        with landscape_json_path.open() as f:\n            js = json.load(f)\n            quaternions = np.array(js[\"quaternions\"], dtype=np.float32)\n            num_templates = js[\"num_templates\"]\n    elif (quat_path := path / \"quaternions.txt\").exists():\n        quaternions = np.atleast_2d(\n            np.loadtxt(quat_path, delimiter=\",\", dtype=np.float32)\n        )\n        num_templates = 1\n    else:\n        quaternions = np.array([[1, 0, 0, 0]], dtype=np.float32)\n        num_templates = 1\n    scale_factor = energies.scale[\"x\"]\n    return cls(\n        energies=energies.value,\n        molecules=molecules,\n        argmax=argmax,\n        quaternions=quaternions,\n        scale_factor=scale_factor,\n        num_templates=num_templates,\n    )\n</code></pre>"},{"location":"api/components/#cylindra.components.landscape.Landscape.from_loader","title":"<code>from_loader(loader, template, mask=None, max_shifts=(0.8, 0.8, 0.8), upsample_factor=5, alignment_model=alignment.ZNCCAlignment)</code>  <code>classmethod</code>","text":"<p>Construct a landscape from a loader object.</p> <p>Parameters:</p> Name Type Description Default <code>loader</code> <code>LoaderBase</code> <p>Any loader object from <code>acryo</code>.</p> required <code>template</code> <code>template input type</code> <p>Template image or a list of template images to be used.</p> required <code>mask</code> <code>mask input type</code> <p>Mask image to be used, by default None</p> <code>None</code> <code>max_shifts</code> <code>(float, float, float)</code> <p>Maximum shifts in nm, in (Z, Y, X) order.</p> <code>(0.8, 0.8, 0.8)</code> <code>upsample_factor</code> <code>int</code> <p>Upsampling factor for landscape construction.</p> <code>5</code> <code>alignment_model</code> <code>alignment model object</code> <p>Alignment model to be used to evaluate correlation score.</p> <code>ZNCCAlignment</code> Source code in <code>cylindra/components/landscape.py</code> <pre><code>@classmethod\ndef from_loader(\n    cls,\n    loader: LoaderBase,\n    template: TemplateInputType,\n    mask: MaskInputType = None,\n    max_shifts: tuple[nm, nm, nm] = (0.8, 0.8, 0.8),\n    upsample_factor: int = 5,\n    alignment_model: alignment.TomographyInput = alignment.ZNCCAlignment,\n) -&gt; Landscape:\n    \"\"\"Construct a landscape from a loader object.\n\n    Parameters\n    ----------\n    loader : LoaderBase\n        Any loader object from ``acryo``.\n    template : template input type\n        Template image or a list of template images to be used.\n    mask : mask input type, optional\n        Mask image to be used, by default None\n    max_shifts : (float, float, float), optional\n        Maximum shifts in nm, in (Z, Y, X) order.\n    upsample_factor : int\n        Upsampling factor for landscape construction.\n    alignment_model : alignment model object\n        Alignment model to be used to evaluate correlation score.\n    \"\"\"\n    if isinstance(template, (str, Path)):\n        template = pipe.from_file(template)\n        num_templates = 1\n    elif isinstance(template, (list, tuple)):\n        if all(isinstance(t, (str, Path)) for t in template):\n            num_templates = len(template)\n            template = pipe.from_files(template)\n        else:\n            template = list(template)\n            num_templates = len(template)\n    elif isinstance(template, np.ndarray):\n        if template.ndim == 4:\n            num_templates = template.shape[0]\n        else:\n            num_templates = 1\n    else:\n        raise TypeError(f\"Invalid type of template: {type(template)}\")\n\n    _Logger.print(f\"Using {num_templates} template(s) for landscape construction.\")\n    _Logger.print(f\"Landscape resolution: {loader.scale / upsample_factor:.3f} nm\")\n\n    score_dsk = loader.construct_landscape(\n        template,\n        mask=mask,\n        max_shifts=max_shifts,\n        upsample=upsample_factor,\n        alignment_model=alignment_model,\n    )\n    score, argmax = _calc_landscape(\n        alignment_model, score_dsk, multi_templates=num_templates &gt; 1\n    )\n    mole = loader.molecules\n    to_drop = set(mole.features.columns) - {Mole.nth, Mole.pf, Mole.position}\n    if to_drop:\n        mole = mole.drop_features(*to_drop)\n    return cls(\n        energies=-np.ascontiguousarray(score),\n        molecules=mole,\n        argmax=argmax,\n        quaternions=alignment_model.quaternions,\n        scale_factor=loader.scale / upsample_factor,\n        num_templates=num_templates,\n    )\n</code></pre>"},{"location":"api/components/#cylindra.components.landscape.Landscape.normed","title":"<code>normed(sd=True)</code>","text":"<p>Return a landscape with normalized mean energy.</p> Source code in <code>cylindra/components/landscape.py</code> <pre><code>def normed(self, sd: bool = True) -&gt; Landscape:\n    \"\"\"Return a landscape with normalized mean energy.\"\"\"\n    each_mean: NDArray[np.float32] = self.energies.mean(axis=(1, 2, 3))\n    all_mean = each_mean.mean()\n    sl = (slice(None), np.newaxis, np.newaxis, np.newaxis)\n    if sd:\n        each_sd: NDArray[np.float32] = self.energies.std(axis=(1, 2, 3))\n        all_sd = each_sd.mean()\n        dif = self.energies - each_mean[sl]\n        new_array = dif * all_sd / each_sd[sl] + all_mean\n    else:\n        new_array = self.energies + all_mean - each_mean[sl]\n    return self.replace_energies(new_array)\n</code></pre>"},{"location":"api/components/#cylindra.components.landscape.Landscape.run_annealing","title":"<code>run_annealing(spl, distance_range_long, distance_range_lat, angle_max=None, temperature_time_const=1.0, temperature=None, cooling_rate=None, reject_limit=None, random_seeds=[0])</code>","text":"<p>Run simulated mesh annealing.</p> Source code in <code>cylindra/components/landscape.py</code> <pre><code>def run_annealing(\n    self,\n    spl: CylSpline,\n    distance_range_long: tuple[_DistLike, _DistLike],\n    distance_range_lat: tuple[_DistLike, _DistLike],\n    angle_max: float | None = None,\n    temperature_time_const: float = 1.0,\n    temperature: float | None = None,\n    cooling_rate: float | None = None,\n    reject_limit: int | None = None,\n    random_seeds: list[int] = [0],\n) -&gt; list[AnnealingResult]:\n    \"\"\"Run simulated mesh annealing.\"\"\"\n\n    if angle_max is None:\n        angle_max = 90.0\n    random_seeds = _normalize_random_seeds(random_seeds)\n    annealing = self.cylindric_annealing_model(\n        spl,\n        distance_range_long=distance_range_long,\n        distance_range_lat=distance_range_lat,\n        angle_max=angle_max,\n        temperature_time_const=temperature_time_const,\n        temperature=temperature,\n        cooling_rate=cooling_rate,\n        reject_limit=reject_limit,\n    )\n\n    batch_size = _to_batch_size(annealing.time_constant())\n    temp0 = annealing.temperature()\n    _Logger.info(\"Running annealing\")\n    _Logger.info(f\"  shape: {self.energies.shape[1:]!r}\")\n    tasks = [\n        _run_annealing(annealing.with_seed(s), batch_size, temp0)\n        for s in random_seeds\n    ]\n    return compute(*tasks)\n</code></pre>"},{"location":"api/components/#cylindra.components.landscape.Landscape.run_min_energy","title":"<code>run_min_energy(spl=None)</code>","text":"<p>Minimize energy for each local landscape independently.</p> Source code in <code>cylindra/components/landscape.py</code> <pre><code>def run_min_energy(\n    self, spl: CylSpline | None = None\n) -&gt; tuple[Molecules, MinEnergyResult]:\n    \"\"\"Minimize energy for each local landscape independently.\"\"\"\n    shape = self.energies.shape[1:]\n    indices = list[NDArray[np.int32]]()\n    engs = list[float]()\n    for i in range(self.energies.shape[0]):\n        eng = self.energies[i]\n        pos = np.unravel_index(np.argmin(eng), shape)\n        indices.append(np.array(pos, dtype=np.int32))\n        engs.append(eng[pos])\n    indices = np.stack(indices, axis=0)\n    engs = np.array(engs, dtype=np.float32)\n    result = MinEnergyResult(indices, engs)\n\n    mole_opt = self.transform_molecules(\n        self.molecules, result.indices, detect_peak=True\n    )\n    if spl is not None:\n        mole_opt = _update_mole_pos(mole_opt, self.molecules, spl)\n    return mole_opt, result\n</code></pre>"},{"location":"api/components/#cylindra.components.landscape.Landscape.run_viterbi","title":"<code>run_viterbi(dist_range, angle_max=None)</code>","text":"<p>Run Viterbi alignment.</p> Source code in <code>cylindra/components/landscape.py</code> <pre><code>def run_viterbi(\n    self, dist_range: tuple[_DistLike, _DistLike], angle_max: float | None = None\n):\n    \"\"\"Run Viterbi alignment.\"\"\"\n    dist_min, dist_max = self._norm_dist(dist_range)\n    if angle_max is not None:\n        angle_max = np.deg2rad(angle_max)\n    grid = self._prep_viterbi_grid()\n    return ViterbiResult(*grid.viterbi(dist_min, dist_max, angle_max))\n</code></pre>"},{"location":"api/components/#cylindra.components.landscape.Landscape.run_viterbi_fixed_start","title":"<code>run_viterbi_fixed_start(first, range_long=(4.0, 4.28), angle_max=5.0)</code>","text":"<p>Run Viterbi alignment with a fixed start edge.</p> Source code in <code>cylindra/components/landscape.py</code> <pre><code>def run_viterbi_fixed_start(\n    self,\n    first: NDArray[np.float32],\n    range_long: tuple[_DistLike, _DistLike] = (4.0, 4.28),\n    angle_max: float | None = 5.0,\n):\n    \"\"\"Run Viterbi alignment with a fixed start edge.\"\"\"\n    mole = self.molecules\n    dist_min, dist_max = self._norm_dist(range_long)\n    if angle_max is not None:\n        angle_max = np.deg2rad(angle_max)\n    grid = self._prep_viterbi_grid()\n    mole0 = Molecules(first, mole.rotator[:1]).translate_internal(-self.offset_nm)\n    origin = (mole0.pos[0] / self.scale_factor).astype(np.float32)\n    res = ViterbiResult(\n        *grid.viterbi_fixed_start(\n            dist_min, dist_max, first / self.scale_factor, origin, angle_max\n        )\n    )\n    max_shifts_px = (np.array(self.energies.shape[1:]) - 1) // 2\n    inds = _check_viterbi_shift(res.indices, max_shifts_px, 0)\n    molecules_opt = self.transform_molecules(mole, inds)\n    return molecules_opt\n</code></pre>"},{"location":"api/components/#cylindra.components.landscape.Landscape.save","title":"<code>save(path)</code>","text":"<p>Save the landscape to a directory.</p> Source code in <code>cylindra/components/landscape.py</code> <pre><code>def save(self, path: str | Path) -&gt; None:\n    \"\"\"Save the landscape to a directory.\"\"\"\n    path = Path(path)\n    if path.suffix != \"\":\n        raise ValueError(f\"Must be a directory, got {path}\")\n    path.mkdir(exist_ok=False)\n    arr = ip.asarray(self.energies, axes=\"tzyx\").set_scale(\n        xyz=self.scale_factor, unit=\"nm\"\n    )\n    arr.imsave(path / \"landscape.tif\")\n    self.molecules.to_parquet(path / \"molecules.parquet\")\n    if self.argmax is not None:\n        pl.DataFrame({\"argmax\": self.argmax}).write_parquet(\n            path / \"argmax.parquet\", compression_level=10\n        )\n    with open(path / \"landscape.json\", \"w\") as f:\n        js = {\n            \"quaternions\": self.quaternions.tolist(),\n            \"num_templates\": self.num_templates,\n        }\n        json.dump(js, f, indent=2)\n    return None\n</code></pre>"},{"location":"api/components/#cylindra.components.landscape.Landscape.transform_molecules","title":"<code>transform_molecules(molecules, indices, detect_peak=False)</code>","text":"<p>Transform the input molecules based on the landscape.</p> <p>Parameters:</p> Name Type Description Default <code>molecules</code> <code>Molecules</code> <p>Molecules object to be transformed.</p> required <code>indices</code> <code>integer array</code> <p>Indices in the landscape to be used for transformation.</p> required <code>detect_peak</code> <code>bool</code> <p>If True, landscape will be sub-sampled to detect the peak in higher precision. This should be false for constrained alignment, as the detected peak usually does not represent the optimal result.</p> <code>False</code> <p>Returns:</p> Type Description <code>Molecules</code> <p>Transformed molecules.</p> Source code in <code>cylindra/components/landscape.py</code> <pre><code>def transform_molecules(\n    self,\n    molecules: Molecules,\n    indices: NDArray[np.int32],\n    detect_peak: bool = False,\n) -&gt; Molecules:\n    \"\"\"Transform the input molecules based on the landscape.\n\n    Parameters\n    ----------\n    molecules : Molecules\n        Molecules object to be transformed.\n    indices : integer array\n        Indices in the landscape to be used for transformation.\n    detect_peak : bool, default False\n        If True, landscape will be sub-sampled to detect the peak in higher\n        precision. This should be false for constrained alignment, as the detected\n        peak usually does not represent the optimal result.\n\n    Returns\n    -------\n    Molecules\n        Transformed molecules.\n    \"\"\"\n    offset = self.offset\n    indices_sub = indices.astype(np.float32)\n    nmole = self.energies.shape[0]\n    opt_energy = np.zeros(nmole, dtype=np.float32)\n    nrepeat = 3 if detect_peak else 0\n    for i in range(nmole):\n        eng = self.energies[i]\n        indices_sub[i], opt_energy[i] = find_peak(eng, indices[i], nrepeat=nrepeat)\n    opt_score = -opt_energy\n    shifts = ((indices_sub - offset) * self.scale_factor).astype(np.float32)\n    molecules_opt = molecules.translate_internal(shifts)\n    dr_feat = _as_n_series(\"align-d{}\", shifts)\n    if (nrots := self.quaternions.shape[0]) &gt; 1:\n        quats = np.stack(\n            [\n                self.quaternions[self.argmax[(i, *ind)] % nrots]\n                for i, ind in enumerate(indices)\n            ],\n            axis=0,\n        )\n        rotator = Rotation.from_quat(quats).inv()\n        molecules_opt = molecules_opt.rotate_by(rotator)\n        rotvec = rotator.as_rotvec().astype(np.float32)\n        rotvec_feat = _as_n_series(\"align-d{}rot\", rotvec)\n        molecules_opt = molecules_opt.with_features(*rotvec_feat)\n    if self.num_templates &gt; 1:\n        template_id = np.stack(\n            [self.argmax[(i, *ind)] // nrots for i, ind in enumerate(indices)]\n        )\n        molecules_opt = molecules_opt.with_features(\n            pl.Series(Mole.template, template_id)\n        )\n    return molecules_opt.with_features(*dr_feat, pl.Series(Mole.score, opt_score))\n</code></pre>"},{"location":"api/components/#cylindra.components.landscape.SurfaceData","title":"<code>SurfaceData</code>","text":"<p>Tuple for storing isosurface data for landscapes.</p> Source code in <code>cylindra/components/landscape.py</code> <pre><code>class SurfaceData(NamedTuple):\n    \"\"\"Tuple for storing isosurface data for landscapes.\"\"\"\n\n    vertices: NDArray[np.float32]\n    faces: NDArray[np.int32]\n    values: NDArray[np.float32]\n</code></pre>"},{"location":"api/components/#cylindra.components.landscape.ViterbiResult","title":"<code>ViterbiResult</code>  <code>dataclass</code>","text":"<p>Dataclass for storing the Viterbi alignment results.</p> <p>Parameters:</p> Name Type Description Default <code>indices</code> <code>ndarray</code> <p>The optimized indices of the molecules.</p> required <code>score</code> <code>float</code> <p>The score of the optimal alignment.</p> required Source code in <code>cylindra/components/landscape.py</code> <pre><code>@dataclass\nclass ViterbiResult:\n    \"\"\"Dataclass for storing the Viterbi alignment results.\n\n    Parameters\n    ----------\n    indices : np.ndarray\n        The optimized indices of the molecules.\n    score : float\n        The score of the optimal alignment.\n    \"\"\"\n\n    indices: NDArray[np.int32]\n    score: float\n</code></pre>"},{"location":"api/components/#cylindra.components.landscape.delayed_isosurface","title":"<code>delayed_isosurface(arr, level, spacing, step_size=1)</code>","text":"<p>Create an isosurface from a 3D array using marching cubes algorithm.</p> Source code in <code>cylindra/components/landscape.py</code> <pre><code>@delayed\ndef delayed_isosurface(\n    arr: NDArray[np.float32],\n    level: float,\n    spacing: tuple[float, float, float],\n    step_size: int = 1,\n) -&gt; SurfaceData:\n    \"\"\"Create an isosurface from a 3D array using marching cubes algorithm.\"\"\"\n    arr_pad = np.pad(arr, step_size, mode=\"constant\", constant_values=arr.min())\n    try:\n        verts, faces, _, vals = marching_cubes(\n            arr_pad,\n            level,\n            spacing=spacing,\n            gradient_direction=\"descent\",\n            step_size=step_size,\n        )\n        verts -= np.array(spacing)[np.newaxis] * step_size\n    except (RuntimeError, ValueError):\n        verts = np.zeros((0, 3), dtype=np.float32)\n        faces = np.zeros((0, 3), dtype=np.int32)\n        vals = np.zeros((0,), dtype=np.float32)\n    return SurfaceData(verts, faces, vals)\n</code></pre>"},{"location":"api/components/#cylindra.components.seam_search.CorrelationSeamSearcher","title":"<code>CorrelationSeamSearcher</code>","text":"<p>Seam searcher based on correlation with the template.</p> Source code in <code>cylindra/components/seam_search.py</code> <pre><code>class CorrelationSeamSearcher(SeamSearcher):\n    \"\"\"Seam searcher based on correlation with the template.\"\"\"\n\n    def search(\n        self,\n        loader: SubtomogramLoader,\n        template: ip.ImgArray,\n        anti_template: ip.ImgArray | None = None,\n        mask: NDArray[np.float32] | None = None,\n        cutoff: float = 0.5,\n    ) -&gt; CorrelationSeamSearchResult:\n        corrs = list[float]()\n\n        if mask is None:\n            mask = 1\n\n        masked_template = (template * mask).lowpass_filter(cutoff, dims=\"zyx\")\n        has_anti_template = anti_template is not None\n        loader = loader.replace(output_shape=template.shape)\n        averaged_images = self.calc_averages(loader)\n        if has_anti_template:\n            if anti_template.shape != template.shape:\n                raise ValueError(\n                    f\"The shape of anti-template ({anti_template.shape}) must be the \"\n                    f\"same as the shape of template ({template.shape}).\"\n                )\n            masked_anti_template = (anti_template * mask).lowpass_filter(\n                cutoff, dims=\"zyx\"\n            )\n            anti_corrs = np.empty(averaged_images.shape[0], dtype=np.float32)\n        else:\n            masked_anti_template = None\n            anti_corrs = None\n\n        corrs = np.empty(averaged_images.shape[0], dtype=np.float32)\n        for _i, avg in enumerate(averaged_images):\n            avg: ip.ImgArray\n            masked_avg = (avg * mask).lowpass_filter(cutoff=cutoff, dims=\"zyx\")\n            corrs[_i] = ip.zncc(masked_avg, masked_template)\n            if has_anti_template:\n                anti_corrs[_i] = ip.zncc(masked_avg, masked_anti_template)\n\n        if has_anti_template:\n            score = corrs - anti_corrs\n        else:\n            corr1, corr2 = corrs[: self.npf], corrs[self.npf :]\n            score = np.empty_like(corrs, dtype=np.float32)\n            score[: self.npf] = corr1 - corr2\n            score[self.npf :] = corr2 - corr1\n\n        return CorrelationSeamSearchResult(score, averaged_images, corrs, anti_corrs)\n</code></pre>"},{"location":"api/components/#cylindra.components.seam_search.SeamSearcher","title":"<code>SeamSearcher</code>","text":"Source code in <code>cylindra/components/seam_search.py</code> <pre><code>class SeamSearcher(ABC):\n    def __init__(self, npf: int):\n        self._npf = npf\n\n    @property\n    def npf(self) -&gt; int:\n        return self._npf\n\n    @abstractmethod\n    def search(self, *args, **kwargs) -&gt; SeamSearchResult:\n        \"\"\"Search for the seam position.\"\"\"\n\n    def label_with_seam(self, size: int) -&gt; NDArray[np.bool_]:\n        labels = list[NDArray[np.bool_]]()  # list of boolean arrays\n        _id = np.arange(size)\n        assert _id.size % self.npf == 0\n        for pf in range(2 * self.npf):\n            res = (_id - pf) // self.npf\n            sl = res % 2 == 0\n            labels.append(sl)\n        return np.stack(labels, axis=0)\n\n    def calc_averages(self, loader: SubtomogramLoader) -&gt; ip.ImgArray:\n        # prepare all the labels in advance\n        labels = self.label_with_seam(loader.molecules.count())\n\n        # here, dask_array is (N, Z, Y, X) array where dask_array[i] is i-th subtomogram.\n        dask_array = loader.construct_dask()\n        averaged_images = da.compute(\n            [da.mean(dask_array[sl], axis=0) for sl in labels]\n        )[0]\n        return ip.asarray(np.stack(averaged_images, axis=0), axes=\"pzyx\").set_scale(\n            zyx=loader.scale\n        )\n</code></pre>"},{"location":"api/components/#cylindra.components.seam_search.SeamSearcher.search","title":"<code>search(*args, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Search for the seam position.</p> Source code in <code>cylindra/components/seam_search.py</code> <pre><code>@abstractmethod\ndef search(self, *args, **kwargs) -&gt; SeamSearchResult:\n    \"\"\"Search for the seam position.\"\"\"\n</code></pre>"},{"location":"api/core/","title":"cylindra.core","text":""},{"location":"api/core/#cylindra.core.collect_projects","title":"<code>collect_projects(files, *, skip_exc=False)</code>","text":"<p>Collect project files into a ProjectSequence object.</p> <p>Examples:</p> <pre><code>collect_projects(\"path/to/dir/*.json\")\ncollect_projects([\"path/to/dir-0/*.zip\", \"path/to/dir-1/*.zip\"])\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>files</code> <code>path-like or iterable of path-like</code> <p>Project file paths or glob pattern(s).</p> required Source code in <code>cylindra/core.py</code> <pre><code>def collect_projects(\n    files: PathLike | Iterable[PathLike],\n    *,\n    skip_exc: bool = False,\n) -&gt; ProjectSequence:\n    \"\"\"Collect project files into a ProjectSequence object.\n\n    Examples\n    --------\n    ``` python\n    collect_projects(\"path/to/dir/*.json\")\n    collect_projects([\"path/to/dir-0/*.zip\", \"path/to/dir-1/*.zip\"])\n    ```\n\n    Parameters\n    ----------\n    files : path-like or iterable of path-like\n        Project file paths or glob pattern(s).\n    \"\"\"\n    from cylindra.project import ProjectSequence\n\n    if isinstance(files, (str, Path)):\n        if \"*\" in str(files):\n            _files = glob.glob(str(files))\n        else:\n            if not Path(files).exists():\n                raise FileNotFoundError(f\"File not found: {files}\")\n            _files = [files]\n    elif hasattr(files, \"__iter__\"):\n        _files = []\n        for f in files:\n            f = str(f)\n            if \"*\" not in f:\n                _files.append(f)\n            else:\n                _files.extend(list(glob.glob(f)))\n    else:\n        raise TypeError(f\"files must be path or iterable of paths, got {type(files)}\")\n    if len(_files) == 0:\n        raise FileNotFoundError(f\"No project files found from the input {files!r}.\")\n    seq = ProjectSequence.from_paths(_files, check_scale=False, skip_exc=skip_exc)\n    return seq\n</code></pre>"},{"location":"api/core/#cylindra.core.instance","title":"<code>instance(create=False)</code>","text":"<pre><code>instance(create: Literal[False] = False) -&gt; CylindraMainWidget | None\n</code></pre><pre><code>instance(create: Literal[True]) -&gt; CylindraMainWidget\n</code></pre> <p>Get the current CylindraMainWidget instance.</p> Source code in <code>cylindra/core.py</code> <pre><code>def instance(create=False):\n    \"\"\"Get the current CylindraMainWidget instance.\"\"\"\n    ins = _CURRENT_INSTANCE\n    if ins is None and create:\n        ins = start()\n    return ins\n</code></pre>"},{"location":"api/core/#cylindra.core.read_molecules","title":"<code>read_molecules(file, pos_cols=('z', 'y', 'x'), rot_cols=('zvec', 'yvec', 'xvec'))</code>","text":"<p>Read a molecules CSV or parquet file.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>PathLike</code> <p>File path.</p> required <code>pos_cols</code> <code>sequence of str</code> <p>Column names for the molecule positions.</p> <code>(\"z\", \"y\", \"x\")</code> <code>rot_cols</code> <code>sequence of str</code> <p>Column names for the molecule rotation vectors.</p> <code>(\"zvec\", \"yvec\", \"xvec\")</code> <p>Returns:</p> Type Description <code>Molecules</code> <p>Molecules object.</p> Source code in <code>cylindra/core.py</code> <pre><code>def read_molecules(\n    file: PathLike,\n    pos_cols: Sequence[str] = (\"z\", \"y\", \"x\"),\n    rot_cols: Sequence[str] = (\"zvec\", \"yvec\", \"xvec\"),\n) -&gt; Molecules:\n    \"\"\"Read a molecules CSV or parquet file.\n\n    Parameters\n    ----------\n    file : PathLike\n        File path.\n    pos_cols : sequence of str, default (\"z\", \"y\", \"x\")\n        Column names for the molecule positions.\n    rot_cols : sequence of str, default (\"zvec\", \"yvec\", \"xvec\")\n        Column names for the molecule rotation vectors.\n\n    Returns\n    -------\n    Molecules\n        Molecules object.\n    \"\"\"\n    from acryo import Molecules\n\n    path = Path(file)\n    return Molecules.from_file(path, pos_cols=list(pos_cols), rot_cols=list(rot_cols))\n</code></pre>"},{"location":"api/core/#cylindra.core.read_project","title":"<code>read_project(file)</code>","text":"<p>Read the Cylindra project file.</p> Source code in <code>cylindra/core.py</code> <pre><code>def read_project(file: PathLike) -&gt; CylindraProject:\n    \"\"\"Read the Cylindra project file.\"\"\"\n    from cylindra.project import CylindraProject\n\n    return CylindraProject.from_file(file)\n</code></pre>"},{"location":"api/core/#cylindra.core.read_spline","title":"<code>read_spline(file)</code>","text":"<p>Read a spline file.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>PathLike</code> <p>File path.</p> required <p>Returns:</p> Type Description <code>CylSpline</code> <p>CylSpline object.</p> Source code in <code>cylindra/core.py</code> <pre><code>def read_spline(file: PathLike) -&gt; CylSpline:\n    \"\"\"Read a spline file.\n\n    Parameters\n    ----------\n    file : PathLike\n        File path.\n\n    Returns\n    -------\n    CylSpline\n        CylSpline object.\n    \"\"\"\n    from cylindra.components import CylSpline\n\n    return CylSpline.from_json(file)\n</code></pre>"},{"location":"api/core/#cylindra.core.start","title":"<code>start(project_file=None, viewer=None, *, log_level='INFO', headless=False, add_main_widget=True, run=True)</code>","text":"<p>Start napari viewer and dock cylindra widget as a dock widget.</p> <p>Parameters:</p> Name Type Description Default <code>project_file</code> <code>path - like</code> <p>If given, load the project file.</p> <code>None</code> <code>viewer</code> <code>Viewer</code> <p>Give a viewer object and this viewer will be used as the parent.</p> <code>None</code> <code>log_level</code> <code>int or str</code> <p>Log level. See <code>logging</code> module for details.</p> <code>\"INFO\"</code> <code>headless</code> <code>bool</code> <p>If True, do not show the viewer.</p> <code>False</code> Source code in <code>cylindra/core.py</code> <pre><code>def start(\n    project_file: str | None = None,\n    viewer: napari.Viewer | None = None,\n    *,\n    log_level: int | str = \"INFO\",\n    headless: bool = False,\n    add_main_widget: bool = True,\n    run: bool = True,\n) -&gt; CylindraMainWidget:\n    \"\"\"Start napari viewer and dock cylindra widget as a dock widget.\n\n    Parameters\n    ----------\n    project_file : path-like, optional\n        If given, load the project file.\n    viewer : napari.Viewer\n        Give a viewer object and this viewer will be used as the parent.\n    log_level : int or str, default \"INFO\"\n        Log level. See `logging` module for details.\n    headless : bool, default False\n        If True, do not show the viewer.\n    \"\"\"\n    from cylindra.widgets import CylindraMainWidget  # noqa: I001\n    import impy as ip\n    import matplotlib.pyplot as plt\n    import napari\n    import numpy as np\n    import polars as pl\n    from IPython import get_ipython\n    from magicclass import logging\n\n    from cylindra._config import init_config\n\n    global _CURRENT_INSTANCE\n\n    if viewer is None:\n        viewer = napari.Viewer(show=not headless)\n    elif not isinstance(viewer, napari.Viewer):\n        raise TypeError(f\"viewer must be a napari.Viewer object, got {type(viewer)}\")\n\n    init_config()\n    ui = CylindraMainWidget()\n    ui.macro.options.max_undo = 16\n    ACTIVE_WIDGETS.add(ui)\n\n    # set logger\n    logger = logging.getLogger(\"cylindra\")\n    formatter = logging.Formatter(fmt=\"%(levelname)s || %(message)s\")\n    logger.widget.setFormatter(formatter)\n    logger.widget.min_height = 150\n\n    # set log level\n    if isinstance(log_level, str):\n        log_level = log_level.upper()\n        if log_level in (\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"):\n            log_level = getattr(logging, log_level)\n        else:\n            raise ValueError(f\"Invalid log level: {log_level}\")\n    logger.setLevel(log_level)\n\n    # set polars display options\n    pl.Config().set_tbl_width_chars(120)\n\n    if add_main_widget:\n        dock = viewer.window.add_dock_widget(\n            ui, area=\"right\", allowed_areas=[\"right\"], name=\"cylindra\"\n        )\n        dock.setMinimumHeight(300)\n    viewer.window.add_dock_widget(logger.widget, name=\"Log\")\n    ui.macro.options.syntax_highlight = False\n\n    if project_file is not None:\n        ui.load_project(project_file)\n    _CURRENT_INSTANCE = ui\n\n    with suppress(Exception):\n        # update console namespace\n        viewer.window._qt_viewer.console.push(\n            {\n                \".ui\": ui,  # only available from namespace dict\n                \"ui\": ui,\n                \"np\": np,\n                \"ip\": ip,\n                \"pl\": pl,\n                \"plt\": plt,\n                \"Path\": Path,\n            }\n        )\n\n    with suppress(Exception):  # This block uses private API.\n        # napari viewer does not disconnect layer events when the viewer is closed,\n        # so we need to do it manually\n        @viewer.window._qt_window.destroyed.connect\n        def _on_destroy():\n            viewer.layers.events.removing.disconnect()\n            viewer.layers.events.removed.disconnect()\n\n        # napari-console disables calltips by default. It's better to enable it.\n        viewer.window._qt_viewer.console.enable_calltips = True\n\n    with suppress(Exception):  # napari&gt;=0.6.0\n        viewer.camera.orientation = (\"away\", \"down\", \"right\")\n\n    @viewer.bind_key(\"J\", overwrite=True)\n    def _focus_up(v: napari.Viewer):\n        v.dims.set_current_step(0, v.dims.current_step[0] - 4)\n\n    @viewer.bind_key(\"K\", overwrite=True)\n    def _focus_down(v: napari.Viewer):\n        v.dims.set_current_step(0, v.dims.current_step[0] + 4)\n\n    ui.show(run=run)\n    if add_main_widget:\n        try:  # Just in case\n            # avoid accidentally closing/hiding the dock widget\n            dock.title.close_button.disconnect()\n            dock.title.hide_button.disconnect()\n        except Exception:  # pragma: no cover\n            print(\"Failed to disconnect the close/hide button of the dock widget.\")\n\n    # Programmatically run `%matplotlib inline` magic\n    if ipy := get_ipython():\n        ipy.run_line_magic(\"matplotlib\", \"inline\")\n\n    return ui\n</code></pre>"},{"location":"api/core/#cylindra.core.start_as_plugin","title":"<code>start_as_plugin(run=True)</code>","text":"<p>Start Cylindra as a napari plugin</p> Source code in <code>cylindra/core.py</code> <pre><code>def start_as_plugin(run: bool = True):\n    \"\"\"Start Cylindra as a napari plugin\"\"\"\n    import napari\n    from magicclass import logging\n\n    ui = start(\n        viewer=napari.current_viewer(),\n        add_main_widget=False,\n        run=run,\n    )\n    # float logger widget\n    logger = logging.getLogger(\"cylindra\")\n    logger.widget.native.parentWidget().setFloating(True)\n    logger.widget.height = 160\n    return ui\n</code></pre>"},{"location":"api/core/#cylindra.core.view_project","title":"<code>view_project(project_file, show=True)</code>","text":"<p>View the Cylindra project file.</p> Source code in <code>cylindra/core.py</code> <pre><code>def view_project(project_file: PathLike, show: bool = True):\n    \"\"\"View the Cylindra project file.\"\"\"\n    from cylindra.project import CylindraProject\n\n    widget = CylindraProject.from_file(project_file).make_project_viewer()\n    if show:\n        widget.show(run=False)\n    ACTIVE_WIDGETS.add(widget)\n    return widget\n</code></pre>"},{"location":"api/cylfilters/","title":"cylindra.cylfilters","text":"<p>Filtering functions for cylindric structure, with <code>scipy.ndimage</code>-like API.</p>"},{"location":"api/cylfilters/#cylindra.cylfilters.CylindricArray","title":"<code>CylindricArray</code>","text":"Source code in <code>cylindra/cylfilters.py</code> <pre><code>class CylindricArray:\n    def __init__(self, rust_obj: _CylindricArray):\n        self._rust_obj = rust_obj\n\n    def __repr__(self) -&gt; str:\n        return f\"CylindricArray({self._rust_obj.asarray()}, nrise={self.nrise})\"\n\n    @property\n    def nrise(self) -&gt; int:\n        \"\"\"The number of rise of the cylindric structure.\"\"\"\n        return self._rust_obj.nrise()\n\n    def asarray(self, dtype=None) -&gt; NDArray[np.float32]:\n        \"\"\"As a 2D numpy array.\"\"\"\n        out = self._rust_obj.asarray()\n        if dtype is not None:\n            out = out.astype(dtype, copy=False)\n        return out\n\n    def as1d(self, dtype=None) -&gt; NDArray[np.float32]:\n        out = self._rust_obj.as1d()\n        if dtype is not None:\n            out = out.astype(dtype, copy=False)\n        return out\n\n    def as_series(self, name: str = \"\", dtype=None) -&gt; pl.Series:\n        if type(dtype) is type and dtype in pl.DataType:\n            pl_dtype = dtype\n            np_dtype = None\n        else:\n            pl_dtype = None\n            np_dtype = dtype\n        return pl.Series(name, self.as1d(np_dtype), dtype=pl_dtype)\n\n    def with_values(self, values: ArrayLike) -&gt; Self:\n        return CylindricArray(\n            self._rust_obj.with_values(np.asarray(values, dtype=np.float32))\n        )\n\n    __array__ = asarray\n\n    @classmethod\n    def from_sequences(\n        cls, nth: ArrayLike, npf: ArrayLike, value: ArrayLike, nrise: int\n    ) -&gt; Self:\n        nth = np.asarray(nth, dtype=np.int32)\n        npf = np.asarray(npf, dtype=np.int32)\n        value = np.asarray(value, dtype=np.float32)\n        nrise = int(nrise)\n        return cls(_CylindricArray(nth, npf, value, nrise))\n\n    @classmethod\n    def zeros_like(self, df: pl.DataFrame, nrise: int) -&gt; Self:\n        nth = df[Mole.nth].to_numpy()\n        npf = df[Mole.pf].to_numpy()\n        value = np.zeros(len(df), dtype=np.float32)\n        return CylindricArray.from_sequences(nth, npf, value, nrise)\n\n    @classmethod\n    def from_dataframe(self, df: pl.DataFrame, target: str, nrise: int) -&gt; Self:\n        nth = df[Mole.nth].to_numpy()\n        npf = df[Mole.pf].to_numpy()\n        value = df[target].to_numpy()\n        return CylindricArray.from_sequences(nth, npf, value, nrise)\n\n    def convolve(self, kernel: ArrayLike) -&gt; Self:\n        ker = np.asarray(kernel, dtype=np.float32)\n        return CylindricArray(self._rust_obj.convolve(ker))\n\n    def mean_filter(self, kernel: ArrayLike) -&gt; Self:\n        ker = np.asarray(kernel, dtype=np.bool_)\n        return CylindricArray(self._rust_obj.mean_filter(ker))\n\n    def count_neighbors(self, kernel: ArrayLike) -&gt; Self:\n        ker = np.asarray(kernel, dtype=np.bool_)\n        return CylindricArray(self._rust_obj.count_neighbors(ker))\n\n    def max_filter(self, kernel: ArrayLike) -&gt; Self:\n        ker = np.asarray(kernel, dtype=np.bool_)\n        return CylindricArray(self._rust_obj.max_filter(ker))\n\n    def min_filter(self, kernel: ArrayLike) -&gt; Self:\n        ker = np.asarray(kernel, dtype=np.bool_)\n        return CylindricArray(self._rust_obj.min_filter(ker))\n\n    def median_filter(self, kernel: ArrayLike) -&gt; Self:\n        ker = np.asarray(kernel, dtype=np.bool_)\n        return CylindricArray(self._rust_obj.median_filter(ker))\n\n    def binarize(self, threshold: float) -&gt; Self:\n        value = self.as1d()\n        new_value = value &gt;= threshold\n        return self.with_values(new_value)\n\n    def label(self) -&gt; Self:\n        return CylindricArray(self._rust_obj.label())\n\n    def __neg__(self) -&gt; Self:\n        return self.with_values(-self.as1d())\n\n    @staticmethod\n    def _make_operator(op) -&gt; Callable[[CylindricArray, Any], CylindricArray]:\n        def _method(self: CylindricArray, value) -&gt; CylindricArray:\n            if isinstance(value, CylindricArray):\n                value = value.as1d()\n            return self.with_values(op(self.as1d(), value))\n\n        _method.__name__ = op.__name__\n        _method.__qualname__ = f\"CylindricArray.{op.__name__}\"\n        return _method\n\n    __eq__ = _make_operator(operator.__eq__)\n    __ne__ = _make_operator(operator.__ne__)\n    __lt__ = _make_operator(operator.__lt__)\n    __le__ = _make_operator(operator.__le__)\n    __gt__ = _make_operator(operator.__gt__)\n    __ge__ = _make_operator(operator.__ge__)\n    __add__ = _make_operator(operator.__add__)\n    __sub__ = _make_operator(operator.__sub__)\n    __mul__ = _make_operator(operator.__mul__)\n    __truediv__ = _make_operator(operator.__truediv__)\n    __pow__ = _make_operator(operator.__pow__)\n    __and__ = _make_operator(operator.__and__)\n    __or__ = _make_operator(operator.__or__)\n    __xor__ = _make_operator(operator.__xor__)\n</code></pre>"},{"location":"api/cylfilters/#cylindra.cylfilters.CylindricArray.nrise","title":"<code>nrise</code>  <code>property</code>","text":"<p>The number of rise of the cylindric structure.</p>"},{"location":"api/cylfilters/#cylindra.cylfilters.CylindricArray.asarray","title":"<code>asarray(dtype=None)</code>","text":"<p>As a 2D numpy array.</p> Source code in <code>cylindra/cylfilters.py</code> <pre><code>def asarray(self, dtype=None) -&gt; NDArray[np.float32]:\n    \"\"\"As a 2D numpy array.\"\"\"\n    out = self._rust_obj.asarray()\n    if dtype is not None:\n        out = out.astype(dtype, copy=False)\n    return out\n</code></pre>"},{"location":"api/cylmeasure/","title":"cylindra.cylmeasure","text":""},{"location":"api/cylmeasure/#cylindra.cylmeasure.CylinderSurface","title":"<code>CylinderSurface</code>","text":"<p>Class to define the surface of a spline cylinder.</p> Source code in <code>cylindra/cylmeasure.py</code> <pre><code>class CylinderSurface:\n    \"\"\"Class to define the surface of a spline cylinder.\"\"\"\n\n    def __init__(self, spl: CylSpline):\n        self._spl = spl\n        self._radius = spl.radius\n        if self._radius is None:\n            raise ValueError(\"The spline must have a radius.\")\n\n    def transform_vector(\n        self,\n        vec: NDArray[np.float32],  # (N, 3)\n        start: NDArray[np.float32],  # (N, 4)\n    ) -&gt; NDArray[np.float32]:\n        \"\"\"Transform vector(s) to (r, y, a).\"\"\"\n        start = np.atleast_2d(start)\n        start_zyx = start[:, :3]\n        start_pos = start[:, 3]\n\n        # the displacement in the spline coordinate\n        dpos = _dot(self._spline_vec_norm(start_pos), vec)\n        end_pos = start_pos + dpos\n        dy = _dot(self._spline_vec_norm(start_pos + dpos / 2), vec)\n\n        # surface normal vectors at the start and end points\n        er0 = self._surface_vec(_concat(start_zyx, start_pos))\n        er1 = self._surface_vec(_concat(start_zyx + vec, end_pos))\n        ey0 = self._spline_vec_norm(start_pos)\n        ey1 = self._spline_vec_norm(end_pos)\n\n        # the \"mean\" unit vectors\n        ey = _norm(ey0 + ey1)\n        er = _norm(er0 + er1)\n        ea = np.cross(er, ey, axis=1)\n\n        er0y = _norm(_cancel_component(er0, ey))\n        er1y = _norm(_cancel_component(er1, ey))\n        v_ang_len = 2 * self._radius * _half_sin(er0y, er1y)\n        _sign = np.sign(_dot(_norm(er1y - er0y), ea))\n        v_ang = v_ang_len * _sign\n        v_ang[np.isnan(v_ang)] = 0.0\n        return np.stack([_dot(vec, er), dy, v_ang], axis=1)\n\n    def _surface_vec(\n        self,\n        coords: NDArray[np.float32],\n    ) -&gt; NDArray[np.float32]:\n        \"\"\"\n        Get the surface vector at the given coordinates.\n\n        Parameters\n        ----------\n        coords : (N, 4) array\n            Coordinate of points. The last column is the spline parameter.\n        \"\"\"\n        coords = np.atleast_2d(coords)\n        assert coords.ndim == 2 and coords.shape[1] == 4\n        zyx = coords[:, :3]\n        u = self._spl.y_to_position(coords[:, 3])\n        _spl_coords = self._spl.map(u, der=0)\n        _spl_vec_norm = _norm(self._spl.map(u, der=1))\n        _mole_to_spl_vec = _spl_coords - zyx\n        return _norm(_cancel_component(_mole_to_spl_vec, _spl_vec_norm))\n\n    def _spline_vec_norm(self, pos: NDArray[np.float32]) -&gt; NDArray[np.float32]:\n        \"\"\"Normalized spline tangent vector for given positions (nm).\"\"\"\n        u = self._spl.y_to_position(pos)\n        _spl_vec = self._spl.map(u, der=1)\n        return _norm(_spl_vec)\n</code></pre>"},{"location":"api/cylmeasure/#cylindra.cylmeasure.CylinderSurface.transform_vector","title":"<code>transform_vector(vec, start)</code>","text":"<p>Transform vector(s) to (r, y, a).</p> Source code in <code>cylindra/cylmeasure.py</code> <pre><code>def transform_vector(\n    self,\n    vec: NDArray[np.float32],  # (N, 3)\n    start: NDArray[np.float32],  # (N, 4)\n) -&gt; NDArray[np.float32]:\n    \"\"\"Transform vector(s) to (r, y, a).\"\"\"\n    start = np.atleast_2d(start)\n    start_zyx = start[:, :3]\n    start_pos = start[:, 3]\n\n    # the displacement in the spline coordinate\n    dpos = _dot(self._spline_vec_norm(start_pos), vec)\n    end_pos = start_pos + dpos\n    dy = _dot(self._spline_vec_norm(start_pos + dpos / 2), vec)\n\n    # surface normal vectors at the start and end points\n    er0 = self._surface_vec(_concat(start_zyx, start_pos))\n    er1 = self._surface_vec(_concat(start_zyx + vec, end_pos))\n    ey0 = self._spline_vec_norm(start_pos)\n    ey1 = self._spline_vec_norm(end_pos)\n\n    # the \"mean\" unit vectors\n    ey = _norm(ey0 + ey1)\n    er = _norm(er0 + er1)\n    ea = np.cross(er, ey, axis=1)\n\n    er0y = _norm(_cancel_component(er0, ey))\n    er1y = _norm(_cancel_component(er1, ey))\n    v_ang_len = 2 * self._radius * _half_sin(er0y, er1y)\n    _sign = np.sign(_dot(_norm(er1y - er0y), ea))\n    v_ang = v_ang_len * _sign\n    v_ang[np.isnan(v_ang)] = 0.0\n    return np.stack([_dot(vec, er), dy, v_ang], axis=1)\n</code></pre>"},{"location":"api/cylmeasure/#cylindra.cylmeasure.LatticeParameters","title":"<code>LatticeParameters</code>","text":"Source code in <code>cylindra/cylmeasure.py</code> <pre><code>class LatticeParameters(Enum):\n    spacing = \"spacing\"\n    elev_angle = \"elev_angle\"\n    twist = \"twist\"\n    skew_angle = \"skew_angle\"\n    radius = \"radius\"\n    rise_angle = \"rise_angle\"\n    lat_interv = \"lat_interv\"\n    curve_index = \"curve_index\"\n\n    @overload\n    def calculate(self, mole: Molecules, spl: CylSpline) -&gt; pl.Series:\n        ...\n\n    @overload\n    def calculate(self, layer: MoleculesLayer) -&gt; pl.Series:\n        ...\n\n    def calculate(self, mole, spl=None):\n        \"\"\"Calculate this lattice parameter for the given molecule.\"\"\"\n        if spl is None:\n            from cylindra._napari import MoleculesLayer\n\n            if not isinstance(mole, MoleculesLayer):\n                raise TypeError(\"mole must be a MoleculesLayer.\")\n            mole, spl = mole.molecules, mole.source_spline\n            if spl is None:\n                raise ValueError(\"The source spline is not defined.\")\n        match self:\n            case LatticeParameters.spacing:\n                return calc_spacing(mole, spl)\n            case LatticeParameters.elev_angle:\n                return calc_elevation_angle(mole, spl)\n            case LatticeParameters.twist:\n                return calc_twist(mole, spl)\n            case LatticeParameters.skew_angle:\n                return calc_skew(mole, spl)\n            case LatticeParameters.radius:\n                return calc_radius(mole, spl)\n            case LatticeParameters.rise_angle:\n                return calc_rise(mole, spl)\n            case LatticeParameters.lat_interv:\n                return calc_lateral_interval(mole, spl)\n            case LatticeParameters.curve_index:\n                return calc_curve_index(mole, spl)\n            case _:  # pragma: no cover\n                raise ValueError(f\"Unknown lattice parameter {self!r}.\")\n\n    @classmethod\n    def choices(cls) -&gt; list[str]:\n        return [v.name for v in cls]\n</code></pre>"},{"location":"api/cylmeasure/#cylindra.cylmeasure.LatticeParameters.calculate","title":"<code>calculate(mole, spl=None)</code>","text":"<pre><code>calculate(mole: Molecules, spl: CylSpline) -&gt; pl.Series\n</code></pre><pre><code>calculate(layer: MoleculesLayer) -&gt; pl.Series\n</code></pre> <p>Calculate this lattice parameter for the given molecule.</p> Source code in <code>cylindra/cylmeasure.py</code> <pre><code>def calculate(self, mole, spl=None):\n    \"\"\"Calculate this lattice parameter for the given molecule.\"\"\"\n    if spl is None:\n        from cylindra._napari import MoleculesLayer\n\n        if not isinstance(mole, MoleculesLayer):\n            raise TypeError(\"mole must be a MoleculesLayer.\")\n        mole, spl = mole.molecules, mole.source_spline\n        if spl is None:\n            raise ValueError(\"The source spline is not defined.\")\n    match self:\n        case LatticeParameters.spacing:\n            return calc_spacing(mole, spl)\n        case LatticeParameters.elev_angle:\n            return calc_elevation_angle(mole, spl)\n        case LatticeParameters.twist:\n            return calc_twist(mole, spl)\n        case LatticeParameters.skew_angle:\n            return calc_skew(mole, spl)\n        case LatticeParameters.radius:\n            return calc_radius(mole, spl)\n        case LatticeParameters.rise_angle:\n            return calc_rise(mole, spl)\n        case LatticeParameters.lat_interv:\n            return calc_lateral_interval(mole, spl)\n        case LatticeParameters.curve_index:\n            return calc_curve_index(mole, spl)\n        case _:  # pragma: no cover\n            raise ValueError(f\"Unknown lattice parameter {self!r}.\")\n</code></pre>"},{"location":"api/cylmeasure/#cylindra.cylmeasure.RegionProfiler","title":"<code>RegionProfiler</code>","text":"Source code in <code>cylindra/cylmeasure.py</code> <pre><code>class RegionProfiler:\n    CHOICES = [\n        \"area\", \"length\", \"width\", \"sum\", \"mean\", \"median\", \"max\", \"min\", \"std\",\n    ]  # fmt: skip\n\n    def __init__(self, rust_obj: _RegionProfiler) -&gt; None:\n        self._rust_obj = rust_obj\n\n    @classmethod\n    def from_arrays(\n        cls,\n        image: NDArray[np.float32],\n        label_image: NDArray[np.uint32],\n        nrise: int,\n    ) -&gt; RegionProfiler:\n        return cls(_RegionProfiler.from_arrays(image, label_image, nrise))\n\n    @classmethod\n    def from_components(\n        cls,\n        mole: Molecules,\n        spl: CylSpline,\n        target: str = \"nth\",\n        label: str = \"pf-id\",\n    ) -&gt; RegionProfiler:\n        \"\"\"\n        Construct a region profiler from molecules and splines.\n\n        Parameters\n        ----------\n        mole : Molecules\n            Molecules to be profiled. Must have features \"nth\", \"pf-id\".\n        spl : CylSpline\n            Spline from which the molecules are generated.\n        target : str, optional\n            Column name of the target values. This is not needed if properties that\n            do not require target values are to be calculated.\n        label : str\n            Column name of the label values. Must be an integer column.\n        \"\"\"\n        feat = mole.features\n        assert_column_exists(feat, [target, label])\n        feat_label = feat[label]\n\n        if (dtype := feat_label.dtype) not in POLARS_INTEGER_DTYPES:\n            raise TypeError(f\"label must be an integer column, got {dtype}.\")\n        nth = feat[Mole.nth].cast(pl.Int32).to_numpy()\n        pf = feat[Mole.pf].cast(pl.Int32).to_numpy()\n        values = feat[target].cast(pl.Float32).to_numpy()\n        labels = feat_label.cast(pl.UInt32).to_numpy()\n        nrise = spl.nrise()\n        npf = spl.props.get_glob(H.npf)\n\n        reg = _RegionProfiler.from_features(nth, pf, values, labels, npf, nrise)\n\n        return cls(reg)\n\n    def calculate(self, props: Iterable[str], *more_props: str) -&gt; pl.DataFrame:\n        \"\"\"\n        Calculate properties for each region.\n\n        Parameters\n        ----------\n        props : str or list of str\n            Property names. Must be chosen from following:\n            - area: total number of molecules.\n            - length: longitudinal length of the region.\n            - width: lateral width of the region.\n            - sum: sum of target values.\n            - mean: mean of target values.\n            - median: median of target values.\n            - max: max of target values.\n            - min: min of target values.\n            - std: standard deviation of target values.\n\n        Returns\n        -------\n        pl.DataFrame\n            DataFrame with columns corresponding to the given property names.\n        \"\"\"\n        if isinstance(props, str):\n            all_props = [props, *more_props]\n        else:\n            if more_props:\n                raise TypeError(\n                    \"Must be calculate(str, str, ...) or calculate([str, str, ...])\"\n                )\n            all_props = list(props)\n        props = list(props)\n        # NOTE: output dict is not sorted\n        out = self._rust_obj.calculate(all_props)\n        return pl.DataFrame({k: out[k] for k in all_props})\n\n    def n_regions(self) -&gt; int:\n        \"\"\"Number of regions.\"\"\"\n        _area = \"area\"\n        return self._rust_obj.calculate([_area])[_area].size\n</code></pre>"},{"location":"api/cylmeasure/#cylindra.cylmeasure.RegionProfiler.calculate","title":"<code>calculate(props, *more_props)</code>","text":"<p>Calculate properties for each region.</p> <p>Parameters:</p> Name Type Description Default <code>props</code> <code>str or list of str</code> <p>Property names. Must be chosen from following: - area: total number of molecules. - length: longitudinal length of the region. - width: lateral width of the region. - sum: sum of target values. - mean: mean of target values. - median: median of target values. - max: max of target values. - min: min of target values. - std: standard deviation of target values.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with columns corresponding to the given property names.</p> Source code in <code>cylindra/cylmeasure.py</code> <pre><code>def calculate(self, props: Iterable[str], *more_props: str) -&gt; pl.DataFrame:\n    \"\"\"\n    Calculate properties for each region.\n\n    Parameters\n    ----------\n    props : str or list of str\n        Property names. Must be chosen from following:\n        - area: total number of molecules.\n        - length: longitudinal length of the region.\n        - width: lateral width of the region.\n        - sum: sum of target values.\n        - mean: mean of target values.\n        - median: median of target values.\n        - max: max of target values.\n        - min: min of target values.\n        - std: standard deviation of target values.\n\n    Returns\n    -------\n    pl.DataFrame\n        DataFrame with columns corresponding to the given property names.\n    \"\"\"\n    if isinstance(props, str):\n        all_props = [props, *more_props]\n    else:\n        if more_props:\n            raise TypeError(\n                \"Must be calculate(str, str, ...) or calculate([str, str, ...])\"\n            )\n        all_props = list(props)\n    props = list(props)\n    # NOTE: output dict is not sorted\n    out = self._rust_obj.calculate(all_props)\n    return pl.DataFrame({k: out[k] for k in all_props})\n</code></pre>"},{"location":"api/cylmeasure/#cylindra.cylmeasure.RegionProfiler.from_components","title":"<code>from_components(mole, spl, target='nth', label='pf-id')</code>  <code>classmethod</code>","text":"<p>Construct a region profiler from molecules and splines.</p> <p>Parameters:</p> Name Type Description Default <code>mole</code> <code>Molecules</code> <p>Molecules to be profiled. Must have features \"nth\", \"pf-id\".</p> required <code>spl</code> <code>CylSpline</code> <p>Spline from which the molecules are generated.</p> required <code>target</code> <code>str</code> <p>Column name of the target values. This is not needed if properties that do not require target values are to be calculated.</p> <code>'nth'</code> <code>label</code> <code>str</code> <p>Column name of the label values. Must be an integer column.</p> <code>'pf-id'</code> Source code in <code>cylindra/cylmeasure.py</code> <pre><code>@classmethod\ndef from_components(\n    cls,\n    mole: Molecules,\n    spl: CylSpline,\n    target: str = \"nth\",\n    label: str = \"pf-id\",\n) -&gt; RegionProfiler:\n    \"\"\"\n    Construct a region profiler from molecules and splines.\n\n    Parameters\n    ----------\n    mole : Molecules\n        Molecules to be profiled. Must have features \"nth\", \"pf-id\".\n    spl : CylSpline\n        Spline from which the molecules are generated.\n    target : str, optional\n        Column name of the target values. This is not needed if properties that\n        do not require target values are to be calculated.\n    label : str\n        Column name of the label values. Must be an integer column.\n    \"\"\"\n    feat = mole.features\n    assert_column_exists(feat, [target, label])\n    feat_label = feat[label]\n\n    if (dtype := feat_label.dtype) not in POLARS_INTEGER_DTYPES:\n        raise TypeError(f\"label must be an integer column, got {dtype}.\")\n    nth = feat[Mole.nth].cast(pl.Int32).to_numpy()\n    pf = feat[Mole.pf].cast(pl.Int32).to_numpy()\n    values = feat[target].cast(pl.Float32).to_numpy()\n    labels = feat_label.cast(pl.UInt32).to_numpy()\n    nrise = spl.nrise()\n    npf = spl.props.get_glob(H.npf)\n\n    reg = _RegionProfiler.from_features(nth, pf, values, labels, npf, nrise)\n\n    return cls(reg)\n</code></pre>"},{"location":"api/cylmeasure/#cylindra.cylmeasure.RegionProfiler.n_regions","title":"<code>n_regions()</code>","text":"<p>Number of regions.</p> Source code in <code>cylindra/cylmeasure.py</code> <pre><code>def n_regions(self) -&gt; int:\n    \"\"\"Number of regions.\"\"\"\n    _area = \"area\"\n    return self._rust_obj.calculate([_area])[_area].size\n</code></pre>"},{"location":"api/cylmeasure/#cylindra.cylmeasure.calc_curve_index","title":"<code>calc_curve_index(mole, spl)</code>","text":"<p>The curve orientation index.</p> <p>The curve orientation is defined as the cosine of the angle between the second derivative and the relative molecule vector. That is, the inside of the curve is positive.</p> Source code in <code>cylindra/cylmeasure.py</code> <pre><code>def calc_curve_index(mole: Molecules, spl: CylSpline):\n    \"\"\"\n    The curve orientation index.\n\n    The curve orientation is defined as the cosine of the angle between the\n    second derivative and the relative molecule vector. That is, the inside\n    of the curve is positive.\n    \"\"\"\n    _u = spl.y_to_position(mole.features[Mole.position])\n    der0 = spl.map(_u, der=0)\n    der2 = spl.map(_u, der=2)\n    mole_vec_normed = _norm(mole.pos - der0)\n    der2_normed = _norm(der2, fill=0.0)\n    _cos = _dot(mole_vec_normed, der2_normed)\n    return pl.Series(Mole.curve_index, _cos).cast(pl.Float32)\n</code></pre>"},{"location":"api/cylmeasure/#cylindra.cylmeasure.calc_elevation_angle","title":"<code>calc_elevation_angle(mole, spl)</code>","text":"<p>Calculate the elevation angle of the longitudinal neighbors.</p> Source code in <code>cylindra/cylmeasure.py</code> <pre><code>def calc_elevation_angle(mole: Molecules, spl: CylSpline) -&gt; pl.Series:\n    \"\"\"Calculate the elevation angle of the longitudinal neighbors.\"\"\"\n    return (\n        calc_localvec_long(mole, spl, fill=np.nan)\n        .select(\n            pl.arctan2(\"vecr\", \"vecy\")\n            .degrees()\n            .fill_nan(-float(\"inf\"))\n            .alias(Mole.elev_angle)\n        )\n        .to_series()\n    )\n</code></pre>"},{"location":"api/cylmeasure/#cylindra.cylmeasure.calc_radius","title":"<code>calc_radius(mole, spl)</code>","text":"<p>Calculate the radius of each molecule.</p> Source code in <code>cylindra/cylmeasure.py</code> <pre><code>def calc_radius(mole: Molecules, spl: CylSpline) -&gt; pl.Series:\n    \"\"\"Calculate the radius of each molecule.\"\"\"\n    _u = spl.y_to_position(mole.features[Mole.position])\n    _spl_pos = spl.map(_u, der=0)\n    _spl_vec = spl.map(_u, der=1)\n    _spl_vec_norm = _norm(_spl_vec)\n    _radius_vec = _spl_pos - mole.pos\n    result = np.sqrt(_dot(_radius_vec, _radius_vec) - _dot(_radius_vec, _spl_vec_norm))\n    return pl.Series(Mole.radius, result).cast(pl.Float32)\n</code></pre>"},{"location":"api/cylmeasure/#cylindra.cylmeasure.calc_rise","title":"<code>calc_rise(mole, spl)</code>","text":"<p>Add a column of rise angles of each molecule.</p> Source code in <code>cylindra/cylmeasure.py</code> <pre><code>def calc_rise(mole: Molecules, spl: CylSpline) -&gt; pl.Series:\n    \"\"\"Add a column of rise angles of each molecule.\"\"\"\n    # NOTE: molecules must be in the canonical arrangement.\n    sign = spl.config.rise_sign\n    return (\n        calc_localvec_lat(mole, spl, fill=np.nan)\n        .select(pl.arctan2(\"vecy\", \"veca\").degrees().alias(Mole.rise))\n        .to_series()\n        * sign\n    ).fill_nan(-float(\"inf\"))\n</code></pre>"},{"location":"api/cylmeasure/#cylindra.cylmeasure.calc_skew","title":"<code>calc_skew(mole, spl)</code>","text":"<p>Calculate the skew of each molecule to the next one.</p> Source code in <code>cylindra/cylmeasure.py</code> <pre><code>def calc_skew(mole: Molecules, spl: CylSpline) -&gt; pl.Series:\n    \"\"\"Calculate the skew of each molecule to the next one.\"\"\"\n    return (\n        calc_localvec_long(mole, spl, fill=np.nan)\n        .select(\n            pl.arctan2(\"veca\", \"vecy\")\n            .degrees()\n            .fill_nan(-float(\"inf\"))\n            .alias(Mole.skew)\n        )\n        .to_series()\n    )\n</code></pre>"},{"location":"api/cylmeasure/#cylindra.cylmeasure.calc_spacing","title":"<code>calc_spacing(mole, spl)</code>","text":"<p>Calculate the interval of each molecule to the next one.</p> Source code in <code>cylindra/cylmeasure.py</code> <pre><code>def calc_spacing(mole: Molecules, spl: CylSpline) -&gt; pl.Series:\n    \"\"\"Calculate the interval of each molecule to the next one.\"\"\"\n    return (\n        calc_localvec_long(mole, spl, fill=np.nan)\n        .select(\n            (pl.col(\"vecy\") ** 2 + pl.col(\"veca\") ** 2)\n            .sqrt()\n            .fill_nan(-float(\"inf\"))\n            .alias(Mole.spacing)\n        )\n        .to_series()\n    )\n</code></pre>"},{"location":"api/cylmeasure/#cylindra.cylmeasure.calc_twist","title":"<code>calc_twist(mole, spl)</code>","text":"<p>Calculate the twist of each molecule to the next one.</p> Source code in <code>cylindra/cylmeasure.py</code> <pre><code>def calc_twist(mole: Molecules, spl: CylSpline) -&gt; pl.Series:\n    \"\"\"Calculate the twist of each molecule to the next one.\"\"\"\n    return (\n        calc_localvec_long(mole, spl, fill=np.nan)\n        .select(\n            (pl.col(\"veca\") / 2 / spl.radius)\n            .arcsin()\n            .degrees()\n            .fill_nan(-float(\"inf\"))\n            .alias(Mole.twist)\n            * 2\n        )\n        .to_series()\n    )\n</code></pre>"},{"location":"api/plugin/","title":"cylindra.plugin","text":"<p>This submodule includes functions for plugin management.</p>"},{"location":"api/plugin/#cylindra.plugin.CylindraPluginFunction","title":"<code>CylindraPluginFunction</code>","text":"Source code in <code>cylindra/plugin/function.py</code> <pre><code>class CylindraPluginFunction(Generic[_P, _R]):\n    def __init__(\n        self,\n        func: Callable[_P, _R],\n        name: str | None = None,\n        module: str | None = None,\n    ):\n        if not callable(func):\n            raise TypeError(\"func must be a callable\")\n        if not hasattr(func, \"__name__\"):\n            raise ValueError(\"func must have a __name__ attribute.\")\n        self._func = func\n        if name is None:\n            name = func.__name__.replace(\"_\", \" \").capitalize()\n        self._name = name\n        if module is None:\n            module = func.__module__\n        self._is_recordable = _is_recordable(func)\n        if module == \"__main__\" and self._is_recordable:\n            warnings.warn(\n                f\"Plugin function {func!r} is in the top-level module '__main__', \"\n                \"which means it is only defined during this session. Calls of this \"\n                \"function will be recorded in the macro but the script will not work. \"\n                \"Add 'record=False' to the `register_function` decorator, or define \"\n                \"plugin function in a separate module.\",\n                UserWarning,\n                stacklevel=2,\n            )\n        self._module = module\n        wraps(func)(self)\n        self.__signature__ = inspect.signature(func)\n        first_arg = next(iter(self.__signature__.parameters.values()))\n        self._ui_arg_name = first_arg.name\n        # check if the first argument is a CylindraMainWidget\n        if first_arg.annotation is not inspect.Parameter.empty:\n            from cylindra.widgets import CylindraMainWidget\n\n            if first_arg.annotation is not CylindraMainWidget:\n                warnings.warn(\n                    f\"The first argument of a plugin function {func!r} should be a \"\n                    f\"CylindraMainWidget but was {first_arg.annotation!r}.\",\n                    UserWarning,\n                    stacklevel=2,\n                )\n\n    def __repr__(self) -&gt; str:\n        return f\"{self.__class__.__name__}&lt;{self._name}&gt;\"\n\n    def import_statement(self) -&gt; str:\n        \"\"\"Make an import statement for the plugin\"\"\"\n        expr = f\"import {self._module}\"\n        try:\n            ast.parse(expr)\n        except SyntaxError:\n            raise ValueError(f\"Invalid import statement: {expr}\") from None\n        return expr\n\n    def update_module(self, mod: ModuleType):\n        \"\"\"Update the module name of the plugin function\"\"\"\n        self._module = mod.__name__\n        return self\n\n    def as_method(self, ui):\n        from magicclass.signature import upgrade_signature\n\n        def _method(*args: _P.args, **kwargs: _P.kwargs) -&gt; _R:\n            return self(ui, *args, **kwargs)\n\n        params = list(self.__signature__.parameters.values())\n        _method.__signature__ = inspect.Signature(params[1:])\n        _method.__name__ = self._name\n        _method.__doc__ = getattr(self._func, \"__doc__\", \"\")\n        if qualname := getattr(self._func, \"__qualname__\", None):\n            _method.__qualname__ = qualname\n        upgrade_signature(_method)\n        return _method\n\n    def __call__(self, *args: _P.args, **kwargs: _P.kwargs) -&gt; _R:\n        from macrokit import Expr, Symbol\n        from magicclass.undo import UndoCallback\n\n        from cylindra.widgets import CylindraMainWidget\n\n        bound = self.__signature__.bind(*args, **kwargs)\n        bound.apply_defaults()\n        ui = bound.arguments[self._ui_arg_name]\n        if not isinstance(ui, CylindraMainWidget):\n            raise TypeError(\n                f\"Expected a CylindraMainWidget instance as the first argument \"\n                f\"{self._ui_arg_name!r} but got {ui!r}\"\n            )\n        # TODO: how to use thread_worker?\n        out = self._func(*bound.args, **bound.kwargs)\n\n        # macro recording\n        _args = []\n        _kwargs = {}\n        for name, param in bound.signature.parameters.items():\n            if name == self._ui_arg_name:\n                _args.append(ui._my_symbol)\n            elif param.kind is inspect.Parameter.POSITIONAL_ONLY:\n                _args.append(bound.arguments[name])\n            else:\n                _kwargs[name] = bound.arguments[name]\n        fn_expr = Expr(\"getattr\", [Symbol(self._module), self._func.__name__])\n        expr = Expr.parse_call(fn_expr, tuple(_args), _kwargs)\n        ui.macro.append(expr)\n        ui.macro._last_setval = None\n        if self not in ui._plugins_called:\n            ui._plugins_called.append(self)\n        if isinstance(out, UndoCallback):\n            ui.macro._append_undo(out.with_name(str(expr)))\n            out = out.return_value\n        else:\n            ui.macro.clear_undo_stack()\n        return out\n</code></pre>"},{"location":"api/plugin/#cylindra.plugin.CylindraPluginFunction.import_statement","title":"<code>import_statement()</code>","text":"<p>Make an import statement for the plugin</p> Source code in <code>cylindra/plugin/function.py</code> <pre><code>def import_statement(self) -&gt; str:\n    \"\"\"Make an import statement for the plugin\"\"\"\n    expr = f\"import {self._module}\"\n    try:\n        ast.parse(expr)\n    except SyntaxError:\n        raise ValueError(f\"Invalid import statement: {expr}\") from None\n    return expr\n</code></pre>"},{"location":"api/plugin/#cylindra.plugin.CylindraPluginFunction.update_module","title":"<code>update_module(mod)</code>","text":"<p>Update the module name of the plugin function</p> Source code in <code>cylindra/plugin/function.py</code> <pre><code>def update_module(self, mod: ModuleType):\n    \"\"\"Update the module name of the plugin function\"\"\"\n    self._module = mod.__name__\n    return self\n</code></pre>"},{"location":"api/plugin/#cylindra.plugin.register_function","title":"<code>register_function(func=None, *, record=True, name=None)</code>","text":"<pre><code>register_function(func: Callable[_P, _R], *, record: bool = True, name: str | None = None) -&gt; CylindraPluginFunction[_P, _R]\n</code></pre><pre><code>register_function(func: Literal[None], *, record: bool = True, name: str | None = None) -&gt; Callable[..., CylindraPluginFunction[_P, _R]]\n</code></pre> <p>Register a function as a plugin function.</p> <p>The registered function will be added to the plugin menu when the module is installed as a plugin.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>callable</code> <p>The plugin function. If the function is to be called in the GUI, its signature must be interpretable for <code>magicgui</code>. The first argument of the function must be the <code>CylindraMainWidget</code> instance.</p> <code>None</code> <code>record</code> <code>bool</code> <p>If False, the function will not be recorded in the macro.</p> <code>True</code> <code>name</code> <code>str</code> <p>Name to display in the menu. If None, the capitalized function name will be used.</p> <code>None</code> Source code in <code>cylindra/plugin/core.py</code> <pre><code>def register_function(func=None, *, record=True, name=None):\n    \"\"\"Register a function as a plugin function.\n\n    The registered function will be added to the plugin menu when the module is\n    installed as a plugin.\n\n    Parameters\n    ----------\n    func : callable, optional\n        The plugin function. If the function is to be called in the GUI, its signature\n        must be interpretable for `magicgui`. The first argument of the function must be\n        the `CylindraMainWidget` instance.\n    record : bool, default True\n        If False, the function will not be recorded in the macro.\n    name : str, optional\n        Name to display in the menu. If None, the capitalized function name will be\n        used.\n    \"\"\"\n\n    def _inner(fn: Callable[_P, _R]) -&gt; CylindraPluginFunction[_P, _R]:\n        f = CylindraPluginFunction(fn, name=name)\n        if not record:\n            f._is_recordable = record\n        return f\n\n    return _inner if func is None else _inner(func)\n</code></pre>"},{"location":"api/project/","title":"cylindra.project","text":""},{"location":"api/project/#cylindra.project.CylindraBatchProject","title":"<code>CylindraBatchProject</code>","text":"<p>A project of cylindra batch processing.</p> Source code in <code>cylindra/project/_batch.py</code> <pre><code>class CylindraBatchProject(BaseProject):\n    \"\"\"A project of cylindra batch processing.\"\"\"\n\n    datetime: str\n    version: str\n    dependency_versions: dict[str, str]\n    children: list[ChildProjectInfo] = []\n    loaders: list[LoaderInfoModel]\n    project_path: Path | None = None\n\n    def resolve_path(self, file_dir: PathLike):\n        \"\"\"Resolve the path of the project.\"\"\"\n        file_dir = Path(file_dir)\n        self.loaders = [ldr.resolve_path(file_dir) for ldr in self.loaders]\n        return self\n\n    @property\n    def macro_path(self) -&gt; Path:\n        return self.project_path / \"script.py\"\n\n    @classmethod\n    def from_gui(\n        cls,\n        gui: \"CylindraBatchWidget\",\n        project_dir: Path,\n        mole_ext: str = \".csv\",\n    ) -&gt; \"CylindraBatchProject\":\n        from datetime import datetime\n\n        _versions = get_versions()\n\n        def as_relative(p: Path):\n            assert isinstance(p, Path)\n            try:\n                out = p.relative_to(project_dir)\n            except Exception:\n                out = p\n            return out\n\n        loaders = list[LoaderInfoModel]()\n        for info in gui._loaders:\n            name = info.name\n            loaders.append(\n                LoaderInfoModel(\n                    molecule=project_dir / f\"Molecules-{name}{mole_ext}\",\n                    name=name,\n                    images=[\n                        ImageInfo(\n                            id=id,\n                            image=as_relative(fp),\n                            scale=info.loader.scale,\n                            invert=info.invert.get(id, False),\n                        )\n                        for id, fp in info.image_paths.items()\n                    ],\n                    scale=info.loader.scale,\n                )\n            )\n\n        children = list[ChildProjectInfo]()\n        for child_widget in gui.constructor.projects:\n            child_project_path = as_relative(Path(child_widget.path))\n            if child_project_path is None:\n                warnings.warn(\n                    f\"Child project path {child_widget.path!r} could not be resolved \"\n                    f\"as relative to {project_dir}, skipping.\",\n                    UserWarning,\n                    stacklevel=1,\n                )\n                continue\n            spl_checked = [s.check for s in child_widget.splines]\n            mol_checked = [m.check for m in child_widget.molecules]\n            info = ChildProjectInfo(\n                path=child_project_path,\n                spline_selected=spl_checked,\n                molecules_selected=mol_checked,\n            )\n            children.append(info)\n        return cls(\n            datetime=datetime.now().strftime(\"%Y/%m/%d %H:%M:%S\"),\n            version=next(iter(_versions.values())),\n            dependency_versions=_versions,\n            children=children,\n            loaders=loaders,\n            project_path=project_dir,\n        )\n\n    @classmethod\n    def save_gui(\n        cls: \"type[CylindraBatchProject]\",\n        gui: \"CylindraBatchWidget\",\n        project_dir: Path,\n        mole_ext: str = \".csv\",\n    ) -&gt; None:\n        \"\"\"Save the GUI state to a project directory.\"\"\"\n        self = cls.from_gui(gui, project_dir, mole_ext)\n\n        if not project_dir.exists():\n            project_dir.mkdir()\n\n        # save molecules\n        for lmodel, info in zip(self.loaders, gui._loaders, strict=True):\n            info.loader.molecules.to_file(lmodel.molecule)\n\n        self.project_path.joinpath(\"script.py\").write_text(as_main_function(gui.macro))\n\n        # save objects\n        self.to_json(project_dir / \"project.json\")\n\n    def _to_gui(self, gui: \"CylindraBatchWidget\") -&gt; None:\n        import impy as ip\n        from acryo import BatchLoader, Molecules\n\n        gui.constructor.clear_projects()\n        for child in self.children:\n            # solve relative path\n            child_path = resolve_relative_paths(child.path, self.project_path)\n            if child_path is None:\n                warnings.warn(\n                    f\"Child project path {child.path!r} could not be resolved \"\n                    f\"as relative to {self.project_path}, skipping.\",\n                    UserWarning,\n                    stacklevel=1,\n                )\n                continue\n            gui.constructor.add_projects([child_path], clear=False)\n            last_project = gui.constructor.projects[-1]\n            for spl_widget, checked in zip(\n                iter(last_project.splines), child.spline_selected, strict=False\n            ):\n                spl_widget.check = checked\n            for mol_widget, checked in zip(\n                iter(last_project.molecules), child.molecules_selected, strict=False\n            ):\n                mol_widget.check = checked\n        for lmodel in self.loaders:\n            loader = BatchLoader(scale=lmodel.scale)\n            mole_dict = dict(Molecules.from_file(lmodel.molecule).groupby(Mole.image))\n            for imginfo in lmodel.images:\n                loader.add_tomogram(\n                    image=ip.lazy.imread(imginfo.image, chunks=get_config().dask_chunk)\n                    .set_scale(zyx=imginfo.scale)\n                    .value,\n                    molecules=mole_dict[imginfo.id],\n                    image_id=imginfo.id,\n                )\n            image_paths = {imginfo.id: imginfo.image for imginfo in lmodel.images}\n            invert = {imginfo.id: imginfo.invert for imginfo in lmodel.images}\n            gui._add_loader(loader, lmodel.name, image_paths, invert)\n\n        txt = self.project_path.joinpath(\"script.py\").read_text()\n        macro = mk.parse(txt)\n        gui.macro.extend(macro.args)\n        gui.reset_choices()\n</code></pre>"},{"location":"api/project/#cylindra.project.CylindraBatchProject.resolve_path","title":"<code>resolve_path(file_dir)</code>","text":"<p>Resolve the path of the project.</p> Source code in <code>cylindra/project/_batch.py</code> <pre><code>def resolve_path(self, file_dir: PathLike):\n    \"\"\"Resolve the path of the project.\"\"\"\n    file_dir = Path(file_dir)\n    self.loaders = [ldr.resolve_path(file_dir) for ldr in self.loaders]\n    return self\n</code></pre>"},{"location":"api/project/#cylindra.project.CylindraBatchProject.save_gui","title":"<code>save_gui(gui, project_dir, mole_ext='.csv')</code>  <code>classmethod</code>","text":"<p>Save the GUI state to a project directory.</p> Source code in <code>cylindra/project/_batch.py</code> <pre><code>@classmethod\ndef save_gui(\n    cls: \"type[CylindraBatchProject]\",\n    gui: \"CylindraBatchWidget\",\n    project_dir: Path,\n    mole_ext: str = \".csv\",\n) -&gt; None:\n    \"\"\"Save the GUI state to a project directory.\"\"\"\n    self = cls.from_gui(gui, project_dir, mole_ext)\n\n    if not project_dir.exists():\n        project_dir.mkdir()\n\n    # save molecules\n    for lmodel, info in zip(self.loaders, gui._loaders, strict=True):\n        info.loader.molecules.to_file(lmodel.molecule)\n\n    self.project_path.joinpath(\"script.py\").write_text(as_main_function(gui.macro))\n\n    # save objects\n    self.to_json(project_dir / \"project.json\")\n</code></pre>"},{"location":"api/project/#cylindra.project.CylindraProject","title":"<code>CylindraProject</code>","text":"<p>A project of cylindra.</p> Source code in <code>cylindra/project/_single.py</code> <pre><code>class CylindraProject(BaseProject):\n    \"\"\"A project of cylindra.\"\"\"\n\n    # this allows extra fields in the json file, for backward compatibility\n    model_config = ConfigDict(extra=\"allow\")\n\n    datetime: str\n    version: str\n    dependency_versions: dict[str, str]\n    image: PathLike | None\n    \"\"\"Path to the image file.\"\"\"\n    image_relative: PathLike | None = None\n    \"\"\"Relative path to the image file, used as a fallback.\"\"\"\n    cache_image: bool = False\n    \"\"\"Whether to cache the image in SSD.\"\"\"\n    scale: float\n    \"\"\"Scale of the image, in nm/pixel.\"\"\"\n    image_reference: PathLike | None = None\n    \"\"\"Path to the reference image.\"\"\"\n    invert: bool = False\n    \"\"\"Whether to invert the image when loaded.\"\"\"\n    multiscales: list[int]\n    \"\"\"List of bin factors for multiscale tomogram.\"\"\"\n    molecules_info: list[MoleculesInfo] = Field(default_factory=list)\n    landscape_info: list[LandscapeInfo] = Field(default_factory=list)\n    interaction_info: list[InteractionInfo] = Field(default_factory=list)\n    missing_wedge: MissingWedge = MissingWedge(params={}, kind=\"none\")\n    \"\"\"Missing wedge model, used for masking subtomograms.\"\"\"\n    project_path: Path | None = None\n    project_description: str = \"\"\n    metadata: dict[str, Any] = Field(default_factory=dict)\n\n    def resolve_path(self, file_dir: PathLike):\n        \"\"\"Resolve the path of the project.\"\"\"\n        file_dir = Path(file_dir)\n        self.image = resolve_path(self.image, file_dir)\n        return self\n\n    @classmethod\n    def new(\n        cls,\n        image: PathLike,\n        scale: float | None,\n        image_reference: PathLike | None = None,\n        multiscales: list[int] = [1],\n        missing_wedge: Any | None = None,\n        invert: bool = False,\n        project_path: Path | None = None,\n    ):\n        \"\"\"Create a new project.\"\"\"\n        _versions = get_versions()\n        if image is None:\n            raise ValueError(\"image must not be None.\")\n        if scale is None:\n            import impy as ip\n\n            header = ip.read_header(image)\n            scale = header.scale[\"x\"]\n        return CylindraProject(\n            datetime=datetime.now().strftime(\"%Y/%m/%d %H:%M:%S\"),\n            version=_versions.pop(\"cylindra\", \"unknown\"),\n            dependency_versions=_versions,\n            image=image,\n            image_reference=image_reference,\n            scale=scale,\n            multiscales=list(multiscales),\n            missing_wedge=MissingWedge.parse(missing_wedge),\n            invert=invert,\n            project_path=project_path,\n        )\n\n    def save(\n        self,\n        project_dir: Path,\n        splines: \"list[CylSpline]\" = [],\n        molecules: \"dict[str, Molecules]\" = {},\n    ) -&gt; None:\n        \"\"\"Save this project.\"\"\"\n        from macrokit import parse\n\n        from cylindra.components.tomogram._spline_list import SplineList\n\n        path = Path(self.image).as_posix()\n        scale = self.scale\n        bin_size = self.multiscales\n        tilt_range = self.missing_wedge.as_param()\n        with _prep_save_dir(project_dir) as results_dir:\n            expr_open = parse(\n                f\"ui.open_image({path=}, {scale=:.4f}, {bin_size=}, {tilt_range=})\",\n                squeeze=False,\n            )\n            expr = as_main_function(expr_open)\n            self._script_py_path(results_dir).write_text(expr)\n            self_copy = self.model_copy()\n            spl_list = SplineList(splines)\n            if (df_loc := spl_list.collect_localprops()) is not None:\n                df_loc.write_csv(self._localprops_path(results_dir))\n            if (df_glob := spl_list.collect_globalprops()) is not None:\n                df_glob.write_csv(self._globalprops_path(results_dir))\n            for ith, spl in spl_list.enumerate():\n                spl.to_json(results_dir / f\"spline-{ith}.json\")\n            for name, mole in molecules.items():\n                save_path = results_dir / name\n                if save_path.suffix == \"\":\n                    save_path = save_path.with_suffix(\".csv\")\n                self_copy.molecules_info.append(MoleculesInfo(name=save_path.name))\n                mole.to_file(save_path)\n            self_copy.to_json(self._project_json_path(results_dir))\n\n    @classmethod\n    def from_gui(\n        cls,\n        gui: \"CylindraMainWidget\",\n        project_dir: Path,\n        mole_ext: str = \".csv\",\n        save_landscape: bool = False,\n    ) -&gt; \"CylindraProject\":\n        \"\"\"Construct a project from a widget state.\"\"\"\n        from cylindra._napari import InteractionVector, LandscapeSurface\n\n        _versions = get_versions()\n        tomo = gui.tomogram\n\n        # Save path of molecules\n        mole_infos = list[MoleculesInfo]()\n        for layer in gui.mole_layers:\n            mole_infos.append(MoleculesInfo.from_layer(gui, layer, mole_ext))\n\n        # Save paths of landscape\n        landscape_infos = list[LandscapeInfo]()\n        if save_landscape:\n            for layer in gui.parent_viewer.layers:\n                if isinstance(layer, LandscapeSurface):\n                    landscape_infos.append(LandscapeInfo.from_layer(gui, layer))\n\n        # Save paths of interaction\n        interaction_infos = list[InteractionInfo]()\n        for layer in gui.parent_viewer.layers:\n            if isinstance(layer, InteractionVector):\n                interaction_infos.append(InteractionInfo.from_layer(gui, layer))\n\n        orig_path = tomo.metadata.get(\"orig_path\", None)\n        img_ref_path = gui._reserved_layers.image_data.source\n        if tomo.metadata.get(\"source\", None) == img_ref_path:\n            img_ref_path = None\n        return cls(\n            datetime=datetime.now().strftime(\"%Y/%m/%d %H:%M:%S\"),\n            version=_versions.pop(\"cylindra\", \"unknown\"),\n            dependency_versions=_versions,\n            image=orig_path,\n            image_relative=as_relative(orig_path, project_dir),\n            cache_image=tomo.metadata.get(\"cache_image\", False),\n            scale=tomo.scale,\n            image_reference=img_ref_path,\n            invert=tomo.is_inverted,\n            multiscales=[x[0] for x in tomo.multiscaled],\n            molecules_info=mole_infos,\n            landscape_info=landscape_infos,\n            interaction_info=interaction_infos,\n            missing_wedge=MissingWedge.parse(tomo.tilt),\n            project_path=project_dir,\n        )\n\n    @classmethod\n    def save_gui(\n        cls: \"type[CylindraProject]\",\n        gui: \"CylindraMainWidget\",\n        project_dir: Path,\n        mole_ext: str = \".csv\",\n        save_landscape: bool = False,\n    ) -&gt; None:\n        \"\"\"Serialize the GUI state to a json file.\n\n        Parameters\n        ----------\n        gui : CylindraMainWidget\n            The main widget from which project model will be constructed.\n        project_dir : Path\n            The path to the project json file.\n        \"\"\"\n        self = cls.from_gui(gui, project_dir, mole_ext, save_landscape)\n\n        tomo = gui.tomogram\n        localprops = tomo.splines.collect_localprops(allow_none=True)\n        globalprops = tomo.splines.collect_globalprops(allow_none=True)\n\n        with _prep_save_dir(project_dir) as results_dir:\n            if localprops is not None:\n                localprops.write_csv(self._localprops_path(results_dir))\n            if globalprops is not None:\n                globalprops.write_csv(self._globalprops_path(results_dir))\n            for i, spl in enumerate(gui.tomogram.splines):\n                spl.to_json(results_dir / f\"spline-{i}.json\")\n            for info in (\n                self.molecules_info + self.landscape_info + self.interaction_info\n            ):\n                info.save_layer(gui, results_dir)\n\n            _cfg_json = gui.default_config.json_dumps()\n            self._default_spline_config_path(results_dir).write_text(_cfg_json)\n\n            # save macro\n            expr = as_main_function(\n                gui._format_macro(gui.macro[gui._macro_offset :]),\n                imports=[plg.import_statement() for plg in gui._plugins_called],\n            )\n            self._script_py_path(results_dir).write_text(expr)\n\n            self.project_description = gui.GeneralInfo.project_desc.value\n\n            # dry run metadata serialization\n            try:\n                json.dumps(\n                    gui._project_metadata,\n                    default=project_json_encoder,\n                )\n            except Exception:  # pragma: no cover\n                warnings.warn(\n                    \"Project metadata is not serializable. Skipping.\",\n                    UserWarning,\n                    stacklevel=2,\n                )\n            else:\n                self.metadata = gui._project_metadata\n            self.to_json(self._project_json_path(results_dir))\n\n    def _to_gui(\n        self,\n        gui: \"CylindraMainWidget | None\" = None,\n        filter: \"ImageFilter | None\" = True,\n        read_image: bool = True,\n        read_reference: bool = True,\n        update_config: bool = True,\n    ):\n        \"\"\"Update CylindraMainWidget state based on the project model.\"\"\"\n        import impy as ip\n        from magicclass.utils import thread_worker\n\n        from cylindra.components import SplineConfig\n\n        gui = _get_instance(gui)\n        if (\n            read_reference\n            and self.image_reference\n            and Path(self.image_reference).exists()\n        ):\n            path_ref = Path(self.image_reference)\n        else:\n            path_ref = None\n        with self.open_project() as project_dir:\n            tomogram = self.load_tomogram(\n                project_dir, compute=read_image and path_ref is None\n            )\n            macro_expr = extract(self._script_py_path(project_dir).read_text()).args\n            cfg_path = project_dir / \"default_spline_config.json\"\n            if cfg_path.exists() and update_config:\n                default_config = SplineConfig.from_file(cfg_path)\n            else:\n                default_config = None\n\n            cb = gui._send_tomogram_to_viewer.with_args(\n                tomogram, filt=filter, invert=self.invert\n            )\n            yield cb\n            cb.await_call()\n            gui._init_macro_state()\n\n            if path_ref:\n                try:\n                    img_ref = ip.imread(path_ref)\n                except Exception as e:\n                    LOGGER.warning(\n                        f\"Cannot read reference image at {path_ref.as_posix()}: {e}\"\n                    )\n                    img_ref = None\n                else:\n                    cb = thread_worker.callback(gui._update_reference_image).with_args(\n                        img_ref\n                    )\n                    yield cb\n                    cb.await_call()\n\n            @thread_worker.callback\n            def _update_widget():\n                if len(tomogram.splines) &gt; 0:\n                    gui._update_splines_in_images()\n                    with gui.macro.blocked():\n                        gui.sample_subtomograms()\n                if default_config is not None:\n                    gui.default_config = default_config\n\n                gui.macro.extend(macro_expr)\n\n                # load subtomogram analyzer state\n                gui.reset_choices()\n                gui._need_save = False\n\n            yield _update_widget\n            _update_widget.await_call()\n\n            # load molecules and landscapes\n            _add_layer = thread_worker.callback(gui.parent_viewer.add_layer)\n            with gui._pend_reset_choices():\n                for info in (\n                    self.molecules_info + self.landscape_info + self.interaction_info\n                ):\n                    layer = info.to_layer(gui, project_dir)\n                    cb = _add_layer.with_args(layer)\n                    yield cb\n                    cb.await_call(timeout=10)\n\n            gui._project_metadata = self.metadata\n\n        @thread_worker.callback\n        def out():\n            # update project description widget\n            gui.GeneralInfo.project_desc.value = self.project_description\n            gui.reset_choices()\n\n        return out\n\n    def load_spline(\n        self,\n        idx: int,\n        dir: Path | None = None,\n        props: bool = True,\n    ) -&gt; \"CylSpline\":\n        \"\"\"Load the spline of the given index.\n\n        &gt;&gt;&gt; spl = project.load_spline(0)  # load the 0-th spline instance\n\n        Parameters\n        ----------\n        idx : int\n            The index of the spline.\n        dir : Path, optional\n            The project directory. Can be given if the project is already opened.\n        props : bool, default True\n            Whether to load the properties of the spline.\n\n        Returns\n        -------\n        CylSpline\n            The spline instance.\n        \"\"\"\n        from cylindra.components import CylSpline\n\n        if dir is None:\n            with self.open_project() as dir:\n                return self.load_spline(idx, dir, props)\n        spl = CylSpline.from_json(dir / f\"spline-{idx}.json\")\n        if not props:\n            return spl\n        localprops_path = self._localprops_path(dir)\n        globalprops_path = self._globalprops_path(dir)\n        if localprops_path.exists():\n            _loc = pl.read_csv(localprops_path).filter(pl.col(H.spline_id) == idx)\n            _loc = _drop_null_columns(_loc)\n        else:\n            _loc = pl.DataFrame([])\n        if globalprops_path.exists():\n            _glob = pl.read_csv(globalprops_path)[idx]\n            _glob = _drop_null_columns(_glob)\n        else:\n            _glob = pl.DataFrame([])\n\n        if H.spl_dist in _loc.columns:\n            _loc = _loc.drop(H.spl_dist)\n        if H.spl_pos in _loc.columns:\n            spl._anchors = _loc[H.spl_pos].to_numpy()\n            _loc = _loc.drop(H.spl_pos)\n        for c in [H.spline_id, H.pos_id]:\n            if c in _loc.columns:\n                _loc = _loc.drop(c)\n        spl.props.loc = cast_dataframe(_loc)\n        spl.props.glob = cast_dataframe(_glob)\n\n        return spl\n\n    def iter_spline_paths(\n        self, dir: Path | None = None\n    ) -&gt; \"Iterable[tuple[int, Path]]\":\n        \"\"\"Iterate over the paths of splines and their indices.\"\"\"\n        if dir is None:\n            with self.open_project() as dir:\n                paths = list(dir.glob(\"spline-*.json\"))\n        else:\n            paths = list(dir.glob(\"spline-*.json\"))\n        # sort by index\n        idx_paths = [(int(p.stem.split(\"-\")[1]), p) for p in paths]\n        idx_paths.sort(key=lambda x: x[0])\n        yield from idx_paths\n\n    def iter_load_splines(\n        self,\n        dir: Path | None = None,\n        drop_columns: bool = True,\n    ) -&gt; \"Iterable[CylSpline]\":\n        \"\"\"Load all splines including its properties iteratively.\"\"\"\n        from cylindra.components import CylSpline\n\n        if dir is None:\n            with self.open_project() as dir:\n                yield from self.iter_load_splines(dir, drop_columns)\n            return\n\n        localprops_path = self._localprops_path(dir)\n        globalprops_path = self._globalprops_path(dir)\n        if localprops_path.exists():\n            _localprops = pl.read_csv(localprops_path)\n        else:\n            _localprops = None\n        if globalprops_path.exists():\n            _globalprops = pl.read_csv(globalprops_path)\n        else:\n            _globalprops = None\n        for idx, spl_path in self.iter_spline_paths(dir):\n            spl = CylSpline.from_json(spl_path)\n            if _localprops is not None:\n                _loc = _localprops.filter(pl.col(H.spline_id) == idx)\n                _loc = _drop_null_columns(_loc)\n                if len(_loc) == 0:\n                    _loc = pl.DataFrame([])\n            else:\n                _loc = pl.DataFrame([])\n            if _globalprops is not None:\n                _glob = _globalprops.filter(pl.col(H.spline_id) == idx)\n                _glob = _drop_null_columns(_glob)\n                if len(_glob) == 0:\n                    _glob = pl.DataFrame([])\n            else:\n                _glob = pl.DataFrame([])\n\n            if H.spl_dist in _loc.columns and drop_columns:\n                _loc = _loc.drop(H.spl_dist)\n            if H.spl_pos in _loc.columns:\n                spl._anchors = _loc[H.spl_pos].to_numpy()\n                if drop_columns:\n                    _loc = _loc.drop(H.spl_pos)\n            for c in [H.spline_id, H.pos_id]:\n                if c in _loc.columns and drop_columns:\n                    _loc = _loc.drop(c)\n            spl.props.loc = cast_dataframe(_loc)\n            spl.props.glob = cast_dataframe(_glob)\n            yield spl\n\n    def iter_load_molecules(\n        self, dir: Path | None = None\n    ) -&gt; \"Iterable[tuple[MoleculesInfo, Molecules]]\":\n        \"\"\"Load all molecules iteratively.\"\"\"\n        from acryo import Molecules\n\n        if dir is None:\n            with self.open_project() as dir:\n                yield from self.iter_load_molecules(dir)\n            return\n\n        for info in self.molecules_info:\n            path = dir / info.name\n            if not path.exists():\n                LOGGER.warning(\n                    f\"Cannot find molecule file: {path.as_posix()}. \"\n                    \"Probably it was moved?\"\n                )\n                continue\n            mole = Molecules.from_file(path)\n            yield info, mole\n\n    def load_molecules(self, name: str, dir: Path | None = None) -&gt; \"Molecules\":\n        \"\"\"Load the molecule with the given name.\n\n        &gt;&gt;&gt; mole = project.load_molecules(\"Mole-0\")  # load one with name \"Mole-0\"\n\n        Parameters\n        ----------\n        name : str\n            Name of the molecules layer.\n        dir : Path, optional\n            The project directory. Can be given if the project is already opened.\n\n        Returns\n        -------\n        Molecules\n            The molecules instance that matches the given name.\n        \"\"\"\n        from acryo import Molecules\n\n        if dir is None:\n            with self.open_project() as dir:\n                return self.load_molecules(name, dir)\n        for info in self.molecules_info:\n            if info.name == name or info.stem == name:\n                path = dir / info.name\n                if not path.exists():\n                    raise ValueError(\n                        f\"Cannot find molecule file: {path.as_posix()}. Probably the \"\n                        \"`dir` parameter is not correct.\"\n                    )\n                return Molecules.from_file(path)\n        raise ValueError(f\"Cannot find molecule with name: {name}.\")\n\n    def load_tomogram(\n        self,\n        dir: Path | None = None,\n        compute: bool = True,\n    ) -&gt; \"CylTomogram\":\n        \"\"\"Load the tomogram object of the project.\n\n        Parameters\n        ----------\n        dir : Path, optional\n            Can be given if the project is already opened.\n        compute : bool, optional\n            Whether to compute the binned tomograms.\n        \"\"\"\n        from cylindra.components import CylTomogram\n\n        if self.image is not None:\n            if self.cache_image:\n                read_path = _config.cache_tomogram(self.image)\n            else:\n                read_path = Path(self.image)\n            if read_path.exists():\n                tomo = CylTomogram.imread(\n                    path=read_path,\n                    scale=self.scale,\n                    tilt=self.missing_wedge.as_param(),\n                    binsize=self.multiscales,\n                    compute=compute,\n                ).with_cache_info(orig_path=Path(self.image), cached=self.cache_image)\n            elif _rpath := self._try_resolve_image_relative():\n                tomo = CylTomogram.imread(\n                    path=_rpath,\n                    scale=self.scale,\n                    tilt=self.missing_wedge.as_param(),\n                    binsize=self.multiscales,\n                    compute=compute,\n                ).with_cache_info(orig_path=Path(self.image), cached=self.cache_image)\n            else:\n                LOGGER.warning(\n                    f\"Cannot find image file: {read_path.as_posix()}. \"\n                    \"Load other components only.\",\n                )\n                tomo = CylTomogram.dummy(\n                    scale=self.scale,\n                    tilt=self.missing_wedge.as_param(),\n                    binsize=self.multiscales,\n                    name=\"&lt;Image not found&gt;\",\n                )\n        else:\n            tomo = CylTomogram.dummy(\n                scale=self.scale,\n                tilt=self.missing_wedge.as_param(),\n                binsize=self.multiscales,\n                name=\"&lt;No image&gt;\",\n            )\n        tomo.splines.extend(self.iter_load_splines(dir))\n        return tomo\n\n    def _try_resolve_image_relative(self) -&gt; Path | None:\n        if self.image_relative is None or self.project_path is None:\n            return None\n        return resolve_relative_paths(self.image_relative, self.project_path.parent)\n\n    def make_project_viewer(self):\n        \"\"\"Build a project viewer widget from this project.\"\"\"\n        from cylindra.project._widgets import ProjectViewer\n\n        pviewer = ProjectViewer()\n        pviewer._from_project(self)\n        return pviewer\n\n    def make_component_viewer(self):\n        \"\"\"Build a molecules viewer widget from this project.\"\"\"\n        from cylindra.project._widgets import ComponentsViewer\n\n        mviewer = ComponentsViewer()\n        mviewer._from_project(self)\n        return mviewer\n\n    @contextmanager\n    def open_project(self) -&gt; Generator[Path, None, None]:\n        \"\"\"Open the project within this context.\"\"\"\n        if self.project_path is None:\n            raise ValueError(\"Project path is not set.\")\n        ext = self.project_path.suffix\n        if ext == \"\":\n            yield self.project_path\n\n        elif ext in (\".tar\",):\n            import tarfile\n\n            with tempfile.TemporaryDirectory() as tmpdir:\n                with tarfile.open(self.project_path) as tar:\n                    _tar_extract_all(tar, tmpdir)\n                yield Path(tmpdir)\n\n        elif ext in (\".zip\",):\n            import zipfile\n\n            with tempfile.TemporaryDirectory() as tmpdir:\n                with zipfile.ZipFile(self.project_path) as _zip:\n                    _zip.extractall(tmpdir)\n                yield Path(tmpdir)\n\n        else:\n            raise ValueError(f\"Unsupported extension {ext}.\")\n\n        return None\n\n    def rewrite(self, dir: Path):\n        \"\"\"Rewrite tar/zip file using given temporary directory.\n\n        This method is only used after some mutable operation on the\n        project directory.\n        \"\"\"\n        if self.project_path is None:\n            raise ValueError(\"Project path is not set.\")\n\n        ext = self.project_path.suffix\n        if ext == \"\":\n            return\n\n        elif ext in (\".tar\",):\n            import tarfile\n\n            self.project_path.unlink()\n\n            with tarfile.open(self.project_path, mode=\"w\") as tar:\n                for file in Path(dir).glob(\"*\"):\n                    tar.add(file, arcname=file.name)\n\n        elif ext in (\".zip\",):\n            import zipfile\n\n            self.project_path.unlink()\n            with zipfile.ZipFile(self.project_path, mode=\"w\") as zip:\n                for file in Path(dir).glob(\"*\"):\n                    zip.write(file, arcname=file.name)\n\n        else:\n            raise ValueError(f\"Unsupported extension {ext}.\")\n\n        return None\n\n    def _localprops_path(self, dir: Path) -&gt; Path:\n        \"\"\"Path to the spline local properties file.\"\"\"\n        return dir / \"localprops.csv\"\n\n    def _globalprops_path(self, dir: Path) -&gt; Path:\n        \"\"\"Path to the spline global properties file.\"\"\"\n        return dir / \"globalprops.csv\"\n\n    def _default_spline_config_path(self, dir: Path) -&gt; Path:\n        \"\"\"Path to the default spline config file.\"\"\"\n        return dir / \"default_spline_config.json\"\n\n    def _script_py_path(self, dir: Path) -&gt; Path:\n        \"\"\"Path to the script.py file.\"\"\"\n        return dir / \"script.py\"\n\n    def _project_json_path(self, dir: Path) -&gt; Path:\n        \"\"\"Path to the project.json file.\"\"\"\n        return dir / \"project.json\"\n</code></pre>"},{"location":"api/project/#cylindra.project.CylindraProject.cache_image","title":"<code>cache_image = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether to cache the image in SSD.</p>"},{"location":"api/project/#cylindra.project.CylindraProject.image","title":"<code>image</code>  <code>instance-attribute</code>","text":"<p>Path to the image file.</p>"},{"location":"api/project/#cylindra.project.CylindraProject.image_reference","title":"<code>image_reference = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Path to the reference image.</p>"},{"location":"api/project/#cylindra.project.CylindraProject.image_relative","title":"<code>image_relative = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Relative path to the image file, used as a fallback.</p>"},{"location":"api/project/#cylindra.project.CylindraProject.invert","title":"<code>invert = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether to invert the image when loaded.</p>"},{"location":"api/project/#cylindra.project.CylindraProject.missing_wedge","title":"<code>missing_wedge = MissingWedge(params={}, kind='none')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Missing wedge model, used for masking subtomograms.</p>"},{"location":"api/project/#cylindra.project.CylindraProject.multiscales","title":"<code>multiscales</code>  <code>instance-attribute</code>","text":"<p>List of bin factors for multiscale tomogram.</p>"},{"location":"api/project/#cylindra.project.CylindraProject.scale","title":"<code>scale</code>  <code>instance-attribute</code>","text":"<p>Scale of the image, in nm/pixel.</p>"},{"location":"api/project/#cylindra.project.CylindraProject.from_gui","title":"<code>from_gui(gui, project_dir, mole_ext='.csv', save_landscape=False)</code>  <code>classmethod</code>","text":"<p>Construct a project from a widget state.</p> Source code in <code>cylindra/project/_single.py</code> <pre><code>@classmethod\ndef from_gui(\n    cls,\n    gui: \"CylindraMainWidget\",\n    project_dir: Path,\n    mole_ext: str = \".csv\",\n    save_landscape: bool = False,\n) -&gt; \"CylindraProject\":\n    \"\"\"Construct a project from a widget state.\"\"\"\n    from cylindra._napari import InteractionVector, LandscapeSurface\n\n    _versions = get_versions()\n    tomo = gui.tomogram\n\n    # Save path of molecules\n    mole_infos = list[MoleculesInfo]()\n    for layer in gui.mole_layers:\n        mole_infos.append(MoleculesInfo.from_layer(gui, layer, mole_ext))\n\n    # Save paths of landscape\n    landscape_infos = list[LandscapeInfo]()\n    if save_landscape:\n        for layer in gui.parent_viewer.layers:\n            if isinstance(layer, LandscapeSurface):\n                landscape_infos.append(LandscapeInfo.from_layer(gui, layer))\n\n    # Save paths of interaction\n    interaction_infos = list[InteractionInfo]()\n    for layer in gui.parent_viewer.layers:\n        if isinstance(layer, InteractionVector):\n            interaction_infos.append(InteractionInfo.from_layer(gui, layer))\n\n    orig_path = tomo.metadata.get(\"orig_path\", None)\n    img_ref_path = gui._reserved_layers.image_data.source\n    if tomo.metadata.get(\"source\", None) == img_ref_path:\n        img_ref_path = None\n    return cls(\n        datetime=datetime.now().strftime(\"%Y/%m/%d %H:%M:%S\"),\n        version=_versions.pop(\"cylindra\", \"unknown\"),\n        dependency_versions=_versions,\n        image=orig_path,\n        image_relative=as_relative(orig_path, project_dir),\n        cache_image=tomo.metadata.get(\"cache_image\", False),\n        scale=tomo.scale,\n        image_reference=img_ref_path,\n        invert=tomo.is_inverted,\n        multiscales=[x[0] for x in tomo.multiscaled],\n        molecules_info=mole_infos,\n        landscape_info=landscape_infos,\n        interaction_info=interaction_infos,\n        missing_wedge=MissingWedge.parse(tomo.tilt),\n        project_path=project_dir,\n    )\n</code></pre>"},{"location":"api/project/#cylindra.project.CylindraProject.iter_load_molecules","title":"<code>iter_load_molecules(dir=None)</code>","text":"<p>Load all molecules iteratively.</p> Source code in <code>cylindra/project/_single.py</code> <pre><code>def iter_load_molecules(\n    self, dir: Path | None = None\n) -&gt; \"Iterable[tuple[MoleculesInfo, Molecules]]\":\n    \"\"\"Load all molecules iteratively.\"\"\"\n    from acryo import Molecules\n\n    if dir is None:\n        with self.open_project() as dir:\n            yield from self.iter_load_molecules(dir)\n        return\n\n    for info in self.molecules_info:\n        path = dir / info.name\n        if not path.exists():\n            LOGGER.warning(\n                f\"Cannot find molecule file: {path.as_posix()}. \"\n                \"Probably it was moved?\"\n            )\n            continue\n        mole = Molecules.from_file(path)\n        yield info, mole\n</code></pre>"},{"location":"api/project/#cylindra.project.CylindraProject.iter_load_splines","title":"<code>iter_load_splines(dir=None, drop_columns=True)</code>","text":"<p>Load all splines including its properties iteratively.</p> Source code in <code>cylindra/project/_single.py</code> <pre><code>def iter_load_splines(\n    self,\n    dir: Path | None = None,\n    drop_columns: bool = True,\n) -&gt; \"Iterable[CylSpline]\":\n    \"\"\"Load all splines including its properties iteratively.\"\"\"\n    from cylindra.components import CylSpline\n\n    if dir is None:\n        with self.open_project() as dir:\n            yield from self.iter_load_splines(dir, drop_columns)\n        return\n\n    localprops_path = self._localprops_path(dir)\n    globalprops_path = self._globalprops_path(dir)\n    if localprops_path.exists():\n        _localprops = pl.read_csv(localprops_path)\n    else:\n        _localprops = None\n    if globalprops_path.exists():\n        _globalprops = pl.read_csv(globalprops_path)\n    else:\n        _globalprops = None\n    for idx, spl_path in self.iter_spline_paths(dir):\n        spl = CylSpline.from_json(spl_path)\n        if _localprops is not None:\n            _loc = _localprops.filter(pl.col(H.spline_id) == idx)\n            _loc = _drop_null_columns(_loc)\n            if len(_loc) == 0:\n                _loc = pl.DataFrame([])\n        else:\n            _loc = pl.DataFrame([])\n        if _globalprops is not None:\n            _glob = _globalprops.filter(pl.col(H.spline_id) == idx)\n            _glob = _drop_null_columns(_glob)\n            if len(_glob) == 0:\n                _glob = pl.DataFrame([])\n        else:\n            _glob = pl.DataFrame([])\n\n        if H.spl_dist in _loc.columns and drop_columns:\n            _loc = _loc.drop(H.spl_dist)\n        if H.spl_pos in _loc.columns:\n            spl._anchors = _loc[H.spl_pos].to_numpy()\n            if drop_columns:\n                _loc = _loc.drop(H.spl_pos)\n        for c in [H.spline_id, H.pos_id]:\n            if c in _loc.columns and drop_columns:\n                _loc = _loc.drop(c)\n        spl.props.loc = cast_dataframe(_loc)\n        spl.props.glob = cast_dataframe(_glob)\n        yield spl\n</code></pre>"},{"location":"api/project/#cylindra.project.CylindraProject.iter_spline_paths","title":"<code>iter_spline_paths(dir=None)</code>","text":"<p>Iterate over the paths of splines and their indices.</p> Source code in <code>cylindra/project/_single.py</code> <pre><code>def iter_spline_paths(\n    self, dir: Path | None = None\n) -&gt; \"Iterable[tuple[int, Path]]\":\n    \"\"\"Iterate over the paths of splines and their indices.\"\"\"\n    if dir is None:\n        with self.open_project() as dir:\n            paths = list(dir.glob(\"spline-*.json\"))\n    else:\n        paths = list(dir.glob(\"spline-*.json\"))\n    # sort by index\n    idx_paths = [(int(p.stem.split(\"-\")[1]), p) for p in paths]\n    idx_paths.sort(key=lambda x: x[0])\n    yield from idx_paths\n</code></pre>"},{"location":"api/project/#cylindra.project.CylindraProject.load_molecules","title":"<code>load_molecules(name, dir=None)</code>","text":"<p>Load the molecule with the given name.</p> <pre><code>mole = project.load_molecules(\"Mole-0\")  # load one with name \"Mole-0\"\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the molecules layer.</p> required <code>dir</code> <code>Path</code> <p>The project directory. Can be given if the project is already opened.</p> <code>None</code> <p>Returns:</p> Type Description <code>Molecules</code> <p>The molecules instance that matches the given name.</p> Source code in <code>cylindra/project/_single.py</code> <pre><code>def load_molecules(self, name: str, dir: Path | None = None) -&gt; \"Molecules\":\n    \"\"\"Load the molecule with the given name.\n\n    &gt;&gt;&gt; mole = project.load_molecules(\"Mole-0\")  # load one with name \"Mole-0\"\n\n    Parameters\n    ----------\n    name : str\n        Name of the molecules layer.\n    dir : Path, optional\n        The project directory. Can be given if the project is already opened.\n\n    Returns\n    -------\n    Molecules\n        The molecules instance that matches the given name.\n    \"\"\"\n    from acryo import Molecules\n\n    if dir is None:\n        with self.open_project() as dir:\n            return self.load_molecules(name, dir)\n    for info in self.molecules_info:\n        if info.name == name or info.stem == name:\n            path = dir / info.name\n            if not path.exists():\n                raise ValueError(\n                    f\"Cannot find molecule file: {path.as_posix()}. Probably the \"\n                    \"`dir` parameter is not correct.\"\n                )\n            return Molecules.from_file(path)\n    raise ValueError(f\"Cannot find molecule with name: {name}.\")\n</code></pre>"},{"location":"api/project/#cylindra.project.CylindraProject.load_spline","title":"<code>load_spline(idx, dir=None, props=True)</code>","text":"<p>Load the spline of the given index.</p> <pre><code>spl = project.load_spline(0)  # load the 0-th spline instance\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>int</code> <p>The index of the spline.</p> required <code>dir</code> <code>Path</code> <p>The project directory. Can be given if the project is already opened.</p> <code>None</code> <code>props</code> <code>bool</code> <p>Whether to load the properties of the spline.</p> <code>True</code> <p>Returns:</p> Type Description <code>CylSpline</code> <p>The spline instance.</p> Source code in <code>cylindra/project/_single.py</code> <pre><code>def load_spline(\n    self,\n    idx: int,\n    dir: Path | None = None,\n    props: bool = True,\n) -&gt; \"CylSpline\":\n    \"\"\"Load the spline of the given index.\n\n    &gt;&gt;&gt; spl = project.load_spline(0)  # load the 0-th spline instance\n\n    Parameters\n    ----------\n    idx : int\n        The index of the spline.\n    dir : Path, optional\n        The project directory. Can be given if the project is already opened.\n    props : bool, default True\n        Whether to load the properties of the spline.\n\n    Returns\n    -------\n    CylSpline\n        The spline instance.\n    \"\"\"\n    from cylindra.components import CylSpline\n\n    if dir is None:\n        with self.open_project() as dir:\n            return self.load_spline(idx, dir, props)\n    spl = CylSpline.from_json(dir / f\"spline-{idx}.json\")\n    if not props:\n        return spl\n    localprops_path = self._localprops_path(dir)\n    globalprops_path = self._globalprops_path(dir)\n    if localprops_path.exists():\n        _loc = pl.read_csv(localprops_path).filter(pl.col(H.spline_id) == idx)\n        _loc = _drop_null_columns(_loc)\n    else:\n        _loc = pl.DataFrame([])\n    if globalprops_path.exists():\n        _glob = pl.read_csv(globalprops_path)[idx]\n        _glob = _drop_null_columns(_glob)\n    else:\n        _glob = pl.DataFrame([])\n\n    if H.spl_dist in _loc.columns:\n        _loc = _loc.drop(H.spl_dist)\n    if H.spl_pos in _loc.columns:\n        spl._anchors = _loc[H.spl_pos].to_numpy()\n        _loc = _loc.drop(H.spl_pos)\n    for c in [H.spline_id, H.pos_id]:\n        if c in _loc.columns:\n            _loc = _loc.drop(c)\n    spl.props.loc = cast_dataframe(_loc)\n    spl.props.glob = cast_dataframe(_glob)\n\n    return spl\n</code></pre>"},{"location":"api/project/#cylindra.project.CylindraProject.load_tomogram","title":"<code>load_tomogram(dir=None, compute=True)</code>","text":"<p>Load the tomogram object of the project.</p> <p>Parameters:</p> Name Type Description Default <code>dir</code> <code>Path</code> <p>Can be given if the project is already opened.</p> <code>None</code> <code>compute</code> <code>bool</code> <p>Whether to compute the binned tomograms.</p> <code>True</code> Source code in <code>cylindra/project/_single.py</code> <pre><code>def load_tomogram(\n    self,\n    dir: Path | None = None,\n    compute: bool = True,\n) -&gt; \"CylTomogram\":\n    \"\"\"Load the tomogram object of the project.\n\n    Parameters\n    ----------\n    dir : Path, optional\n        Can be given if the project is already opened.\n    compute : bool, optional\n        Whether to compute the binned tomograms.\n    \"\"\"\n    from cylindra.components import CylTomogram\n\n    if self.image is not None:\n        if self.cache_image:\n            read_path = _config.cache_tomogram(self.image)\n        else:\n            read_path = Path(self.image)\n        if read_path.exists():\n            tomo = CylTomogram.imread(\n                path=read_path,\n                scale=self.scale,\n                tilt=self.missing_wedge.as_param(),\n                binsize=self.multiscales,\n                compute=compute,\n            ).with_cache_info(orig_path=Path(self.image), cached=self.cache_image)\n        elif _rpath := self._try_resolve_image_relative():\n            tomo = CylTomogram.imread(\n                path=_rpath,\n                scale=self.scale,\n                tilt=self.missing_wedge.as_param(),\n                binsize=self.multiscales,\n                compute=compute,\n            ).with_cache_info(orig_path=Path(self.image), cached=self.cache_image)\n        else:\n            LOGGER.warning(\n                f\"Cannot find image file: {read_path.as_posix()}. \"\n                \"Load other components only.\",\n            )\n            tomo = CylTomogram.dummy(\n                scale=self.scale,\n                tilt=self.missing_wedge.as_param(),\n                binsize=self.multiscales,\n                name=\"&lt;Image not found&gt;\",\n            )\n    else:\n        tomo = CylTomogram.dummy(\n            scale=self.scale,\n            tilt=self.missing_wedge.as_param(),\n            binsize=self.multiscales,\n            name=\"&lt;No image&gt;\",\n        )\n    tomo.splines.extend(self.iter_load_splines(dir))\n    return tomo\n</code></pre>"},{"location":"api/project/#cylindra.project.CylindraProject.make_component_viewer","title":"<code>make_component_viewer()</code>","text":"<p>Build a molecules viewer widget from this project.</p> Source code in <code>cylindra/project/_single.py</code> <pre><code>def make_component_viewer(self):\n    \"\"\"Build a molecules viewer widget from this project.\"\"\"\n    from cylindra.project._widgets import ComponentsViewer\n\n    mviewer = ComponentsViewer()\n    mviewer._from_project(self)\n    return mviewer\n</code></pre>"},{"location":"api/project/#cylindra.project.CylindraProject.make_project_viewer","title":"<code>make_project_viewer()</code>","text":"<p>Build a project viewer widget from this project.</p> Source code in <code>cylindra/project/_single.py</code> <pre><code>def make_project_viewer(self):\n    \"\"\"Build a project viewer widget from this project.\"\"\"\n    from cylindra.project._widgets import ProjectViewer\n\n    pviewer = ProjectViewer()\n    pviewer._from_project(self)\n    return pviewer\n</code></pre>"},{"location":"api/project/#cylindra.project.CylindraProject.new","title":"<code>new(image, scale, image_reference=None, multiscales=[1], missing_wedge=None, invert=False, project_path=None)</code>  <code>classmethod</code>","text":"<p>Create a new project.</p> Source code in <code>cylindra/project/_single.py</code> <pre><code>@classmethod\ndef new(\n    cls,\n    image: PathLike,\n    scale: float | None,\n    image_reference: PathLike | None = None,\n    multiscales: list[int] = [1],\n    missing_wedge: Any | None = None,\n    invert: bool = False,\n    project_path: Path | None = None,\n):\n    \"\"\"Create a new project.\"\"\"\n    _versions = get_versions()\n    if image is None:\n        raise ValueError(\"image must not be None.\")\n    if scale is None:\n        import impy as ip\n\n        header = ip.read_header(image)\n        scale = header.scale[\"x\"]\n    return CylindraProject(\n        datetime=datetime.now().strftime(\"%Y/%m/%d %H:%M:%S\"),\n        version=_versions.pop(\"cylindra\", \"unknown\"),\n        dependency_versions=_versions,\n        image=image,\n        image_reference=image_reference,\n        scale=scale,\n        multiscales=list(multiscales),\n        missing_wedge=MissingWedge.parse(missing_wedge),\n        invert=invert,\n        project_path=project_path,\n    )\n</code></pre>"},{"location":"api/project/#cylindra.project.CylindraProject.open_project","title":"<code>open_project()</code>","text":"<p>Open the project within this context.</p> Source code in <code>cylindra/project/_single.py</code> <pre><code>@contextmanager\ndef open_project(self) -&gt; Generator[Path, None, None]:\n    \"\"\"Open the project within this context.\"\"\"\n    if self.project_path is None:\n        raise ValueError(\"Project path is not set.\")\n    ext = self.project_path.suffix\n    if ext == \"\":\n        yield self.project_path\n\n    elif ext in (\".tar\",):\n        import tarfile\n\n        with tempfile.TemporaryDirectory() as tmpdir:\n            with tarfile.open(self.project_path) as tar:\n                _tar_extract_all(tar, tmpdir)\n            yield Path(tmpdir)\n\n    elif ext in (\".zip\",):\n        import zipfile\n\n        with tempfile.TemporaryDirectory() as tmpdir:\n            with zipfile.ZipFile(self.project_path) as _zip:\n                _zip.extractall(tmpdir)\n            yield Path(tmpdir)\n\n    else:\n        raise ValueError(f\"Unsupported extension {ext}.\")\n\n    return None\n</code></pre>"},{"location":"api/project/#cylindra.project.CylindraProject.resolve_path","title":"<code>resolve_path(file_dir)</code>","text":"<p>Resolve the path of the project.</p> Source code in <code>cylindra/project/_single.py</code> <pre><code>def resolve_path(self, file_dir: PathLike):\n    \"\"\"Resolve the path of the project.\"\"\"\n    file_dir = Path(file_dir)\n    self.image = resolve_path(self.image, file_dir)\n    return self\n</code></pre>"},{"location":"api/project/#cylindra.project.CylindraProject.rewrite","title":"<code>rewrite(dir)</code>","text":"<p>Rewrite tar/zip file using given temporary directory.</p> <p>This method is only used after some mutable operation on the project directory.</p> Source code in <code>cylindra/project/_single.py</code> <pre><code>def rewrite(self, dir: Path):\n    \"\"\"Rewrite tar/zip file using given temporary directory.\n\n    This method is only used after some mutable operation on the\n    project directory.\n    \"\"\"\n    if self.project_path is None:\n        raise ValueError(\"Project path is not set.\")\n\n    ext = self.project_path.suffix\n    if ext == \"\":\n        return\n\n    elif ext in (\".tar\",):\n        import tarfile\n\n        self.project_path.unlink()\n\n        with tarfile.open(self.project_path, mode=\"w\") as tar:\n            for file in Path(dir).glob(\"*\"):\n                tar.add(file, arcname=file.name)\n\n    elif ext in (\".zip\",):\n        import zipfile\n\n        self.project_path.unlink()\n        with zipfile.ZipFile(self.project_path, mode=\"w\") as zip:\n            for file in Path(dir).glob(\"*\"):\n                zip.write(file, arcname=file.name)\n\n    else:\n        raise ValueError(f\"Unsupported extension {ext}.\")\n\n    return None\n</code></pre>"},{"location":"api/project/#cylindra.project.CylindraProject.save","title":"<code>save(project_dir, splines=[], molecules={})</code>","text":"<p>Save this project.</p> Source code in <code>cylindra/project/_single.py</code> <pre><code>def save(\n    self,\n    project_dir: Path,\n    splines: \"list[CylSpline]\" = [],\n    molecules: \"dict[str, Molecules]\" = {},\n) -&gt; None:\n    \"\"\"Save this project.\"\"\"\n    from macrokit import parse\n\n    from cylindra.components.tomogram._spline_list import SplineList\n\n    path = Path(self.image).as_posix()\n    scale = self.scale\n    bin_size = self.multiscales\n    tilt_range = self.missing_wedge.as_param()\n    with _prep_save_dir(project_dir) as results_dir:\n        expr_open = parse(\n            f\"ui.open_image({path=}, {scale=:.4f}, {bin_size=}, {tilt_range=})\",\n            squeeze=False,\n        )\n        expr = as_main_function(expr_open)\n        self._script_py_path(results_dir).write_text(expr)\n        self_copy = self.model_copy()\n        spl_list = SplineList(splines)\n        if (df_loc := spl_list.collect_localprops()) is not None:\n            df_loc.write_csv(self._localprops_path(results_dir))\n        if (df_glob := spl_list.collect_globalprops()) is not None:\n            df_glob.write_csv(self._globalprops_path(results_dir))\n        for ith, spl in spl_list.enumerate():\n            spl.to_json(results_dir / f\"spline-{ith}.json\")\n        for name, mole in molecules.items():\n            save_path = results_dir / name\n            if save_path.suffix == \"\":\n                save_path = save_path.with_suffix(\".csv\")\n            self_copy.molecules_info.append(MoleculesInfo(name=save_path.name))\n            mole.to_file(save_path)\n        self_copy.to_json(self._project_json_path(results_dir))\n</code></pre>"},{"location":"api/project/#cylindra.project.CylindraProject.save_gui","title":"<code>save_gui(gui, project_dir, mole_ext='.csv', save_landscape=False)</code>  <code>classmethod</code>","text":"<p>Serialize the GUI state to a json file.</p> <p>Parameters:</p> Name Type Description Default <code>gui</code> <code>CylindraMainWidget</code> <p>The main widget from which project model will be constructed.</p> required <code>project_dir</code> <code>Path</code> <p>The path to the project json file.</p> required Source code in <code>cylindra/project/_single.py</code> <pre><code>@classmethod\ndef save_gui(\n    cls: \"type[CylindraProject]\",\n    gui: \"CylindraMainWidget\",\n    project_dir: Path,\n    mole_ext: str = \".csv\",\n    save_landscape: bool = False,\n) -&gt; None:\n    \"\"\"Serialize the GUI state to a json file.\n\n    Parameters\n    ----------\n    gui : CylindraMainWidget\n        The main widget from which project model will be constructed.\n    project_dir : Path\n        The path to the project json file.\n    \"\"\"\n    self = cls.from_gui(gui, project_dir, mole_ext, save_landscape)\n\n    tomo = gui.tomogram\n    localprops = tomo.splines.collect_localprops(allow_none=True)\n    globalprops = tomo.splines.collect_globalprops(allow_none=True)\n\n    with _prep_save_dir(project_dir) as results_dir:\n        if localprops is not None:\n            localprops.write_csv(self._localprops_path(results_dir))\n        if globalprops is not None:\n            globalprops.write_csv(self._globalprops_path(results_dir))\n        for i, spl in enumerate(gui.tomogram.splines):\n            spl.to_json(results_dir / f\"spline-{i}.json\")\n        for info in (\n            self.molecules_info + self.landscape_info + self.interaction_info\n        ):\n            info.save_layer(gui, results_dir)\n\n        _cfg_json = gui.default_config.json_dumps()\n        self._default_spline_config_path(results_dir).write_text(_cfg_json)\n\n        # save macro\n        expr = as_main_function(\n            gui._format_macro(gui.macro[gui._macro_offset :]),\n            imports=[plg.import_statement() for plg in gui._plugins_called],\n        )\n        self._script_py_path(results_dir).write_text(expr)\n\n        self.project_description = gui.GeneralInfo.project_desc.value\n\n        # dry run metadata serialization\n        try:\n            json.dumps(\n                gui._project_metadata,\n                default=project_json_encoder,\n            )\n        except Exception:  # pragma: no cover\n            warnings.warn(\n                \"Project metadata is not serializable. Skipping.\",\n                UserWarning,\n                stacklevel=2,\n            )\n        else:\n            self.metadata = gui._project_metadata\n        self.to_json(self._project_json_path(results_dir))\n</code></pre>"},{"location":"api/project/#cylindra.project.ProjectSequence","title":"<code>ProjectSequence</code>","text":"<p>Collection of Cylindra projects.</p> <p>This object is just for project management. BatchLoader, DataFrame and local/global properties can be generated from this object.</p> Source code in <code>cylindra/project/_sequence.py</code> <pre><code>class ProjectSequence(MutableSequence[CylindraProject]):\n    \"\"\"\n    Collection of Cylindra projects.\n\n    This object is just for project management. BatchLoader, DataFrame and local/global\n    properties can be generated from this object.\n    \"\"\"\n\n    def __init__(self, *, check_scale: bool = True):\n        self._projects = list[CylindraProject]()\n        self._scale_validator = ScaleValidator(check_scale)\n\n    def __repr__(self) -&gt; str:\n        if len(self) &gt; 1:\n            return (\n                f\"{type(self).__name__} with {len(self)} projects such as {self[0]!r}\"\n            )\n        return f\"{type(self).__name__} (empty)\"\n\n    @overload\n    def __getitem__(self, key: int) -&gt; CylindraProject: ...\n\n    @overload\n    def __getitem__(self, key: slice) -&gt; ProjectSequence: ...\n\n    def __getitem__(self, key: int):\n        out = self._projects[key]\n        if isinstance(key, slice):\n            out = ProjectSequence(check_scale=self._scale_validator._check)\n            out._projects = self._projects[key]\n        return out\n\n    def __setitem__(self, key: int, value: CylindraProject) -&gt; None:\n        if not isinstance(value, CylindraProject):\n            raise TypeError(f\"Expected CylindraProject, got {type(value)}.\")\n        if not isinstance(key, SupportsIndex):\n            raise TypeError(f\"Expected int, got {type(key)}.\")\n        self._projects[key] = value\n\n    def __delitem__(self, key: int) -&gt; None:\n        del self._projects[key]\n        if len(self) == 0:\n            self._scale_validator.initialize()\n\n    def __len__(self) -&gt; int:\n        return len(self._projects)\n\n    def __iter__(self) -&gt; Iterator[CylindraProject]:\n        return iter(self._projects)\n\n    def insert(self, index: int, value: CylindraProject) -&gt; None:\n        \"\"\"Insert a project at the given index.\"\"\"\n        if not isinstance(value, CylindraProject):\n            raise TypeError(f\"Expected CylindraProject, got {type(value)}.\")\n        return self._projects.insert(index, value)\n\n    def __add__(self, other: ProjectSequence) -&gt; ProjectSequence:\n        \"\"\"Concatenate two ProjectSequence objects.\"\"\"\n        if not isinstance(other, ProjectSequence):\n            raise TypeError(f\"Expected ProjectSequence, got {type(other)}.\")\n        new = ProjectSequence(check_scale=True)\n        new._projects = self._projects + other._projects\n        if len(self) &gt; 0:\n            new._scale_validator.value = self._scale_validator.value\n        if len(other) &gt; 0:\n            new._scale_validator.value = other._scale_validator.value\n        return new\n\n    @classmethod\n    def from_paths(\n        cls,\n        paths: Iterable[str | Path],\n        *,\n        check_scale: bool = True,\n        skip_exc: bool = False,\n    ) -&gt; Self:\n        \"\"\"Add all the projects of the given paths.\"\"\"\n        self = cls(check_scale=check_scale)\n        if skip_exc:\n            for path in paths:\n                with suppress(Exception):\n                    self.append_file(path)\n        else:\n            for path in paths:\n                self.append_file(path)\n        return self\n\n    def append_file(self, path: str | Path) -&gt; Self:\n        \"\"\"Add a project from a file path.\"\"\"\n        prj = CylindraProject.from_file(path)\n        self._scale_validator.value = prj.scale\n        self._projects.append(prj)\n        return self\n\n    def sta_loader(\n        self,\n        name_filter: Callable[[str], bool] | None = None,\n        *,\n        curvature: bool = False,\n        allow_no_image: bool = False,\n    ) -&gt; BatchLoader:\n        \"\"\"\n        Construct a STA loader from all the projects.\n\n        Parameters\n        ----------\n        name_filter : callable, default None\n            Function that takes a molecule file name (without extension) and\n            returns True if the molecule should be collected. Collect all the\n            molecules by default.\n        curvature : bool, default False\n            If True, the spline curvature will be added to the molecule features.\n        allow_no_image : bool, default False\n            If True, this method will not raise an error when the image file is not\n            found.\n        \"\"\"\n        import impy as ip\n        from acryo import BatchLoader\n\n        col = BatchLoader(scale=self._scale_validator.value)\n        if name_filter is None:\n\n            def name_filter(_):\n                return True\n\n        for idx, prj in enumerate(self._projects):\n            if prj.image is None or not prj.image.exists():\n                if not allow_no_image:\n                    raise ValueError(\n                        f\"Image file not found in project at {prj.project_path}.\"\n                    )\n                import numpy as np\n\n                img = np.zeros((0, 0, 0), dtype=np.float32)  # dummy\n            else:\n                img = ip.lazy.imread(prj.image, chunks=get_config().dask_chunk).value\n            with prj.open_project() as dir:\n                for info, mole in prj.iter_load_molecules(dir):\n                    if not name_filter(info.stem):\n                        continue\n                    if (\n                        curvature\n                        and (_spl_i := info.source) is not None\n                        and Mole.position in mole.features.columns\n                    ):\n                        _spl = prj.load_spline(_spl_i, dir=dir, props=False)\n                        _u = _spl.y_to_position(mole.features[Mole.position])\n                        cv = _spl.curvature(_u)\n                        mole.features = mole.features.with_columns(\n                            pl.Series(cv, dtype=pl.Float32).alias(\"spline_curvature\")\n                        )\n                    mole.features = mole.features.with_columns(\n                        pl.repeat(info.stem, pl.len()).alias(Mole.id)\n                    )\n                    col.add_tomogram(img, molecules=mole, image_id=idx)\n        return col\n\n    def collect_localprops(\n        self,\n        allow_none: bool = True,\n        id: _IDTYPE = \"int\",\n        spline_details: bool = False,\n    ) -&gt; pl.DataFrame:\n        \"\"\"\n        Collect all localprops into a single dataframe.\n\n        Parameters\n        ----------\n        allow_none : bool, default True\n            Continue data collection even if property table data file was not\n            found in any project. Raise error otherwise.\n        id : str, default \"int\"\n            How to describe the source tomogram. If \"int\", each tomogram will\n            be labeled with ascending integers. If \"path\", each tomogram will\n            be labeled with the name of the project directory.\n        spline_details : bool, default False\n            If True, spline coordinates, its derivatives and the curvature\n            will also be collected as well. This will take more memory and time.\n\n        Returns\n        -------\n        pl.DataFrame\n            Dataframe with all the properties.\n        \"\"\"\n        dfs_prj = list[pl.DataFrame]()  # localprops of each project\n        for idx, prj in enumerate(self._projects):\n            with prj.open_project() as dir:\n                if not prj._localprops_path(dir).exists():\n                    if not allow_none:\n                        raise ValueError(\n                            f\"Localprops not found in project at {prj.project_path}.\"\n                        )\n                    continue\n                dfs_spl = list[pl.DataFrame]()\n                for spl in prj.iter_load_splines(dir, drop_columns=False):\n                    _df_spl = spl.props.loc\n                    if spline_details:\n                        if not spl.has_anchors:\n                            raise ValueError(\n                                f\"Cannot collect spline details because spline {spl!r} \"\n                                \"does not have anchors.\"\n                            )\n                        _crds = [spl.map(der=der) for der in [0, 1, 2]]\n                        _cv = spl.curvature()\n                        _df_spl = _df_spl.with_columns(\n                            pl.Series(\"spline_z\", _crds[0][:, 0], dtype=pl.Float32),\n                            pl.Series(\"spline_y\", _crds[0][:, 1], dtype=pl.Float32),\n                            pl.Series(\"spline_x\", _crds[0][:, 2], dtype=pl.Float32),\n                            pl.Series(\"spline_dz\", _crds[1][:, 0], dtype=pl.Float32),\n                            pl.Series(\"spline_dy\", _crds[1][:, 1], dtype=pl.Float32),\n                            pl.Series(\"spline_dx\", _crds[1][:, 2], dtype=pl.Float32),\n                            pl.Series(\"spline_ddz\", _crds[2][:, 0], dtype=pl.Float32),\n                            pl.Series(\"spline_ddy\", _crds[2][:, 1], dtype=pl.Float32),\n                            pl.Series(\"spline_ddx\", _crds[2][:, 2], dtype=pl.Float32),\n                            pl.Series(\"spline_curvature\", _cv, dtype=pl.Float32),\n                        )\n                    dfs_spl.append(_df_spl)\n                _df_prj = pl.concat(dfs_spl, how=\"diagonal\")\n                columns = [pl.repeat(idx, pl.len()).cast(pl.UInt16).alias(Mole.image)]\n                if H.spline_id in _df_prj.columns:\n                    columns.append(pl.col(H.spline_id).cast(pl.UInt16))\n\n            dfs_prj.append(_df_prj.with_columns(columns))\n        out = cast_dataframe(pl.concat(dfs_prj, how=\"diagonal\"))\n        return self._normalize_id(out, id)\n\n    def collect_globalprops(\n        self,\n        allow_none: bool = True,\n        suffix: str = \"\",\n        id: _IDTYPE = \"int\",\n    ) -&gt; pl.DataFrame:\n        \"\"\"\n        Collect all globalprops into a single dataframe.\n\n        Parameters\n        ----------\n        allow_none : bool, default True\n            Continue data collection even if property table data file was not\n            found in any project. Raise error otherwise.\n        suffix : str, default \"\"\n            Suffix to add to the column names that may collide with the local\n            properties.\n        id : str, default \"int\"\n            How to describe the source tomogram. If \"int\", each tomogram will\n            be labeled with ascending integers. If \"path\", each tomogram will\n            be labeled with the name of the project directory.\n\n        Returns\n        -------\n        pl.DataFrame\n            Dataframe with all the properties.\n        \"\"\"\n        dataframes = list[pl.DataFrame]()\n        for idx, prj in enumerate(self._projects):\n            with prj.open_project() as dir:\n                path = prj._globalprops_path(dir)\n                if path is None:\n                    if not allow_none:\n                        raise ValueError(\n                            f\"Globalprops not found in project at {prj.project_path}.\"\n                        )\n                    continue\n                imagespec = pl.lit(idx).alias(Mole.image).cast(pl.UInt16)\n                df = pl.read_csv(path).with_columns(imagespec)\n            dataframes.append(df)\n        out = cast_dataframe(pl.concat(dataframes, how=\"diagonal\"))\n        if suffix:\n            need_rename = [\n                H.spacing, H.twist, H.npf, H.rise, H.skew,\n                H.rise_length, H.radius, H.start,\n            ]  # fmt: skip\n            nmap = {col: col + suffix for col in need_rename if col in out.columns}\n            out = out.rename(nmap)\n        return self._normalize_id(out, id)\n\n    def collect_joinedprops(\n        self,\n        allow_none: bool = True,\n        id: _IDTYPE = \"int\",\n        spline_details: bool = False,\n    ) -&gt; pl.DataFrame:\n        \"\"\"\n        Collect all the local and global properties into a single dataframe.\n\n        The global properties are suffixed with \"_glob\". Note that these columns\n        will repeat the same values for each spline. For instance, the \"spacing\"\n        columns will look like following.\n\n        &gt;&gt;&gt; col.collect_joinedprops().select([\"spacing\", \"spacing_glob\"])\n\n            shape: (12, 2)\n            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n            \u2502 spacing   \u2506 spacing_glob \u2502\n            \u2502 ---       \u2506 ---          \u2502\n            \u2502 f32       \u2506 f32          \u2502\n            \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n            \u2502 4.093385  \u2506 4.1024575    \u2502\n            \u2502 4.0987015 \u2506 4.1024575    \u2502\n            \u2502 4.1013646 \u2506 4.1024575    \u2502\n            \u2502 \u2026         \u2506 \u2026            \u2502\n            \u2502 4.074887  \u2506 4.089436     \u2502\n            \u2502 4.0987015 \u2506 4.089436     \u2502\n            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n        Parameters\n        ----------\n        allow_none : bool, default True\n            Forwarded to `collect_localprops` and `collect_globalprops`.\n        id : str, default \"int\"\n            How to describe the source tomogram. If \"int\", each tomogram will\n            be labeled with ascending integers. If \"path\", each tomogram will\n            be labeled with the name of the project directory.\n        spline_details : bool, default False\n            Forwarded to `collect_localprops`.\n\n        Returns\n        -------\n        pl.DataFrame\n            Dataframe with all the properties.\n        \"\"\"\n        props = self.collect_props(\n            allow_none=allow_none, spline_details=spline_details, suffix=\"_glob\"\n        ).join()\n        return self._normalize_id(props, id)\n\n    def collect_props(\n        self,\n        allow_none: bool = True,\n        spline_details: bool = False,\n        suffix: str = \"\",\n    ) -&gt; CollectedProps:\n        \"\"\"\n        Collect all the local and global properties.\n\n        Parameters\n        ----------\n        allow_none : bool, default True\n            Forwarded to `collect_localprops` and `collect_globalprops`.\n        spline_details : bool, default False\n            Forwarded to `collect_localprops`.\n        suffix : str, default \"\"\n            Suffix to add to the column names of global properties that may collide\n            with the local properties.\n\n        Returns\n        -------\n        CollectedProps\n            Tuple of the collected local and global properties.\n        \"\"\"\n        loc = self.collect_localprops(\n            allow_none=allow_none, id=\"int\", spline_details=spline_details\n        )\n        glb = self.collect_globalprops(allow_none=allow_none, id=\"int\", suffix=suffix)\n        if spline_details:\n            lengths = list[float]()\n            for _, spl in self.iter_splines():\n                lengths.append(spl.length())\n            col = pl.Series(\"spline_length\", lengths, dtype=pl.Float32)\n            glb = glb.with_columns(col)\n        return CollectedProps(loc, glb)\n\n    def collect_molecules(\n        self,\n        name_filter: Callable[[str], bool] | None = None,\n        *,\n        curvature: bool = False,\n    ) -&gt; Molecules:\n        \"\"\"\n        Collect all the molecules in this project sequence.\n\n        Parameters\n        ----------\n        name_filter : callable, optional\n            Function that takes a molecule file name (without extension) and\n            returns True if the molecule should be collected. Collect all the\n            molecules by default.\n        curvature : bool, default False\n            If True, the spline curvature will be added to the molecule features.\n        \"\"\"\n        loader = self.sta_loader(name_filter, curvature=curvature, allow_no_image=True)\n        return loader.molecules\n\n    def iter_splines(self) -&gt; Iterable[tuple[SplineKey, CylSpline]]:\n        \"\"\"Iterate over all the splines in all the projects.\"\"\"\n        for i_prj, prj in enumerate(self._projects):\n            with prj.open_project() as dir:\n                for i_spl, spl in enumerate(prj.iter_load_splines(dir)):\n                    yield SplineKey(i_prj, i_spl), spl\n\n    def iter_molecules(\n        self,\n        name_filter: Callable[[str], bool] | None = None,\n    ) -&gt; Iterable[tuple[MoleculesKey, Molecules]]:\n        \"\"\"\n        Iterate over all the molecules in all the projects.\n\n        Parameters\n        ----------\n        name_filter : callable, optional\n            Function that takes a molecule file name (without extension) and\n            returns True if the molecule should be collected. Collect all the\n            molecules by default.\n        \"\"\"\n        for sl, (mole, _) in self.iter_molecules_with_splines(\n            name_filter, skip_no_spline=False\n        ):\n            yield sl, mole\n\n    def iter_molecules_with_splines(\n        self,\n        name_filter: Callable[[str], bool] | None = None,\n        *,\n        skip_no_spline: bool = True,\n    ) -&gt; Iterator[MoleculesItem]:\n        \"\"\"\n        Iterate over all the molecules and its source spline.\n\n        Parameters\n        ----------\n        name_filter : callable, optional\n            Function that takes a molecule file name (without extension) and\n            returns True if the molecule should be collected. Collect all the\n            molecules by default.\n        skip_no_spline : bool, default True\n            If True, molecules without a source spline will be skipped.\n        \"\"\"\n        if name_filter is None:\n\n            def name_filter(_):\n                return True\n\n        for i_prj, prj in enumerate(self._projects):\n            with prj.open_project() as dir_:\n                for info, mole in prj.iter_load_molecules():\n                    if not name_filter(info.name):\n                        continue\n                    if (src := info.source) is None and skip_no_spline:\n                        continue\n                    spl = prj.load_spline(src, dir=dir_)\n                    yield MoleculesItem(MoleculesKey(i_prj, info.stem), (mole, spl))\n\n    def collect_spline_coords(self, ders: int | Iterable[int] = 0) -&gt; pl.DataFrame:\n        \"\"\"\n        Collect spline coordinates or its derivative(s) as a dataframe.\n\n        Coordinates will be labeled as \"z\", \"y\", \"x\". The 1st derivative will be\n        labeled as \"dz\", \"dy\", \"dx\", and so on.\n\n        Parameters\n        ----------\n        ders : int or iterable of int, default 0\n            Derivative order(s) to collect. If multiple values are given, all the\n            derivatives will be concatenated in a single dataframe.\n        \"\"\"\n        dfs = list[pl.DataFrame]()\n        if not hasattr(ders, \"__iter__\"):\n            ders = [ders]\n        for (i, j), spl in self.iter_splines():\n            nanc = spl.anchors.size\n            df = pl.DataFrame(\n                [\n                    pl.repeat(i, nanc, eager=True, dtype=pl.UInt16).alias(Mole.image),\n                    pl.repeat(j, nanc, eager=True, dtype=pl.UInt16).alias(H.spline_id),\n                ]\n            )\n            for der in ders:\n                d = \"d\" * der\n                coords = spl.map(der=der)\n                df = df.with_columns(\n                    pl.Series(coords[:, 0], dtype=pl.Float32).alias(f\"{d}z\"),\n                    pl.Series(coords[:, 1], dtype=pl.Float32).alias(f\"{d}y\"),\n                    pl.Series(coords[:, 2], dtype=pl.Float32).alias(f\"{d}x\"),\n                )\n            dfs.append(df)\n        return pl.concat(dfs, how=\"vertical\")\n\n    def _normalize_id(self, out: pl.DataFrame, id: _IDTYPE) -&gt; pl.DataFrame:\n        match id:\n            case \"int\":\n                pass\n            case \"path\":\n                _map = dict[int, str]()\n                _appeared = set[str]()\n                for i, prj in enumerate(self._projects):\n                    path = prj.project_path\n                    if path is None:\n                        raise ValueError(\n                            f\"The {i}-th project {prj!r} does not have a path.\"\n                        )\n                    path = Path(path)\n                    if path.suffix == \".json\":\n                        label = path.parent.name\n                    elif path.suffix == \"\":\n                        label = path.name\n                    else:\n                        label = path.stem\n                    label = _make_unique_label(label, _appeared)\n                    _map[i] = label\n                    _appeared.add(label)\n                _image_col = pl.col(Mole.image).replace_strict(\n                    _map, return_dtype=pl.Enum(list(_map.values()))\n                )\n                out = out.with_columns(_image_col)\n            case _:\n                raise ValueError(f\"Invalid id type {id!r}.\")\n        return out\n</code></pre>"},{"location":"api/project/#cylindra.project.ProjectSequence.__add__","title":"<code>__add__(other)</code>","text":"<p>Concatenate two ProjectSequence objects.</p> Source code in <code>cylindra/project/_sequence.py</code> <pre><code>def __add__(self, other: ProjectSequence) -&gt; ProjectSequence:\n    \"\"\"Concatenate two ProjectSequence objects.\"\"\"\n    if not isinstance(other, ProjectSequence):\n        raise TypeError(f\"Expected ProjectSequence, got {type(other)}.\")\n    new = ProjectSequence(check_scale=True)\n    new._projects = self._projects + other._projects\n    if len(self) &gt; 0:\n        new._scale_validator.value = self._scale_validator.value\n    if len(other) &gt; 0:\n        new._scale_validator.value = other._scale_validator.value\n    return new\n</code></pre>"},{"location":"api/project/#cylindra.project.ProjectSequence.append_file","title":"<code>append_file(path)</code>","text":"<p>Add a project from a file path.</p> Source code in <code>cylindra/project/_sequence.py</code> <pre><code>def append_file(self, path: str | Path) -&gt; Self:\n    \"\"\"Add a project from a file path.\"\"\"\n    prj = CylindraProject.from_file(path)\n    self._scale_validator.value = prj.scale\n    self._projects.append(prj)\n    return self\n</code></pre>"},{"location":"api/project/#cylindra.project.ProjectSequence.collect_globalprops","title":"<code>collect_globalprops(allow_none=True, suffix='', id='int')</code>","text":"<p>Collect all globalprops into a single dataframe.</p> <p>Parameters:</p> Name Type Description Default <code>allow_none</code> <code>bool</code> <p>Continue data collection even if property table data file was not found in any project. Raise error otherwise.</p> <code>True</code> <code>suffix</code> <code>str</code> <p>Suffix to add to the column names that may collide with the local properties.</p> <code>\"\"</code> <code>id</code> <code>str</code> <p>How to describe the source tomogram. If \"int\", each tomogram will be labeled with ascending integers. If \"path\", each tomogram will be labeled with the name of the project directory.</p> <code>\"int\"</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Dataframe with all the properties.</p> Source code in <code>cylindra/project/_sequence.py</code> <pre><code>def collect_globalprops(\n    self,\n    allow_none: bool = True,\n    suffix: str = \"\",\n    id: _IDTYPE = \"int\",\n) -&gt; pl.DataFrame:\n    \"\"\"\n    Collect all globalprops into a single dataframe.\n\n    Parameters\n    ----------\n    allow_none : bool, default True\n        Continue data collection even if property table data file was not\n        found in any project. Raise error otherwise.\n    suffix : str, default \"\"\n        Suffix to add to the column names that may collide with the local\n        properties.\n    id : str, default \"int\"\n        How to describe the source tomogram. If \"int\", each tomogram will\n        be labeled with ascending integers. If \"path\", each tomogram will\n        be labeled with the name of the project directory.\n\n    Returns\n    -------\n    pl.DataFrame\n        Dataframe with all the properties.\n    \"\"\"\n    dataframes = list[pl.DataFrame]()\n    for idx, prj in enumerate(self._projects):\n        with prj.open_project() as dir:\n            path = prj._globalprops_path(dir)\n            if path is None:\n                if not allow_none:\n                    raise ValueError(\n                        f\"Globalprops not found in project at {prj.project_path}.\"\n                    )\n                continue\n            imagespec = pl.lit(idx).alias(Mole.image).cast(pl.UInt16)\n            df = pl.read_csv(path).with_columns(imagespec)\n        dataframes.append(df)\n    out = cast_dataframe(pl.concat(dataframes, how=\"diagonal\"))\n    if suffix:\n        need_rename = [\n            H.spacing, H.twist, H.npf, H.rise, H.skew,\n            H.rise_length, H.radius, H.start,\n        ]  # fmt: skip\n        nmap = {col: col + suffix for col in need_rename if col in out.columns}\n        out = out.rename(nmap)\n    return self._normalize_id(out, id)\n</code></pre>"},{"location":"api/project/#cylindra.project.ProjectSequence.collect_joinedprops","title":"<code>collect_joinedprops(allow_none=True, id='int', spline_details=False)</code>","text":"<p>Collect all the local and global properties into a single dataframe.</p> <p>The global properties are suffixed with \"_glob\". Note that these columns will repeat the same values for each spline. For instance, the \"spacing\" columns will look like following.</p> <pre><code>col.collect_joinedprops().select([\"spacing\", \"spacing_glob\"])\n</code></pre> <pre><code>shape: (12, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 spacing   \u2506 spacing_glob \u2502\n\u2502 ---       \u2506 ---          \u2502\n\u2502 f32       \u2506 f32          \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 4.093385  \u2506 4.1024575    \u2502\n\u2502 4.0987015 \u2506 4.1024575    \u2502\n\u2502 4.1013646 \u2506 4.1024575    \u2502\n\u2502 \u2026         \u2506 \u2026            \u2502\n\u2502 4.074887  \u2506 4.089436     \u2502\n\u2502 4.0987015 \u2506 4.089436     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>allow_none</code> <code>bool</code> <p>Forwarded to <code>collect_localprops</code> and <code>collect_globalprops</code>.</p> <code>True</code> <code>id</code> <code>str</code> <p>How to describe the source tomogram. If \"int\", each tomogram will be labeled with ascending integers. If \"path\", each tomogram will be labeled with the name of the project directory.</p> <code>\"int\"</code> <code>spline_details</code> <code>bool</code> <p>Forwarded to <code>collect_localprops</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Dataframe with all the properties.</p> Source code in <code>cylindra/project/_sequence.py</code> <pre><code>def collect_joinedprops(\n    self,\n    allow_none: bool = True,\n    id: _IDTYPE = \"int\",\n    spline_details: bool = False,\n) -&gt; pl.DataFrame:\n    \"\"\"\n    Collect all the local and global properties into a single dataframe.\n\n    The global properties are suffixed with \"_glob\". Note that these columns\n    will repeat the same values for each spline. For instance, the \"spacing\"\n    columns will look like following.\n\n    &gt;&gt;&gt; col.collect_joinedprops().select([\"spacing\", \"spacing_glob\"])\n\n        shape: (12, 2)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 spacing   \u2506 spacing_glob \u2502\n        \u2502 ---       \u2506 ---          \u2502\n        \u2502 f32       \u2506 f32          \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 4.093385  \u2506 4.1024575    \u2502\n        \u2502 4.0987015 \u2506 4.1024575    \u2502\n        \u2502 4.1013646 \u2506 4.1024575    \u2502\n        \u2502 \u2026         \u2506 \u2026            \u2502\n        \u2502 4.074887  \u2506 4.089436     \u2502\n        \u2502 4.0987015 \u2506 4.089436     \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n    Parameters\n    ----------\n    allow_none : bool, default True\n        Forwarded to `collect_localprops` and `collect_globalprops`.\n    id : str, default \"int\"\n        How to describe the source tomogram. If \"int\", each tomogram will\n        be labeled with ascending integers. If \"path\", each tomogram will\n        be labeled with the name of the project directory.\n    spline_details : bool, default False\n        Forwarded to `collect_localprops`.\n\n    Returns\n    -------\n    pl.DataFrame\n        Dataframe with all the properties.\n    \"\"\"\n    props = self.collect_props(\n        allow_none=allow_none, spline_details=spline_details, suffix=\"_glob\"\n    ).join()\n    return self._normalize_id(props, id)\n</code></pre>"},{"location":"api/project/#cylindra.project.ProjectSequence.collect_localprops","title":"<code>collect_localprops(allow_none=True, id='int', spline_details=False)</code>","text":"<p>Collect all localprops into a single dataframe.</p> <p>Parameters:</p> Name Type Description Default <code>allow_none</code> <code>bool</code> <p>Continue data collection even if property table data file was not found in any project. Raise error otherwise.</p> <code>True</code> <code>id</code> <code>str</code> <p>How to describe the source tomogram. If \"int\", each tomogram will be labeled with ascending integers. If \"path\", each tomogram will be labeled with the name of the project directory.</p> <code>\"int\"</code> <code>spline_details</code> <code>bool</code> <p>If True, spline coordinates, its derivatives and the curvature will also be collected as well. This will take more memory and time.</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Dataframe with all the properties.</p> Source code in <code>cylindra/project/_sequence.py</code> <pre><code>def collect_localprops(\n    self,\n    allow_none: bool = True,\n    id: _IDTYPE = \"int\",\n    spline_details: bool = False,\n) -&gt; pl.DataFrame:\n    \"\"\"\n    Collect all localprops into a single dataframe.\n\n    Parameters\n    ----------\n    allow_none : bool, default True\n        Continue data collection even if property table data file was not\n        found in any project. Raise error otherwise.\n    id : str, default \"int\"\n        How to describe the source tomogram. If \"int\", each tomogram will\n        be labeled with ascending integers. If \"path\", each tomogram will\n        be labeled with the name of the project directory.\n    spline_details : bool, default False\n        If True, spline coordinates, its derivatives and the curvature\n        will also be collected as well. This will take more memory and time.\n\n    Returns\n    -------\n    pl.DataFrame\n        Dataframe with all the properties.\n    \"\"\"\n    dfs_prj = list[pl.DataFrame]()  # localprops of each project\n    for idx, prj in enumerate(self._projects):\n        with prj.open_project() as dir:\n            if not prj._localprops_path(dir).exists():\n                if not allow_none:\n                    raise ValueError(\n                        f\"Localprops not found in project at {prj.project_path}.\"\n                    )\n                continue\n            dfs_spl = list[pl.DataFrame]()\n            for spl in prj.iter_load_splines(dir, drop_columns=False):\n                _df_spl = spl.props.loc\n                if spline_details:\n                    if not spl.has_anchors:\n                        raise ValueError(\n                            f\"Cannot collect spline details because spline {spl!r} \"\n                            \"does not have anchors.\"\n                        )\n                    _crds = [spl.map(der=der) for der in [0, 1, 2]]\n                    _cv = spl.curvature()\n                    _df_spl = _df_spl.with_columns(\n                        pl.Series(\"spline_z\", _crds[0][:, 0], dtype=pl.Float32),\n                        pl.Series(\"spline_y\", _crds[0][:, 1], dtype=pl.Float32),\n                        pl.Series(\"spline_x\", _crds[0][:, 2], dtype=pl.Float32),\n                        pl.Series(\"spline_dz\", _crds[1][:, 0], dtype=pl.Float32),\n                        pl.Series(\"spline_dy\", _crds[1][:, 1], dtype=pl.Float32),\n                        pl.Series(\"spline_dx\", _crds[1][:, 2], dtype=pl.Float32),\n                        pl.Series(\"spline_ddz\", _crds[2][:, 0], dtype=pl.Float32),\n                        pl.Series(\"spline_ddy\", _crds[2][:, 1], dtype=pl.Float32),\n                        pl.Series(\"spline_ddx\", _crds[2][:, 2], dtype=pl.Float32),\n                        pl.Series(\"spline_curvature\", _cv, dtype=pl.Float32),\n                    )\n                dfs_spl.append(_df_spl)\n            _df_prj = pl.concat(dfs_spl, how=\"diagonal\")\n            columns = [pl.repeat(idx, pl.len()).cast(pl.UInt16).alias(Mole.image)]\n            if H.spline_id in _df_prj.columns:\n                columns.append(pl.col(H.spline_id).cast(pl.UInt16))\n\n        dfs_prj.append(_df_prj.with_columns(columns))\n    out = cast_dataframe(pl.concat(dfs_prj, how=\"diagonal\"))\n    return self._normalize_id(out, id)\n</code></pre>"},{"location":"api/project/#cylindra.project.ProjectSequence.collect_molecules","title":"<code>collect_molecules(name_filter=None, *, curvature=False)</code>","text":"<p>Collect all the molecules in this project sequence.</p> <p>Parameters:</p> Name Type Description Default <code>name_filter</code> <code>callable</code> <p>Function that takes a molecule file name (without extension) and returns True if the molecule should be collected. Collect all the molecules by default.</p> <code>None</code> <code>curvature</code> <code>bool</code> <p>If True, the spline curvature will be added to the molecule features.</p> <code>False</code> Source code in <code>cylindra/project/_sequence.py</code> <pre><code>def collect_molecules(\n    self,\n    name_filter: Callable[[str], bool] | None = None,\n    *,\n    curvature: bool = False,\n) -&gt; Molecules:\n    \"\"\"\n    Collect all the molecules in this project sequence.\n\n    Parameters\n    ----------\n    name_filter : callable, optional\n        Function that takes a molecule file name (without extension) and\n        returns True if the molecule should be collected. Collect all the\n        molecules by default.\n    curvature : bool, default False\n        If True, the spline curvature will be added to the molecule features.\n    \"\"\"\n    loader = self.sta_loader(name_filter, curvature=curvature, allow_no_image=True)\n    return loader.molecules\n</code></pre>"},{"location":"api/project/#cylindra.project.ProjectSequence.collect_props","title":"<code>collect_props(allow_none=True, spline_details=False, suffix='')</code>","text":"<p>Collect all the local and global properties.</p> <p>Parameters:</p> Name Type Description Default <code>allow_none</code> <code>bool</code> <p>Forwarded to <code>collect_localprops</code> and <code>collect_globalprops</code>.</p> <code>True</code> <code>spline_details</code> <code>bool</code> <p>Forwarded to <code>collect_localprops</code>.</p> <code>False</code> <code>suffix</code> <code>str</code> <p>Suffix to add to the column names of global properties that may collide with the local properties.</p> <code>\"\"</code> <p>Returns:</p> Type Description <code>CollectedProps</code> <p>Tuple of the collected local and global properties.</p> Source code in <code>cylindra/project/_sequence.py</code> <pre><code>def collect_props(\n    self,\n    allow_none: bool = True,\n    spline_details: bool = False,\n    suffix: str = \"\",\n) -&gt; CollectedProps:\n    \"\"\"\n    Collect all the local and global properties.\n\n    Parameters\n    ----------\n    allow_none : bool, default True\n        Forwarded to `collect_localprops` and `collect_globalprops`.\n    spline_details : bool, default False\n        Forwarded to `collect_localprops`.\n    suffix : str, default \"\"\n        Suffix to add to the column names of global properties that may collide\n        with the local properties.\n\n    Returns\n    -------\n    CollectedProps\n        Tuple of the collected local and global properties.\n    \"\"\"\n    loc = self.collect_localprops(\n        allow_none=allow_none, id=\"int\", spline_details=spline_details\n    )\n    glb = self.collect_globalprops(allow_none=allow_none, id=\"int\", suffix=suffix)\n    if spline_details:\n        lengths = list[float]()\n        for _, spl in self.iter_splines():\n            lengths.append(spl.length())\n        col = pl.Series(\"spline_length\", lengths, dtype=pl.Float32)\n        glb = glb.with_columns(col)\n    return CollectedProps(loc, glb)\n</code></pre>"},{"location":"api/project/#cylindra.project.ProjectSequence.collect_spline_coords","title":"<code>collect_spline_coords(ders=0)</code>","text":"<p>Collect spline coordinates or its derivative(s) as a dataframe.</p> <p>Coordinates will be labeled as \"z\", \"y\", \"x\". The 1st derivative will be labeled as \"dz\", \"dy\", \"dx\", and so on.</p> <p>Parameters:</p> Name Type Description Default <code>ders</code> <code>int or iterable of int</code> <p>Derivative order(s) to collect. If multiple values are given, all the derivatives will be concatenated in a single dataframe.</p> <code>0</code> Source code in <code>cylindra/project/_sequence.py</code> <pre><code>def collect_spline_coords(self, ders: int | Iterable[int] = 0) -&gt; pl.DataFrame:\n    \"\"\"\n    Collect spline coordinates or its derivative(s) as a dataframe.\n\n    Coordinates will be labeled as \"z\", \"y\", \"x\". The 1st derivative will be\n    labeled as \"dz\", \"dy\", \"dx\", and so on.\n\n    Parameters\n    ----------\n    ders : int or iterable of int, default 0\n        Derivative order(s) to collect. If multiple values are given, all the\n        derivatives will be concatenated in a single dataframe.\n    \"\"\"\n    dfs = list[pl.DataFrame]()\n    if not hasattr(ders, \"__iter__\"):\n        ders = [ders]\n    for (i, j), spl in self.iter_splines():\n        nanc = spl.anchors.size\n        df = pl.DataFrame(\n            [\n                pl.repeat(i, nanc, eager=True, dtype=pl.UInt16).alias(Mole.image),\n                pl.repeat(j, nanc, eager=True, dtype=pl.UInt16).alias(H.spline_id),\n            ]\n        )\n        for der in ders:\n            d = \"d\" * der\n            coords = spl.map(der=der)\n            df = df.with_columns(\n                pl.Series(coords[:, 0], dtype=pl.Float32).alias(f\"{d}z\"),\n                pl.Series(coords[:, 1], dtype=pl.Float32).alias(f\"{d}y\"),\n                pl.Series(coords[:, 2], dtype=pl.Float32).alias(f\"{d}x\"),\n            )\n        dfs.append(df)\n    return pl.concat(dfs, how=\"vertical\")\n</code></pre>"},{"location":"api/project/#cylindra.project.ProjectSequence.from_paths","title":"<code>from_paths(paths, *, check_scale=True, skip_exc=False)</code>  <code>classmethod</code>","text":"<p>Add all the projects of the given paths.</p> Source code in <code>cylindra/project/_sequence.py</code> <pre><code>@classmethod\ndef from_paths(\n    cls,\n    paths: Iterable[str | Path],\n    *,\n    check_scale: bool = True,\n    skip_exc: bool = False,\n) -&gt; Self:\n    \"\"\"Add all the projects of the given paths.\"\"\"\n    self = cls(check_scale=check_scale)\n    if skip_exc:\n        for path in paths:\n            with suppress(Exception):\n                self.append_file(path)\n    else:\n        for path in paths:\n            self.append_file(path)\n    return self\n</code></pre>"},{"location":"api/project/#cylindra.project.ProjectSequence.insert","title":"<code>insert(index, value)</code>","text":"<p>Insert a project at the given index.</p> Source code in <code>cylindra/project/_sequence.py</code> <pre><code>def insert(self, index: int, value: CylindraProject) -&gt; None:\n    \"\"\"Insert a project at the given index.\"\"\"\n    if not isinstance(value, CylindraProject):\n        raise TypeError(f\"Expected CylindraProject, got {type(value)}.\")\n    return self._projects.insert(index, value)\n</code></pre>"},{"location":"api/project/#cylindra.project.ProjectSequence.iter_molecules","title":"<code>iter_molecules(name_filter=None)</code>","text":"<p>Iterate over all the molecules in all the projects.</p> <p>Parameters:</p> Name Type Description Default <code>name_filter</code> <code>callable</code> <p>Function that takes a molecule file name (without extension) and returns True if the molecule should be collected. Collect all the molecules by default.</p> <code>None</code> Source code in <code>cylindra/project/_sequence.py</code> <pre><code>def iter_molecules(\n    self,\n    name_filter: Callable[[str], bool] | None = None,\n) -&gt; Iterable[tuple[MoleculesKey, Molecules]]:\n    \"\"\"\n    Iterate over all the molecules in all the projects.\n\n    Parameters\n    ----------\n    name_filter : callable, optional\n        Function that takes a molecule file name (without extension) and\n        returns True if the molecule should be collected. Collect all the\n        molecules by default.\n    \"\"\"\n    for sl, (mole, _) in self.iter_molecules_with_splines(\n        name_filter, skip_no_spline=False\n    ):\n        yield sl, mole\n</code></pre>"},{"location":"api/project/#cylindra.project.ProjectSequence.iter_molecules_with_splines","title":"<code>iter_molecules_with_splines(name_filter=None, *, skip_no_spline=True)</code>","text":"<p>Iterate over all the molecules and its source spline.</p> <p>Parameters:</p> Name Type Description Default <code>name_filter</code> <code>callable</code> <p>Function that takes a molecule file name (without extension) and returns True if the molecule should be collected. Collect all the molecules by default.</p> <code>None</code> <code>skip_no_spline</code> <code>bool</code> <p>If True, molecules without a source spline will be skipped.</p> <code>True</code> Source code in <code>cylindra/project/_sequence.py</code> <pre><code>def iter_molecules_with_splines(\n    self,\n    name_filter: Callable[[str], bool] | None = None,\n    *,\n    skip_no_spline: bool = True,\n) -&gt; Iterator[MoleculesItem]:\n    \"\"\"\n    Iterate over all the molecules and its source spline.\n\n    Parameters\n    ----------\n    name_filter : callable, optional\n        Function that takes a molecule file name (without extension) and\n        returns True if the molecule should be collected. Collect all the\n        molecules by default.\n    skip_no_spline : bool, default True\n        If True, molecules without a source spline will be skipped.\n    \"\"\"\n    if name_filter is None:\n\n        def name_filter(_):\n            return True\n\n    for i_prj, prj in enumerate(self._projects):\n        with prj.open_project() as dir_:\n            for info, mole in prj.iter_load_molecules():\n                if not name_filter(info.name):\n                    continue\n                if (src := info.source) is None and skip_no_spline:\n                    continue\n                spl = prj.load_spline(src, dir=dir_)\n                yield MoleculesItem(MoleculesKey(i_prj, info.stem), (mole, spl))\n</code></pre>"},{"location":"api/project/#cylindra.project.ProjectSequence.iter_splines","title":"<code>iter_splines()</code>","text":"<p>Iterate over all the splines in all the projects.</p> Source code in <code>cylindra/project/_sequence.py</code> <pre><code>def iter_splines(self) -&gt; Iterable[tuple[SplineKey, CylSpline]]:\n    \"\"\"Iterate over all the splines in all the projects.\"\"\"\n    for i_prj, prj in enumerate(self._projects):\n        with prj.open_project() as dir:\n            for i_spl, spl in enumerate(prj.iter_load_splines(dir)):\n                yield SplineKey(i_prj, i_spl), spl\n</code></pre>"},{"location":"api/project/#cylindra.project.ProjectSequence.sta_loader","title":"<code>sta_loader(name_filter=None, *, curvature=False, allow_no_image=False)</code>","text":"<p>Construct a STA loader from all the projects.</p> <p>Parameters:</p> Name Type Description Default <code>name_filter</code> <code>callable</code> <p>Function that takes a molecule file name (without extension) and returns True if the molecule should be collected. Collect all the molecules by default.</p> <code>None</code> <code>curvature</code> <code>bool</code> <p>If True, the spline curvature will be added to the molecule features.</p> <code>False</code> <code>allow_no_image</code> <code>bool</code> <p>If True, this method will not raise an error when the image file is not found.</p> <code>False</code> Source code in <code>cylindra/project/_sequence.py</code> <pre><code>def sta_loader(\n    self,\n    name_filter: Callable[[str], bool] | None = None,\n    *,\n    curvature: bool = False,\n    allow_no_image: bool = False,\n) -&gt; BatchLoader:\n    \"\"\"\n    Construct a STA loader from all the projects.\n\n    Parameters\n    ----------\n    name_filter : callable, default None\n        Function that takes a molecule file name (without extension) and\n        returns True if the molecule should be collected. Collect all the\n        molecules by default.\n    curvature : bool, default False\n        If True, the spline curvature will be added to the molecule features.\n    allow_no_image : bool, default False\n        If True, this method will not raise an error when the image file is not\n        found.\n    \"\"\"\n    import impy as ip\n    from acryo import BatchLoader\n\n    col = BatchLoader(scale=self._scale_validator.value)\n    if name_filter is None:\n\n        def name_filter(_):\n            return True\n\n    for idx, prj in enumerate(self._projects):\n        if prj.image is None or not prj.image.exists():\n            if not allow_no_image:\n                raise ValueError(\n                    f\"Image file not found in project at {prj.project_path}.\"\n                )\n            import numpy as np\n\n            img = np.zeros((0, 0, 0), dtype=np.float32)  # dummy\n        else:\n            img = ip.lazy.imread(prj.image, chunks=get_config().dask_chunk).value\n        with prj.open_project() as dir:\n            for info, mole in prj.iter_load_molecules(dir):\n                if not name_filter(info.stem):\n                    continue\n                if (\n                    curvature\n                    and (_spl_i := info.source) is not None\n                    and Mole.position in mole.features.columns\n                ):\n                    _spl = prj.load_spline(_spl_i, dir=dir, props=False)\n                    _u = _spl.y_to_position(mole.features[Mole.position])\n                    cv = _spl.curvature(_u)\n                    mole.features = mole.features.with_columns(\n                        pl.Series(cv, dtype=pl.Float32).alias(\"spline_curvature\")\n                    )\n                mole.features = mole.features.with_columns(\n                    pl.repeat(info.stem, pl.len()).alias(Mole.id)\n                )\n                col.add_tomogram(img, molecules=mole, image_id=idx)\n    return col\n</code></pre>"},{"location":"api/project/#cylindra.project.as_main_function","title":"<code>as_main_function(expr, imports=())</code>","text":"<p>Convert a macro to a main(ui) function string.</p> Source code in <code>cylindra/project/_utils.py</code> <pre><code>def as_main_function(expr: Expr, imports: Iterable[str] = ()) -&gt; str:\n    \"\"\"Convert a macro to a main(ui) function string.\"\"\"\n    txt = \"\\n\".join(f\"    {line}\" for line in expr.args)\n    if all(line.strip().startswith(\"#\") for line in txt.splitlines()):\n        txt += \"\\n    pass\"\n    import_statements = \"\\n\".join(imports) + \"\\n\"\n    return _MACRO_FORMAT.format(import_statements, txt)\n</code></pre>"},{"location":"api/project/#cylindra.project.extract","title":"<code>extract(text)</code>","text":"<p>Extract the content of main function.</p> Source code in <code>cylindra/project/_utils.py</code> <pre><code>def extract(text: str) -&gt; Expr:\n    \"\"\"Extract the content of main function.\"\"\"\n\n    macro_expr = parse(text, squeeze=False)\n    if macro_expr.args[0].head is Head.import_:\n        for line in macro_expr.args:\n            if line.head is Head.function and str(line.args[0].args[0]) == \"main\":\n                macro_expr = line.args[1]\n                break\n\n    return macro_expr\n</code></pre>"},{"location":"api/project/#cylindra.project.get_project_file","title":"<code>get_project_file(path)</code>","text":"<p>Return the path to the project file.</p> Source code in <code>cylindra/project/_utils.py</code> <pre><code>def get_project_file(path: str | Path):\n    \"\"\"Return the path to the project file.\"\"\"\n    path = Path(path)\n    if path.is_dir():\n        path = path / \"project.json\"\n        if not path.exists():\n            raise FileNotFoundError(\n                f\"Directory {path} seems not a cylindra project directory. A \"\n                \"project directory should contain a 'project.json' file.\"\n            )\n    return path\n</code></pre>"},{"location":"api/builtins/imod/","title":"cylindra_builtins.imod","text":"<p>This built-in plugin submodule provides functions to work with IMOD file formats.</p>"},{"location":"api/builtins/imod/#cylindra_builtins.imod.export_project","title":"<code>export_project(ui, layer, save_dir, template_path, mask_params=None, project_name='project-0')</code>","text":"<p>Export cylindra state as a PEET prm file.</p> <p>Molecules and images will be exported to a directory that can be directly used by PEET.</p> <p>Parameters:</p> Name Type Description Default <code>layer</code> <code>MoleculesLayer</code> <p>Molecules layer to export.</p> required <code>save_dir</code> <code>Path</code> <p>Directory to save the files needed for a PEET project.</p> required <code>template_path</code> <code>str</code> <p>Path to the template image.</p> required <code>mask_params</code> <code>Any</code> <p>Mask parameters.</p> <code>None</code> <code>project_name</code> <code>str</code> <p>Name of the PEET project.</p> <code>\"project-0\"</code> Source code in <code>cylindra_builtins/imod/io.py</code> <pre><code>@register_function(name=\"Export project\")\ndef export_project(\n    ui: CylindraMainWidget,\n    layer: MoleculesLayerType,\n    save_dir: Path.Dir,\n    template_path: Annotated[str, {\"bind\": _get_template_path}],\n    mask_params: Annotated[Any, {\"bind\": _get_mask_params}] = None,\n    project_name: str = \"project-0\",\n):\n    \"\"\"Export cylindra state as a PEET prm file.\n\n    Molecules and images will be exported to a directory that can be\n    directly used by PEET.\n\n    Parameters\n    ----------\n    layer : MoleculesLayer\n        Molecules layer to export.\n    save_dir : Path\n        Directory to save the files needed for a PEET project.\n    template_path : str\n        Path to the template image.\n    mask_params : Any, default None\n        Mask parameters.\n    project_name : str, default \"project-0\"\n        Name of the PEET project.\n    \"\"\"\n    save_dir = Path(save_dir)\n    layer = assert_layer(layer, ui.parent_viewer)\n    if not save_dir.exists():\n        save_dir.mkdir()\n    loader = ui.tomogram.get_subtomogram_loader(\n        Molecules.empty(),\n        binsize=1,\n    )\n    template_image, mask_image = loader.normalize_input(\n        template=ui.sta.params._norm_template_param(template_path),\n        mask=ui.sta.params._get_mask(params=mask_params),\n    )\n\n    if template_image is None:\n        raise ValueError(\"Template image is not loaded.\")\n\n    # paths\n    coordinates_path = \"./coordinates.mod\"\n    angles_path = \"./angles.csv\"\n    template_path = \"./template-image.mrc\"\n    mask_path = \"./mask-image.mrc\"\n    prm_path = save_dir / f\"{project_name}.prm\"\n\n    txt = PEET_TEMPLATE.format(\n        tomograms=repr(ui.tomogram.source),\n        coordinates=repr(coordinates_path),\n        angles=repr(angles_path),\n        tilt_range=list(ui.tomogram.tilt[\"range\"]),\n        template=template_path,\n        project_name=project_name,\n        shape=list(template_image.shape),\n        mask_type=mask_path,\n    )\n\n    # save files\n    prm_path.write_text(txt)\n    mol = layer.molecules\n    _save_molecules(save_dir=save_dir, mol=mol, scale=ui.tomogram.scale)\n    ip.asarray(template_image, axes=\"zyx\").set_scale(\n        zyx=ui.tomogram.scale, unit=\"nm\"\n    ).imsave(save_dir / template_path)\n    if mask_image is not None:\n        ip.asarray(mask_image, axes=\"zyx\").set_scale(\n            zyx=ui.tomogram.scale, unit=\"nm\"\n        ).imsave(save_dir / mask_path)\n</code></pre>"},{"location":"api/builtins/imod/#cylindra_builtins.imod.export_project_batch","title":"<code>export_project_batch(ui, save_dir, path_sets, project_name='project-0', size=10.0)</code>","text":"<p>Export cylindra batch analyzer state as a PEET prm file.</p> <p>A epe file will be generated, which can directly be used by <code>etomo &lt;name&gt;.epe</code>.</p> <p>Parameters:</p> Name Type Description Default <code>save_dir</code> <code>Path</code> <p>Directory to save the files needed for a PEET project.</p> required <code>path_sets</code> <code>Any</code> <p>Path sets of the tomograms and coordinates.</p> required <code>project_name</code> <code>str</code> <p>Name of the PEET project.</p> <code>\"project-0\"</code> <code>size</code> <code>float</code> <p>Size of the subtomograms in nanometers.</p> <code>10.0</code> Source code in <code>cylindra_builtins/imod/io.py</code> <pre><code>@register_function(name=\"Export project as batch\")\ndef export_project_batch(\n    ui: CylindraMainWidget,\n    save_dir: Path.Dir,\n    path_sets: Annotated[Any, {\"bind\": _get_loader_paths}],\n    project_name: str = \"project-0\",\n    size: Annotated[float, {\"label\": \"Subtomogram size (nm)\", \"min\": 1.0, \"max\": 1000.0}] = 10.0,  # fmt: skip\n):\n    \"\"\"Export cylindra batch analyzer state as a PEET prm file.\n\n    A epe file will be generated, which can directly be used by `etomo &lt;name&gt;.epe`.\n\n    Parameters\n    ----------\n    save_dir : Path\n        Directory to save the files needed for a PEET project.\n    path_sets : Any\n        Path sets of the tomograms and coordinates.\n    project_name : str, default \"project-0\"\n        Name of the PEET project.\n    size : float, default 10.0\n        Size of the subtomograms in nanometers.\n    \"\"\"\n    from cylindra.widgets.batch._sequence import PathInfo\n    from cylindra.widgets.batch._utils import TempFeatures\n\n    save_dir = Path(save_dir)\n    if not save_dir.exists():\n        save_dir.mkdir()\n\n    _temp_feat = TempFeatures()\n\n    _tomogram_list = list[str]()\n    _coords_list = list[str]()\n    _angle_list = list[str]()\n    _tilt_list = list[str]()\n    _count = 0\n    scales = []\n    for path_info in path_sets:\n        path_info = PathInfo(*path_info)\n        prj = path_info.project_instance(missing_ok=False)\n        moles = list(path_info.iter_molecules(_temp_feat, prj.scale))\n        if len(moles) &gt; 0:\n            _tomogram_list.append(repr(path_info.image.as_posix()))\n            mod_name = f\"coordinates-{_count:0&gt;3}_{path_info.image.stem}.mod\"\n            csv_name = f\"angles-{_count:0&gt;3}_{path_info.image.stem}.csv\"\n            _save_molecules(\n                save_dir=save_dir,\n                mol=Molecules.concat(moles),\n                scale=prj.scale,\n                mod_name=mod_name,\n                csv_name=csv_name,\n            )\n            _coords_list.append(f\"'./{mod_name}'\")\n            _angle_list.append(f\"'./{csv_name}'\")\n            if mw_dict := prj.missing_wedge.as_param():\n                if \"range\" in mw_dict:\n                    tilt_range = mw_dict[\"range\"]\n                    _tilt_list.append(f\"[{tilt_range[0]}, {tilt_range[1]}]\")\n            scales.append(prj.scale)\n            _count += 1\n\n    # determine shape using the average scale\n    if len(scales) == 0:\n        raise ValueError(\"No tomograms found in the project.\")\n    scale = np.mean(scales)\n    shape = [int(round(size / scale / 2)) * 2] * 3  # must be even\n\n    # paths\n    prm_path = save_dir / f\"{project_name}.prm\"\n    epe_path = save_dir / f\"{project_name}.epe\"\n\n    prm_txt = PEET_TEMPLATE.format(\n        tomograms=\", \".join(_tomogram_list),\n        coordinates=\", \".join(_coords_list),\n        angles=\", \".join(_angle_list),\n        tilt_range=\", \".join(_tilt_list),\n        template=\"\",\n        project_name=project_name,\n        shape=shape,\n        mask_type=\"none\",\n    )\n\n    # save files\n    prm_path.write_text(prm_txt)\n    epe_path.write_text(f\"Peet.RootName={project_name}\\n\")\n</code></pre>"},{"location":"api/builtins/imod/#cylindra_builtins.imod.import_imod_projects","title":"<code>import_imod_projects(ui, edf_path, project_root=None, scale_override=None, invert=True, bin_size=[1])</code>","text":"<p>Import IMOD projects as batch analyzer entries.</p> <p>Parameters:</p> Name Type Description Default <code>edf_path</code> <code>Path</code> <p>Path to the edf file(s). Path can contain wildcards.</p> required <code>project_root</code> <code>Path</code> <p>Root directory to save the cylindra project folders. If None, a new directory will be created under the same level as the first IMOD project.</p> <code>None</code> <code>scale_override</code> <code>float</code> <p>Override the scale used for all the tomograms inside cylindra.</p> <code>None</code> <code>invert</code> <code>bool</code> <p>If true, invert the intensity of the image.</p> <code>False</code> <code>bin_size</code> <code>list of int</code> <p>Bin sizes to load the tomograms.</p> <code>[1]</code> Source code in <code>cylindra_builtins/imod/io.py</code> <pre><code>@register_function(name=\"Import IMOD projects\")\ndef import_imod_projects(\n    ui: CylindraMainWidget,\n    edf_path: Annotated[Path.Read[FileFilter.EDF], {\"label\": \"IMOD edf file(s)\"}],\n    project_root: Optional[Path.Save] = None,\n    scale_override: Annotated[Optional[float], {\"text\": \"Use header scale\", \"options\": {\"step\": 0.0001, \"value\": 1.0}}] = None,\n    invert: bool = True,\n    bin_size: list[int] = [1],\n):  # fmt: skip\n    \"\"\"Import IMOD projects as batch analyzer entries.\n\n    Parameters\n    ----------\n    edf_path : Path\n        Path to the edf file(s). Path can contain wildcards.\n    project_root : Path, default None\n        Root directory to save the cylindra project folders. If None, a new directory\n        will be created under the same level as the first IMOD project.\n    scale_override : float, default None\n        Override the scale used for all the tomograms inside cylindra.\n    invert : bool, default False\n        If true, invert the intensity of the image.\n    bin_size : list of int, default [1]\n        Bin sizes to load the tomograms.\n    \"\"\"\n    from cylindra.widgets.batch._utils import unwrap_wildcard\n\n    tomo_paths: list[Path] = []\n    tilt_models: list[dict | None] = []\n    for each in unwrap_wildcard(edf_path):\n        if (res := _edf_to_tomo_and_tilt(each)) is not None:\n            tomo_path, tilt_model = res\n            tomo_paths.append(tomo_path)\n            tilt_models.append(tilt_model)\n    if len(tomo_paths) == 0:\n        raise ValueError(f\"No tomograms found with the given path input: {edf_path}\")\n    if scale_override is not None:\n        scales = [scale_override] * len(tomo_paths)\n    else:\n        scales = None\n\n    if project_root is None:\n        project_root = tomo_paths[0].parent.parent / \"cylindra\"\n\n    ui.batch._new_projects_from_table(\n        tomo_paths,\n        save_root=project_root,\n        scale=scales,\n        tilt_model=tilt_models,\n        invert=[invert] * len(tomo_paths),\n        bin_size=[bin_size] * len(tomo_paths),\n    )\n</code></pre>"},{"location":"api/builtins/imod/#cylindra_builtins.imod.load_molecules","title":"<code>load_molecules(ui, mod_path, ang_path, shift_mol=True)</code>","text":"<p>Read molecule coordinates and angles from IMOD .mod files.</p> <p>Parameters:</p> Name Type Description Default <code>mod_path</code> <code>Path</code> <p>Path to the mod file that contains molecule coordinates.</p> required <code>ang_path</code> <code>Path</code> <p>Path to the text file that contains molecule angles in Euler angles.</p> required <code>shift_mol</code> <code>bool</code> <p>In PEET output csv there may be xOffset, yOffset, zOffset columns that can be directly applied to the molecule coordinates.</p> <code>True</code> Source code in <code>cylindra_builtins/imod/io.py</code> <pre><code>@register_function(name=\"Load molecules\")\ndef load_molecules(\n    ui: CylindraMainWidget,\n    mod_path: Annotated[Path.Read[FileFilter.MOD], {\"label\": \"Path to MOD file\"}],\n    ang_path: Annotated[Path.Read[FileFilter.CSV], {\"label\": \"Path to csv file\"}],\n    shift_mol: Annotated[bool, {\"label\": \"Apply shifts to monomers if offsets are available.\"}] = True,\n):  # fmt: skip\n    \"\"\"Read molecule coordinates and angles from IMOD .mod files.\n\n    Parameters\n    ----------\n    mod_path : Path\n        Path to the mod file that contains molecule coordinates.\n    ang_path : Path\n        Path to the text file that contains molecule angles in Euler angles.\n    shift_mol : bool, default True\n        In PEET output csv there may be xOffset, yOffset, zOffset columns that can\n        be directly applied to the molecule coordinates.\n    \"\"\"\n    mod_path = Path(mod_path)\n    df = read_mod(mod_path)\n    mod = df.select(\"z\", \"y\", \"x\").to_numpy(writable=True)\n    mod[:, 1:] -= 0.5  # shift to center of voxel\n    shifts, angs = _read_shift_and_angle(ang_path)\n    scale = ui.tomogram.scale\n    mol = Molecules.from_euler(pos=mod * scale, angles=angs, degrees=True)\n    if shift_mol:\n        mol.translate(shifts * scale, copy=False)\n\n    return add_molecules(ui.parent_viewer, mol, mod_path.name, source=None)\n</code></pre>"},{"location":"api/builtins/imod/#cylindra_builtins.imod.load_splines","title":"<code>load_splines(ui, mod_path)</code>","text":"<p>Read a mod file and register all the contours as splines.</p> Source code in <code>cylindra_builtins/imod/io.py</code> <pre><code>@register_function(name=\"Load splines\")\ndef load_splines(\n    ui: CylindraMainWidget,\n    mod_path: Annotated[Path.Read[FileFilter.MOD], {\"label\": \"Path to MOD file\"}],\n):\n    \"\"\"Read a mod file and register all the contours as splines.\"\"\"\n    df = read_mod(mod_path)\n    for _, sub in df.group_by(\"object_id\", \"contour_id\", maintain_order=True):\n        coords = sub.select(\"z\", \"y\", \"x\").to_numpy(writable=True)\n        coords[:, 1:] -= 0.5  # shift YX to center of voxel\n        ui.register_path(coords * ui.tomogram.scale, err_max=1e-8)\n</code></pre>"},{"location":"api/builtins/imod/#cylindra_builtins.imod.open_image_from_imod_project","title":"<code>open_image_from_imod_project(ui, edf_path, scale_override=None, bin_size=[4], filter=ImageFilter.Lowpass, invert=True, eager=False, cache_image=False)</code>","text":"<p>Open an image from an IMOD project.</p> <p>Parameters:</p> Name Type Description Default <code>edf_path</code> <code>Path</code> <p>Path to the edf file.</p> required <code>scale_override</code> <code>float</code> <p>Override the scale used for all the tomograms inside cylindra.</p> <code>None</code> <code>bin_size</code> <code>list of int</code> <p>Bin sizes to load the tomograms.</p> <code>[1]</code> <code>filter</code> <code>ImageFilter</code> <p>Filter to apply when binning the image.</p> <code>ImageFilter.Lowpass</code> <code>invert</code> <code>bool</code> <p>If true, invert the intensity of the image.</p> <code>False</code> <code>eager</code> <code>bool</code> <p>If true, the image will be loaded immediately. Otherwise, it will be loaded lazily.</p> <code>False</code> <code>cache_image</code> <code>bool</code> <p>If true, the image will first be copied to the cache directory before loading.</p> <code>False</code> Source code in <code>cylindra_builtins/imod/io.py</code> <pre><code>@register_function(name=\"Open image from an IMOD project\", record=False)\ndef open_image_from_imod_project(\n    ui: CylindraMainWidget,\n    edf_path: Annotated[Path.Read[FileFilter.EDF], {\"label\": \"IMOD edf file\"}],\n    scale_override: Annotated[\n        Optional[float],\n        {\"text\": \"Use header scale\", \"options\": {\"step\": 0.0001, \"value\": 1.0}},\n    ] = None,\n    bin_size: list[int] = [4],\n    filter: ImageFilter | None = ImageFilter.Lowpass,\n    invert: bool = True,\n    eager: Annotated[bool, {\"label\": \"Load the entire image into memory\"}] = False,\n    cache_image: Annotated[bool, {\"label\": \"Cache image on SSD\"}] = False,\n):\n    \"\"\"Open an image from an IMOD project.\n\n    Parameters\n    ----------\n    edf_path : Path\n        Path to the edf file.\n    scale_override : float, default None\n        Override the scale used for all the tomograms inside cylindra.\n    bin_size : list of int, default [1]\n        Bin sizes to load the tomograms.\n    filter : ImageFilter, default ImageFilter.Lowpass\n        Filter to apply when binning the image.\n    invert : bool, default False\n        If true, invert the intensity of the image.\n    eager : bool, default False\n        If true, the image will be loaded immediately. Otherwise, it will be loaded\n        lazily.\n    cache_image : bool, default False\n        If true, the image will first be copied to the cache directory before\n        loading.\n    \"\"\"\n    res = _edf_to_tomo_and_tilt(edf_path)\n    if res is None:\n        raise ValueError(f\"Could not find tomogram in the IMOD project {edf_path}.\")\n    tomo_path, tilt_model = res\n    ui.open_image(\n        tomo_path,\n        scale=scale_override,\n        invert=invert,\n        tilt_range=tilt_model,\n        bin_size=bin_size,\n        filter=filter,\n        eager=eager,\n        cache_image=cache_image,\n    )\n</code></pre>"},{"location":"api/builtins/imod/#cylindra_builtins.imod.save_molecules","title":"<code>save_molecules(ui, save_dir, layers)</code>","text":"<p>Save monomer positions and angles in the PEET format.</p> <p>Parameters:</p> Name Type Description Default <code>save_dir</code> <code>Path</code> <p>Saving path.</p> required <code>layers</code> <code>sequence of MoleculesLayer</code> <p>Select the layers to save. All the molecules will be concatenated.</p> required Source code in <code>cylindra_builtins/imod/io.py</code> <pre><code>@register_function(name=\"Save molecules\")\ndef save_molecules(\n    ui: CylindraMainWidget, save_dir: Path.Dir, layers: MoleculesLayersType\n):\n    \"\"\"Save monomer positions and angles in the PEET format.\n\n    Parameters\n    ----------\n    save_dir : Path\n        Saving path.\n    layers : sequence of MoleculesLayer\n        Select the layers to save. All the molecules will be concatenated.\n    \"\"\"\n    save_dir = Path(save_dir)\n    layers = assert_list_of_layers(layers, ui.parent_viewer)\n    mol = Molecules.concat([l.molecules for l in layers])\n    return _save_molecules(save_dir=save_dir, mol=mol, scale=ui.tomogram.scale)\n</code></pre>"},{"location":"api/builtins/imod/#cylindra_builtins.imod.save_splines","title":"<code>save_splines(ui, save_path, interval=10.0)</code>","text":"<p>Save splines as a mod file.</p> <p>This function will sample coordinates along the splines and save the coordinates as a mod file. The mod file will be labeled with object_id=1 and contour_id=i+1, where i is the index of the spline.</p> <p>Parameters:</p> Name Type Description Default <code>save_path</code> <code>Path</code> <p>Saving path.</p> required <code>interval</code> <code>float</code> <p>Sampling interval along the splines. For example, if interval=10.0 and the length of a spline is 100.0, 11 points will be sampled.</p> <code>10.0</code> Source code in <code>cylindra_builtins/imod/io.py</code> <pre><code>@register_function(name=\"Save splines\")\ndef save_splines(\n    ui: CylindraMainWidget,\n    save_path: Path.Save[FileFilter.MOD],\n    interval: Annotated[float, {\"min\": 0.01, \"max\": 1000.0, \"label\": \"Sampling interval (nm)\"}] = 10.0,\n):  # fmt: skip\n    \"\"\"Save splines as a mod file.\n\n    This function will sample coordinates along the splines and save the coordinates\n    as a mod file. The mod file will be labeled with object_id=1 and contour_id=i+1,\n    where i is the index of the spline.\n\n    Parameters\n    ----------\n    save_path : Path\n        Saving path.\n    interval : float, default 10.0\n        Sampling interval along the splines. For example, if interval=10.0 and the\n        length of a spline is 100.0, 11 points will be sampled.\n    \"\"\"\n    if interval &lt;= 1e-4:\n        raise ValueError(\"Interval must be larger than 1e-4.\")\n    data_list = []\n    for i, spl in enumerate(ui.splines):\n        num = int(spl.length() / interval)\n        coords = spl.partition(num) / ui.tomogram.scale\n        df = pl.DataFrame(\n            {\n                \"object_id\": 1,\n                \"contour_id\": i + 1,\n                \"x\": coords[:, 2] + 0.5,\n                \"y\": coords[:, 1] + 0.5,\n                \"z\": coords[:, 0],\n            }\n        )\n        data_list.append(df)\n    data_all = pl.concat(data_list, how=\"vertical\")\n    save_mod(save_path, data_all)\n</code></pre>"},{"location":"api/builtins/relion/","title":"cylindra_builtins.relion","text":"<p>This built-in plugin submodule provides functions to work with RELION file formats.</p>"},{"location":"api/builtins/relion/#cylindra_builtins.relion.load_molecules","title":"<code>load_molecules(ui, path)</code>","text":"<p>Read monomer coordinates and angles from RELION .star file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>path - like</code> <p>The path to the star file.</p> required Source code in <code>cylindra_builtins/relion/io.py</code> <pre><code>@register_function(name=\"Load molecules\")\ndef load_molecules(ui: CylindraMainWidget, path: Path.Read[FileFilter.STAR]):\n    \"\"\"Read monomer coordinates and angles from RELION .star file.\n\n    Parameters\n    ----------\n    path : path-like\n        The path to the star file.\n    \"\"\"\n    path = Path(path)\n    moles = _read_star(path, ui.tomogram)\n    for i, mole in enumerate(moles.values()):\n        add_molecules(ui.parent_viewer, mole, f\"{path.name}-{i}\", source=None)\n</code></pre>"},{"location":"api/builtins/relion/#cylindra_builtins.relion.load_splines","title":"<code>load_splines(ui, path)</code>","text":"<p>Read a star file and register all the tubes as splines.</p> <p>The \"rlnHelicalTubeID\" column will be used to group the points into splines.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>path - like</code> <p>The path to the star file.</p> required Source code in <code>cylindra_builtins/relion/io.py</code> <pre><code>@register_function(name=\"Load splines\")\ndef load_splines(ui: CylindraMainWidget, path: Path.Read[FileFilter.STAR]):\n    \"\"\"Read a star file and register all the tubes as splines.\n\n    The \"rlnHelicalTubeID\" column will be used to group the points into splines.\n\n    Parameters\n    ----------\n    path : path-like\n        The path to the star file.\n    \"\"\"\n    mole = Molecules.concat(_read_star(path, ui.tomogram).values())\n    if RELION_TUBE_ID not in mole.features.columns:\n        warnings.warn(\n            f\"{RELION_TUBE_ID!r} not found in star file. Use all points as a \"\n            \"single spline.\",\n            UserWarning,\n            stacklevel=2,\n        )\n        ui.register_path(mole.pos, err_max=1e-8)\n    else:\n        for _, each in mole.group_by(RELION_TUBE_ID):\n            ui.register_path(each.pos, err_max=1e-8)\n</code></pre>"},{"location":"api/builtins/relion/#cylindra_builtins.relion.open_relion_job","title":"<code>open_relion_job(ui, path, project_root=None, invert=True, bin_size=[1])</code>","text":"<p>Open a RELION tomogram reconstruction job folder.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>path - like</code> <p>The path to the RELION job.star file.</p> required <code>project_root</code> <code>path - like</code> <p>The root directory to save the projects for each tomogram. If not provided, it will be automatically created in the RELION job directory.</p> <code>None</code> <code>invert</code> <code>bool</code> <p>Set to True if the tomograms are light backgroud.</p> <code>True</code> <code>bin_size</code> <code>list[int]</code> <p>The multiscale binning size for the tomograms.</p> <code>[1]</code> Source code in <code>cylindra_builtins/relion/io.py</code> <pre><code>@register_function(name=\"Open RELION job\")\ndef open_relion_job(\n    ui: CylindraMainWidget,\n    path: Path.Read[FileFilter.STAR_JOB],\n    project_root: Optional[Path.Save] = None,\n    invert: bool = True,\n    bin_size: list[int] = [1],\n):\n    \"\"\"Open a RELION tomogram reconstruction job folder.\n\n    Parameters\n    ----------\n    path : path-like\n        The path to the RELION job.star file.\n    project_root : path-like, optional\n        The root directory to save the projects for each tomogram. If not provided,\n        it will be automatically created in the RELION job directory.\n    invert : bool, default True\n        Set to True if the tomograms are light backgroud.\n    bin_size : list[int], default [1]\n        The multiscale binning size for the tomograms.\n    \"\"\"\n    path = Path(path)\n    if path.name != \"job.star\" or not path.is_file() or not path.exists():\n        raise ValueError(f\"Path must be an existing RELION job.star file, got {path}\")\n    job_dir_path = Path(path).parent\n    rln_project_path = _relion_project_path(job_dir_path)\n    jobtype = _get_job_type(job_dir_path)\n    if project_root is None:\n        project_root = job_dir_path / \"cylindra\"\n    if jobtype in (\"relion.reconstructtomograms\", \"relion.denoisetomo\"):\n        # Reconstruct Tomogram job\n        tomogram_star_path = job_dir_path / \"tomograms.star\"\n        if not tomogram_star_path.exists():\n            raise FileNotFoundError(\n                f\"tomogram.star file {tomogram_star_path} does not exist. Make sure \"\n                \"the input job has an tomogram output.\"\n            )\n        col = (\n            REC_TOMO_DENOISED_PATH if jobtype == \"relion.denoisetomo\" else REC_TOMO_PATH\n        )\n        _, tomo_paths, scales = _parse_tomo_star(tomogram_star_path, col)\n        paths = [rln_project_path / p for p in tomo_paths]\n        moles = None\n    elif jobtype in (\"relion.picktomo\", \"relion.pseudosubtomo\"):\n        if not (opt_star_path := job_dir_path / \"optimisation_set.star\").exists():\n            raise ValueError(\n                f\"Optimisation set star file not found in {job_dir_path}. \"\n                \"Please ensure the job is a RELION 5.0 pick-particles job.\"\n            )\n        paths, scales, moles = _parse_optimisation_star(opt_star_path, rln_project_path)\n    elif jobtype in (\"relion.initialmodel.tomo\", \"relion.refine3d.tomo\"):\n        opt_set_path_list = sorted(\n            job_dir_path.glob(\"run_it*_optimisation_set.star\"),\n            key=lambda p: p.stem,\n        )\n        if len(opt_set_path_list) == 0:\n            raise ValueError(\n                f\"No optimisation set star files found in {job_dir_path}. \"\n                \"Please ensure at least one iteration has finished.\"\n            )\n        opt_star_path = opt_set_path_list[-1]\n        paths, scales, moles = _parse_optimisation_star(opt_star_path, rln_project_path)\n    else:\n        raise ValueError(f\"Job {job_dir_path.name} is not a supported RELION job.\")\n    # TODO: parse tilt angles\n    ui.batch._new_projects_from_table(\n        paths,\n        save_root=project_root,\n        scale=scales,\n        invert=[invert] * len(paths),\n        molecules=moles,\n        bin_size=[bin_size] * len(paths),\n    )\n</code></pre>"},{"location":"api/builtins/relion/#cylindra_builtins.relion.save_molecules","title":"<code>save_molecules(ui, save_path, layers, save_features=False, tomo_name_override='', shift_by_origin=True)</code>","text":"<p>Save the selected molecules to a RELION .star file.</p> <p>If multiple layers are selected, the <code>MoleculeGroupID</code> column will be added to the star file to distinguish the layers. This method is RELION 5 compliant.</p> <p>Parameters:</p> Name Type Description Default <code>save_path</code> <code>path - like</code> <p>The path to save the star file.</p> required <code>layers</code> <code>sequence of MoleculesLayer</code> <p>The layers to save.</p> required <code>save_features</code> <code>bool</code> <p>Whether to save the features of the molecules.</p> <code>True</code> <code>tomo_name_override</code> <code>str</code> <p>If provided, this will override the tomogram name identifier (the rlnTomoName column) in the star file.</p> <code>\"\"</code> <code>shift_by_origin</code> <code>bool</code> <p>If True, the positions will be shifted by the origin of the tomogram. This option is required if you picked molecules in a trimmed tomogram.</p> <code>True</code> Source code in <code>cylindra_builtins/relion/io.py</code> <pre><code>@register_function(name=\"Save molecules\")\ndef save_molecules(\n    ui: CylindraMainWidget,\n    save_path: Path.Save[FileFilter.STAR],\n    layers: MoleculesLayersType,\n    save_features: bool = False,\n    tomo_name_override: str = \"\",\n    shift_by_origin: bool = True,\n):\n    \"\"\"Save the selected molecules to a RELION .star file.\n\n    If multiple layers are selected, the `MoleculeGroupID` column will be added\n    to the star file to distinguish the layers. This method is RELION 5 compliant.\n\n    Parameters\n    ----------\n    save_path : path-like\n        The path to save the star file.\n    layers : sequence of MoleculesLayer\n        The layers to save.\n    save_features : bool, default True\n        Whether to save the features of the molecules.\n    tomo_name_override : str, default \"\"\n        If provided, this will override the tomogram name identifier (the rlnTomoName\n        column) in the star file.\n    shift_by_origin : bool, default True\n        If True, the positions will be shifted by the origin of the tomogram. This\n        option is required if you picked molecules in a trimmed tomogram.\n    \"\"\"\n    save_path = Path(save_path)\n    layers = assert_list_of_layers(layers, ui.parent_viewer)\n    tomo_name = tomo_name_override or _strip_relion5_prefix(ui.tomogram.image.name)\n    df = _mole_to_star_df(\n        [layer.molecules for layer in layers],\n        ui.tomogram,\n        tomo_name,\n        save_features,\n        shift_by_origin,\n    )\n    starfile.write(df, save_path)\n</code></pre>"},{"location":"api/builtins/relion/#cylindra_builtins.relion.save_molecules_for_extract","title":"<code>save_molecules_for_extract(ui, coordinates_path, path_sets, save_features=False, shift_by_origin=True, centered=True)</code>","text":"<p>Save the batch analyzer state as a star file for \"Extract subtomo\" job.</p> <p>The output star file should be provided as the \"I/O &gt; Input particle set\" with \"OR: use direct entries\" set to \"Yes\".</p> <p>Parameters:</p> Name Type Description Default <code>coordinates_path</code> <code>path - like</code> <p>The path to save the star file containing the particles.</p> required <code>path_sets</code> <code>sequence of PathInfo</code> <p>The path sets to the tomograms and molecules.</p> required <code>save_features</code> <code>bool</code> <p>Whether to save the features of the molecules to the star file.</p> <code>False</code> <code>shift_by_origin</code> <code>bool</code> <p>If True, the positions will be shifted by the origin of the tomogram. This option is required if you picked molecules in a trimmed tomogram.</p> <code>True</code> <code>centered</code> <code>bool</code> <p>If True, the positions will be centered around the tomogram center, and columns \"rlnCenteredCoordinateX/Y/ZAngst\" will be used. If False, columns \"rlnCoordinateX/Y/Z\" will be used.</p> <code>True</code> Source code in <code>cylindra_builtins/relion/io.py</code> <pre><code>@register_function(name=\"Save molecules for extract\", record=False)\ndef save_molecules_for_extract(\n    ui: CylindraMainWidget,\n    coordinates_path: Path.Save[FileFilter.STAR],\n    path_sets: Annotated[Any, {\"bind\": _get_loader_paths}],\n    save_features: bool = False,\n    shift_by_origin: bool = True,\n    centered: bool = True,\n):\n    \"\"\"Save the batch analyzer state as a star file for \"Extract subtomo\" job.\n\n    The output star file should be provided as the \"I/O &gt; Input particle set\" with\n    \"OR: use direct entries\" set to \"Yes\".\n\n    Parameters\n    ----------\n    coordinates_path : path-like\n        The path to save the star file containing the particles.\n    path_sets : sequence of PathInfo\n        The path sets to the tomograms and molecules.\n    save_features : bool, default False\n        Whether to save the features of the molecules to the star file.\n    shift_by_origin : bool, default True\n        If True, the positions will be shifted by the origin of the tomogram. This\n        option is required if you picked molecules in a trimmed tomogram.\n    centered : bool, default True\n        If True, the positions will be centered around the tomogram center, and columns\n        \"rlnCenteredCoordinateX/Y/ZAngst\" will be used. If False, columns\n        \"rlnCoordinateX/Y/Z\" will be used.\n    \"\"\"\n    particles_dfs = list[pd.DataFrame]()\n    for _, df in _iter_dataframe_from_path_sets(\n        path_sets,\n        save_features=save_features,\n        shift_by_origin=shift_by_origin,\n        centered=centered,\n    ):\n        particles_dfs.append(df)\n    particles_df = pd.concat(particles_dfs)\n    starfile.write({\"particles\": particles_df}, coordinates_path)\n</code></pre>"},{"location":"api/builtins/relion/#cylindra_builtins.relion.save_molecules_for_import","title":"<code>save_molecules_for_import(ui, coordinates_path, path_sets, save_features=False, shift_by_origin=True, centered=True)</code>","text":"<p>Save the batch analyzer state as star files for \"Import\" job.</p> <p>Parameters:</p> Name Type Description Default <code>coordinates_path</code> <code>path - like</code> <p>The path to save the star file containing the particles.</p> required <code>path_sets</code> <code>sequence of PathInfo</code> <p>The path sets to the tomograms and molecules.</p> required <code>save_features</code> <code>bool</code> <p>Whether to save the features of the molecules to the star file.</p> <code>False</code> <code>shift_by_origin</code> <code>bool</code> <p>If True, the positions will be shifted by the origin of the tomogram. This option is required if you picked molecules in a trimmed tomogram.</p> <code>True</code> <code>centered</code> <code>bool</code> <p>If True, the positions will be centered around the tomogram center, and columns \"rlnCenteredCoordinateX/Y/ZAngst\" will be used. If False, columns \"rlnCoordinateX/Y/Z\" will be used.</p> <code>True</code> Source code in <code>cylindra_builtins/relion/io.py</code> <pre><code>@register_function(name=\"Save molecules for import\", record=False)\ndef save_molecules_for_import(\n    ui: CylindraMainWidget,\n    coordinates_path: Path.Save[FileFilter.STAR],\n    path_sets: Annotated[Any, {\"bind\": _get_loader_paths}],\n    save_features: bool = False,\n    shift_by_origin: bool = True,\n    centered: bool = True,\n):\n    \"\"\"Save the batch analyzer state as star files for \"Import\" job.\n\n    Parameters\n    ----------\n    coordinates_path : path-like\n        The path to save the star file containing the particles.\n    path_sets : sequence of PathInfo\n        The path sets to the tomograms and molecules.\n    save_features : bool, default False\n        Whether to save the features of the molecules to the star file.\n    shift_by_origin : bool, default True\n        If True, the positions will be shifted by the origin of the tomogram. This\n        option is required if you picked molecules in a trimmed tomogram.\n    centered : bool, default True\n        If True, the positions will be centered around the tomogram center, and columns\n        \"rlnCenteredCoordinateX/Y/ZAngst\" will be used. If False, columns\n        \"rlnCoordinateX/Y/Z\" will be used.\n    \"\"\"\n    coordinates_path = Path(coordinates_path)\n    save_dir = coordinates_path.parent / f\"{coordinates_path.stem}_particles\"\n    save_dir.mkdir(exist_ok=True)\n\n    tomo_names = list[str]()\n    particles_paths = list[str]()\n    particles_dfs = list[pd.DataFrame]()\n    for tomo_name, df in _iter_dataframe_from_path_sets(\n        path_sets,\n        save_features=save_features,\n        shift_by_origin=shift_by_origin,\n        centered=centered,\n    ):\n        particles_path = save_dir / f\"{tomo_name}_particles.star\"\n        particles_dfs.append(df)\n        particles_paths.append(particles_path)\n        tomo_names.append(tomo_name)\n        starfile.write(df, particles_path)\n\n    df_opt = pd.DataFrame(\n        {\n            TOMO_NAME: tomo_names,\n            IMPORT_PARTICLE_FILE: particles_paths,\n        }\n    )\n    starfile.write(df_opt, coordinates_path)\n</code></pre>"},{"location":"api/builtins/relion/#cylindra_builtins.relion.save_splines","title":"<code>save_splines(ui, save_path, interval=10.0, tomo_name_override='', shift_by_origin=True)</code>","text":"<p>Save the current splines to a RELION .star file.</p> <p>Parameters:</p> Name Type Description Default <code>save_path</code> <code>path - like</code> <p>The path to save the star file.</p> required <code>interval</code> <code>float</code> <p>Sampling interval along the splines. For example, if interval=10.0 and the length of a spline is 100.0, 11 points will be sampled.</p> <code>10.0</code> <code>tomo_name_override</code> <code>str</code> <p>If provided, this will override the tomogram name identifier (the rlnTomoName column) in the star file.</p> <code>\"\"</code> <code>shift_by_origin</code> <code>bool</code> <p>If True, the positions will be shifted by the origin of the tomogram. This option is required if you picked molecules in a trimmed tomogram.</p> <code>True</code> Source code in <code>cylindra_builtins/relion/io.py</code> <pre><code>@register_function(name=\"Save splines\")\ndef save_splines(\n    ui: CylindraMainWidget,\n    save_path: Path.Save[FileFilter.STAR],\n    interval: Annotated[float, {\"min\": 0.01, \"max\": 1000.0, \"label\": \"Sampling interval (nm)\"}] = 10.0,\n    tomo_name_override: str = \"\",\n    shift_by_origin: bool = True,\n):  # fmt: skip\n    \"\"\"Save the current splines to a RELION .star file.\n\n    Parameters\n    ----------\n    save_path : path-like\n        The path to save the star file.\n    interval : float, default 10.0\n        Sampling interval along the splines. For example, if interval=10.0 and the\n        length of a spline is 100.0, 11 points will be sampled.\n    tomo_name_override : str, default \"\"\n        If provided, this will override the tomogram name identifier (the rlnTomoName\n        column) in the star file.\n    shift_by_origin : bool, default True\n        If True, the positions will be shifted by the origin of the tomogram. This\n        option is required if you picked molecules in a trimmed tomogram.\n    \"\"\"\n\n    if interval &lt;= 1e-4:\n        raise ValueError(\"Interval must be larger than 1e-4.\")\n    save_path = Path(save_path)\n    data_list: list[pl.DataFrame] = []\n    orig = ui.tomogram.origin\n    if not shift_by_origin:\n        orig = type(orig)(0.0, 0.0, 0.0)\n    tomo_name = tomo_name_override or ui.tomogram.image.name\n    scale = ui.tomogram.scale\n    centerz, centery, centerx = (np.array(ui.tomogram.image.shape) / 2 - 1) * scale\n    for i, spl in enumerate(ui.splines):\n        num = int(spl.length() / interval)\n        coords = spl.partition(num)\n        mole_count = coords.shape[0]\n        df = pl.DataFrame(\n            {\n                TOMO_NAME: [tomo_name] * mole_count,\n                POS_CENTERED[2]: (coords[:, 2] - centerx + orig.x) * 10,  # Angstrom\n                POS_CENTERED[1]: (coords[:, 1] - centery + orig.y) * 10,  # Angstrom\n                POS_CENTERED[0]: (coords[:, 0] - centerz + orig.z) * 10,  # Angstrom\n                ROT_COLUMNS[0]: 0.0,\n                ROT_COLUMNS[1]: 0.0,\n                ROT_COLUMNS[2]: 0.0,\n                RELION_TUBE_ID: i,\n            }\n        )\n        data_list.append(df)\n    df = pl.concat(data_list, how=\"vertical\").to_pandas()\n    starfile.write(df, save_path)\n</code></pre>"},{"location":"api/widgets/batch/","title":"cylindra.widgets.batch","text":""},{"location":"api/widgets/batch/#cylindrabatchwidget","title":"CylindraBatchWidget","text":"<p>Methods are available in the namespace <code>ui.batch</code>.</p> Source code in <code>cylindra/widgets/batch/main.py</code> <pre><code>@magicclass(\n    widget_type=\"split\",\n    layout=\"horizontal\",\n    name=\"Batch Analysis\",\n    properties={\"min_height\": 360},\n    symbol=Expr(\"getattr\", [Symbol(\"ui\"), \"batch\"]),\n)\nclass CylindraBatchWidget(MagicTemplate):\n    constructor = field(ProjectSequenceEdit)\n    sta = field(BatchSubtomogramAveraging)\n    loader_infos = BatchLoaderAccessor()\n\n    def __init__(self):\n        self._loaders = LoaderList()\n        self._loaders.events.inserted.connect(self.reset_choices)\n        self._loaders.events.removed.connect(self.reset_choices)\n        self._loaders.events.moved.connect(self.reset_choices)\n\n    def __post_init__(self):\n        self.native.setSizePolicy(\n            QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding\n        )\n        self.sta.visible = False\n\n    def _get_loader_paths(self, *_) -&gt; list[PathInfo]:\n        return [prj._get_loader_paths() for prj in self.constructor.projects]\n\n    def _get_expression(self, *_):\n        return self.constructor._get_expression()\n\n    def _get_constructor_scale(self, *_) -&gt; float:\n        return self.constructor.scale.value\n\n    @set_design(text=capitalize, location=ProjectSequenceEdit.File)\n    @do_not_record\n    def new_projects(\n        self,\n        paths: Path.Multiple[FileFilter.IMAGE],\n        save_root: Path.Save[FileFilter.DIRECTORY],\n        ref_paths: Path.Multiple[FileFilter.IMAGE] = [],\n        scale: Annotated[Optional[float], {\"text\": \"Use image original scale\", \"options\": {\"min\": 0.01, \"step\": 0.0001},}] = None,\n        tilt_model: Annotated[dict, {\"widget_type\": TiltModelEdit}] = None,\n        bin_size: list[int] = [1],\n        invert: bool = False,\n        extension: Literal[\"\", \".zip\", \".tar\"] = \"\",\n        strip_prefix: str = \"\",\n        strip_suffix: str = \"\",\n        overwrite: bool = True,\n    ):  # fmt: skip\n        \"\"\"Create new projects from images.\n\n        This method is usually used for batch processing, efficient visual inspection,\n        and particle picking.\n\n        Parameters\n        ----------\n        paths : list of str or Path\n            A list of image paths or wildcard patterns, such as \"path/to/*.mrc\".\n        save_root : str or Path\n            The root directory to save the output projects.\n        ref_paths : list of str or Path, optional\n            A list of reference image paths. Reference images are usually a binned or\n            denoised version of the original images.\n        scale : float, optional\n            The scale of the images in nanometers. If None, the original scale of the\n            images will be used.\n        tilt_model : dict, optional\n            A tilt model that describes the tilt angles and axis.\n        bin_size : list of int, default [1]\n            Initial bin size of image. Binned image will be used for visualization in\n            the viewer. You can use both binned and non-binned image for analysis.\n        invert : bool, default False\n            Whether to invert the image intensities.\n        extension : str, default \"\"\n            The file extension (or directory) of the saved project files.\n        strip_prefix : str, default \"\"\n            A prefix to strip from the project name.\n        strip_suffix : str, default \"\"\n            A suffix to strip from the project name.\n        overwrite : bool, default True\n            If child project files of the same name already exist under the save root,\n            they will be overwritten. This is useful when cylindra batch project is\n            imported from file outputs of a long-running job from other softwares.\n        \"\"\"\n        self._new_projects_from_table(\n            unwrap_wildcard(paths),\n            save_root=save_root,\n            ref_paths=unwrap_wildcard(ref_paths) or None,\n            scale=[scale] * len(paths),\n            tilt_model=[tilt_model] * len(paths),\n            bin_size=[bin_size] * len(paths),\n            invert=[invert] * len(paths),\n            extension=extension,\n            strip_prefix=strip_prefix,\n            strip_suffix=strip_suffix,\n            overwrite=overwrite,\n        )\n\n    def _new_projects_from_table(\n        self,\n        path: list[Path],\n        save_root: Path,\n        ref_paths: list[Path] | None = None,\n        scale: list[float | None] | None = None,\n        tilt_model: list[dict | None] | None = None,\n        bin_size: list[list[int]] | None = None,\n        invert: list[bool] | None = None,\n        splines: list[\"CylSpline\"] | None = None,\n        molecules: list[dict[str, Molecules]] | None = None,\n        extension: Literal[\"\", \".zip\", \".tar\"] = \"\",\n        strip_prefix: str = \"\",\n        strip_suffix: str = \"\",\n        overwrite: bool = True,\n    ):\n        projects = list[tuple[CylindraProject, str]]()\n        num_projects = len(path)\n        for img_path, _scale, _ref, tlt, _bin_size, _inv in zip(\n            path,\n            _or_default_list(scale, None, num_projects),\n            _or_default_list(ref_paths, None, num_projects),\n            _or_default_list(tilt_model, None, num_projects),\n            _or_default_list(bin_size, [1], num_projects),\n            _or_default_list(invert, False, num_projects),\n            strict=True,\n        ):\n            each_project = CylindraProject.new(\n                img_path,\n                scale=_scale,\n                image_reference=_ref,\n                multiscales=_bin_size,\n                missing_wedge=tlt,\n                invert=_inv,\n            )\n            prj_name = img_path.stem\n            projects.append((each_project, prj_name))\n        if len(projects) == 0:\n            raise ValueError(\"No projects created.\")\n        save_root.mkdir(parents=True, exist_ok=True)\n        self.constructor.projects.clear()\n        for (prj, prj_name), spl, mole in zip(\n            projects,\n            splines or [[]] * num_projects,\n            molecules or [{}] * num_projects,\n            strict=True,\n        ):\n            if strip_prefix and prj_name.startswith(strip_prefix):\n                prj_name = prj_name[len(strip_prefix) :]\n            if strip_suffix and prj_name.endswith(strip_suffix):\n                prj_name = prj_name[: -len(strip_suffix)]\n            save_path = save_root / f\"{prj_name}{extension}\"\n            if save_path.exists() and not overwrite:\n                prj = CylindraProject.from_file(save_path)\n            else:\n                prj.save(save_path, splines=spl, molecules=mole)\n                prj.project_path = save_path\n            self.constructor.projects._add(prj.project_path)\n        self.save_batch_project(save_path=save_root)\n\n    @set_design(text=capitalize, location=constructor)\n    @thread_worker\n    def construct_loader(\n        self,\n        paths: Annotated[Any, {\"bind\": _get_loader_paths}],\n        predicate: Annotated[str | pl.Expr | None, {\"bind\": _get_expression}] = None,\n        name: str = \"Loader\",\n        scale: Annotated[float | None, {\"bind\": _get_constructor_scale}] = None,\n    ):  # fmt: skip\n        \"\"\"Construct a batch loader object from the given paths and predicate.\n\n        Parameters\n        ----------\n        paths : list of (Path, list[Path]) or list of (Path, list[Path], Path)\n            List of tuples of image path, list of molecule paths, and project path. The\n            project path is optional.\n        predicate : str or polars expression, optional\n            Filter predicate of molecules.\n        name : str, default \"Loader\"\n            Name of the loader.\n        \"\"\"\n        if name == \"\":\n            raise ValueError(\"Name must be given.\")\n\n        yield 0.0, 0.0  # this function yields the progress\n        loader = BatchLoader()\n        image_paths = dict[int, Path]()\n        invert = dict[int, bool]()\n        _temp_feat = TempFeatures()\n        for img_id, path_info in enumerate(paths):\n            path_info = PathInfo(*path_info)\n            img = path_info.lazy_imread()\n            image_paths[img_id] = Path(path_info.image)\n            invert[img_id] = path_info.need_invert\n            if scale is None:\n                if prj := path_info.project_instance():\n                    scale = prj.scale\n                else:\n                    scale = img.scale.x\n            if prj := path_info.project_instance():\n                tilt = prj.missing_wedge.as_param()\n                if tilt is not None:\n                    tilt = parse_tilt_model(tilt)\n            else:\n                tilt = None\n            for molecule_id, mole in enumerate(\n                path_info.iter_molecules(_temp_feat, scale)\n            ):\n                loader.add_tomogram(img.value, mole, img_id, tilt_model=tilt)\n                yield img_id / len(paths), molecule_id / len(path_info.molecules)\n            yield (img_id + 1) / len(paths), 0.0\n        yield 1.0, 1.0\n\n        if predicate is not None:\n            if isinstance(predicate, str):\n                predicate = eval(predicate, POLARS_NAMESPACE, {})\n            loader = loader.filter(predicate)\n        new = loader.replace(\n            molecules=loader.molecules.drop_features(_temp_feat.to_drop),\n            scale=scale,\n        )\n\n        @thread_worker.callback\n        def _on_return():\n            self._add_loader(new, name, image_paths, invert)\n\n        return _on_return\n\n    @construct_loader.yielded.connect\n    def _on_construct_loader_yielded(self, prog: tuple[float, float]):\n        btn = get_button(self.construct_loader, cache=True)\n        btn.text = f\"Constructing... ({prog[0]:.1%}, {prog[1]:.1%})\"\n\n    @construct_loader.finished.connect\n    def _on_construct_loader_finished(self):\n        btn = get_button(self.construct_loader, cache=True)\n        btn.text = \"Construct loader\"\n\n    @set_design(text=capitalize, location=ProjectSequenceEdit.File)\n    def construct_loader_by_list(\n        self,\n        project_paths: Path.Multiple[FileFilter.PROJECT],\n        mole_pattern: str = \"*\",\n        predicate: Annotated[str | pl.Expr | None, {\"bind\": _get_expression}] = None,\n        name: str = \"Loader\",\n    ):\n        \"\"\"Construct a batch loader from a list of project paths and a molecule pattern.\n\n        Parameters\n        ----------\n        project_paths : list of path-like\n            All the project paths to be used for construction. Entries can contain\n            glob patterns such as \"*\" and \"?\".\n        mole_pattern : str, default \"*\"\n            A glob pattern for molecule file names. For example, \"*-ALN1.csv\" will only\n            collect the molecule file names ends with \"-ALN1.csv\".\n        predicate : str or polars expression, optional\n            Filter predicate of molecules.\n        name : str, default \"Loader\"\n            Name of the loader.\n        \"\"\"\n        self.constructor.add_projects(project_paths, clear=True)\n        self.constructor.select_molecules_by_pattern(mole_pattern)\n        self.construct_loader(self._get_loader_paths(), predicate=predicate, name=name)\n\n    def _add_loader(\n        self,\n        loader: BatchLoader,\n        name: str,\n        image_paths: dict[int, Path],\n        invert: dict[int, bool],\n    ):\n        self._loaders.append(LoaderInfo(loader, name, image_paths, invert))\n        self.sta.visible = True\n        try:\n            self.sta[\"loader_name\"].value = self.sta[\"loader_name\"].choices[-1]\n        except Exception:\n            pass  # Updating the value is not important. Silence just in case.\n\n    @set_design(text=capitalize, location=ProjectSequenceEdit.MacroMenu)\n    @do_not_record\n    def show_macro(self):\n        \"\"\"Show the macro widget of the batch analyzer.\"\"\"\n        from cylindra import instance\n\n        ui = instance()\n        assert ui is not None\n        macro_str = self.macro.widget.textedit.value\n        ui.OthersMenu.Macro._get_macro_window(macro_str, \"Batch\")\n\n    @set_design(text=capitalize, location=ProjectSequenceEdit.MacroMenu)\n    @do_not_record\n    def show_native_macro(self):\n        \"\"\"Show the native macro widget of the batch analyzer.\"\"\"\n        self.macro.widget.show()\n        ACTIVE_WIDGETS.add(self.macro.widget)\n\n    @set_design(text=\"Load batch analysis project\", location=ProjectSequenceEdit.File)\n    @confirm(\n        text=\"Are you sure to clear all loaders?\", condition=\"len(self._loaders) &gt; 0\"\n    )\n    def load_batch_project(self, path: Path.Read[FileFilter.PROJECT]):\n        \"\"\"Load a batch project from a JSON file.\n\n        Parameters\n        ----------\n        path : path-like\n            Path to the JSON file.\n        \"\"\"\n        self._loaders.clear()\n        return CylindraBatchProject.from_file(path)._to_gui(self)\n\n    @set_design(\n        text=\"Save as batch analysis project\", location=ProjectSequenceEdit.File\n    )\n    @do_not_record\n    def save_batch_project(\n        self,\n        save_path: Path.Save,\n        molecules_ext: Literal[\".csv\", \".parquet\"] = \".csv\",\n    ):\n        \"\"\"Save the GUI state to a JSON file.\n\n        Parameters\n        ----------\n        save_path : path-like\n            Path to the JSON file.\n        molecules_ext : str, default \".csv\"\n            Extension of the molecule files.\n        \"\"\"\n        return CylindraBatchProject.save_gui(self, Path(save_path), molecules_ext)\n</code></pre>"},{"location":"api/widgets/batch/#cylindra.widgets.batch.CylindraBatchWidget.construct_loader","title":"<code>construct_loader(paths, predicate=None, name='Loader', scale=None)</code>","text":"<p>Construct a batch loader object from the given paths and predicate.</p> <p>Parameters:</p> Name Type Description Default <code>paths</code> <code>list of (Path, list[Path]) or list of (Path, list[Path], Path)</code> <p>List of tuples of image path, list of molecule paths, and project path. The project path is optional.</p> required <code>predicate</code> <code>str or polars expression</code> <p>Filter predicate of molecules.</p> <code>None</code> <code>name</code> <code>str</code> <p>Name of the loader.</p> <code>\"Loader\"</code> Source code in <code>cylindra/widgets/batch/main.py</code> <pre><code>@set_design(text=capitalize, location=constructor)\n@thread_worker\ndef construct_loader(\n    self,\n    paths: Annotated[Any, {\"bind\": _get_loader_paths}],\n    predicate: Annotated[str | pl.Expr | None, {\"bind\": _get_expression}] = None,\n    name: str = \"Loader\",\n    scale: Annotated[float | None, {\"bind\": _get_constructor_scale}] = None,\n):  # fmt: skip\n    \"\"\"Construct a batch loader object from the given paths and predicate.\n\n    Parameters\n    ----------\n    paths : list of (Path, list[Path]) or list of (Path, list[Path], Path)\n        List of tuples of image path, list of molecule paths, and project path. The\n        project path is optional.\n    predicate : str or polars expression, optional\n        Filter predicate of molecules.\n    name : str, default \"Loader\"\n        Name of the loader.\n    \"\"\"\n    if name == \"\":\n        raise ValueError(\"Name must be given.\")\n\n    yield 0.0, 0.0  # this function yields the progress\n    loader = BatchLoader()\n    image_paths = dict[int, Path]()\n    invert = dict[int, bool]()\n    _temp_feat = TempFeatures()\n    for img_id, path_info in enumerate(paths):\n        path_info = PathInfo(*path_info)\n        img = path_info.lazy_imread()\n        image_paths[img_id] = Path(path_info.image)\n        invert[img_id] = path_info.need_invert\n        if scale is None:\n            if prj := path_info.project_instance():\n                scale = prj.scale\n            else:\n                scale = img.scale.x\n        if prj := path_info.project_instance():\n            tilt = prj.missing_wedge.as_param()\n            if tilt is not None:\n                tilt = parse_tilt_model(tilt)\n        else:\n            tilt = None\n        for molecule_id, mole in enumerate(\n            path_info.iter_molecules(_temp_feat, scale)\n        ):\n            loader.add_tomogram(img.value, mole, img_id, tilt_model=tilt)\n            yield img_id / len(paths), molecule_id / len(path_info.molecules)\n        yield (img_id + 1) / len(paths), 0.0\n    yield 1.0, 1.0\n\n    if predicate is not None:\n        if isinstance(predicate, str):\n            predicate = eval(predicate, POLARS_NAMESPACE, {})\n        loader = loader.filter(predicate)\n    new = loader.replace(\n        molecules=loader.molecules.drop_features(_temp_feat.to_drop),\n        scale=scale,\n    )\n\n    @thread_worker.callback\n    def _on_return():\n        self._add_loader(new, name, image_paths, invert)\n\n    return _on_return\n</code></pre>"},{"location":"api/widgets/batch/#cylindra.widgets.batch.CylindraBatchWidget.construct_loader_by_list","title":"<code>construct_loader_by_list(project_paths, mole_pattern='*', predicate=None, name='Loader')</code>","text":"<p>Construct a batch loader from a list of project paths and a molecule pattern.</p> <p>Parameters:</p> Name Type Description Default <code>project_paths</code> <code>list of path-like</code> <p>All the project paths to be used for construction. Entries can contain glob patterns such as \"*\" and \"?\".</p> required <code>mole_pattern</code> <code>str</code> <p>A glob pattern for molecule file names. For example, \"*-ALN1.csv\" will only collect the molecule file names ends with \"-ALN1.csv\".</p> <code>\"*\"</code> <code>predicate</code> <code>str or polars expression</code> <p>Filter predicate of molecules.</p> <code>None</code> <code>name</code> <code>str</code> <p>Name of the loader.</p> <code>\"Loader\"</code> Source code in <code>cylindra/widgets/batch/main.py</code> <pre><code>@set_design(text=capitalize, location=ProjectSequenceEdit.File)\ndef construct_loader_by_list(\n    self,\n    project_paths: Path.Multiple[FileFilter.PROJECT],\n    mole_pattern: str = \"*\",\n    predicate: Annotated[str | pl.Expr | None, {\"bind\": _get_expression}] = None,\n    name: str = \"Loader\",\n):\n    \"\"\"Construct a batch loader from a list of project paths and a molecule pattern.\n\n    Parameters\n    ----------\n    project_paths : list of path-like\n        All the project paths to be used for construction. Entries can contain\n        glob patterns such as \"*\" and \"?\".\n    mole_pattern : str, default \"*\"\n        A glob pattern for molecule file names. For example, \"*-ALN1.csv\" will only\n        collect the molecule file names ends with \"-ALN1.csv\".\n    predicate : str or polars expression, optional\n        Filter predicate of molecules.\n    name : str, default \"Loader\"\n        Name of the loader.\n    \"\"\"\n    self.constructor.add_projects(project_paths, clear=True)\n    self.constructor.select_molecules_by_pattern(mole_pattern)\n    self.construct_loader(self._get_loader_paths(), predicate=predicate, name=name)\n</code></pre>"},{"location":"api/widgets/batch/#cylindra.widgets.batch.CylindraBatchWidget.load_batch_project","title":"<code>load_batch_project(path)</code>","text":"<p>Load a batch project from a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>path - like</code> <p>Path to the JSON file.</p> required Source code in <code>cylindra/widgets/batch/main.py</code> <pre><code>@set_design(text=\"Load batch analysis project\", location=ProjectSequenceEdit.File)\n@confirm(\n    text=\"Are you sure to clear all loaders?\", condition=\"len(self._loaders) &gt; 0\"\n)\ndef load_batch_project(self, path: Path.Read[FileFilter.PROJECT]):\n    \"\"\"Load a batch project from a JSON file.\n\n    Parameters\n    ----------\n    path : path-like\n        Path to the JSON file.\n    \"\"\"\n    self._loaders.clear()\n    return CylindraBatchProject.from_file(path)._to_gui(self)\n</code></pre>"},{"location":"api/widgets/batch/#cylindra.widgets.batch.CylindraBatchWidget.new_projects","title":"<code>new_projects(paths, save_root, ref_paths=[], scale=None, tilt_model=None, bin_size=[1], invert=False, extension='', strip_prefix='', strip_suffix='', overwrite=True)</code>","text":"<p>Create new projects from images.</p> <p>This method is usually used for batch processing, efficient visual inspection, and particle picking.</p> <p>Parameters:</p> Name Type Description Default <code>paths</code> <code>list of str or Path</code> <p>A list of image paths or wildcard patterns, such as \"path/to/*.mrc\".</p> required <code>save_root</code> <code>str or Path</code> <p>The root directory to save the output projects.</p> required <code>ref_paths</code> <code>list of str or Path</code> <p>A list of reference image paths. Reference images are usually a binned or denoised version of the original images.</p> <code>[]</code> <code>scale</code> <code>float</code> <p>The scale of the images in nanometers. If None, the original scale of the images will be used.</p> <code>None</code> <code>tilt_model</code> <code>dict</code> <p>A tilt model that describes the tilt angles and axis.</p> <code>None</code> <code>bin_size</code> <code>list of int</code> <p>Initial bin size of image. Binned image will be used for visualization in the viewer. You can use both binned and non-binned image for analysis.</p> <code>[1]</code> <code>invert</code> <code>bool</code> <p>Whether to invert the image intensities.</p> <code>False</code> <code>extension</code> <code>str</code> <p>The file extension (or directory) of the saved project files.</p> <code>\"\"</code> <code>strip_prefix</code> <code>str</code> <p>A prefix to strip from the project name.</p> <code>\"\"</code> <code>strip_suffix</code> <code>str</code> <p>A suffix to strip from the project name.</p> <code>\"\"</code> <code>overwrite</code> <code>bool</code> <p>If child project files of the same name already exist under the save root, they will be overwritten. This is useful when cylindra batch project is imported from file outputs of a long-running job from other softwares.</p> <code>True</code> Source code in <code>cylindra/widgets/batch/main.py</code> <pre><code>@set_design(text=capitalize, location=ProjectSequenceEdit.File)\n@do_not_record\ndef new_projects(\n    self,\n    paths: Path.Multiple[FileFilter.IMAGE],\n    save_root: Path.Save[FileFilter.DIRECTORY],\n    ref_paths: Path.Multiple[FileFilter.IMAGE] = [],\n    scale: Annotated[Optional[float], {\"text\": \"Use image original scale\", \"options\": {\"min\": 0.01, \"step\": 0.0001},}] = None,\n    tilt_model: Annotated[dict, {\"widget_type\": TiltModelEdit}] = None,\n    bin_size: list[int] = [1],\n    invert: bool = False,\n    extension: Literal[\"\", \".zip\", \".tar\"] = \"\",\n    strip_prefix: str = \"\",\n    strip_suffix: str = \"\",\n    overwrite: bool = True,\n):  # fmt: skip\n    \"\"\"Create new projects from images.\n\n    This method is usually used for batch processing, efficient visual inspection,\n    and particle picking.\n\n    Parameters\n    ----------\n    paths : list of str or Path\n        A list of image paths or wildcard patterns, such as \"path/to/*.mrc\".\n    save_root : str or Path\n        The root directory to save the output projects.\n    ref_paths : list of str or Path, optional\n        A list of reference image paths. Reference images are usually a binned or\n        denoised version of the original images.\n    scale : float, optional\n        The scale of the images in nanometers. If None, the original scale of the\n        images will be used.\n    tilt_model : dict, optional\n        A tilt model that describes the tilt angles and axis.\n    bin_size : list of int, default [1]\n        Initial bin size of image. Binned image will be used for visualization in\n        the viewer. You can use both binned and non-binned image for analysis.\n    invert : bool, default False\n        Whether to invert the image intensities.\n    extension : str, default \"\"\n        The file extension (or directory) of the saved project files.\n    strip_prefix : str, default \"\"\n        A prefix to strip from the project name.\n    strip_suffix : str, default \"\"\n        A suffix to strip from the project name.\n    overwrite : bool, default True\n        If child project files of the same name already exist under the save root,\n        they will be overwritten. This is useful when cylindra batch project is\n        imported from file outputs of a long-running job from other softwares.\n    \"\"\"\n    self._new_projects_from_table(\n        unwrap_wildcard(paths),\n        save_root=save_root,\n        ref_paths=unwrap_wildcard(ref_paths) or None,\n        scale=[scale] * len(paths),\n        tilt_model=[tilt_model] * len(paths),\n        bin_size=[bin_size] * len(paths),\n        invert=[invert] * len(paths),\n        extension=extension,\n        strip_prefix=strip_prefix,\n        strip_suffix=strip_suffix,\n        overwrite=overwrite,\n    )\n</code></pre>"},{"location":"api/widgets/batch/#cylindra.widgets.batch.CylindraBatchWidget.save_batch_project","title":"<code>save_batch_project(save_path, molecules_ext='.csv')</code>","text":"<p>Save the GUI state to a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>save_path</code> <code>path - like</code> <p>Path to the JSON file.</p> required <code>molecules_ext</code> <code>str</code> <p>Extension of the molecule files.</p> <code>\".csv\"</code> Source code in <code>cylindra/widgets/batch/main.py</code> <pre><code>@set_design(\n    text=\"Save as batch analysis project\", location=ProjectSequenceEdit.File\n)\n@do_not_record\ndef save_batch_project(\n    self,\n    save_path: Path.Save,\n    molecules_ext: Literal[\".csv\", \".parquet\"] = \".csv\",\n):\n    \"\"\"Save the GUI state to a JSON file.\n\n    Parameters\n    ----------\n    save_path : path-like\n        Path to the JSON file.\n    molecules_ext : str, default \".csv\"\n        Extension of the molecule files.\n    \"\"\"\n    return CylindraBatchProject.save_gui(self, Path(save_path), molecules_ext)\n</code></pre>"},{"location":"api/widgets/batch/#cylindra.widgets.batch.CylindraBatchWidget.show_macro","title":"<code>show_macro()</code>","text":"<p>Show the macro widget of the batch analyzer.</p> Source code in <code>cylindra/widgets/batch/main.py</code> <pre><code>@set_design(text=capitalize, location=ProjectSequenceEdit.MacroMenu)\n@do_not_record\ndef show_macro(self):\n    \"\"\"Show the macro widget of the batch analyzer.\"\"\"\n    from cylindra import instance\n\n    ui = instance()\n    assert ui is not None\n    macro_str = self.macro.widget.textedit.value\n    ui.OthersMenu.Macro._get_macro_window(macro_str, \"Batch\")\n</code></pre>"},{"location":"api/widgets/batch/#cylindra.widgets.batch.CylindraBatchWidget.show_native_macro","title":"<code>show_native_macro()</code>","text":"<p>Show the native macro widget of the batch analyzer.</p> Source code in <code>cylindra/widgets/batch/main.py</code> <pre><code>@set_design(text=capitalize, location=ProjectSequenceEdit.MacroMenu)\n@do_not_record\ndef show_native_macro(self):\n    \"\"\"Show the native macro widget of the batch analyzer.\"\"\"\n    self.macro.widget.show()\n    ACTIVE_WIDGETS.add(self.macro.widget)\n</code></pre>"},{"location":"api/widgets/batch/#batchsubtomogramaveraging","title":"BatchSubtomogramAveraging","text":"<p>Methods are available in the namespace <code>ui.batch.sta</code>.</p> Source code in <code>cylindra/widgets/batch/sta.py</code> <pre><code>@magicclass(name=\"Batch Subtomogram Analysis\")\n@_shared_doc.update_cls\nclass BatchSubtomogramAveraging(MagicTemplate):\n    def _get_parent(self):\n        from .main import CylindraBatchWidget\n\n        return self.find_ancestor(CylindraBatchWidget, cache=True)\n\n    def _get_loader_names(self, _=None) -&gt; list[str]:\n        try:\n            parent = self._get_parent()\n        except Exception:\n            return []\n        return parent.loader_infos.names()\n\n    # Menus\n    BatchSubtomogramAnalysis = field(\n        BatchSubtomogramAnalysis, name=\"Subtomogram Analysis\"\n    )\n    BatchRefinement = field(BatchRefinement, name=\"Refinement\")\n    BatchLoaderMenu = field(BatchLoaderMenu, name=\"Loader\")\n\n    @magicclass(layout=\"horizontal\", properties={\"margins\": (0, 0, 0, 0)})\n    class Header(MagicTemplate):\n        loader_name = abstractapi()\n        show_loader_info = abstractapi()\n        remove_loader = abstractapi()\n\n    loader_name = vfield(str, location=Header, record=False).with_choices(\n        choices=_get_loader_names\n    )\n\n    def _get_current_loader_name(self, _=None) -&gt; str:\n        return self.loader_name\n\n    @set_design(text=\"??\", max_width=36, location=Header)\n    @do_not_record\n    def show_loader_info(self):\n        \"\"\"Show information about this loader\"\"\"\n        info = self._get_parent().loader_infos[self.loader_name]\n        loader = info.loader\n        img_info = \"\\n\" + \"\\n\".join(\n            f\"{img_id}: {img_path}\" for img_id, img_path in info.image_paths.items()\n        )\n\n        info_text = (\n            f\"name: {info.name}\\nmolecule: n={loader.count()}\\nimages:{img_info}\"\n        )\n        view = DataFrameView(value=loader.molecules.to_dataframe())\n        txt = ConsoleTextEdit(value=info_text)\n        txt.read_only = True\n        cnt = Container(widgets=[txt, view], layout=\"horizontal\", labels=False)\n        cnt.native.setParent(self.native, cnt.native.windowFlags())\n        cnt.show()\n\n    @set_design(text=\"\u2715\", max_width=36, location=Header)\n    def remove_loader(\n        self, loader_name: Annotated[str, {\"bind\": _get_current_loader_name}]\n    ):\n        \"\"\"Remove this loader\"\"\"\n        del self._get_parent().loader_infos[loader_name]\n\n    params = field(StaParameters)\n\n    def _get_selected_loader_choice(self, *_) -&gt; list[str]:\n        try:\n            loader = self.get_loader(self.loader_name)\n            return loader.molecules.features.columns\n        except Exception:\n            return []\n\n    def _get_template_path(self, _=None):\n        return self.params.template_path.value\n\n    def _get_mask_params(self, _=None):\n        return self.params._get_mask_params()\n\n    @set_design(text=\"Split loader\", location=BatchLoaderMenu)\n    def split_loader(\n        self,\n        loader_name: Annotated[str, {\"bind\": _get_current_loader_name}],\n        by: Annotated[str, {\"choices\": _get_selected_loader_choice}],\n        delete_old: bool = False,\n    ):\n        \"\"\"Split the selected loader by the values of the given column.\n\n        Parameters\n        ----------\n        loader_name : str\n            Name of the input loader\n        by : str\n            Column name to split the loader\n        delete_old : bool, default False\n            If true, the original loader will be deleted.\n        \"\"\"\n        parent = self._get_parent()\n        loaders = parent._loaders\n        batch_info = loaders[loader_name]\n        batch_loader = batch_info.loader\n        n_unique = batch_loader.molecules.features[by].n_unique()\n        if n_unique &gt; 48:\n            raise ValueError(\n                f\"Too many groups ({n_unique}). Did you choose a float column?\"\n            )\n        for _key, loader in batch_loader.groupby(by):\n            existing_id = set(loader.features[Mole.image])\n            image_paths = {\n                k: v for k, v in batch_info.image_paths.items() if v in existing_id\n            }\n            invert = {k: v for k, v in batch_info.invert.items() if v in existing_id}\n            parent._add_loader(loader, f\"{loader_name}_{_key}\", image_paths, invert)\n\n        if delete_old:\n            idx = -1\n            for i, info in enumerate(loaders):\n                if info.loader is batch_loader:\n                    idx = i\n                    break\n            else:\n                idx = -1\n            if idx &lt; 0:\n                raise RuntimeError(\"Loader not found.\")\n            del loaders[idx]\n\n    @set_design(text=\"Filter loader\", location=BatchLoaderMenu)\n    def filter_loader(\n        self,\n        loader_name: Annotated[str, {\"bind\": _get_current_loader_name}],\n        expression: PolarsExprStr,\n    ):\n        \"\"\"Filter the selected loader and add the filtered one to the list.\n\n        Parameters\n        ----------\n        loader_name : str\n            Name of the input loader\n        expression : str\n            polars expression that will be used to filter the loader. For example,\n            `col(\"score\") &gt; 0.7` will filter out all low-score molecules.\n        \"\"\"\n        loaderlist = self._get_parent()._loaders\n        info = loaderlist[loader_name]\n        loader = info.loader\n        new = loader.filter(norm_expr(expression))\n        existing_id = set(new.features[Mole.image])\n        loaderlist.add_loader(\n            new,\n            name=f\"{info.name}-Filt\",\n            image_paths={k: v for k, v in info.image_paths.items() if v in existing_id},\n            invert={k: v for k, v in info.invert.items() if v in existing_id},\n        )\n        return None\n\n    @nogui\n    def get_loader(self, name: str) -&gt; BatchLoader:\n        \"\"\"Return the acryo.BatchLoader object with the given name\"\"\"\n        if not isinstance(name, str):\n            raise TypeError(f\"Name must be a string, got {type(name).__name__}\")\n        return self._get_parent().loader_infos[name].loader\n\n    @set_design(text=\"Average all molecules\", location=BatchSubtomogramAnalysis)\n    @dask_thread_worker.with_progress(desc=\"Averaging all molecules in projects\")\n    def average_all(\n        self,\n        loader_name: Annotated[str, {\"bind\": _get_current_loader_name}],\n        size: _SubVolumeSize = None,\n        interpolation: Annotated[int, {\"choices\": INTERPOLATION_CHOICES}] = 1,\n        bin_size: _BINSIZE = 1,\n    ):\n        \"\"\"Average all the molecules in the selected loader.\n\n        Parameters\n        ----------\n        {loader_name}{size}{interpolation}{bin_size}\n        \"\"\"\n        t0 = timer()\n        loader = self._get_parent().loader_infos[loader_name].loader\n        shape = self._get_shape_in_px(size, loader)\n        img = ip.asarray(\n            loader.replace(output_shape=shape, order=interpolation)\n            .binning(bin_size, compute=False)\n            .average(),\n            axes=\"zyx\",\n        ).set_scale(zyx=loader.scale * bin_size, unit=\"nm\")\n        t0.toc()\n        return self._show_rec.with_args(img, f\"[AVG]{loader_name}\")\n\n    @set_design(text=\"Average group-wise\", location=BatchSubtomogramAnalysis)\n    @dask_thread_worker.with_progress(desc=\"Grouped subtomogram averaging\")\n    def average_groups(\n        self,\n        loader_name: Annotated[str, {\"bind\": _get_current_loader_name}],\n        size: _SubVolumeSize = None,\n        by: PolarsExprStr = \"col('pf-id')\",\n        interpolation: Annotated[int, {\"choices\": INTERPOLATION_CHOICES}] = 1,\n        bin_size: _BINSIZE = 1,\n    ):\n        \"\"\"Groupwise subtomogram averaging using molecules grouped by the given expression.\n\n        This method first group molecules by its features, and then average each group.\n        This method is useful for such as get average of each protofilament and\n        segmented subtomogram averaging.\n\n        Parameters\n        ----------\n        {loader_name}{size}\n        by : str or polars expression\n            Expression to group molecules.\n        {interpolation}{bin_size}\n        \"\"\"\n        t0 = timer()\n        loader = self._get_parent().loader_infos[loader_name].loader\n        shape = self._get_shape_in_px(size, loader)\n        img = ip.asarray(\n            loader.replace(output_shape=shape, order=interpolation)\n            .binning(bin_size, compute=False)\n            .groupby(norm_expr(by))\n            .average()\n            .value_stack(axis=0),\n            axes=\"pzyx\",\n        ).set_scale(zyx=loader.scale * bin_size, unit=\"nm\")\n        t0.toc()\n        return self._show_rec.with_args(img, f\"[AVG]{loader_name}\", store=False)\n\n    @set_design(text=\"Align all molecules\", location=BatchRefinement)\n    @dask_thread_worker.with_progress(desc=\"Aligning all molecules\")\n    def align_all(\n        self,\n        loader_name: Annotated[str, {\"bind\": _get_current_loader_name}],\n        template_path: Annotated[str | Path, {\"bind\": _get_template_path}],\n        mask_params: Annotated[Any, {\"bind\": _get_mask_params}],\n        max_shifts: _MaxShifts = (1.0, 1.0, 1.0),\n        rotations: _Rotations = ((0.0, 0.0), (0.0, 0.0), (0.0, 0.0)),\n        cutoff: _CutoffFreq = 0.5,\n        interpolation: Annotated[int, {\"choices\": INTERPOLATION_CHOICES}] = 3,\n        method: Annotated[str, {\"choices\": METHOD_CHOICES}] = \"zncc\",\n        bin_size: _BINSIZE = 1,\n    ):  # fmt: skip\n        \"\"\"\n        Align all the molecules in the selected loader.\n\n        Parameters\n        ----------\n        {loader_name}{template_path}{mask_params}{max_shifts}{rotations}{cutoff}\n        {interpolation}{method}{bin_size}\n        \"\"\"\n        t0 = timer()\n        loaderlist = self._get_parent()._loaders\n        info = loaderlist[loader_name]\n        loader = info.loader\n        template, mask = loader.normalize_input(\n            template=self.params._norm_template_param(template_path),\n            mask=self.params._get_mask(params=mask_params),\n        )\n        _Logger.print(f\"Aligning {loader.molecules.count()} molecules ...\")\n        aligned = (\n            loader.replace(output_shape=template.shape, order=interpolation)\n            .binning(bin_size, compute=False)\n            .align(\n                template=template,\n                mask=mask,\n                max_shifts=max_shifts,\n                rotations=rotations,\n                cutoff=cutoff,\n                alignment_model=_get_alignment(method),\n            )\n        )\n        loaderlist.add_loader(\n            aligned,\n            name=_coerce_aligned_name(info.name, loaderlist),\n            image_paths=info.image_paths,\n            invert=info.invert,\n        )\n        t0.toc()\n        return None\n\n    @set_design(text=\"Align all (template-free)\", location=BatchRefinement)\n    @dask_thread_worker.with_progress()\n    def align_all_template_free(\n        self,\n        loader_name: Annotated[str, {\"bind\": _get_current_loader_name}],\n        mask_params: Annotated[Any, {\"bind\": _get_mask_params}],\n        size: _SubVolumeSize = 12.0,\n        max_shifts: _MaxShifts = (1.0, 1.0, 1.0),\n        rotations: _Rotations = ((0.0, 0.0), (0.0, 0.0), (0.0, 0.0)),\n        interpolation: Annotated[int, {\"choices\": INTERPOLATION_CHOICES}] = 3,\n        method: Annotated[str, {\"choices\": METHOD_CHOICES}] = \"zncc\",\n        bin_size: _BINSIZE = 1,\n        seed: Annotated[Optional[int], {\"text\": \"Do not use random seed.\"}] = 0,\n        tolerance: float = 0.01,\n    ):  # fmt: skip\n        \"\"\"Iteratively align molecules and validate using FSC without template.\n\n        Parameters\n        ----------\n        {loader_name}{mask_params}{size}{max_shifts}{rotations}{interpolation}\n        {method}{bin_size}\n        seed : int, optional\n            Random seed for FSC calculation.\n        tolerance : float, default 0.01\n            Tolerance for convergence of the FSC calculation.\n        \"\"\"\n        t0 = timer()\n        rng = np.random.default_rng(seed)\n        loaderlist = self._get_parent()._loaders\n        info = loaderlist[loader_name]\n        loader = info.loader\n        mask = self.params._get_mask(params=mask_params)\n        shape = self._get_shape_in_px(size, loader)\n        aligned_loader = current_loader = loader.replace(\n            output_shape=shape, order=interpolation\n        ).binning(bin_size, compute=False)\n        _Logger.print(f\"Aligning {loader.molecules.count()} molecules ...\")\n        _alignment_state = TemplateFreeAlignmentState(rng=rng)\n\n        while True:\n            yield thread_worker.description(\n                f\"Calculating FSC for iteration {_alignment_state.niter}\"\n            )\n            fsc_result, avg = _alignment_state.eval_fsc(\n                aligned_loader,\n                mask,\n                tolerance=tolerance,\n            )\n            yield _plot_current_fsc.with_args(\n                fsc_result, _alignment_state.niter, avg\n            ).with_desc(f\"Alignment for iteration {_alignment_state.niter}\")\n            if _alignment_state.converged:\n                _Logger.print(\"FSC converged.\")\n                yield self._show_rec.with_args(avg, f\"[Aligned]{info.name}\")\n                break\n            _alignment_state.niter += 1\n            aligned_loader = current_loader.align(\n                avg, mask=mask, max_shifts=max_shifts, rotations=rotations,\n                cutoff=current_loader.scale / fsc_result.get_resolution(0.143),\n                alignment_model=_get_alignment(method),\n            )  # fmt: skip\n\n        loaderlist.add_loader(\n            aligned_loader,\n            name=_coerce_aligned_name(info.name, loaderlist),\n            image_paths=info.image_paths,\n            invert=info.invert,\n        )\n        t0.toc()\n        return None\n\n    @set_design(text=\"Calculate FSC\", location=BatchSubtomogramAnalysis)\n    @dask_thread_worker.with_progress(desc=\"Calculating FSC\")\n    def calculate_fsc(\n        self,\n        loader_name: Annotated[str, {\"bind\": _get_current_loader_name}],\n        template_path: Annotated[str | Path | None, {\"bind\": _get_template_path}] = None,\n        mask_params: Annotated[Any, {\"bind\": _get_mask_params}] = None,\n        size: _SubVolumeSize = None,\n        seed: Annotated[Optional[int], {\"text\": \"Do not use random seed.\"}] = 0,\n        interpolation: Annotated[int, {\"choices\": INTERPOLATION_CHOICES}] = 1,\n        n_pairs: Annotated[int, {\"min\": 1, \"label\": \"number of image pairs\"}] = 1,\n        show_average: bool = True,\n        dfreq: FSCFreq = None,\n    ):  # fmt: skip\n        \"\"\"\n        Calculate Fourier Shell Correlation using the selected loader.\n\n        Parameters\n        ----------\n        {loader_name}{template_path}{mask_params}{size}\n        seed : int, optional\n            Random seed used for subtomogram sampling.\n        {interpolation}\n        n_pairs : int, default 1\n            How many sets of image pairs will be generated to average FSC.\n        show_average : bool, default True\n            If true, subtomogram averaging will be shown after FSC calculation.\n        dfreq : float, default 0.02\n            Precision of frequency to calculate FSC. \"0.02\" means that FSC will be\n            calculated at frequency 0.01, 0.03, 0.05, ..., 0.45.\n        \"\"\"\n        t0 = timer()\n        loader = (\n            self._get_parent()\n            .loader_infos[loader_name]\n            .loader.replace(order=interpolation)\n        )\n\n        template, mask = loader.normalize_input(\n            template=self.params._norm_template_param(template_path, allow_none=True),\n            mask=self.params._get_mask(params=mask_params),\n        )\n\n        fsc, (img_0, img_1), img_mask = loader.reshape(\n            template=template if size is None else None,\n            mask=mask,\n            shape=None if size is None else self._get_shape_in_px(size, loader),\n        ).fsc_with_halfmaps(mask, seed=seed, n_set=n_pairs, dfreq=dfreq, squeeze=False)\n\n        def _as_imgarray(im, axes: str = \"zyx\") -&gt; ip.ImgArray | None:\n            if np.isscalar(im):\n                return None\n            return ip.asarray(im, axes=axes).set_scale(zyx=loader.scale, unit=\"nm\")\n\n        if show_average:\n            avg = (img_0[0] + img_1[0]) / 2\n            img_avg = _as_imgarray(avg)\n        else:\n            img_avg = None\n\n        result = FscResult.from_dataframe(fsc, loader.scale)\n        criteria = [0.5, 0.143]\n        t0.toc()\n\n        @thread_worker.callback\n        def _calculate_fsc_on_return():\n            _Logger.print_html(f\"&lt;b&gt;Fourier Shell Correlation of {loader_name!r}&lt;/b&gt;\")\n            with _Logger.set_plt():\n                result.plot(criteria)\n                plt.tight_layout()\n                plt.show()\n            for _c in criteria:\n                _r = result.get_resolution(_c)\n                _Logger.print_html(f\"Resolution at FSC={_c:.3f} ... &lt;b&gt;{_r:.3f} nm&lt;/b&gt;\")\n\n            if img_avg is not None:\n                _imlayer: Image = self._show_rec(img_avg, name=f\"[AVG]{loader_name}\")\n                _imlayer.metadata[\"fsc\"] = result\n                _imlayer.metadata[\"fsc_halfmaps\"] = (\n                    _as_imgarray(img_0, axes=\"izyx\"),\n                    _as_imgarray(img_1, axes=\"izyx\"),\n                )\n                _imlayer.metadata[\"fsc_mask\"] = _as_imgarray(img_mask)\n\n        return _calculate_fsc_on_return\n\n    @set_design(text=\"PCA/K-means classification\", location=BatchSubtomogramAnalysis)\n    @dask_thread_worker.with_progress(descs=_classify_pca_fmt)\n    def classify_pca(\n        self,\n        loader_name: Annotated[str, {\"bind\": _get_current_loader_name}],\n        template_path: Annotated[str | Path | None, {\"bind\": _get_template_path}] = None,\n        mask_params: Annotated[Any, {\"bind\": _get_mask_params}] = None,\n        size: Annotated[Optional[nm], {\"text\": \"Use mask shape\", \"options\": {\"value\": 12.0, \"max\": 100.0}, \"label\": \"size (nm)\"}] = None,\n        cutoff: _CutoffFreq = 0.5,\n        interpolation: Annotated[int, {\"choices\": INTERPOLATION_CHOICES}] = 3,\n        bin_size: _BINSIZE = 1,\n        n_components: Annotated[int, {\"min\": 2, \"max\": 20}] = 2,\n        n_clusters: Annotated[int, {\"min\": 2, \"max\": 100}] = 2,\n        seed: Annotated[Optional[int], {\"text\": \"Do not use random seed.\"}] = 0,\n    ):  # fmt: skip\n        \"\"\"\n        Classify molecules in the loader using PCA and K-means clustering.\n\n        Parameters\n        ----------\n        {loader_name}{template_path}{mask_params}{size}{cutoff}{interpolation}{bin_size}\n        n_components : int, default 2\n            The number of PCA dimensions.\n        n_clusters : int, default 2\n            The number of clusters.\n        seed : int, default\n            Random seed.\n        \"\"\"\n        from cylindra.components.visualize import plot_pca_classification\n\n        t0 = timer()\n        loader = self._get_parent().loader_infos[loader_name].loader\n        template, mask = loader.normalize_input(\n            template=self.params._norm_template_param(template_path, allow_none=True),\n            mask=self.params._get_mask(params=mask_params),\n        )\n        shape = None\n        if mask is None:\n            shape = self._get_shape_in_px(size, loader)\n        out, pca = (\n            loader.reshape(\n                template=template if mask is None and shape is None else None,\n                mask=mask,\n                shape=shape,\n            )\n            .replace(order=interpolation)\n            .binning(binsize=bin_size, compute=False)\n            .classify(\n                mask=mask,\n                seed=seed,\n                cutoff=cutoff,\n                n_components=n_components,\n                n_clusters=n_clusters,\n                label_name=\"cluster\",\n            )\n        )\n\n        avgs = ip.asarray(\n            out.groupby(\"cluster\").average().value_stack(axis=0),\n            axes=[\"cluster\", \"z\", \"y\", \"x\"],\n        ).set_scale(zyx=loader.scale, unit=\"nm\")\n\n        transformed = pca.get_transform()\n        t0.toc()\n\n        @thread_worker.callback\n        def _on_return():\n            loader.molecules.features = out.molecules.features\n            with _Logger.set_plt():\n                plot_pca_classification(pca, transformed)\n            self._show_rec(avgs, name=f\"[PCA]{loader_name}\", store=False)\n\n        return _on_return\n\n    @magictoolbar\n    class STATools(MagicTemplate):\n        show_template = abstractapi()\n        show_template_original = abstractapi()\n        show_mask = abstractapi()\n\n    @set_design(icon=\"ic:baseline-view-in-ar\", location=STATools)\n    @do_not_record\n    def show_template(self):\n        \"\"\"Load and show template image in the scale of the tomogram.\"\"\"\n        template = self._get_template_image()\n        self._show_rec(template, name=\"Template image\", store=False)\n\n    @set_design(icon=\"material-symbols:view-in-ar\", location=STATools)\n    @do_not_record\n    def show_template_original(self):\n        \"\"\"Load and show template image in the original scale.\"\"\"\n        _input = self.params._get_template_input(allow_multiple=True)\n        if _input is None:\n            raise ValueError(\"No template path provided.\")\n        elif isinstance(_input, Path):\n            self._show_rec(ip.imread(_input), name=\"Template image\", store=False)\n        else:\n            for i, fp in enumerate(_input):\n                img = ip.imread(fp)\n                self._show_rec(img, name=f\"Template image [{i}]\", store=False)\n\n    @set_design(icon=\"fluent:shape-organic-20-filled\", location=STATools)\n    @do_not_record\n    def show_mask(self):\n        \"\"\"Load and show mask image in the scale of the tomogram.\"\"\"\n        loader = self.get_loader(self.loader_name)\n        _, mask = loader.normalize_input(\n            self.params._norm_template_param(\n                self.params._get_template_input(allow_multiple=False),\n                allow_none=True,\n            ),\n            self.params._get_mask(),\n        )\n        if mask is None:\n            raise ValueError(\"No mask to show.\")\n        mask = ip.asarray(mask, axes=\"zyx\").set_scale(zyx=loader.scale, unit=\"nm\")\n        self._show_rec(mask, name=\"Mask image\", store=False, threshold=0.5)\n\n    @thread_worker.callback\n    def _show_rec(\n        self, img: ip.ImgArray, name: str, store: bool = True, threshold=None\n    ):\n        return self.params._show_reconstruction(img, name, store, threshold)\n\n    def _get_shape_in_px(\n        self, default: \"nm | None\", loader: BatchLoader\n    ) -&gt; tuple[int, ...]:\n        if default is None:\n            tmp = self._get_template_image()\n            return tmp.sizesof(\"zyx\")\n        else:\n            return (roundint(default / loader.scale),) * 3\n\n    def _get_template_image(self) -&gt; ip.ImgArray:\n        scale = self.get_loader(self.loader_name).scale\n\n        template = self.params._norm_template_param(\n            self.params._get_template_input(allow_multiple=True),\n            allow_none=False,\n            allow_multiple=True,\n        ).provide(scale)\n        if isinstance(template, list):\n            template = ip.asarray(np.stack(template, axis=0), axes=\"zyx\")\n        else:\n            template = ip.asarray(template, axes=\"zyx\")\n        return template.set_scale(zyx=scale, unit=\"nm\")\n</code></pre>"},{"location":"api/widgets/batch/#cylindra.widgets.batch.sta.BatchSubtomogramAveraging.align_all","title":"<code>align_all(loader_name, template_path, mask_params, max_shifts=(1.0, 1.0, 1.0), rotations=((0.0, 0.0), (0.0, 0.0), (0.0, 0.0)), cutoff=0.5, interpolation=3, method='zncc', bin_size=1)</code>","text":"<p>Align all the molecules in the selected loader.</p> <p>Parameters:</p> Name Type Description Default <code>loader_name</code> <code>str</code> <p>Name of the batch subtomogram loader to be used.</p> required <code>template_path</code> <code>Path or str</code> <p>Path to template image.</p> required <code>mask_params</code> <code>str or (float, float)</code> <p>Mask image path or dilation/Gaussian blur parameters. If a path is given, image must in the same shape as the template.</p> required <code>max_shifts</code> <code>int or tuple of int</code> <p>Maximum shift between subtomograms and template in nm. ZYX order.</p> <code>(1.0, 1.0, 1.0)</code> <code>rotations</code> <code>((float, float), (float, float), (float, float))</code> <p>Rotation in external degree around each axis.</p> <code>((0.0, 0.0), (0.0, 0.0), (0.0, 0.0))</code> <code>cutoff</code> <code>float</code> <p>Cutoff frequency of low-pass filter applied in each subtomogram.</p> <code>0.5</code> <code>interpolation</code> <code>int</code> <p>Interpolation order.</p> <code>3</code> <code>method</code> <code>str</code> <p>Correlation metrics for alignment.</p> <code>'zncc'</code> <code>bin_size</code> <code>int</code> <p>Bin size of multiscale image to be used. Set to &gt;1 to boost performance.</p> <code>1</code> Source code in <code>cylindra/widgets/batch/sta.py</code> <pre><code>@set_design(text=\"Align all molecules\", location=BatchRefinement)\n@dask_thread_worker.with_progress(desc=\"Aligning all molecules\")\ndef align_all(\n    self,\n    loader_name: Annotated[str, {\"bind\": _get_current_loader_name}],\n    template_path: Annotated[str | Path, {\"bind\": _get_template_path}],\n    mask_params: Annotated[Any, {\"bind\": _get_mask_params}],\n    max_shifts: _MaxShifts = (1.0, 1.0, 1.0),\n    rotations: _Rotations = ((0.0, 0.0), (0.0, 0.0), (0.0, 0.0)),\n    cutoff: _CutoffFreq = 0.5,\n    interpolation: Annotated[int, {\"choices\": INTERPOLATION_CHOICES}] = 3,\n    method: Annotated[str, {\"choices\": METHOD_CHOICES}] = \"zncc\",\n    bin_size: _BINSIZE = 1,\n):  # fmt: skip\n    \"\"\"\n    Align all the molecules in the selected loader.\n\n    Parameters\n    ----------\n    {loader_name}{template_path}{mask_params}{max_shifts}{rotations}{cutoff}\n    {interpolation}{method}{bin_size}\n    \"\"\"\n    t0 = timer()\n    loaderlist = self._get_parent()._loaders\n    info = loaderlist[loader_name]\n    loader = info.loader\n    template, mask = loader.normalize_input(\n        template=self.params._norm_template_param(template_path),\n        mask=self.params._get_mask(params=mask_params),\n    )\n    _Logger.print(f\"Aligning {loader.molecules.count()} molecules ...\")\n    aligned = (\n        loader.replace(output_shape=template.shape, order=interpolation)\n        .binning(bin_size, compute=False)\n        .align(\n            template=template,\n            mask=mask,\n            max_shifts=max_shifts,\n            rotations=rotations,\n            cutoff=cutoff,\n            alignment_model=_get_alignment(method),\n        )\n    )\n    loaderlist.add_loader(\n        aligned,\n        name=_coerce_aligned_name(info.name, loaderlist),\n        image_paths=info.image_paths,\n        invert=info.invert,\n    )\n    t0.toc()\n    return None\n</code></pre>"},{"location":"api/widgets/batch/#cylindra.widgets.batch.sta.BatchSubtomogramAveraging.align_all_template_free","title":"<code>align_all_template_free(loader_name, mask_params, size=12.0, max_shifts=(1.0, 1.0, 1.0), rotations=((0.0, 0.0), (0.0, 0.0), (0.0, 0.0)), interpolation=3, method='zncc', bin_size=1, seed=0, tolerance=0.01)</code>","text":"<p>Iteratively align molecules and validate using FSC without template.</p> <p>Parameters:</p> Name Type Description Default <code>loader_name</code> <code>str</code> <p>Name of the batch subtomogram loader to be used.</p> required <code>mask_params</code> <code>str or (float, float)</code> <p>Mask image path or dilation/Gaussian blur parameters. If a path is given, image must in the same shape as the template.</p> required <code>size</code> <code>nm</code> <p>Size of the template in nm. Use the size of template image by default.</p> <code>12.0</code> <code>max_shifts</code> <code>int or tuple of int</code> <p>Maximum shift between subtomograms and template in nm. ZYX order.</p> <code>(1.0, 1.0, 1.0)</code> <code>rotations</code> <code>((float, float), (float, float), (float, float))</code> <p>Rotation in external degree around each axis.</p> <code>((0.0, 0.0), (0.0, 0.0), (0.0, 0.0))</code> <code>interpolation</code> <code>int</code> <p>Interpolation order.</p> <code>3</code> <code>method</code> <code>str</code> <p>Correlation metrics for alignment.</p> <code>'zncc'</code> <code>bin_size</code> <code>int</code> <p>Bin size of multiscale image to be used. Set to &gt;1 to boost performance.</p> <code>1</code> <code>seed</code> <code>int</code> <p>Random seed for FSC calculation.</p> <code>0</code> <code>tolerance</code> <code>float</code> <p>Tolerance for convergence of the FSC calculation.</p> <code>0.01</code> Source code in <code>cylindra/widgets/batch/sta.py</code> <pre><code>@set_design(text=\"Align all (template-free)\", location=BatchRefinement)\n@dask_thread_worker.with_progress()\ndef align_all_template_free(\n    self,\n    loader_name: Annotated[str, {\"bind\": _get_current_loader_name}],\n    mask_params: Annotated[Any, {\"bind\": _get_mask_params}],\n    size: _SubVolumeSize = 12.0,\n    max_shifts: _MaxShifts = (1.0, 1.0, 1.0),\n    rotations: _Rotations = ((0.0, 0.0), (0.0, 0.0), (0.0, 0.0)),\n    interpolation: Annotated[int, {\"choices\": INTERPOLATION_CHOICES}] = 3,\n    method: Annotated[str, {\"choices\": METHOD_CHOICES}] = \"zncc\",\n    bin_size: _BINSIZE = 1,\n    seed: Annotated[Optional[int], {\"text\": \"Do not use random seed.\"}] = 0,\n    tolerance: float = 0.01,\n):  # fmt: skip\n    \"\"\"Iteratively align molecules and validate using FSC without template.\n\n    Parameters\n    ----------\n    {loader_name}{mask_params}{size}{max_shifts}{rotations}{interpolation}\n    {method}{bin_size}\n    seed : int, optional\n        Random seed for FSC calculation.\n    tolerance : float, default 0.01\n        Tolerance for convergence of the FSC calculation.\n    \"\"\"\n    t0 = timer()\n    rng = np.random.default_rng(seed)\n    loaderlist = self._get_parent()._loaders\n    info = loaderlist[loader_name]\n    loader = info.loader\n    mask = self.params._get_mask(params=mask_params)\n    shape = self._get_shape_in_px(size, loader)\n    aligned_loader = current_loader = loader.replace(\n        output_shape=shape, order=interpolation\n    ).binning(bin_size, compute=False)\n    _Logger.print(f\"Aligning {loader.molecules.count()} molecules ...\")\n    _alignment_state = TemplateFreeAlignmentState(rng=rng)\n\n    while True:\n        yield thread_worker.description(\n            f\"Calculating FSC for iteration {_alignment_state.niter}\"\n        )\n        fsc_result, avg = _alignment_state.eval_fsc(\n            aligned_loader,\n            mask,\n            tolerance=tolerance,\n        )\n        yield _plot_current_fsc.with_args(\n            fsc_result, _alignment_state.niter, avg\n        ).with_desc(f\"Alignment for iteration {_alignment_state.niter}\")\n        if _alignment_state.converged:\n            _Logger.print(\"FSC converged.\")\n            yield self._show_rec.with_args(avg, f\"[Aligned]{info.name}\")\n            break\n        _alignment_state.niter += 1\n        aligned_loader = current_loader.align(\n            avg, mask=mask, max_shifts=max_shifts, rotations=rotations,\n            cutoff=current_loader.scale / fsc_result.get_resolution(0.143),\n            alignment_model=_get_alignment(method),\n        )  # fmt: skip\n\n    loaderlist.add_loader(\n        aligned_loader,\n        name=_coerce_aligned_name(info.name, loaderlist),\n        image_paths=info.image_paths,\n        invert=info.invert,\n    )\n    t0.toc()\n    return None\n</code></pre>"},{"location":"api/widgets/batch/#cylindra.widgets.batch.sta.BatchSubtomogramAveraging.average_all","title":"<code>average_all(loader_name, size=None, interpolation=1, bin_size=1)</code>","text":"<p>Average all the molecules in the selected loader.</p> <p>Parameters:</p> Name Type Description Default <code>loader_name</code> <code>str</code> <p>Name of the batch subtomogram loader to be used.</p> required <code>size</code> <code>nm</code> <p>Size of the template in nm. Use the size of template image by default.</p> <code>None</code> <code>interpolation</code> <code>int</code> <p>Interpolation order.</p> <code>1</code> <code>bin_size</code> <code>int</code> <p>Bin size of multiscale image to be used. Set to &gt;1 to boost performance.</p> <code>1</code> Source code in <code>cylindra/widgets/batch/sta.py</code> <pre><code>@set_design(text=\"Average all molecules\", location=BatchSubtomogramAnalysis)\n@dask_thread_worker.with_progress(desc=\"Averaging all molecules in projects\")\ndef average_all(\n    self,\n    loader_name: Annotated[str, {\"bind\": _get_current_loader_name}],\n    size: _SubVolumeSize = None,\n    interpolation: Annotated[int, {\"choices\": INTERPOLATION_CHOICES}] = 1,\n    bin_size: _BINSIZE = 1,\n):\n    \"\"\"Average all the molecules in the selected loader.\n\n    Parameters\n    ----------\n    {loader_name}{size}{interpolation}{bin_size}\n    \"\"\"\n    t0 = timer()\n    loader = self._get_parent().loader_infos[loader_name].loader\n    shape = self._get_shape_in_px(size, loader)\n    img = ip.asarray(\n        loader.replace(output_shape=shape, order=interpolation)\n        .binning(bin_size, compute=False)\n        .average(),\n        axes=\"zyx\",\n    ).set_scale(zyx=loader.scale * bin_size, unit=\"nm\")\n    t0.toc()\n    return self._show_rec.with_args(img, f\"[AVG]{loader_name}\")\n</code></pre>"},{"location":"api/widgets/batch/#cylindra.widgets.batch.sta.BatchSubtomogramAveraging.average_groups","title":"<code>average_groups(loader_name, size=None, by=\"col('pf-id')\", interpolation=1, bin_size=1)</code>","text":"<p>Groupwise subtomogram averaging using molecules grouped by the given expression.</p> <p>This method first group molecules by its features, and then average each group. This method is useful for such as get average of each protofilament and segmented subtomogram averaging.</p> <p>Parameters:</p> Name Type Description Default <code>loader_name</code> <code>str</code> <p>Name of the batch subtomogram loader to be used.</p> required <code>size</code> <code>nm</code> <p>Size of the template in nm. Use the size of template image by default.</p> <code>None</code> <code>by</code> <code>str or polars expression</code> <p>Expression to group molecules.</p> <code>\"col('pf-id')\"</code> <code>interpolation</code> <code>int</code> <p>Interpolation order.</p> <code>1</code> <code>bin_size</code> <code>int</code> <p>Bin size of multiscale image to be used. Set to &gt;1 to boost performance.</p> <code>1</code> Source code in <code>cylindra/widgets/batch/sta.py</code> <pre><code>@set_design(text=\"Average group-wise\", location=BatchSubtomogramAnalysis)\n@dask_thread_worker.with_progress(desc=\"Grouped subtomogram averaging\")\ndef average_groups(\n    self,\n    loader_name: Annotated[str, {\"bind\": _get_current_loader_name}],\n    size: _SubVolumeSize = None,\n    by: PolarsExprStr = \"col('pf-id')\",\n    interpolation: Annotated[int, {\"choices\": INTERPOLATION_CHOICES}] = 1,\n    bin_size: _BINSIZE = 1,\n):\n    \"\"\"Groupwise subtomogram averaging using molecules grouped by the given expression.\n\n    This method first group molecules by its features, and then average each group.\n    This method is useful for such as get average of each protofilament and\n    segmented subtomogram averaging.\n\n    Parameters\n    ----------\n    {loader_name}{size}\n    by : str or polars expression\n        Expression to group molecules.\n    {interpolation}{bin_size}\n    \"\"\"\n    t0 = timer()\n    loader = self._get_parent().loader_infos[loader_name].loader\n    shape = self._get_shape_in_px(size, loader)\n    img = ip.asarray(\n        loader.replace(output_shape=shape, order=interpolation)\n        .binning(bin_size, compute=False)\n        .groupby(norm_expr(by))\n        .average()\n        .value_stack(axis=0),\n        axes=\"pzyx\",\n    ).set_scale(zyx=loader.scale * bin_size, unit=\"nm\")\n    t0.toc()\n    return self._show_rec.with_args(img, f\"[AVG]{loader_name}\", store=False)\n</code></pre>"},{"location":"api/widgets/batch/#cylindra.widgets.batch.sta.BatchSubtomogramAveraging.calculate_fsc","title":"<code>calculate_fsc(loader_name, template_path=None, mask_params=None, size=None, seed=0, interpolation=1, n_pairs=1, show_average=True, dfreq=None)</code>","text":"<p>Calculate Fourier Shell Correlation using the selected loader.</p> <p>Parameters:</p> Name Type Description Default <code>loader_name</code> <code>str</code> <p>Name of the batch subtomogram loader to be used.</p> required <code>template_path</code> <code>Path or str</code> <p>Path to template image.</p> <code>None</code> <code>mask_params</code> <code>str or (float, float)</code> <p>Mask image path or dilation/Gaussian blur parameters. If a path is given, image must in the same shape as the template.</p> <code>None</code> <code>size</code> <code>nm</code> <p>Size of the template in nm. Use the size of template image by default.</p> <code>None</code> <code>seed</code> <code>int</code> <p>Random seed used for subtomogram sampling.</p> <code>0</code> <code>interpolation</code> <code>int</code> <p>Interpolation order.</p> <code>1</code> <code>n_pairs</code> <code>int</code> <p>How many sets of image pairs will be generated to average FSC.</p> <code>1</code> <code>show_average</code> <code>bool</code> <p>If true, subtomogram averaging will be shown after FSC calculation.</p> <code>True</code> <code>dfreq</code> <code>float</code> <p>Precision of frequency to calculate FSC. \"0.02\" means that FSC will be calculated at frequency 0.01, 0.03, 0.05, ..., 0.45.</p> <code>0.02</code> Source code in <code>cylindra/widgets/batch/sta.py</code> <pre><code>@set_design(text=\"Calculate FSC\", location=BatchSubtomogramAnalysis)\n@dask_thread_worker.with_progress(desc=\"Calculating FSC\")\ndef calculate_fsc(\n    self,\n    loader_name: Annotated[str, {\"bind\": _get_current_loader_name}],\n    template_path: Annotated[str | Path | None, {\"bind\": _get_template_path}] = None,\n    mask_params: Annotated[Any, {\"bind\": _get_mask_params}] = None,\n    size: _SubVolumeSize = None,\n    seed: Annotated[Optional[int], {\"text\": \"Do not use random seed.\"}] = 0,\n    interpolation: Annotated[int, {\"choices\": INTERPOLATION_CHOICES}] = 1,\n    n_pairs: Annotated[int, {\"min\": 1, \"label\": \"number of image pairs\"}] = 1,\n    show_average: bool = True,\n    dfreq: FSCFreq = None,\n):  # fmt: skip\n    \"\"\"\n    Calculate Fourier Shell Correlation using the selected loader.\n\n    Parameters\n    ----------\n    {loader_name}{template_path}{mask_params}{size}\n    seed : int, optional\n        Random seed used for subtomogram sampling.\n    {interpolation}\n    n_pairs : int, default 1\n        How many sets of image pairs will be generated to average FSC.\n    show_average : bool, default True\n        If true, subtomogram averaging will be shown after FSC calculation.\n    dfreq : float, default 0.02\n        Precision of frequency to calculate FSC. \"0.02\" means that FSC will be\n        calculated at frequency 0.01, 0.03, 0.05, ..., 0.45.\n    \"\"\"\n    t0 = timer()\n    loader = (\n        self._get_parent()\n        .loader_infos[loader_name]\n        .loader.replace(order=interpolation)\n    )\n\n    template, mask = loader.normalize_input(\n        template=self.params._norm_template_param(template_path, allow_none=True),\n        mask=self.params._get_mask(params=mask_params),\n    )\n\n    fsc, (img_0, img_1), img_mask = loader.reshape(\n        template=template if size is None else None,\n        mask=mask,\n        shape=None if size is None else self._get_shape_in_px(size, loader),\n    ).fsc_with_halfmaps(mask, seed=seed, n_set=n_pairs, dfreq=dfreq, squeeze=False)\n\n    def _as_imgarray(im, axes: str = \"zyx\") -&gt; ip.ImgArray | None:\n        if np.isscalar(im):\n            return None\n        return ip.asarray(im, axes=axes).set_scale(zyx=loader.scale, unit=\"nm\")\n\n    if show_average:\n        avg = (img_0[0] + img_1[0]) / 2\n        img_avg = _as_imgarray(avg)\n    else:\n        img_avg = None\n\n    result = FscResult.from_dataframe(fsc, loader.scale)\n    criteria = [0.5, 0.143]\n    t0.toc()\n\n    @thread_worker.callback\n    def _calculate_fsc_on_return():\n        _Logger.print_html(f\"&lt;b&gt;Fourier Shell Correlation of {loader_name!r}&lt;/b&gt;\")\n        with _Logger.set_plt():\n            result.plot(criteria)\n            plt.tight_layout()\n            plt.show()\n        for _c in criteria:\n            _r = result.get_resolution(_c)\n            _Logger.print_html(f\"Resolution at FSC={_c:.3f} ... &lt;b&gt;{_r:.3f} nm&lt;/b&gt;\")\n\n        if img_avg is not None:\n            _imlayer: Image = self._show_rec(img_avg, name=f\"[AVG]{loader_name}\")\n            _imlayer.metadata[\"fsc\"] = result\n            _imlayer.metadata[\"fsc_halfmaps\"] = (\n                _as_imgarray(img_0, axes=\"izyx\"),\n                _as_imgarray(img_1, axes=\"izyx\"),\n            )\n            _imlayer.metadata[\"fsc_mask\"] = _as_imgarray(img_mask)\n\n    return _calculate_fsc_on_return\n</code></pre>"},{"location":"api/widgets/batch/#cylindra.widgets.batch.sta.BatchSubtomogramAveraging.classify_pca","title":"<code>classify_pca(loader_name, template_path=None, mask_params=None, size=None, cutoff=0.5, interpolation=3, bin_size=1, n_components=2, n_clusters=2, seed=0)</code>","text":"<p>Classify molecules in the loader using PCA and K-means clustering.</p> <p>Parameters:</p> Name Type Description Default <code>loader_name</code> <code>str</code> <p>Name of the batch subtomogram loader to be used.</p> required <code>template_path</code> <code>Path or str</code> <p>Path to template image.</p> <code>None</code> <code>mask_params</code> <code>str or (float, float)</code> <p>Mask image path or dilation/Gaussian blur parameters. If a path is given, image must in the same shape as the template.</p> <code>None</code> <code>size</code> <code>nm</code> <p>Size of the template in nm. Use the size of template image by default.</p> <code>None</code> <code>cutoff</code> <code>float</code> <p>Cutoff frequency of low-pass filter applied in each subtomogram.</p> <code>0.5</code> <code>interpolation</code> <code>int</code> <p>Interpolation order.</p> <code>3</code> <code>bin_size</code> <code>int</code> <p>Bin size of multiscale image to be used. Set to &gt;1 to boost performance.</p> <code>1</code> <code>n_components</code> <code>int</code> <p>The number of PCA dimensions.</p> <code>2</code> <code>n_clusters</code> <code>int</code> <p>The number of clusters.</p> <code>2</code> <code>seed</code> <code>(int, default)</code> <p>Random seed.</p> <code>0</code> Source code in <code>cylindra/widgets/batch/sta.py</code> <pre><code>@set_design(text=\"PCA/K-means classification\", location=BatchSubtomogramAnalysis)\n@dask_thread_worker.with_progress(descs=_classify_pca_fmt)\ndef classify_pca(\n    self,\n    loader_name: Annotated[str, {\"bind\": _get_current_loader_name}],\n    template_path: Annotated[str | Path | None, {\"bind\": _get_template_path}] = None,\n    mask_params: Annotated[Any, {\"bind\": _get_mask_params}] = None,\n    size: Annotated[Optional[nm], {\"text\": \"Use mask shape\", \"options\": {\"value\": 12.0, \"max\": 100.0}, \"label\": \"size (nm)\"}] = None,\n    cutoff: _CutoffFreq = 0.5,\n    interpolation: Annotated[int, {\"choices\": INTERPOLATION_CHOICES}] = 3,\n    bin_size: _BINSIZE = 1,\n    n_components: Annotated[int, {\"min\": 2, \"max\": 20}] = 2,\n    n_clusters: Annotated[int, {\"min\": 2, \"max\": 100}] = 2,\n    seed: Annotated[Optional[int], {\"text\": \"Do not use random seed.\"}] = 0,\n):  # fmt: skip\n    \"\"\"\n    Classify molecules in the loader using PCA and K-means clustering.\n\n    Parameters\n    ----------\n    {loader_name}{template_path}{mask_params}{size}{cutoff}{interpolation}{bin_size}\n    n_components : int, default 2\n        The number of PCA dimensions.\n    n_clusters : int, default 2\n        The number of clusters.\n    seed : int, default\n        Random seed.\n    \"\"\"\n    from cylindra.components.visualize import plot_pca_classification\n\n    t0 = timer()\n    loader = self._get_parent().loader_infos[loader_name].loader\n    template, mask = loader.normalize_input(\n        template=self.params._norm_template_param(template_path, allow_none=True),\n        mask=self.params._get_mask(params=mask_params),\n    )\n    shape = None\n    if mask is None:\n        shape = self._get_shape_in_px(size, loader)\n    out, pca = (\n        loader.reshape(\n            template=template if mask is None and shape is None else None,\n            mask=mask,\n            shape=shape,\n        )\n        .replace(order=interpolation)\n        .binning(binsize=bin_size, compute=False)\n        .classify(\n            mask=mask,\n            seed=seed,\n            cutoff=cutoff,\n            n_components=n_components,\n            n_clusters=n_clusters,\n            label_name=\"cluster\",\n        )\n    )\n\n    avgs = ip.asarray(\n        out.groupby(\"cluster\").average().value_stack(axis=0),\n        axes=[\"cluster\", \"z\", \"y\", \"x\"],\n    ).set_scale(zyx=loader.scale, unit=\"nm\")\n\n    transformed = pca.get_transform()\n    t0.toc()\n\n    @thread_worker.callback\n    def _on_return():\n        loader.molecules.features = out.molecules.features\n        with _Logger.set_plt():\n            plot_pca_classification(pca, transformed)\n        self._show_rec(avgs, name=f\"[PCA]{loader_name}\", store=False)\n\n    return _on_return\n</code></pre>"},{"location":"api/widgets/batch/#cylindra.widgets.batch.sta.BatchSubtomogramAveraging.filter_loader","title":"<code>filter_loader(loader_name, expression)</code>","text":"<p>Filter the selected loader and add the filtered one to the list.</p> <p>Parameters:</p> Name Type Description Default <code>loader_name</code> <code>str</code> <p>Name of the input loader</p> required <code>expression</code> <code>str</code> <p>polars expression that will be used to filter the loader. For example, <code>col(\"score\") &gt; 0.7</code> will filter out all low-score molecules.</p> required Source code in <code>cylindra/widgets/batch/sta.py</code> <pre><code>@set_design(text=\"Filter loader\", location=BatchLoaderMenu)\ndef filter_loader(\n    self,\n    loader_name: Annotated[str, {\"bind\": _get_current_loader_name}],\n    expression: PolarsExprStr,\n):\n    \"\"\"Filter the selected loader and add the filtered one to the list.\n\n    Parameters\n    ----------\n    loader_name : str\n        Name of the input loader\n    expression : str\n        polars expression that will be used to filter the loader. For example,\n        `col(\"score\") &gt; 0.7` will filter out all low-score molecules.\n    \"\"\"\n    loaderlist = self._get_parent()._loaders\n    info = loaderlist[loader_name]\n    loader = info.loader\n    new = loader.filter(norm_expr(expression))\n    existing_id = set(new.features[Mole.image])\n    loaderlist.add_loader(\n        new,\n        name=f\"{info.name}-Filt\",\n        image_paths={k: v for k, v in info.image_paths.items() if v in existing_id},\n        invert={k: v for k, v in info.invert.items() if v in existing_id},\n    )\n    return None\n</code></pre>"},{"location":"api/widgets/batch/#cylindra.widgets.batch.sta.BatchSubtomogramAveraging.get_loader","title":"<code>get_loader(name)</code>","text":"<p>Return the acryo.BatchLoader object with the given name</p> Source code in <code>cylindra/widgets/batch/sta.py</code> <pre><code>@nogui\ndef get_loader(self, name: str) -&gt; BatchLoader:\n    \"\"\"Return the acryo.BatchLoader object with the given name\"\"\"\n    if not isinstance(name, str):\n        raise TypeError(f\"Name must be a string, got {type(name).__name__}\")\n    return self._get_parent().loader_infos[name].loader\n</code></pre>"},{"location":"api/widgets/batch/#cylindra.widgets.batch.sta.BatchSubtomogramAveraging.remove_loader","title":"<code>remove_loader(loader_name)</code>","text":"<p>Remove this loader</p> Source code in <code>cylindra/widgets/batch/sta.py</code> <pre><code>@set_design(text=\"\u2715\", max_width=36, location=Header)\ndef remove_loader(\n    self, loader_name: Annotated[str, {\"bind\": _get_current_loader_name}]\n):\n    \"\"\"Remove this loader\"\"\"\n    del self._get_parent().loader_infos[loader_name]\n</code></pre>"},{"location":"api/widgets/batch/#cylindra.widgets.batch.sta.BatchSubtomogramAveraging.show_loader_info","title":"<code>show_loader_info()</code>","text":"<p>Show information about this loader</p> Source code in <code>cylindra/widgets/batch/sta.py</code> <pre><code>@set_design(text=\"??\", max_width=36, location=Header)\n@do_not_record\ndef show_loader_info(self):\n    \"\"\"Show information about this loader\"\"\"\n    info = self._get_parent().loader_infos[self.loader_name]\n    loader = info.loader\n    img_info = \"\\n\" + \"\\n\".join(\n        f\"{img_id}: {img_path}\" for img_id, img_path in info.image_paths.items()\n    )\n\n    info_text = (\n        f\"name: {info.name}\\nmolecule: n={loader.count()}\\nimages:{img_info}\"\n    )\n    view = DataFrameView(value=loader.molecules.to_dataframe())\n    txt = ConsoleTextEdit(value=info_text)\n    txt.read_only = True\n    cnt = Container(widgets=[txt, view], layout=\"horizontal\", labels=False)\n    cnt.native.setParent(self.native, cnt.native.windowFlags())\n    cnt.show()\n</code></pre>"},{"location":"api/widgets/batch/#cylindra.widgets.batch.sta.BatchSubtomogramAveraging.show_mask","title":"<code>show_mask()</code>","text":"<p>Load and show mask image in the scale of the tomogram.</p> Source code in <code>cylindra/widgets/batch/sta.py</code> <pre><code>@set_design(icon=\"fluent:shape-organic-20-filled\", location=STATools)\n@do_not_record\ndef show_mask(self):\n    \"\"\"Load and show mask image in the scale of the tomogram.\"\"\"\n    loader = self.get_loader(self.loader_name)\n    _, mask = loader.normalize_input(\n        self.params._norm_template_param(\n            self.params._get_template_input(allow_multiple=False),\n            allow_none=True,\n        ),\n        self.params._get_mask(),\n    )\n    if mask is None:\n        raise ValueError(\"No mask to show.\")\n    mask = ip.asarray(mask, axes=\"zyx\").set_scale(zyx=loader.scale, unit=\"nm\")\n    self._show_rec(mask, name=\"Mask image\", store=False, threshold=0.5)\n</code></pre>"},{"location":"api/widgets/batch/#cylindra.widgets.batch.sta.BatchSubtomogramAveraging.show_template","title":"<code>show_template()</code>","text":"<p>Load and show template image in the scale of the tomogram.</p> Source code in <code>cylindra/widgets/batch/sta.py</code> <pre><code>@set_design(icon=\"ic:baseline-view-in-ar\", location=STATools)\n@do_not_record\ndef show_template(self):\n    \"\"\"Load and show template image in the scale of the tomogram.\"\"\"\n    template = self._get_template_image()\n    self._show_rec(template, name=\"Template image\", store=False)\n</code></pre>"},{"location":"api/widgets/batch/#cylindra.widgets.batch.sta.BatchSubtomogramAveraging.show_template_original","title":"<code>show_template_original()</code>","text":"<p>Load and show template image in the original scale.</p> Source code in <code>cylindra/widgets/batch/sta.py</code> <pre><code>@set_design(icon=\"material-symbols:view-in-ar\", location=STATools)\n@do_not_record\ndef show_template_original(self):\n    \"\"\"Load and show template image in the original scale.\"\"\"\n    _input = self.params._get_template_input(allow_multiple=True)\n    if _input is None:\n        raise ValueError(\"No template path provided.\")\n    elif isinstance(_input, Path):\n        self._show_rec(ip.imread(_input), name=\"Template image\", store=False)\n    else:\n        for i, fp in enumerate(_input):\n            img = ip.imread(fp)\n            self._show_rec(img, name=f\"Template image [{i}]\", store=False)\n</code></pre>"},{"location":"api/widgets/batch/#cylindra.widgets.batch.sta.BatchSubtomogramAveraging.split_loader","title":"<code>split_loader(loader_name, by, delete_old=False)</code>","text":"<p>Split the selected loader by the values of the given column.</p> <p>Parameters:</p> Name Type Description Default <code>loader_name</code> <code>str</code> <p>Name of the input loader</p> required <code>by</code> <code>str</code> <p>Column name to split the loader</p> required <code>delete_old</code> <code>bool</code> <p>If true, the original loader will be deleted.</p> <code>False</code> Source code in <code>cylindra/widgets/batch/sta.py</code> <pre><code>@set_design(text=\"Split loader\", location=BatchLoaderMenu)\ndef split_loader(\n    self,\n    loader_name: Annotated[str, {\"bind\": _get_current_loader_name}],\n    by: Annotated[str, {\"choices\": _get_selected_loader_choice}],\n    delete_old: bool = False,\n):\n    \"\"\"Split the selected loader by the values of the given column.\n\n    Parameters\n    ----------\n    loader_name : str\n        Name of the input loader\n    by : str\n        Column name to split the loader\n    delete_old : bool, default False\n        If true, the original loader will be deleted.\n    \"\"\"\n    parent = self._get_parent()\n    loaders = parent._loaders\n    batch_info = loaders[loader_name]\n    batch_loader = batch_info.loader\n    n_unique = batch_loader.molecules.features[by].n_unique()\n    if n_unique &gt; 48:\n        raise ValueError(\n            f\"Too many groups ({n_unique}). Did you choose a float column?\"\n        )\n    for _key, loader in batch_loader.groupby(by):\n        existing_id = set(loader.features[Mole.image])\n        image_paths = {\n            k: v for k, v in batch_info.image_paths.items() if v in existing_id\n        }\n        invert = {k: v for k, v in batch_info.invert.items() if v in existing_id}\n        parent._add_loader(loader, f\"{loader_name}_{_key}\", image_paths, invert)\n\n    if delete_old:\n        idx = -1\n        for i, info in enumerate(loaders):\n            if info.loader is batch_loader:\n                idx = i\n                break\n        else:\n            idx = -1\n        if idx &lt; 0:\n            raise RuntimeError(\"Loader not found.\")\n        del loaders[idx]\n</code></pre>"},{"location":"api/widgets/main/","title":"cylindra.widgets.main.CylindraMainWidget","text":"Source code in <code>cylindra/widgets/main.py</code> <pre><code>@magicclass(\n    widget_type=\"scrollable\",\n    stylesheet=_STYLE,\n    name=\"cylindra\",\n    use_native_menubar=False,\n)\n@_shared_doc.update_cls\nclass CylindraMainWidget(MagicTemplate):\n    # Main GUI class.\n\n    # Widget for manual spline fitting\n    spline_fitter = field(_sw.SplineFitter, name=\"_Spline fitter\")\n    # Widget for manual spline clipping\n    spline_clipper = field(_sw.SplineClipper, name=\"_Spline clipper\")\n    # Widget for sweeping along splines\n    spline_slicer = field(_sw.SplineSlicer, name=\"_Spline slicer\")\n    # Widget for manual picking along splines\n    manual_picker = field(_sw.ManualPicker, name=\"_Manual picker\")\n    # Widget for pre-filtering/pre-processing\n    image_processor = field(_sw.ImageProcessor, name=\"_Image Processor\")\n    # Widget for tomogram simulator\n    simulator = field(_sw.Simulator, name=\"_Simulator\")\n    # Widget for spline config\n    config_edit = field(_sw.ConfigEdit, name=\"_Config editor\")\n    # Widget for measuring FFT parameters from a 2D power spectra\n    spectra_inspector = field(_sw.SpectraInspector, name=\"_SpectraInspector\")\n    # Widget for subtomogram analysis\n    sta = field(SubtomogramAveraging, name=\"_STA widget\")\n\n    mole_layers = MoleculesLayerAccessor()\n\n    @property\n    def batch(self) -&gt; \"CylindraBatchWidget\":\n        \"\"\"Return the batch analyzer.\"\"\"\n        return self.AnalysisMenu.open_project_batch_analyzer()\n\n    # Menu bar\n    FileMenu = field(_sw.FileMenu, name=\"File\")\n    ImageMenu = field(_sw.ImageMenu, name=\"Image\")\n    SplinesMenu = field(_sw.SplinesMenu, name=\"Splines\")\n    MoleculesMenu = field(_sw.MoleculesMenu, name=\"Molecules\")\n    AnalysisMenu = field(_sw.AnalysisMenu, name=\"Analysis\")\n    PluginsMenu = field(_sw.PluginsMenu, name=\"Plugins\")\n    OthersMenu = field(_sw.OthersMenu, name=\"Others\")\n\n    # Toolbar\n    Toolbar = field(_sw.CylindraToolbar)\n\n    # Child widgets\n    GeneralInfo = field(_sw.GeneralInfo)\n    # Widget for controling splines\n    SplineControl = field(_sw.SplineControl)\n    # Widget for summary of local properties\n    LocalProperties = box.collapsible(field(_sw.LocalPropertiesWidget), text=\"Local Properties\")  # fmt: skip\n    # Widget for summary of glocal properties\n    GlobalProperties = field(_sw.GlobalPropertiesWidget, name=\"Global Properties\")  # fmt: skip\n    # Widget for 2D overview of splines\n    Overview = field(QtImageCanvas).with_options(tooltip=\"Overview of splines\")  # fmt: skip\n\n    ### methods ###\n\n    def __init__(self):\n        self._tomogram = CylTomogram.dummy(binsize=[1])\n        self._reserved_layers = ReservedLayers()\n        self._macro_offset: int = 1\n        self._macro_image_load_offset: int = 1\n        self._plugins_called: list[CylindraPluginFunction] = []\n        self._need_save: bool = False\n        self._batch: CylindraBatchWidget | None = None\n        self._project_dir: Path | None = None\n        self._current_binsize: int = 1\n        self._project_metadata = dict[str, Any]()\n        self.objectName()  # load napari types\n\n    def __post_init__(self):\n        self.min_width = 400\n        self.LocalProperties.collapsed = False\n        self.GlobalProperties.collapsed = False\n        self.Overview.min_height = 300\n\n        self.LocalProperties._props_changed.connect(\n            lambda: self._update_local_properties_in_widget(replot=True)\n        )\n\n        # load all the workflows\n        cfg = _config.get_config()\n        for file in cfg.list_workflow_paths():\n            try:\n                self.OthersMenu.Workflows.append_workflow(file)\n            except Exception as e:\n                _Logger.exception(f\"Failed to load workflow {file.stem}: {e}\")\n\n        # setup auto saver\n        self._auto_saver = AutoSaver(self, sec=cfg.autosave_interval)\n\n        # dask worker number\n        if cfg.default_dask_n_workers is not None:\n            if cfg.default_dask_n_workers &lt;= 0:\n                _Logger.warning(\"Invalid dask worker number. Set to default.\")\n            else:\n                self.OthersMenu.configure_dask(cfg.default_dask_n_workers)\n\n        @self.macro.on_appended.append\n        def _on_appended(expr: mk.Expr):\n            self._need_save = not str(expr).startswith(\"ui.open_image(\")\n            self._auto_saver.save()\n\n        @self.macro.on_popped.append\n        def _on_popped(*_):\n            self._need_save = len(self.macro) &gt;= self._macro_offset and not str(\n                self.macro[-1]\n            ).startswith(\"ui.open_image(\")\n            self._auto_saver.save()\n\n        self.default_config = SplineConfig.from_file(cfg.default_spline_config_path)\n        self.config_edit.config_new.set_config(\n            self.config_edit.config_current.get_config()\n        )\n\n        # load plugins\n        load_plugin(self)\n\n    @property\n    def tomogram(self) -&gt; CylTomogram:\n        \"\"\"The current tomogram instance.\"\"\"\n        return self._tomogram\n\n    @property\n    def splines(self):\n        \"\"\"The spline list.\"\"\"\n        return self.tomogram.splines\n\n    @property\n    def logger(self):\n        \"\"\"The logger instance.\"\"\"\n        return _Logger\n\n    @property\n    def default_config(self) -&gt; SplineConfig:\n        \"\"\"Default spline configuration.\"\"\"\n        return self.config_edit.config_current.get_config()\n\n    @default_config.setter\n    def default_config(self, cfg: SplineConfig | dict[str, Any]):\n        if not isinstance(cfg, SplineConfig):\n            cfg = SplineConfig.from_dict(cfg, unknown=\"error\")\n        self.config_edit.config_current.set_config(cfg)\n\n    @property\n    def sub_viewer(self) -&gt; \"napari.Viewer\":\n        \"\"\"The sub-viewer for subtomogram averages.\"\"\"\n        return self.sta.sub_viewer\n\n    @property\n    def project_dir(self) -&gt; Path | None:\n        \"\"\"The project directory.\"\"\"\n        return self._project_dir\n\n    @property\n    def project_metadata(self) -&gt; dict[str, Any]:\n        \"\"\"The project metadata.\"\"\"\n        return self._project_metadata\n\n    def _init_macro_state(self):\n        self._macro_offset = len(self.macro)\n        self._plugins_called.clear()\n\n    def _get_splines(self, widget=None) -&gt; list[tuple[str, int]]:\n        \"\"\"Get list of spline objects for categorical widgets.\"\"\"\n        tomo = self.tomogram\n        return [(f\"({i}) {spl}\", i) for i, spl in enumerate(tomo.splines)]\n\n    def _get_spline_coordinates(self, coords=None) -&gt; np.ndarray:\n        \"\"\"Get coordinates of the manually picked spline.\"\"\"\n        if coords is None:\n            coords = self._reserved_layers.work.data\n        out = np.round(coords, 3)\n        if out.ndim != 2 or out.shape[1] != 3 or out.dtype.kind not in \"iuf\":\n            raise ValueError(\"Input coordinates must be a (N, 3) numeric array.\")\n        return out\n\n    def _get_available_binsize(self, _=None) -&gt; list[tuple[str, int]]:\n        bins = [x[0] for x in self.tomogram.multiscaled]\n        if 1 not in bins:\n            bins = [1, *bins]\n        return [\n            (\n                f\"{b} pixel{'s' if b &gt; 1 else ''} ({self.tomogram.scale * b:.2f} nm/pixel)\",\n                b,\n            )\n            for b in sorted(bins)\n        ]\n\n    def _get_default_config(self, config):\n        if config is None:\n            config = self.default_config.asdict()\n        elif isinstance(config, dict):\n            config = self.default_config.updated(**config).asdict()\n        elif isinstance(config, SplineConfig):\n            config = config.asdict()\n        else:\n            raise TypeError(f\"Invalid config type: {type(config)}\")\n        return config\n\n    def _norm_splines(self, splines: list[int] | Literal[\"all\"]) -&gt; list[int]:\n        if isinstance(splines, str) and splines == \"all\":\n            return list(range(self.splines.count()))\n        return splines\n\n    @set_design(icon=\"iconoir:curve-array\", location=Toolbar)\n    @bind_key(\"F1\")\n    def register_path(\n        self,\n        coords: Annotated[np.ndarray, {\"validator\": _get_spline_coordinates}] = None,\n        config: Annotated[dict[str, Any] | SplineConfig, {\"validator\": _get_default_config}] = None,\n        err_max: Annotated[nm, {\"bind\": 0.5}] = 0.5,\n    ):  # fmt: skip\n        \"\"\"Register points as a spline path.\"\"\"\n        if coords is None or coords.size == 0:\n            raise ValueError(\"No points are given.\")\n\n        tomo = self.tomogram\n        tomo.add_spline(coords, config=config, err_max=err_max)\n        self._add_spline_instance(tomo.splines[-1])\n        return undo_callback(self.delete_spline).with_args(-1)\n\n    def _add_spline_instance(self, spl: \"CylSpline\"):\n        # draw path\n        tomo = self.tomogram\n        self._add_spline_to_images(spl, len(tomo.splines) - 1)\n        self._reserved_layers.work.data = []\n        self._reserved_layers.prof.selected_data = set()\n        self.reset_choices()\n        self.SplineControl.num = len(tomo.splines) - 1\n\n    _runner = field(_sw.Runner)\n    _image_loader = _sw.ImageLoader\n    _file_iterator = field(_sw.FileIterator)\n\n    def _confirm_delete(self):\n        i = self.SplineControl.num\n        if i is None:\n            # If user is writing the first spline, there's no spline registered.\n            return False\n        return self.tomogram.splines[i].has_props()\n\n    @set_design(icon=\"solar:eraser-bold\", location=Toolbar)\n    @confirm(text=\"Spline has properties. Are you sure to delete it?\", condition=_confirm_delete)  # fmt: skip\n    @do_not_record(recursive=False)\n    def clear_current(self):\n        \"\"\"Clear current selection.\"\"\"\n        if self._reserved_layers.work.data.size &gt; 0:\n            self._reserved_layers.work.data = []\n        else:\n            self.delete_spline(self.SplineControl.num)\n\n    @set_design(icon=\"material-symbols:bomb\", location=Toolbar)\n    @confirm(text=\"Are you sure to clear all?\\nYou cannot undo this.\")\n    @do_not_record\n    def clear_all(self):\n        \"\"\"Clear all the splines and results.\"\"\"\n        self.macro.clear_undo_stack()\n        self.Overview.layers.clear()\n        self.tomogram.splines.clear()\n        self._init_widget_state()\n        self._init_layers()\n        del self.macro[self._macro_image_load_offset + 1 :]\n        self._need_save = False\n        self.reset_choices()\n\n    def _format_macro(self, macro: \"mk.Macro | None\" = None):\n        if macro is None:\n            macro = self.macro\n        v = mk.Expr(\"getattr\", [mk.symbol(self), \"parent_viewer\"])\n        return macro.format([(mk.symbol(self.parent_viewer), v)])\n\n    @do_not_record(recursive=False)\n    @nogui\n    def run_workflow(self, filename: str, *args, **kwargs):\n        \"\"\"Run a user-defined workflow.\n\n        This method will run a .py file that was defined by the user from\n        `Workflow &gt; Define workflow`. *args and **kwargs follow the signature of the\n        main function of the workflow.\n        \"\"\"\n        main = _config.get_main_function(filename)\n        out = main(self, *args, **kwargs)\n        return out\n\n    @set_design(text=\"Open\", location=_image_loader)\n    @dask_thread_worker.with_progress(desc=\"Reading image\")\n    @confirm(text=\"You may have unsaved data. Open a new tomogram?\", condition=\"self._need_save\")  # fmt: skip\n    def open_image(\n        self,\n        path: Annotated[str | Path, {\"bind\": _image_loader.path}],\n        scale: Annotated[nm, {\"bind\": _image_loader.scale.scale_value}] = None,\n        tilt_range: Annotated[Any, {\"bind\": _image_loader.tilt_model}] = None,\n        bin_size: Annotated[int | Sequence[int], {\"bind\": _image_loader.bin_size}] = [1],\n        filter: Annotated[ImageFilter | None, {\"bind\": _image_loader.filter}] = ImageFilter.Lowpass,\n        invert: Annotated[bool, {\"bind\": _image_loader.invert}] = False,\n        eager: Annotated[bool, {\"bind\": _image_loader.eager}] = False,\n        cache_image: Annotated[bool, {\"bind\": _image_loader.cache_image}] = False,\n    ):  # fmt: skip\n        \"\"\"Load an image file and process it before sending it to the viewer.\n\n        Parameters\n        ----------\n        path : Path\n            Path to the tomogram. Must be 3-D image.\n        scale : float, default 1.0\n            Pixel size in nm/pixel unit.\n        tilt_range : tuple of float, default None\n            Range of tilt angles in degrees.\n        bin_size : int or list of int, default [1]\n            Initial bin size of image. Binned image will be used for visualization in\n            the viewer. You can use both binned and non-binned image for analysis.\n        {filter}\n        invert : bool, default False\n            If true, invert the intensity of the image.\n        eager : bool, default False\n            If true, the image will be loaded immediately. Otherwise, it will be loaded\n            lazily.\n        cache_image : bool, default False\n            If true, the image will first be copied to the cache directory before\n            loading.\n        \"\"\"\n        tomo = widget_utils.prep_tomogram(\n            path, scale, bin_size, tilt_range, eager, cache_image\n        )\n        self._init_macro_state()\n        self._project_dir = None\n        return self._send_tomogram_to_viewer.with_args(tomo, filter, invert=invert)\n\n    @set_design(text=\"Open with reference\", location=_image_loader)\n    @thread_worker.with_progress(desc=\"Reading image\")\n    def open_image_with_reference(\n        self,\n        path: Annotated[str | Path, {\"bind\": _image_loader.path}],\n        reference_path: Annotated[str | Path, {\"bind\": _image_loader.reference_path}],\n        scale: Annotated[nm, {\"bind\": _image_loader.scale.scale_value}] = None,\n        tilt_range: Annotated[Any, {\"bind\": _image_loader.tilt_model}] = None,\n        bin_size: Annotated[int | Sequence[int], {\"bind\": _image_loader.bin_size}] = [1],\n        filter: Annotated[ImageFilter | None, {\"bind\": _image_loader.filter}] = ImageFilter.Lowpass,\n        invert: Annotated[bool, {\"bind\": _image_loader.invert}] = False,\n        fix_reference_scale: Annotated[bool, {\"bind\": _image_loader.fix_reference_scale}] = True,\n        cache_image: Annotated[bool, {\"bind\": _image_loader.cache_image}] = False,\n    ):  # fmt: skip\n        \"\"\"Load a raw image file and a user-supplied reference image file.\n\n        Parameters\n        ----------\n        path : Path\n            Path to the tomogram. Must be 3-D image.\n        reference_path : Path\n            Path to the reference image. Must be a 3-D image.\n        scale : float, default 1.0\n            Pixel size in nm/pixel unit.\n        tilt_range : tuple of float, default None\n            Range of tilt angles in degrees.\n        bin_size : int or list of int, default [1]\n            Initial bin size of image. Binned image will be used for visualization in\n            the viewer. You can use both binned and non-binned image for analysis.\n        {filter}\n        invert : bool, default False\n            If true, invert the intensity of the raw image.\n        fix_reference_scale : bool, default True\n            Fix the pixel size of the reference image if the scale of the raw tomogram\n            was overridden.\n        cache_image : bool, default False\n            If true, the image will first be copied to the cache directory before\n            loading.\n        \"\"\"\n        tomo = widget_utils.prep_tomogram(\n            path, scale, bin_size, tilt_range, cache_image=cache_image, compute=False\n        )\n        self._init_macro_state()\n        cb = self._send_tomogram_to_viewer.with_args(tomo, filt=None, invert=invert)\n        yield cb\n        cb.await_call()\n        img_ref = ip.imread(reference_path)\n        if (\n            fix_reference_scale\n            and (orig_scale := tomo.metadata.get(\"orig_scale\", -1)) &gt; 0\n            and abs((scale_factor := tomo.scale / orig_scale) - 1) &gt; 1e-4\n        ):\n            _Logger.print(\n                f\"Original tomogram has scale {orig_scale:.4f} nm/pixel, while \"\n                f\"reference has scale {tomo.scale:.4f} nm/pixel. \"\n            )\n            img_ref = img_ref.set_scale(\n                **{str(k): v * scale_factor for k, v in img_ref.scale.items()},\n                unit=img_ref.scale_unit,\n            )\n        cb = thread_worker.callback(self._update_reference_image).with_args(img_ref)\n        yield cb\n        cb.await_call()\n        self._project_dir = None\n        if filter is not None:\n            yield from self.filter_reference_image.arun(filter)\n\n    @open_image.started.connect\n    @open_image_with_reference.started.connect\n    def _open_image_on_start(self):\n        return self._image_loader.close()\n\n    @set_design(text=capitalize, location=_sw.FileMenu)\n    @thread_worker.with_progress(desc=\"Reading project\", total=0)\n    @confirm(text=\"You may have unsaved data. Open a new project?\", condition=\"self._need_save\")  # fmt: skip\n    @do_not_record\n    @bind_key(\"Ctrl+K, Ctrl+P\")\n    def load_project(\n        self,\n        path: Path.Read[FileFilter.PROJECT],\n        filter: ImageFilter | None = ImageFilter.Lowpass,\n        read_image: Annotated[bool, {\"label\": \"read image data\"}] = True,\n        read_reference: Annotated[bool, {\"label\": \"read reference image\"}] = True,\n        update_config: bool = False,\n    ):\n        \"\"\"Load a project file (project.json, tar file or zip file).\n\n        Parameters\n        ----------\n        path : path-like or CylindraProject\n            Path to the project file, or the project directory that contains a project\n            file, or a CylindraProject object.\n        {filter}\n        read_image : bool, default True\n            Whether to read image data from the project directory. If false, image data\n            will be memory-mapped and will not be shown in the viewer, or the reference\n            image will be shown instead if `read_reference` is true. Unchecking this is\n            useful to decrease loading time.\n        read_reference : bool, default True\n            Whether to read the reference image instead of calculating it from the\n            loaded image data, if available.\n        update_config : bool, default False\n            Whether to update the default spline configuration with the one described\n            in the project.\n        \"\"\"\n        if isinstance(path, CylindraProject):\n            project = path\n            project_path = project.project_path\n        else:\n            project = CylindraProject.from_file(path)\n            project_path = project.project_path\n        _Logger.print_html(\n            f\"&lt;code&gt;ui.load_project('{Path(project_path).as_posix()}', \"\n            f\"filter={str(filter)!r}, {read_image=}, {read_reference=}, \"\n            f\"{update_config=})&lt;/code&gt;\"\n        )\n        yield from project._to_gui(\n            self,\n            filter=filter,\n            read_image=read_image,\n            read_reference=read_reference,\n            update_config=update_config,\n        )\n        if project_path is not None:\n            self._project_dir = project_path\n        _Logger.print(f\"Project loaded: {project_path.as_posix()}\")\n\n    @set_design(text=capitalize, location=_sw.FileMenu)\n    @do_not_record\n    @bind_key(\"Ctrl+K, Ctrl+S\")\n    def save_project(\n        self,\n        path: Path.Save,\n        molecules_ext: Literal[\".csv\", \".parquet\"] = \".csv\",\n        save_landscape: Annotated[bool, {\"label\": \"Save landscape layers\"}] = False,\n    ):\n        \"\"\"Save current project state and the results in a directory.\n\n        The json file contains paths of images and results, parameters of splines,\n        scales and version. Local and global properties will be exported as csv files.\n        Molecule coordinates and features will be exported as the `molecules_ext`\n        format. If results are saved at the default directory, they will be\n        written as relative paths in the project json file so that moving root\n        directory does not affect the loading behavior.\n\n        Parameters\n        ----------\n        path : Path\n            Path of json file.\n        molecules_ext : str, default \".csv\"\n            Extension of the molecule file. Can be \".csv\" or \".parquet\".\n        save_landscape : bool, default False\n            Save landscape layers if any. False by default because landscape layers are\n            usually large.\n        \"\"\"\n        path = Path(path)\n        CylindraProject.save_gui(self, path, molecules_ext, save_landscape)\n        _Logger.print(f\"Project saved: {path.as_posix()}\")\n        self._need_save = False\n        self._project_dir = path\n        autosave_path = _config.autosave_path()\n        if autosave_path.exists():\n            with suppress(Exception):\n                autosave_path.unlink()\n\n        # update the spline/molecules list in the batch analyzer\n        if batch := self._batch:\n            for proj in batch.constructor.projects:\n                if self._project_dir and Path(proj.path).samefile(self._project_dir):\n                    proj._update_from_project()\n\n        # if the drawing layer has non-registered points, notify the user\n        if self._reserved_layers.work.data.size &gt; 0:\n            _name = self._reserved_layers.work.name\n            _napari_show_info(f\"Points in the {_name!r} is not registered yet.\")\n\n    @set_design(text=capitalize, location=_sw.FileMenu)\n    @do_not_record\n    @bind_key(\"Ctrl+K, Ctrl+Shift+S\")\n    def overwrite_project(self):\n        \"\"\"Overwrite currently opened project.\"\"\"\n        if self._project_dir is None:\n            raise ValueError(\n                \"No project is loaded. You can use `Save project` \"\n                \"(ui.save_project(...)) to save the current session.\"\n            )\n        project = CylindraProject.from_file(self._project_dir)\n        if project.molecules_info:\n            ext = Path(project.molecules_info[0].name).suffix\n        else:\n            ext = \".csv\"\n        return self.save_project(self._project_dir, ext)\n\n    @set_design(text=capitalize, location=_sw.FileMenu)\n    def save_reference_image(self, path: Path.Save[FileFilter.IMAGE]):\n        \"\"\"Save the current reference image to a file.\"\"\"\n        path = Path(path)\n        img_ref = self._reserved_layers.image_data\n        img_ref.imsave(path)\n        img_ref.source = path\n        _Logger.print(f\"Reference image saved: {path.as_posix()}\")\n\n    @set_design(text=capitalize, location=_sw.FileMenu)\n    def load_splines(self, paths: Path.Multiple[FileFilter.JSON]):\n        \"\"\"Load splines from a list of json paths.\n\n        Parameters\n        ----------\n        paths : list of path-like objects\n            Paths to json files that describe spline parameters in the correct format.\n        \"\"\"\n        if isinstance(paths, str | Path | bytes):\n            paths = [paths]\n        splines = [CylSpline.from_json(path) for path in paths]\n        self.tomogram.splines.extend(splines)\n        self._update_splines_in_images()\n        self.reset_choices()\n\n    @set_design(text=capitalize, location=_sw.FileMenu)\n    def load_molecules(self, paths: Path.Multiple[FileFilter.MOLE]):\n        \"\"\"Load molecules from a csv file.\"\"\"\n        if isinstance(paths, str | Path | bytes):\n            paths = [paths]\n        moles = [Molecules.from_file(path) for path in paths]\n        for mole, path in zip(moles, paths, strict=False):\n            name = Path(path).stem\n            add_molecules(self.parent_viewer, mole, name)\n\n    @set_design(text=capitalize, location=_sw.FileMenu)\n    def load_volumes(self, paths: Path.Multiple[FileFilter.IMAGE]):\n        \"\"\"Load 3D volume(s) to the sub-viewer.\"\"\"\n        for path in paths:\n            img = ip.imread(path)\n            if img.ndim != 3:\n                raise ValueError(\"Input image must be 3-D.\")\n            self.sta._show_rec(img, name=img.name)\n\n    @set_design(text=capitalize, location=_sw.FileMenu)\n    @do_not_record\n    def save_spline(\n        self,\n        spline: Annotated[int, {\"choices\": _get_splines}],\n        save_path: Path.Save[FileFilter.JSON],\n    ):\n        \"\"\"Save splines as a json file.\"\"\"\n        spl = self.tomogram.splines[spline]\n        spl.to_json(save_path)\n\n    @do_not_record\n    @set_design(text=capitalize, location=_sw.FileMenu)\n    def save_molecules(\n        self, layer: MoleculesLayerType, save_path: Path.Save[FileFilter.MOLE]\n    ):\n        \"\"\"Save monomer coordinates, orientation and features to a file.\n\n        Parameters\n        ----------\n        {layer}\n        save_path : Path\n            Where to save the molecules.\n        \"\"\"\n        return assert_layer(layer, self.parent_viewer).molecules.to_csv(save_path)\n\n    @set_design(text=capitalize, location=_sw.FileMenu)\n    @do_not_record\n    def open_reference_image(self, path: Path.Read[FileFilter.IMAGE]):\n        \"\"\"Open an image as a reference image of the current tomogram.\n\n        The input image is usually a denoised image created by other softwares, or\n        simply a filtered image. Please note that this method does not check that the\n        input image is appropriate as a reference of the current tomogram, as\n        potentially any 3D image can be used. Make sure that the input image is dark\n        background.\n\n        Parameters\n        ----------\n        path : path-like\n            Path to the image file. The image must be 3-D.\n        \"\"\"\n        img = ip.imread(path)\n        return self._update_reference_image(img)\n\n    @set_design(text=capitalize, location=_sw.FileMenu)\n    @do_not_record\n    def open_label_image(self, path: Path.Read[FileFilter.IMAGE]):\n        \"\"\"Open an image file as a label image of the current tomogram.\"\"\"\n        label = ip.imread(path)\n        if label.ndim != 3:\n            raise ValueError(\"Label image must be 3-D.\")\n        tr = self.tomogram.multiscale_translation(label.scale.x / self.tomogram.scale)\n        label_layer = widget_utils.add_labels(self.parent_viewer, label, tr)\n        self._reserved_layers.to_be_removed.add(label_layer)\n        return label_layer\n\n    @set_design(text=capitalize, location=_sw.ImageMenu)\n    @dask_thread_worker.with_progress(desc=_pdesc.filter_image_fmt)\n    @do_not_record\n    def filter_reference_image(\n        self,\n        method: ImageFilter = ImageFilter.Lowpass,\n    ):  # fmt: skip\n        \"\"\"Apply filter to enhance contrast of the reference image.\"\"\"\n        if _is_dummy_tomogram(self):\n            return\n        method = ImageFilter(method)\n        t0 = timer()\n        with utils.set_gpu():\n            img = self._reserved_layers.image_data\n            overlap = [min(s, 32) for s in img.shape]\n            _tiled = img.tiled(chunks=(224, 224, 224), overlap=overlap)\n            sigma = 1.6 / self._reserved_layers.scale\n            match method:\n                case ImageFilter.Lowpass:\n                    img_filt = _tiled.lowpass_filter(cutoff=0.2)\n                case ImageFilter.Gaussian:\n                    img_filt = _tiled.gaussian_filter(sigma=sigma, fourier=True)\n                case ImageFilter.DoG:\n                    img_filt = _tiled.dog_filter(low_sigma=sigma, fourier=True)\n                case ImageFilter.LoG:\n                    img_filt = _tiled.log_filter(sigma=sigma)\n                case _:  # pragma: no cover\n                    raise ValueError(f\"No method matches {method!r}\")\n\n        t0.toc()\n        return self._reference_updated_callback.with_args(img_filt)\n\n    @set_design(text=\"Z-project reference image\", location=_sw.ImageMenu)\n    @thread_worker.with_progress(desc=\"Projecting reference image\")\n    @do_not_record\n    def z_project_reference_image(\n        self,\n        method: Literal[\"max\", \"min\", \"mean\"] = \"max\",\n        colormap: Literal[\"twilight\", \"cyan\", \"magenta\", \"gray\"] = \"twilight\",\n        overlay: bool = True,\n    ):\n        \"\"\"Z-project the reference image and overlay it on the viewer.\n\n        This method is useful to visualize the overall distribution of specific features\n        in the tomogram during particle picking.\n\n        Parameters\n        ----------\n        method : str, default \"max\"\n            Method to use for z-projection. Can be \"max\", \"min\" or \"mean\".\n        colormap : str, default \"twilight\"\n            Colormap to use for the projected image.\n        overlay : bool, default True\n            If true, the new image layer will be setup to be overlayed on the\n            tomogram.\n        \"\"\"\n        if _is_dummy_tomogram(self):\n            return\n        img_ref = self._reserved_layers.image_data\n        img_proj = img_ref.proj(axis=\"z\", method=method)\n\n        @thread_worker.callback\n        def _z_project_on_return(img_proj):\n            layer_proj = self.parent_viewer.add_image(\n                img_proj,\n                name=f\"Z-projection ({method})\",\n                scale=self._reserved_layers.image.scale[-2:],\n                translate=self._reserved_layers.image.translate[-2:],\n                opacity=0.5 if overlay else 1.0,\n                colormap=colormap,\n                blending=\"additive\" if overlay else \"translucent_no_depth\",\n            )\n            self._reserved_layers.to_be_removed.add(layer_proj)\n\n        return _z_project_on_return.with_args(img_proj)\n\n    @set_design(text=capitalize, location=_sw.ImageMenu)\n    @thread_worker.with_progress(desc=\"Deconvolving reference image ...\")\n    @do_not_record\n    def deconvolve_reference_image(\n        self,\n        kv: Annotated[float, {\"label\": \"Voltage [kV]\"}] = 300.0,\n        cs: Annotated[float, {\"label\": \"Cs [mm]\"}] = 2.7,\n        defocus: Annotated[float, {\"label\": \"Defocus [um]\", \"min\": -100, \"max\": 100}] = -3.0,\n        bfactor: Annotated[float, {\"label\": \"B-factor\"}] = 0.0,\n        snr_falloff: Annotated[float, {\"label\": \"SNR fall-off\", \"max\": 10.0}] = 0.7,\n        phase_flipped: Annotated[bool, {\"text\": \"Phase flipped\"}] = True,\n    ):  # fmt: skip\n        \"\"\"Deconvolve the reference image using CTF info with Wiener filter.\n\n        Parameters\n        ----------\n        kv : float, default 300.0\n            Accelerating voltage in kV.\n        cs : float, default 2.7\n            Spherical aberration in mm.\n        defocus : float, default -3.0\n            Defocus value in micrometers. For the standard image acquisition method,\n            this value should be negative.\n        bfactor : float, default 0.0\n            B-factor for the decay of the CTF amplitude.\n        snr_falloff : float, default 0.7\n            SNR fall-off factor, for the Wiener filter. Larger value means more\n            smoothing.\n        phase_flipped : bool, default True\n            If the tomogram is reconstructed from phase-flipped tilt series, check this.\n        \"\"\"\n        if _is_dummy_tomogram(self):\n            return\n        t0 = timer()\n        ctf = CTFModel.from_kv(kv, cs, defocus=defocus, bfactor=bfactor)\n        scale = self._reserved_layers.scale\n        yield on_ctf_finished.with_args(ctf, scale)\n        img_deconv = ctf.deconvolve(\n            self._reserved_layers.image_data.value,\n            scale=scale,\n            snr_falloff=snr_falloff,\n            phaseflipped=phase_flipped,\n        )\n        img_deconv = ip.asarray(img_deconv, axes=\"zyx\").set_scale(zyx=scale)\n\n        t0.toc()\n        return self._reference_updated_callback.with_args(img_deconv)\n\n    @thread_worker.with_progress(desc=\"Inverting image\")\n    @set_design(text=capitalize, location=_sw.ImageMenu)\n    def invert_image(self):\n        \"\"\"Invert the intensity of the images.\"\"\"\n        t0 = timer()\n        self.tomogram.invert()\n        if self._reserved_layers.is_lazy:\n\n            @thread_worker.callback\n            def _invert_image_on_return():\n                return undo_callback(self.invert_image)\n\n        else:\n            img_inv = -self._reserved_layers.image.data\n            cmin, cmax = fast_percentile(img_inv, [1, 99.9])\n            if cmin &gt;= cmax:\n                cmax = cmin + 1\n\n            @thread_worker.callback\n            def _invert_image_on_return():\n                self._reserved_layers.image.data = img_inv\n                self._reserved_layers.image.contrast_limits = (cmin, cmax)\n                clow, chigh = self.Overview.contrast_limits\n                self.Overview.image = -self.Overview.image\n                self.Overview.contrast_limits = -chigh, -clow\n                return undo_callback(self.invert_image)\n\n        t0.toc()\n        return _invert_image_on_return\n\n    @set_design(text=\"Add multi-scale\", location=_sw.ImageMenu)\n    @dask_thread_worker.with_progress(desc=lambda bin_size: f\"Adding multiscale (bin = {bin_size})\")  # fmt: skip\n    def add_multiscale(\n        self,\n        bin_size: Annotated[int, {\"choices\": list(range(2, 17))}] = 4,\n    ):\n        \"\"\"Add a new multi-scale image of current tomogram.\n\n        Parameters\n        ----------\n        bin_size : int, default 4\n            Bin size of the new image\n        \"\"\"\n        tomo = self.tomogram\n        tomo.get_multiscale(binsize=bin_size, add=True)\n        return thread_worker.callback(self.set_multiscale).with_args(bin_size)\n\n    @set_design(text=\"Set multi-scale\", location=_sw.ImageMenu)\n    def set_multiscale(self, bin_size: Annotated[int, {\"choices\": _get_available_binsize}]):  # fmt: skip\n        \"\"\"Set multiscale used for image display.\n\n        Parameters\n        ----------\n        bin_size: int\n            Bin size of multiscaled image.\n        \"\"\"\n        tomo = self.tomogram\n        _old_bin_size = self._current_binsize\n        imgb = tomo.get_multiscale(bin_size)\n        factor = self._reserved_layers.scale / imgb.scale.x\n        self._reserved_layers.update_image(imgb, tomo.multiscale_translation(bin_size))\n        current_z = self.parent_viewer.dims.current_step[0]\n        self.parent_viewer.dims.set_current_step(axis=0, value=current_z * factor)\n\n        # update overview\n        self.Overview.image = imgb.mean(axis=\"z\")\n        self.Overview.xlim = [x * factor for x in self.Overview.xlim]\n        self.Overview.ylim = [y * factor for y in self.Overview.ylim]\n        self._current_binsize = bin_size\n        self.reset_choices()\n        return undo_callback(self.set_multiscale).with_args(_old_bin_size)\n\n    @set_design(text=capitalize, location=_sw.ImageMenu)\n    def sample_subtomograms(self):\n        \"\"\"Sample subtomograms at the anchor points on splines\"\"\"\n        self.spline_fitter.close()\n\n        # initialize GUI\n        if len(self.tomogram.splines) == 0:\n            raise ValueError(\"No spline found.\")\n        spl = self.tomogram.splines[0]\n        if spl.has_anchors:\n            self.SplineControl[\"pos\"].max = spl.anchors.size - 1\n        self.SplineControl._num_changed()\n        self._reserved_layers.work.mode = \"pan_zoom\"\n\n        self._update_local_properties_in_widget()\n        self._update_global_properties_in_widget()\n        self._highlight_spline()\n\n        # reset contrast limits\n        self.SplineControl._reset_contrast_limits()\n\n    def _get_spline_idx(self, *_) -&gt; int:\n        return self.SplineControl.num\n\n    @set_design(text=capitalize, location=_sw.SplinesMenu.Orientation)\n    def invert_spline(self, spline: Annotated[int, {\"bind\": _get_spline_idx}] = None):\n        \"\"\"Invert current displayed spline **in place**.\n\n        Parameters\n        ----------\n        spline : int, optional\n            ID of splines to be inverted.\n        \"\"\"\n        if spline is None:\n            return\n        spl = self.tomogram.splines[spline]\n        self.tomogram.splines[spline] = spl.invert()\n        self._update_splines_in_images()\n        self.reset_choices()\n\n        need_resample = self.SplineControl.need_resample\n        self._init_widget_state()\n        if need_resample:\n            self.sample_subtomograms()\n        self._set_orientation_marker(spline)\n        return undo_callback(self.invert_spline).with_args(spline)\n\n    @set_design(text=capitalize, location=_sw.SplinesMenu.Orientation)\n    def align_to_polarity(\n        self, orientation: Literal[\"MinusToPlus\", \"PlusToMinus\"] = \"MinusToPlus\"\n    ):\n        \"\"\"Align all the splines in the direction parallel to the cylinder polarity.\n\n        Parameters\n        ----------\n        orientation : Ori, default Ori.MinusToPlus\n            To which direction splines will be aligned.\n        \"\"\"\n        need_resample = self.SplineControl.need_resample\n        _old_orientations = [spl.orientation for spl in self.tomogram.splines]\n        self.tomogram.align_to_polarity(orientation=orientation)\n        self._update_splines_in_images()\n        self._init_widget_state()\n        self.reset_choices()\n        if need_resample:\n            self.sample_subtomograms()\n        for i in range(len(self.tomogram.splines)):\n            self._set_orientation_marker(i)\n        _new_orientations = [spl.orientation for spl in self.tomogram.splines]\n        return (\n            undo_callback(self._set_orientations)\n            .with_args(_old_orientations, need_resample)\n            .with_redo(lambda: self._set_orientations(_new_orientations))\n        )\n\n    @set_design(text=capitalize, location=_sw.SplinesMenu.Orientation)\n    @thread_worker.with_progress(desc=\"Auto-detecting polarities...\", total=_NSPLINES)\n    def infer_polarity(\n        self,\n        splines: SplinesType = None,\n        depth: Annotated[nm, {\"min\": 5.0, \"max\": 500.0, \"step\": 5.0}] = 40,\n        bin_size: Annotated[int, {\"choices\": _get_available_binsize}] = 1,\n    ):  # fmt: skip\n        \"\"\"Automatically detect the cylinder polarities.\n\n        This function uses Fourier vorticity to detect the polarities of the splines.\n        The subtomogram at the center of the spline will be sampled in the cylindric\n        coordinate and the power spectra in (radius, angle) space will be calculated.\n        The peak position of the `angle = nPF` line scan will be used to detect the\n        polarity of the spline.\n\n        Parameters\n        ----------\n        {splines}{depth}{bin_size}\n        \"\"\"\n        tomo = self.tomogram\n        _old_orientations = [spl.orientation for spl in self.tomogram.splines]\n        for i in self._norm_splines(splines):\n            tomo.infer_polarity(i=i, binsize=bin_size, depth=depth, update=True)\n            yield\n        _new_orientations = [spl.orientation for spl in self.tomogram.splines]\n\n        @thread_worker.callback\n        def _on_return():\n            self._update_splines_in_images()\n            for i in range(len(tomo.splines)):\n                self._set_orientation_marker(i)\n\n            self.SplineControl._update_canvas()\n            return (\n                undo_callback(self._set_orientations)\n                .with_args(_old_orientations)\n                .with_redo(lambda: self._set_orientations(_new_orientations))\n            )\n\n        return _on_return\n\n    def _set_orientations(self, orientations: list[Ori], resample: bool = True):\n        for spl, ori in zip(self.tomogram.splines, orientations, strict=True):\n            spl.orientation = ori\n        self._update_splines_in_images()\n        self._init_widget_state()\n        self.reset_choices()\n        for i in range(len(self.tomogram.splines)):\n            self._set_orientation_marker(i)\n        if resample:\n            self.sample_subtomograms()\n        return None\n\n    @set_design(text=capitalize, location=_sw.SplinesMenu)\n    @bind_key(\"Ctrl+K, Ctrl+X\")\n    def clip_spline(\n        self,\n        spline: Annotated[int, {\"choices\": _get_splines}],\n        lengths: Annotated[tuple[nm, nm], {\"options\": {\"min\": -1000.0, \"max\": 1000.0, \"step\": 0.1, \"label\": \"clip length (nm)\"}}] = (0.0, 0.0),\n    ):  # fmt: skip\n        \"\"\"Clip selected spline at its edges by given lengths.\n\n        Parameters\n        ----------\n        spline : int\n            The ID of spline to be clipped.\n        lengths : tuple of float, default (0., 0.)\n            The length in nm to be clipped at the start and end of the spline.\n        \"\"\"\n        if spline is None:\n            return\n        spl = self.tomogram.splines[spline]\n        _old_spl = spl.copy()\n        length = spl.length()\n        start, stop = np.array(lengths) / length\n        self.tomogram.splines[spline] = spl.clip(start, 1 - stop)\n        self._update_splines_in_images()\n        # current layer will be removed. Select another layer.\n        self.parent_viewer.layers.selection = {self._reserved_layers.work}\n\n        @undo_callback\n        def out():\n            self.tomogram.splines[spline] = _old_spl\n            self._update_splines_in_images()\n\n        return out\n\n    @set_design(text=capitalize, location=_sw.SplinesMenu)\n    def split_spline(\n        self,\n        spline: Annotated[int, {\"choices\": _get_splines}],\n        at: Annotated[nm, {\"min\": 0.0, \"max\": 10000.0, \"step\": 0.1, \"label\": \"split at (nm)\"}] = 100.0,\n        from_start: bool = True,\n        trim: Annotated[nm, {\"min\": 0.0, \"max\": 100.0, \"step\": 0.1, \"label\": \"trim (nm)\"}] = 0.0,\n    ):  # fmt: skip\n        \"\"\"Split the spline into two at the given position.\n\n        Parameters\n        ----------\n        {spline}\n        at : float, default 100.0\n            Position to split the spline in nm.\n        from_start : bool, default True\n            If True, the split position will be measured from the start of the spline,\n            otherwise from the end.\n        trim : float, default 0.0\n            Trim the split parts by this length (nm).\n        \"\"\"\n        spl = self.splines[spline]\n        spls = spl.split(at, from_start=from_start, trim=trim)\n        self.splines.pop(spline)\n        for new_spl in reversed(spls):\n            self.splines.insert(spline, new_spl)\n        self._update_splines_in_images()\n        self.reset_choices()\n\n        @undo_callback\n        def _out():\n            del self.splines[-2:]\n            self.splines.insert(spline, spl)\n            self._update_splines_in_images()\n            self.reset_choices()\n\n        return _out\n\n    @set_design(text=capitalize, location=_sw.SplinesMenu)\n    def split_splines_at_changing_point(\n        self,\n        splines: SplinesType = None,\n        estimate_by: str = \"radius\",\n        diff_cutoff: Annotated[float, {\"min\": 0.0, \"max\": 1000.0, \"step\": 0.01}] = 0.4,\n        trim: Annotated[nm, {\"min\": 0.0, \"max\": 1000.0, \"step\": 0.1, \"label\": \"trim (nm)\"}] = 0.0,\n    ):  # fmt: skip\n        \"\"\"Detect the changing point of the spline and split it there.\n\n        This method is useful when (1) there's a change in the protofilament number, or\n        (2) microtubules were polymerized from seeds.\n\n        Parameters\n        ----------\n        {splines}\n        estimate_by : str, default \"radius\"\n            Local property to estimate the changing point. Must be one of the local\n            property of the splines.\n        diff_cutoff : float, default 2.0\n            The cutoff value of the absolute difference between the two regions to be\n            considered as a changing point.\n        trim : float, default 0.0\n            Trim the split parts by this length (nm). If any of the split parts is\n            shorter than this length, the part will be discarded.\n        \"\"\"\n        splines = self._norm_splines(splines)\n        spl_map = dict[int, list[CylSpline]]()\n        _Logger.print(\"`split_spine_at_changing_point`\")\n        for i in splines:\n            spl = self.splines[i]\n            if (loc := spl.props.get_loc(estimate_by, None)) is None:\n                raise ValueError(\n                    f\"Spline-{i} does not have {estimate_by!r} local property. Call \"\n                    \"`measure_local_radius` or `local_cft_analysis` first.\"\n                )\n            idx = utils.find_changing_point(loc)\n            mean_diff = float(abs(loc[:idx].mean() - loc[idx:].mean()))\n            _log = f\"spline-{i}: {mean_diff=:.3g}\"\n            if mean_diff &lt; diff_cutoff:\n                _Logger.print(f\"{_log} ==&gt; skip\")\n                continue\n            at = spl.length(0, (spl.anchors[idx - 1] + spl.anchors[idx]) / 2)\n            _Logger.print(f\"{_log} ==&gt; split at {at:.1f} nm\")\n            spl_map[i] = spl.split(at, from_start=True, trim=trim, allow_discard=True)\n\n        for i, new_spls in sorted(spl_map.items(), key=lambda x: x[0], reverse=True):\n            self.splines.pop(i)\n            for new_spl in reversed(new_spls):\n                self.splines.insert(i, new_spl)\n\n        self._update_splines_in_images()\n        self.reset_choices()\n        return None\n\n    @set_design(text=capitalize, location=_sw.SplinesMenu)\n    @confirm(\n        text=\"Spline has properties. Are you sure to delete it?\",\n        condition=_confirm_delete,\n    )\n    def delete_spline(self, i: Annotated[int, {\"bind\": _get_spline_idx}]):\n        \"\"\"Delete currently selected spline.\"\"\"\n        if i &lt; 0:\n            i = len(self.tomogram.splines) - 1\n        spl = self.tomogram.splines.pop(i)\n        self.reset_choices()\n\n        # update layer\n        features = self._reserved_layers.prof.features\n        old_data = self._reserved_layers.prof.data\n        self._reserved_layers.select_spline(i, len(self.tomogram.splines))\n        self._update_splines_in_images()\n        if self.SplineControl.need_resample and len(self.tomogram.splines) &gt; 0:\n            self.sample_subtomograms()\n\n        @undo_callback\n        def out():\n            self.tomogram.splines.insert(i, spl)\n            self._reserved_layers.prof.data = old_data\n            self._reserved_layers.prof.features = features\n            self._add_spline_to_images(spl, i)\n            self._update_splines_in_images()\n            self.reset_choices()\n\n        return out\n\n    @set_design(text=capitalize, location=_sw.SplinesMenu)\n    def copy_spline(self, i: Annotated[int, {\"bind\": _get_spline_idx}]):\n        \"\"\"Make a copy of the current spline\"\"\"\n        spl = self.tomogram.splines[i]\n        self.tomogram.splines.append(spl.copy())\n        self.reset_choices()\n        self.SplineControl.num = len(self.tomogram.splines) - 1\n        return undo_callback(self.delete_spline).with_args(-1)\n\n    @nogui\n    def update_spline_config(\n        self,\n        splines: SplinesType = None,\n        npf_range: Annotated[tuple[int, int], {\"options\": {\"min\": 2, \"max\": 100}}] = (11, 17),\n        spacing_range: Annotated[tuple[nm, nm], {\"options\": {\"step\": 0.05}}] = (3.9, 4.3),\n        twist_range: Annotated[tuple[float, float], {\"options\": {\"min\": -45.0, \"max\": 45.0, \"step\": 0.05}}] = (-1.0, 1.0),\n        rise_range: Annotated[tuple[float, float], {\"options\": {\"min\": -45.0, \"max\": 45.0, \"step\": 0.1}}] = (0.0, 45.0),\n        rise_sign: Literal[-1, 1] = -1,\n        clockwise: Literal[\"PlusToMinus\", \"MinusToPlus\"] = \"MinusToPlus\",\n        thickness_inner: Annotated[nm, {\"min\": 0.0, \"step\": 0.1}] = 2.8,\n        thickness_outer: Annotated[nm, {\"min\": 0.0, \"step\": 0.1}] = 2.8,\n        fit_depth: Annotated[nm, {\"min\": 4.0, \"step\": 1}] = 48.0,\n        fit_width: Annotated[nm, {\"min\": 4.0, \"step\": 1}] = 44.0,\n    ):  # fmt: skip\n        config = locals()\n        del config[\"splines\"], config[\"self\"]\n        _splines = self._norm_splines(splines)\n        _old_spls = {i: self.tomogram.splines[i].copy() for i in _splines}\n        for i in _splines:\n            spl = self.tomogram.splines[i]\n            spl_new = spl.with_config(config, copy_props=True)\n            self.tomogram.splines[i] = spl_new\n        self._update_splines_in_images()\n\n        @undo_callback\n        def out():\n            for i, old_spl in _old_spls.items():\n                self.tomogram.splines[i] = old_spl\n            self._update_splines_in_images()\n\n        return out\n\n    @set_design(text=capitalize, location=_sw.SplinesMenu.Fitting)\n    @thread_worker.with_progress(desc=\"Spline Fitting\", total=_NSPLINES)\n    def fit_splines(\n        self,\n        splines: SplinesType = None,\n        max_interval: Annotated[nm, {\"label\": \"max interval (nm)\"}] = 30,\n        bin_size: Annotated[int, {\"choices\": _get_available_binsize}] = 1.0,\n        err_max: Annotated[nm, {\"label\": \"max fit error (nm)\", \"step\": 0.1}] = 1.0,\n        degree_precision: float = 0.5,\n        edge_sigma: Annotated[Optional[nm], {\"text\": \"Do not mask image\", \"label\": \"edge \u03c3\"}] = 2.0,\n        max_shift: nm = 5.0,\n    ):  # fmt: skip\n        \"\"\"Fit splines to the cylinder by auto-correlation.\n\n        Parameters\n        ----------\n        {splines}{max_interval}{bin_size}{err_max}\n        degree_precision : float, default 0.5\n            Precision of xy-tilt degree in angular correlation.\n        edge_sigma : bool, default 2.0\n            Check if cylindric structures are densely packed. Initial spline position\n            must be \"almost\" fitted in dense mode.\n        max_shift : nm, default 5.0\n            Maximum shift to be applied to each point of splines.\n        \"\"\"\n        tomo = self.tomogram\n        splines = self._norm_splines(splines)\n        with SplineTracker(widget=self, indices=splines) as tracker:\n            for i in splines:\n                tomo.fit(\n                    i,\n                    max_interval=max_interval,\n                    binsize=bin_size,\n                    err_max=err_max,\n                    degree_precision=degree_precision,\n                    edge_sigma=edge_sigma,\n                    max_shift=max_shift,\n                )\n                yield thread_worker.callback(self._update_splines_in_images)\n\n            @thread_worker.callback\n            def out():\n                self._init_widget_state()\n                self._update_splines_in_images()\n                return tracker.as_undo_callback()\n\n        return out\n\n    @set_design(text=capitalize, location=_sw.SplinesMenu.Fitting)\n    @thread_worker.with_progress(desc=\"Spline Fitting\", total=_NSPLINES)\n    def fit_splines_by_centroid(\n        self,\n        splines: SplinesType = None,\n        max_interval: Annotated[nm, {\"label\": \"max interval (nm)\"}] = 30,\n        bin_size: Annotated[int, {\"choices\": _get_available_binsize}] = 1.0,\n        err_max: Annotated[nm, {\"label\": \"max fit error (nm)\", \"step\": 0.1}] = 1.0,\n        max_shift: nm = 5.0,\n    ):  # fmt: skip\n        \"\"\"Fit splines to the cylinder by centroid of sub-volumes.\n\n        Parameters\n        ----------\n        {splines}{max_interval}{bin_size}{err_max}\n        max_shift : nm, default 5.0\n            Maximum shift to be applied to each point of splines.\n        \"\"\"\n        tomo = self.tomogram\n        splines = self._norm_splines(splines)\n        with SplineTracker(widget=self, indices=splines) as tracker:\n            for i in splines:\n                tomo.fit_centroid(\n                    i,\n                    max_interval=max_interval,\n                    binsize=bin_size,\n                    err_max=err_max,\n                    max_shift=max_shift,\n                )\n                yield thread_worker.callback(self._update_splines_in_images)\n\n            @thread_worker.callback\n            def out():\n                self._init_widget_state()\n                self._update_splines_in_images()\n                return tracker.as_undo_callback()\n\n        return out\n\n    @set_design(text=capitalize, location=_sw.SplinesMenu)\n    def add_anchors(\n        self,\n        splines: SplinesType = None,\n        interval: Annotated[nm, {\"label\": \"Interval between anchors (nm)\", \"min\": 1.0}] = 25.0,\n        how: Literal[\"pack\", \"equal\"] = \"pack\",\n    ):  # fmt: skip\n        \"\"\"Add anchors to splines.\n\n        Parameters\n        ----------\n        {splines}{interval}\n        how : str, default \"pack\"\n            How to add anchors.\n\n            - \"pack\": (x\u2014\u2014\u2014x\u2014\u2014\u2014x\u2014) Pack anchors from the starting point of splines.\n            - \"equal\": (x\u2014\u2014x\u2014\u2014x\u2014\u2014x) Equally distribute anchors between the starting\n              point and the end point of splines. Actual intervals will be smaller.\n        \"\"\"\n        tomo = self.tomogram\n        splines = self._norm_splines(splines)\n        with SplineTracker(widget=self, indices=splines) as tracker:\n            match how:\n                case \"pack\":\n                    tomo.make_anchors(splines, interval=interval)\n                case \"equal\":\n                    tomo.make_anchors(splines, max_interval=interval)\n                case _:  # pragma: no cover\n                    raise ValueError(f\"Unknown method: {how}\")\n\n            self._update_splines_in_images()\n            return tracker.as_undo_callback()\n\n    @set_design(text=capitalize, location=_sw.SplinesMenu.Fitting)\n    @thread_worker.with_progress(desc=\"Refining splines\", total=_NSPLINES)\n    def refine_splines(\n        self,\n        splines: SplinesType = None,\n        max_interval: Annotated[nm, {\"label\": \"maximum interval (nm)\"}] = 30,\n        err_max: Annotated[nm, {\"label\": \"max fit error (nm)\", \"step\": 0.1}] = 0.8,\n        corr_allowed: Annotated[float, {\"label\": \"correlation allowed\", \"max\": 1.0, \"step\": 0.1}] = 0.9,\n        bin_size: Annotated[int, {\"choices\": _get_available_binsize}] = 1,\n    ):  # fmt: skip\n        \"\"\"Refine splines using the global cylindric structural parameters.\n\n        Parameters\n        ----------\n        {splines}{max_interval}{err_max}\n        corr_allowed : float, default 0.9\n            How many images will be used to make template for alignment. If 0.9, then\n            top 90% will be used.\n        {bin_size}\n        \"\"\"\n        tomo = self.tomogram\n        splines = self._norm_splines(splines)\n        with SplineTracker(widget=self, indices=splines) as tracker:\n            for i in splines:\n                tomo.refine(\n                    i,\n                    max_interval=max_interval,\n                    corr_allowed=corr_allowed,\n                    err_max=err_max,\n                    binsize=bin_size,\n                )\n                yield thread_worker.callback(self._update_splines_in_images)\n\n            @thread_worker.callback\n            def out():\n                self._init_widget_state()\n                self._update_splines_in_images()\n                self._update_local_properties_in_widget()\n                return tracker.as_undo_callback()\n\n        return out\n\n    @set_design(text=\"Set spline properties\", location=_sw.SplinesMenu)\n    def set_spline_props(\n        self,\n        spline: Annotated[int, {\"bind\": _get_spline_idx}],\n        npf: Annotated[Optional[int], {\"label\": \"number of PF\", \"text\": \"Do not update\"}] = None,\n        start: Annotated[Optional[int], {\"label\": \"start number\", \"text\": \"Do not update\", \"options\": {\"min\": -100}}] = None,\n        orientation: Annotated[Optional[Literal[\"MinusToPlus\", \"PlusToMinus\"]], {\"text\": \"Do not update\"}] = None,\n    ):  # fmt: skip\n        \"\"\"Set spline global properties.\n\n        This method will overwrite spline properties with the user input. You should\n        not call this method unless there's a good reason to do so, e.g. the number\n        of protofilaments is obviously wrong.\n\n        Parameters\n        ----------\n        npf : int, optional\n            If given, update the number of protofilaments.\n        start : int, optional\n            If given, update the start number of the spline.\n        orientation : str, optional\n            If given, update the spline orientation.\n        \"\"\"\n        spl = self.tomogram.splines[spline]\n        old_spl = spl.copy()\n        spl.update_props(npf=npf, start=start, orientation=orientation)\n        self.sample_subtomograms()\n        self._update_splines_in_images()\n\n        @undo_callback\n        def out():\n            self.tomogram.splines[spline] = old_spl\n            self.sample_subtomograms()\n            self._update_splines_in_images()\n\n        return out\n\n    @set_design(text=capitalize, location=_sw.MoleculesMenu.FromToSpline)\n    def molecules_to_spline(\n        self,\n        layers: MoleculesLayersType = (),\n        err_max: Annotated[nm, {\"label\": \"Max fit error (nm)\", \"step\": 0.1}] = 0.8,\n        delete_old: Annotated[bool, {\"label\": \"Delete old splines\"}] = True,\n        inherits: Annotated[Optional[list[str]], {\"label\": \"Properties to inherit\", \"text\": \"All properties\"}] = None,\n        missing_ok: Annotated[bool, {\"label\": \"Missing OK\"}] = False,\n        update_sources: Annotated[bool, {\"label\": \"Update all the spline sources\"}] = True,\n    ):  # fmt: skip\n        \"\"\"Create splines from molecules.\n\n        This function is useful to refine splines using results of subtomogram\n        alignment. If the molecules layer alreadly has a source spline, replace\n        it with the new one.\n        Note that this function only works with molecules that is correctly\n        assembled by such as :func:`map_monomers`.\n\n        Parameters\n        ----------\n        {layers}{err_max}\n        delete_old : bool, default True\n            If True, delete the old spline if the molecules has one. For instance, if\n            \"Mole-0\" has the spline \"Spline-0\" as the source, and a spline \"Spline-1\" is\n            created from \"Mole-0\", then \"Spline-0\" will be deleted from the list.\n        inherits : bool, optional\n            Which global properties to be copied to the new one. If None, all the properties\n            will be copied.\n        missing_ok : bool, default False\n            If False, raise an error if the source spline is not found in the tomogram.\n        update_sources : bool, default True\n            If True, all the molecules with the out-of-date source spline will be updated\n            to the newly created splines. For instance, if \"Mole-0\" and \"Mole-1\" have the\n            spline \"Spline-0\" as the source, and a spline \"Spline-1\" is created from\n            \"Mole-1\", then the source of \"Mole-1\" will be updated to \"Spline-1\" as well.\n        \"\"\"\n        tomo = self.tomogram\n        layers = assert_list_of_layers(layers, self.parent_viewer)\n\n        # first check missing_ok=False case\n        if not missing_ok:\n            for layer in layers:\n                # NOTE: The source spline may not exist in the list\n                if _s := layer.source_spline:\n                    tomo.splines.index(_s)  # raise error here if not found\n\n        for layer in layers:\n            if _s := layer.source_spline:\n                _config = _s.config\n            else:\n                _config = self.default_config\n            _shape = (*layer.regular_shape(), 3)\n            coords = layer.molecules.pos.reshape(_shape).mean(axis=1)\n            spl = CylSpline(config=_config).fit(coords, err_max=err_max)\n            try:\n                idx = tomo.splines.index(layer.source_spline)\n            except ValueError:\n                tomo.splines.append(spl)\n                idx = len(tomo.splines) - 1\n            else:\n                old_spl = tomo.splines[idx]\n                if inherits is None:\n                    spl.props.glob = old_spl.props.glob.clone()\n                else:\n                    glob = old_spl.props.glob\n                    spl.props.glob = {k: glob[k] for k in glob.columns if k in inherits}\n\n                # Must be updated here, otherwise each.source_component may return\n                # None since GC may delete the old spline.\n                if update_sources:\n                    for each in self.mole_layers:\n                        if each.source_component is old_spl:\n                            each.source_component = spl\n                if delete_old:\n                    tomo.splines[idx] = spl\n                else:\n                    tomo.splines.append(spl)\n            layer.source_component = spl\n            _Logger.print(f\"Layer {layer.name} generated spline-{idx}.\")\n\n        self.reset_choices()\n        self.sample_subtomograms()\n        self._update_splines_in_images()\n        return None\n\n    @set_design(text=capitalize, location=_sw.MoleculesMenu.FromToSpline)\n    def protofilaments_to_spline(\n        self,\n        layer: MoleculesLayerType,\n        err_max: Annotated[nm, {\"label\": \"Max fit error (nm)\", \"step\": 0.1}] = 0.8,\n        ids: list[int] = (0,),\n        config: Annotated[dict[str, Any] | SplineConfig, {\"validator\": _get_default_config}] = None,\n    ):  # fmt: skip\n        \"\"\"Convert protofilaments to splines.\n\n        If no IDs are given, all the molecules will be fitted to a spline, therefore\n        essentially the same as manual filament picking. If IDs are given, selected\n        protofilaments will be fitted to a spline separately.\n\n        Parameters\n        ----------\n        {layer}{err_max}\n        ids : list of int, default (0,)\n            Protofilament IDs to be converted.\n        \"\"\"\n        layer = assert_layer(layer, self.parent_viewer)\n        tomo = self.tomogram\n        mole = layer.molecules\n        if len(ids) == 0:\n            tomo.add_spline(mole.pos, err_max=err_max, config=config)\n            _Logger.print(\n                f\"Layer {layer.name} generated spline-{len(tomo.splines) - 1}.\"\n            )\n        for i in ids:\n            sub = mole.filter(pl.col(Mole.pf) == i)\n            if sub.count() == 0:\n                continue\n            tomo.add_spline(sub.sort(Mole.nth).pos, err_max=err_max, config=config)\n            _Logger.print(\n                f\"{i}-th protofilament of layer {layer.name} generated spline-{len(tomo.splines) - 1}.\"\n            )\n        self.reset_choices()\n        self._update_splines_in_images()\n        return None\n\n    @set_design(text=capitalize, location=_sw.MoleculesMenu.FromToSpline)\n    def filament_to_spline(\n        self,\n        layer: MoleculesLayerType,\n        err_max: Annotated[nm, {\"label\": \"Max fit error (nm)\", \"step\": 0.1}] = 0.8,\n        config: Annotated[dict[str, Any] | SplineConfig, {\"validator\": _get_default_config}] = None,\n    ):  # fmt: skip\n        \"\"\"Convert a filament to splines.\n\n        Parameters\n        ----------\n        {layer}{err_max}\n        \"\"\"\n        return self.protofilaments_to_spline(\n            layer, err_max=err_max, ids=(), config=config\n        )\n\n    @set_design(text=capitalize, location=_sw.AnalysisMenu.Radius)\n    @thread_worker.with_progress(desc=\"Measuring Radius\", total=_NSPLINES)\n    def measure_radius(\n        self,\n        splines: SplinesType = None,\n        bin_size: Annotated[int, {\"choices\": _get_available_binsize}] = 1,\n        min_radius: Annotated[nm, {\"min\": 0.1, \"step\": 0.1}] = 1.0,\n        max_radius: Annotated[nm, {\"min\": 0.1, \"step\": 0.1}] = 100.0,\n    ):  # fmt: skip\n        \"\"\"Measure cylinder radius for each spline curve.\n\n        Parameters\n        ----------\n        {splines}{bin_size}{min_radius}{max_radius}\n        \"\"\"\n        splines = self._norm_splines(splines)\n        with SplineTracker(widget=self, indices=splines, sample=True) as tracker:\n            for i in splines:\n                self.tomogram.measure_radius(\n                    i, binsize=bin_size, min_radius=min_radius, max_radius=max_radius\n                )\n                yield\n\n            return tracker.as_undo_callback()\n\n    @set_design(text=capitalize, location=_sw.AnalysisMenu.Radius)\n    def set_radius(\n        self,\n        splines: SplinesType = None,\n        radius: PolarsExprStrOrScalar = 10.0,\n    ):  # fmt: skip\n        \"\"\"Manually set radius of the splines.\n\n        Parameters\n        ----------\n        {splines}\n        radius : float or str expression\n            Radius of the spline. If a string expression is given, it will be evaluated\n            to get the polars.Expr object. The returned expression will be evaluated\n            with the global properties of the spline as the context.\n        \"\"\"\n        radius_expr = widget_utils.norm_scalar_expr(radius)\n        splines = self._norm_splines(splines)\n        rdict = dict[int, float]()\n        for i in splines:\n            _radius = self.splines[i].props.get_glob(radius_expr)\n            if not isinstance(_radius, int | float):\n                raise ValueError(\n                    f\"Radius must be converted into a number, got {_radius!r}.\"\n                )\n            if _radius &lt;= 0:\n                raise ValueError(f\"Radius must be positive, got {_radius}.\")\n            rdict[i] = _radius\n        with SplineTracker(widget=self, indices=splines, sample=True) as tracker:\n            for i in splines:\n                self.splines[i].radius = rdict[i]\n                _Logger.print(f\"Spline-{i} radius set to {rdict[i]:.2f} nm.\")\n            return tracker.as_undo_callback()\n\n    @set_design(text=capitalize, location=_sw.AnalysisMenu.Radius)\n    @thread_worker.with_progress(desc=\"Measuring local radii\", total=_NSPLINES)\n    def measure_local_radius(\n        self,\n        splines: SplinesType = None,\n        interval: _Interval = None,\n        depth: Annotated[nm, {\"min\": 2.0, \"step\": 0.5}] = 50.0,\n        bin_size: Annotated[int, {\"choices\": _get_available_binsize}] = 1,\n        min_radius: Annotated[nm, {\"min\": 0.1, \"step\": 0.1}] = 1.0,\n        max_radius: Annotated[nm, {\"min\": 0.1, \"step\": 0.1}] = 100.0,\n        update_glob: Annotated[bool, {\"text\": \"Also update the global radius\"}] = True,\n    ):  # fmt: skip\n        \"\"\"Measure radius for each local region along splines.\n\n        Parameters\n        ----------\n        {splines}{interval}{depth}{bin_size}{min_radius}{max_radius}{update_glob}\n        \"\"\"\n        tomo = self.tomogram\n        splines = self._norm_splines(splines)\n\n        @thread_worker.callback\n        def _on_yield():\n            self._update_local_properties_in_widget(replot=True)\n\n        with SplineTracker(widget=self, indices=splines) as tracker:\n            for i in splines:\n                if interval is not None:\n                    tomo.make_anchors(i=i, interval=interval)\n                tomo.local_radii(\n                    i=i,\n                    depth=depth,\n                    binsize=bin_size,\n                    min_radius=min_radius,\n                    max_radius=max_radius,\n                    update_glob=update_glob,\n                )\n                if i == splines[-1]:\n                    yield _on_yield\n                else:\n                    yield\n\n            return tracker.as_undo_callback()\n\n    @set_design(text=capitalize, location=_sw.AnalysisMenu.Radius)\n    def measure_radius_by_molecules(\n        self,\n        layers: MoleculesLayersType = (),\n        interval: _Interval = None,\n        depth: Annotated[nm, {\"min\": 2.0, \"step\": 0.5}] = 50.0,\n        update_glob: Annotated[bool, {\"text\": \"Also update the global radius\"}] = True,\n    ):  # fmt: skip\n        \"\"\"Measure local and global radius for each layer.\n\n        Please note that the radius defined by the peak of the radial profile is not\n        always the same as the radius measured by this method. If the molecules are\n        aligned using a template image whose mass density is not centered, these radii\n        may differ a lot.\n\n        Parameters\n        ----------\n        {layers}{interval}{depth}{update_glob}\n        \"\"\"\n        layers = assert_list_of_layers(layers, self.parent_viewer)\n\n        # check duplicated spline sources\n        _splines = list[CylSpline]()\n        _radius_df = list[pl.DataFrame]()\n        _duplicated = list[CylSpline]()\n        for layer in layers:\n            spl = _assert_source_spline_exists(layer)\n            if any(spl is each for each in _splines):\n                _duplicated.append(spl)\n            _splines.append(spl)\n            mole = layer.molecules\n            df = mole.features\n            _radius_df.append(df.with_columns(cylmeasure.calc_radius(mole, spl)))\n\n        if _duplicated:\n            _layer_names = \", \".join(repr(l.name) for l in layers)\n            raise ValueError(f\"Layers {_layer_names} have duplicated spline sources.\")\n\n        indices = [self.tomogram.splines.index(spl) for spl in _splines]\n        with SplineTracker(widget=self, indices=indices) as tracker:\n            for i, spl, df in zip(indices, _splines, _radius_df, strict=True):\n                if interval is not None:\n                    self.tomogram.make_anchors(i=i, interval=interval)\n                radii = list[float]()\n                for pos in spl.anchors * spl.length():\n                    lower, upper = pos - depth / 2, pos + depth / 2\n                    pred = pl.col(Mole.position).is_between(lower, upper, closed=\"left\")\n                    radii.append(df.filter(pred)[Mole.radius].mean())\n                radii = pl.Series(H.radius, radii, dtype=pl.Float32)\n                if radii.is_nan().any():\n                    _Logger.print_html(f\"&lt;b&gt;Spline-{i} contains NaN radius.&lt;/b&gt;\")\n                spl.props.update_loc([radii], depth, bin_size=1)\n                if update_glob:\n                    spl.radius = df[Mole.radius].mean()\n            self._update_local_properties_in_widget(replot=True)\n            return tracker.as_undo_callback()\n\n    @set_design(text=\"Local CFT analysis\", location=_sw.AnalysisMenu)\n    @thread_worker.with_progress(desc=\"Local Cylindric Fourier transform\", total=_NSPLINES)  # fmt: skip\n    def local_cft_analysis(\n        self,\n        splines: SplinesType = None,\n        interval: _Interval = None,\n        depth: Annotated[nm, {\"min\": 2.0, \"step\": 0.5}] = 50.0,\n        bin_size: Annotated[int, {\"choices\": _get_available_binsize}] = 1,\n        radius: Literal[\"local\", \"global\"] = \"global\",\n        update_glob: Annotated[bool, {\"text\": \"Also update the global properties\"}] = False,\n    ):  # fmt: skip\n        \"\"\"Determine local lattice parameters by local cylindric Fourier transformation.\n\n        This method will sample subtomograms at given intervals and calculate the power\n        spectra in a cylindrical coordinate. The peak position of the power spectra will\n        be used to determine the lattice parameters. Note that if the interval differs\n        from the current spline anchors, the old local properties will be dropped.\n\n        Parameters\n        ----------\n        {splines}{interval}{depth}{bin_size}\n        radius : str, default \"global\"\n            If \"local\", use the local radius for the analysis. If \"global\", use the\n            global radius.\n        {update_glob}\n        \"\"\"\n        tomo = self.tomogram\n        splines = self._norm_splines(splines)\n\n        # first check radius\n        match radius:\n            case \"global\":\n                for i in splines:\n                    if tomo.splines[i].radius is None:\n                        raise ValueError(\n                            f\"Global Radius of {i}-th spline is not measured yet. Please \"\n                            \"measure the radius first from `Analysis &gt; Radius`.\"\n                        )\n            case \"local\":\n                for i in splines:\n                    if not tomo.splines[i].props.has_loc(H.radius):\n                        raise ValueError(\n                            f\"Local Radius of {i}-th spline is not measured yet. Please \"\n                            \"measure the radius first from `Analysis &gt; Radius`.\"\n                        )\n                if interval is not None:\n                    raise ValueError(\n                        \"With `interval`, local radius values will be dropped. Please \"\n                        \"set `radius='global'` or `interval=None`.\"\n                    )\n            case _:\n                raise ValueError(f\"radius must be 'local' or 'global', got {radius!r}.\")\n\n        @thread_worker.callback\n        def _local_cft_analysis_on_yield(i: int):\n            self._update_splines_in_images()\n            if i == self.SplineControl.num:\n                self.sample_subtomograms()\n\n        with SplineTracker(widget=self, indices=splines, sample=True) as tracker:\n            for i in splines:\n                if interval is not None:\n                    tomo.make_anchors(i=i, interval=interval)\n                tomo.local_cft_params(\n                    i=i,\n                    depth=depth,\n                    binsize=bin_size,\n                    radius=radius,\n                    update_glob=update_glob,\n                )\n                yield _local_cft_analysis_on_yield.with_args(i)\n            return tracker.as_undo_callback()\n\n    @set_design(text=\"Global CFT analysis\", location=_sw.AnalysisMenu)\n    @thread_worker.with_progress(desc=\"Global Cylindric Fourier transform\", total=_NSPLINES)  # fmt: skip\n    def global_cft_analysis(\n        self,\n        splines: SplinesType = None,\n        bin_size: Annotated[int, {\"choices\": _get_available_binsize}] = 1,\n    ):  # fmt: skip\n        \"\"\"Determine cylindrical global structural parameters by Fourier transformation.\n\n        Parameters\n        ----------\n        {splines}{bin_size}\n        \"\"\"\n        tomo = self.tomogram\n        splines = self._norm_splines(splines)\n\n        with SplineTracker(widget=self, indices=splines, sample=True) as tracker:\n            for i in splines:\n                spl = tomo.splines[i]\n                if spl.radius is None:\n                    tomo.measure_radius(i=i)\n                tomo.global_cft_params(i=i, binsize=bin_size)\n                yield\n\n            # show all in a table\n            @thread_worker.callback\n            def _global_cft_analysis_on_return():\n                df = (\n                    pl.concat(\n                        [tomo.splines[i].props.glob for i in splines],\n                        how=\"vertical_relaxed\",\n                    )\n                    .to_pandas()\n                    .transpose()\n                )\n                df.columns = [f\"Spline-{i}\" for i in range(len(df.columns))]\n                self.sample_subtomograms()\n                _Logger.print_table(df, precision=3)\n                self._update_global_properties_in_widget()\n\n                return tracker.as_undo_callback()\n\n        return _global_cft_analysis_on_return\n\n    def _get_reanalysis_macro(self, path: Path):\n        \"\"\"Get the macro expression for reanalysis in the given project path.\"\"\"\n        _ui_sym = mk.symbol(self)\n        project = CylindraProject.from_file(path)\n        with project.open_project() as _dir:\n            macro_path = _dir / \"script.py\"\n            macro_expr = extract(macro_path.read_text())\n        return _filter_macro_for_reanalysis(macro_expr, _ui_sym)\n\n    @set_design(text=\"Re-analyze current tomogram\", location=_sw.AnalysisMenu)\n    @do_not_record\n    def reanalyze_image(self):\n        \"\"\"Reanalyze the current tomogram.\n\n        This method will extract the first manual operations from current session.\n        \"\"\"\n        _ui_sym = mk.symbol(self)\n        macro_expr = self._format_macro()[self._macro_image_load_offset :]\n        macro = _filter_macro_for_reanalysis(macro_expr, _ui_sym)\n        self.clear_all()\n        mk.Expr(mk.Head.block, macro.args[1:]).eval({_ui_sym: self})\n        return self.macro.clear_undo_stack()\n\n    @set_design(text=\"Re-analyze with new config\", location=_sw.AnalysisMenu)\n    @do_not_record\n    def reanalyze_image_config_updated(self):\n        \"\"\"Reanalyze the current tomogram with newly set default spline config.\n\n        This method is useful when you have mistakenly drawn splines with wrong spline\n        config.\n        \"\"\"\n        _ui_sym = mk.symbol(self)\n        macro_expr = self._format_macro()[self._macro_image_load_offset :]\n        macro = _filter_macro_for_reanalysis(macro_expr, _ui_sym)\n        macro = _remove_config_kwargs(macro)\n        self.clear_all()\n        mk.Expr(mk.Head.block, macro.args[1:]).eval({_ui_sym: self})\n        return self.macro.clear_undo_stack()\n\n    @set_design(text=\"Re-analyze project\", location=_sw.AnalysisMenu)\n    @do_not_record\n    @bind_key(\"Ctrl+K, Ctrl+L\")\n    def load_project_for_reanalysis(self, path: Path.Read[FileFilter.PROJECT]):\n        \"\"\"Load a project file to re-analyze the data.\n\n        This method will extract the first manual operations from a project file and\n        run them. This is useful when you want to re-analyze the data with a different\n        parameter set, or when there were some improvements in cylindra.\n        \"\"\"\n        macro = self._get_reanalysis_macro(path)\n        macro.eval({mk.symbol(self): self})\n        return self.macro.clear_undo_stack()\n\n    @set_design(text=capitalize, location=_sw.AnalysisMenu.Interaction)\n    def construct_molecule_interaction(\n        self,\n        origin_molecules: MoleculesLayerType,\n        target_molecules: MoleculesLayerType,\n        dist_range: Annotated[tuple[nm, nm], {\"label\": \"distance between (nm)\", \"options\": {\"min\": 0.0, \"step\": 0.01}}] = (0.2, 10.0),\n        layer_name: str = \"Interactions\",\n        standard_features: bool = True,\n    ):  # fmt: skip\n        \"\"\"Construct all the possible inter-molecule interaction network.\n\n        All the possible interactions between the origin and target molecule layers will\n        be added. Alternatively, you can set both origin and target layers to the same\n        layer to get the self-interaction.\n\n        Parameters\n        ----------\n        origin_molecules : MoleculesLayer\n            The layer of origin molecules. Interactions are defined by origin-&gt;target.\n        target_molecules : MoleculesLayer\n            The layer of target molecules. Interactions are defined by origin-&gt;target.\n        dist_range : tuple of float, default (0.2, 10.0)\n            The range of distance to consider for the interaction. Note that wide\n            distance range may cause a very dense interaction map.\n        layer_name : str, default \"Interactions\"\n            Name of the returned layer.\n        standard_features : bool, default True\n            If True, add standard features to the interaction network.\n        \"\"\"\n        origin_molecules = assert_layer(origin_molecules, self.parent_viewer)\n        target_molecules = assert_layer(target_molecules, self.parent_viewer)\n        net = InterMoleculeNet.from_molecules(\n            origin_molecules.molecules,\n            target_molecules.molecules,\n            min_distance=dist_range[0],\n            max_distance=dist_range[1],\n        )\n        if standard_features:\n            net = net.with_standard_features()\n        layer = InteractionVector(net, name=layer_name)\n        _Logger.print(f\"{net.count()} interactions constructed.\")\n        return self._undo_callback_for_layer(self.parent_viewer.add_layer(layer))\n\n    @set_design(text=capitalize, location=_sw.AnalysisMenu.Interaction)\n    def construct_closest_molecule_interaction(\n        self,\n        origin_molecules: MoleculesLayerType,\n        target_molecules: MoleculesLayerType,\n        layer_name: str = \"Interaction\",\n        standard_features: bool = True,\n    ):\n        \"\"\"Construct the closest inter-molecule interaction network.\"\"\"\n        origin_molecules = assert_layer(origin_molecules, self.parent_viewer)\n        target_molecules = assert_layer(target_molecules, self.parent_viewer)\n        net = InterMoleculeNet.from_molecules_closest(\n            origin_molecules.molecules, target_molecules.molecules\n        )\n        if standard_features:\n            net = net.with_standard_features()\n        layer = InteractionVector(net, name=layer_name)\n        _Logger.print(f\"{net.count()} interactions constructed.\")\n        return self._undo_callback_for_layer(self.parent_viewer.add_layer(layer))\n\n    @set_design(text=capitalize, location=_sw.AnalysisMenu.Interaction)\n    def filter_molecule_interaction(\n        self,\n        interaction: _InteractionNetType,\n        predicate: PolarsExprStr,\n    ):\n        \"\"\"Filter the interaction network by the feature.\n\n        Parameters\n        ----------\n        interaction : InteractionVector\n            The layer of interaction network.\n        predicate : ExprStr\n            A polars-style filter predicate, such as `col(\"projection-origin-x\") &gt; 0`.\n        \"\"\"\n        layer = assert_interaction_vectors(interaction, self.parent_viewer)\n        out_net = layer.net.filter(widget_utils.norm_expr(predicate))\n        new_layer = InteractionVector(out_net, name=f\"{layer.name}-Filt\")\n        _Logger.print(f\"{out_net.count()} interactions left after filtering.\")\n        _Logger.print_html(f\"{layer.name} &amp;#8594; {new_layer.name}\")\n        return self._undo_callback_for_layer(self.parent_viewer.add_layer(new_layer))\n\n    @set_design(text=capitalize, location=_sw.AnalysisMenu.Interaction)\n    def interaction_to_molecules(\n        self,\n        interaction: _InteractionNetType,\n        which: Literal[\"origin\", \"target\", \"both\"] = \"origin\",\n    ):\n        \"\"\"Make a molecules layer from the interaction network.\n\n        Parameters\n        ----------\n        interaction : InteractionVector\n            The layer of interaction network.\n        which : \"origin\", \"target\" or \"both\", optional\n            Specify which molecules will be added.\n        \"\"\"\n        layer = assert_interaction_vectors(interaction, self.parent_viewer)\n        m0 = layer.net.molecules_origin.subset(layer.net.indices_origin)\n        m1 = layer.net.molecules_target.subset(layer.net.indices_target)\n        match which:\n            case \"origin\":\n                mole = m0\n            case \"target\":\n                mole = m1\n            case \"both\":\n                mole = m0.concat_with(m1)\n            case _:  # pragma: no cover\n                raise ValueError(f\"Unknown option: {which!r}.\")\n        return self.add_molecules(mole, name=f\"{which} of {layer.name}\")\n\n    @set_design(text=capitalize, location=_sw.AnalysisMenu.Interaction)\n    def label_molecules_by_interaction(\n        self,\n        layer: MoleculesLayerType,\n        interaction: _InteractionNetType,\n        column_name: str = \"interacting\",\n        label_id: Annotated[int, {\"min\": 1}] = 1,\n    ):\n        \"\"\"Label molecules by the interaction network.\n\n        Parameters\n        ----------\n        layer : MoleculesLayer\n            The layer of molecules to be labeled.\n        interaction : InteractionVector\n            The layer of interaction network.\n        column_name : str, default \"interacting\"\n            Name of the new feature column.\n        label_id : int, default 1\n            The label ID to be assigned to the interacting molecules.\n        \"\"\"\n        layer = assert_layer(layer, self.parent_viewer)\n        net = assert_interaction_vectors(interaction, self.parent_viewer).net\n        if net.molecules_origin is layer.molecules:\n            indices = net.indices_origin\n        elif net.molecules_target is layer.molecules:\n            indices = net.indices_target\n        else:\n            raise ValueError(\n                \"Neither origin nor target of the interaction are the molecules from \"\n                \"the molecules layer. Two layers must share the reference to the same \"\n                \"molecules.\"\n            )\n        feat = layer.molecules.features\n        if column_name in feat:\n            new_column = feat[column_name].to_numpy()\n        else:\n            new_column = np.zeros(len(layer.molecules), dtype=np.uint8)\n        new_column[indices] = label_id\n        new_feat = pl.Series(column_name, new_column)\n        layer.molecules = layer.molecules.with_features(new_feat)\n        self.reset_choices()  # choices regarding of features need update\n        return undo_callback(layer.feature_setter(feat))\n\n    # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #\n    #   Monomer mapping methods\n    # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #\n\n    @set_design(text=capitalize, location=_sw.MoleculesMenu.FromToSpline)\n    @bind_key(\"M\")\n    @thread_worker.with_progress(desc=\"Mapping monomers\", total=_NSPLINES)\n    def map_monomers(\n        self,\n        splines: SplinesType = None,\n        orientation: Literal[None, \"PlusToMinus\", \"MinusToPlus\"] = None,\n        offsets: _OffsetType = None,\n        radius: Optional[nm] = None,\n        extensions: Annotated[tuple[int, int], {\"options\": {\"min\": -100}}] = (0, 0),\n        prefix: str = \"Mole\",\n    ):  # fmt: skip\n        \"\"\"Map monomers as a regular cylindric grid assembly.\n\n        This method uses the spline global properties.\n\n        Parameters\n        ----------\n        {splines}{orientation}{offsets}\n        radius : nm, optional\n            Radius of the cylinder to position monomers.\n        extensions : (int, int), default (0, 0)\n            Number of molecules to extend. Should be a tuple of (prepend, append).\n            Negative values will remove molecules.\n        {prefix}\n        \"\"\"\n        tomo = self.tomogram\n\n        _Logger.print_html(\"&lt;code&gt;map_monomers&lt;/code&gt;\")\n        _added_layers = list[MoleculesLayer]()\n\n        @thread_worker.callback\n        def _add_molecules(mol: Molecules, name: str, spl: CylSpline):\n            layer = self.add_molecules(mol, name, source=spl)\n            _added_layers.append(layer)\n            _Logger.print(f\"{name!r}: n = {len(mol)}\")\n\n        for i in self._norm_splines(splines):\n            spl = tomo.splines[i]\n            mol = tomo.map_monomers(\n                i=i,\n                orientation=orientation,\n                offsets=normalize_offsets(offsets, spl),\n                radius=normalize_radius(radius, spl),\n                extensions=extensions,\n            )\n\n            cb = _add_molecules.with_args(mol, f\"{prefix}-{i}\", spl)\n            yield cb\n            cb.await_call()\n\n        return self._undo_callback_for_layer(_added_layers)\n\n    @set_design(text=capitalize, location=_sw.MoleculesMenu.FromToSpline)\n    def map_monomers_with_extensions(\n        self,\n        spline: Annotated[int, {\"choices\": _get_splines}],\n        n_extend: Annotated[dict[int, tuple[int, int]], {\"label\": \"prepend/append\", \"widget_type\": ProtofilamentEdit}] = {},\n        orientation: Literal[None, \"PlusToMinus\", \"MinusToPlus\"] = None,\n        offsets: _OffsetType = None,\n        radius: Optional[nm] = None,\n        prefix: str = \"Mole\",\n    ):  # fmt: skip\n        \"\"\"Map monomers as a regular cylindric grid assembly.\n\n        This method uses the spline global properties.\n\n        Parameters\n        ----------\n        {spline}\n        n_extend : dict[int, (int, int)]\n            Number of molecules to extend. Should be mapping from the PF index to the (prepend,\n            append) number of molecules to add. Remove molecules if negative values are given.\n        {orientation}{offsets}\n        radius : nm, optional\n            Radius of the cylinder to position monomers.\n        {prefix}\n        \"\"\"\n        tomo = self.tomogram\n        spl = tomo.splines[spline]\n        coords = widget_utils.coordinates_with_extensions(spl, n_extend)\n        mole = tomo.map_on_grid(\n            i=spline,\n            coords=coords,\n            orientation=orientation,\n            offsets=normalize_offsets(offsets, spl),\n            radius=normalize_radius(radius, spl),\n        )\n        layer = self.add_molecules(mole, f\"{prefix}-{spline}\", source=spl)\n        return self._undo_callback_for_layer(layer)\n\n    @set_design(text=capitalize, location=_sw.MoleculesMenu.FromToSpline)\n    def map_along_spline(\n        self,\n        splines: SplinesType = None,\n        molecule_interval: PolarsExprStrOrScalar = \"col('spacing')\",\n        orientation: Literal[None, \"PlusToMinus\", \"MinusToPlus\"] = None,\n        rotate_molecules: bool = True,\n        prefix: str = \"Center\",\n    ):  # fmt: skip\n        \"\"\"Map molecules along splines. Each molecule is rotated by skewing.\n\n        Parameters\n        ----------\n        {splines}{molecule_interval}{orientation}\n        rotate_molecules : bool, default True\n            If True, rotate molecules by the \"twist\" parameter of each spline.\n        {prefix}\n        \"\"\"\n        tomo = self.tomogram\n        interv_expr = widget_utils.norm_scalar_expr(molecule_interval)\n        splines = self._norm_splines(splines)\n        _Logger.print_html(\"&lt;code&gt;map_along_spline&lt;/code&gt;\")\n        _added_layers = list[MoleculesLayer]()\n        for idx in splines:\n            spl = tomo.splines[idx]\n            interv = spl.props.get_glob(interv_expr)\n            mole = tomo.map_centers(\n                i=idx,\n                interval=interv,\n                orientation=orientation,\n                rotate_molecules=rotate_molecules,\n            )\n            _name = f\"{prefix}-{idx}\"\n            layer = self.add_molecules(mole, _name, source=spl)\n            _added_layers.append(layer)\n            _Logger.print(f\"{_name!r}: n = {mole.count()}\")\n        return self._undo_callback_for_layer(_added_layers)\n\n    @set_design(\n        text=\"Map along spline (helical symmetry)\",\n        location=_sw.MoleculesMenu.FromToSpline,\n    )\n    def map_along_spline_helical_symmetry(\n        self,\n        splines: SplinesType = None,\n        orientation: Literal[None, \"PlusToMinus\", \"MinusToPlus\"] = None,\n        prefix: str = \"Center\",\n    ):\n        \"\"\"Map molecules along splines considering helical symmetry.\n\n        This method is mainly used for subtomogram averaging of a structure with helical\n        symmetry. For example, if the cylindrical structure is a 14_3 microtubule, this\n        method will map molecules at 4 nm / 14 interval with proper rotations.\n\n        Parameters\n        ----------\n        {splines}{orientation}{prefix}\n        \"\"\"\n        tomo = self.tomogram\n        splines = self._norm_splines(splines)\n        _Logger.print_html(\"&lt;code&gt;map_along_spline_helical_symmetry&lt;/code&gt;\")\n        _added_layers = list[MoleculesLayer]()\n        for idx in splines:\n            spl = tomo.splines[idx]\n            mole = tomo.map_centers_helical_symmetry(i=idx, orientation=orientation)\n            _name = f\"{prefix}-{idx}\"\n            layer = self.add_molecules(mole, _name, source=spl)\n            _added_layers.append(layer)\n            _Logger.print(f\"{_name!r}: n = {mole.count()}\")\n        return self._undo_callback_for_layer(_added_layers)\n\n    @set_design(text=\"Map alogn PF\", location=_sw.MoleculesMenu.FromToSpline)\n    def map_along_pf(\n        self,\n        spline: Annotated[int, {\"choices\": _get_splines}],\n        molecule_interval: PolarsExprStrOrScalar = \"col('spacing')\",\n        offsets: _OffsetType = None,\n        orientation: Literal[None, \"PlusToMinus\", \"MinusToPlus\"] = None,\n        prefix: str = \"PF\",\n    ):  # fmt: skip\n        \"\"\"Map molecules along the line of a protofilament.\n\n        Parameters\n        ----------\n        {spline}{molecule_interval}{offsets}{orientation}{prefix}\n        \"\"\"\n        tomo = self.tomogram\n        interv_expr = widget_utils.norm_scalar_expr(molecule_interval)\n        spl = tomo.splines[spline]\n        _Logger.print_html(\"&lt;code&gt;map_along_PF&lt;/code&gt;\")\n        mol = tomo.map_pf_line(\n            i=spline,\n            interval=spl.props.get_glob(interv_expr),\n            offsets=normalize_offsets(offsets, spl),\n            orientation=orientation,\n        )\n        _name = f\"{prefix}-{spline}\"\n        layer = self.add_molecules(mol, _name, source=spl)\n        _Logger.print(f\"{_name!r}: n = {len(mol)}\")\n        return self._undo_callback_for_layer(layer)\n\n    @set_design(text=capitalize, location=_sw.MoleculesMenu.FromToSpline)\n    def set_source_spline(\n        self,\n        layer: MoleculesLayerType,\n        spline: Annotated[int, {\"choices\": _get_splines}],\n    ):\n        \"\"\"Set source spline for a molecules layer.\n\n        Parameters\n        ----------\n        {layer}{spline}\n        \"\"\"\n        layer = assert_layer(layer, self.parent_viewer)\n        old_spl = layer.source_component\n        layer.source_component = self.tomogram.splines[spline]\n\n        @undo_callback\n        def _undo():\n            layer.source_component = old_spl\n\n        return _undo\n\n    @set_design(text=capitalize, location=_sw.MoleculesMenu.Combine)\n    def concatenate_molecules(\n        self,\n        layers: MoleculesLayersType,\n        name: str = \"Mole-concat\",\n    ):  # fmt: skip\n        \"\"\"Concatenate selected molecules and create a new ones.\n\n        Parameters\n        ----------\n        {layers}\n        name : str, default \"Mole-concat\"\n            Name of the new molecules layer.\n        \"\"\"\n        layers = assert_list_of_layers(layers, self.parent_viewer)\n        all_molecules = Molecules.concat([layer.molecules for layer in layers])\n        points = add_molecules(self.parent_viewer, all_molecules, name=name)\n\n        # logging\n        layer_names = list[str]()\n        for layer in layers:\n            layer.visible = False\n            layer_names.append(layer.name)\n\n        _Logger.print_html(\"&lt;code&gt;concatenate_molecules&lt;/code&gt;\")\n        _Logger.print(\"Concatenated:\", \", \".join(layer_names))\n        _Logger.print(f\"{points.name!r}: n = {len(all_molecules)}\")\n        return self._undo_callback_for_layer(points)\n\n    @set_design(text=capitalize, location=_sw.MoleculesMenu.Combine)\n    def merge_molecule_info(\n        self,\n        pos: MoleculesLayerType,\n        rotation: MoleculesLayerType,\n        features: MoleculesLayerType,\n    ):\n        \"\"\"Merge molecule info from different molecules.\n\n        Parameters\n        ----------\n        pos : MoleculesLayer\n            Molecules whose positions are used.\n        rotation : MoleculesLayer\n            Molecules whose rotations are used.\n        features : MoleculesLayer\n            Molecules whose features are used.\n        \"\"\"\n        pos = assert_layer(pos, self.parent_viewer)\n        rotation = assert_layer(rotation, self.parent_viewer)\n        features = assert_layer(features, self.parent_viewer)\n        _pos = pos.molecules\n        _rot = rotation.molecules\n        _feat = features.molecules\n        mole = Molecules(_pos.pos, _rot.rotator, features=_feat.features)\n        layer = self.add_molecules(\n            mole, name=\"Mole-merged\", source=pos.source_component\n        )\n        return self._undo_callback_for_layer(layer)\n\n    @set_design(text=capitalize, location=_sw.MoleculesMenu.Combine)\n    def copy_molecules_features(\n        self,\n        source: MoleculesLayerType,\n        destinations: MoleculesLayersType,\n        column: Annotated[str, {\"choices\": _choice_getter(\"copy_molecules_features\")}],\n        alias: str = \"\",\n    ):  # fmt: skip\n        \"\"\"\n        Copy molecules features from one layer to another.\n\n        This method is useful when a layer feature (such as seam search result) should be\n        shared by multiple molecules layers that were aligned in a different parameters.\n\n        Parameters\n        ----------\n        source : MoleculesLayer\n            Layer whose features will be copied.\n        destinations : MoleculesLayersType\n            To which layers the features should be copied.\n        column : str\n            Column name of the feature to be copied.\n        alias : str, optional\n            If given, the copied feature will be renamed to this name.\n        \"\"\"\n        source = assert_layer(source, self.parent_viewer)\n        destinations = assert_list_of_layers(destinations, self.parent_viewer)\n        series = source.molecules.features[column]\n        if alias:\n            series = series.alias(alias)\n        for dest in destinations:\n            dest.molecules = dest.molecules.with_features([series])\n        return None\n\n    @set_design(text=\"Split molecules by feature\", location=_sw.MoleculesMenu)\n    def split_molecules(\n        self,\n        layer: MoleculesLayerType,\n        by: Annotated[str, {\"choices\": _choice_getter(\"split_molecules\")}],\n    ):\n        \"\"\"Split molecules by a feature column.\n\n        Parameters\n        ----------\n        {layer}\n        by : str\n            Name of the feature to split by.\n        \"\"\"\n        layer = assert_layer(layer, self.parent_viewer)\n        utils.assert_column_exists(layer.molecules.features, by)\n        _added_layers = list[MoleculesLayer]()\n        for _key, mole in layer.molecules.groupby(by):\n            new = self.add_molecules(\n                mole, name=f\"{layer.name}_{_key}\", source=layer.source_component\n            )\n            _added_layers.append(new)\n        return self._undo_callback_for_layer(_added_layers)\n\n    @set_design(text=capitalize, location=_sw.MoleculesMenu)\n    def register_molecules(\n        self,\n        coords: Annotated[np.ndarray, {\"validator\": _get_spline_coordinates}] = None,\n    ):\n        \"\"\"Register manually added points as molecules.\"\"\"\n        if coords is None or coords.size == 0:\n            raise ValueError(\"No points are given.\")\n        mole = Molecules(coords)\n        layer = self.add_molecules(mole, name=\"Mole-manual\")\n        self._reserved_layers.work.data = []\n        return self._undo_callback_for_layer(layer)\n\n    @set_design(text=capitalize, location=_sw.MoleculesMenu)\n    def translate_molecules(\n        self,\n        layers: MoleculesLayersType,\n        translation: Annotated[tuple[nm, nm, nm], {\"options\": {\"min\": -1000, \"max\": 1000, \"step\": 0.1}, \"label\": \"translation Z, Y, X (nm)\"}],\n        internal: bool = True,\n        inherit_source: Annotated[bool, {\"label\": \"Inherit source spline\"}] = True,\n    ):  # fmt: skip\n        \"\"\"Translate molecule coordinates without changing their rotations.\n\n        Output molecules layer will be named as \"&lt;original name&gt;-Shift\".\n\n        Parameters\n        ----------\n        {layers}\n        translation : tuple of float\n            Translation (nm) of the molecules in (Z, Y, X) order. Whether the world\n            coordinate or the internal coordinate is used depends on the `internal`\n            argument.\n        internal : bool, default True\n            If true, the translation is applied to the internal coordinates, i.e.\n            molecules with different rotations are translated differently.\n        {inherit_source}\n        \"\"\"\n        layers = assert_list_of_layers(layers, self.parent_viewer)\n        new_layers = list[MoleculesLayer]()\n        for layer in layers:\n            mole = layer.molecules\n            if internal:\n                out = mole.translate_internal(translation)\n                if Mole.position in out.features.columns:\n                    # update spline position feature\n                    dy = translation[1]\n                    out = out.with_features([pl.col(Mole.position) + dy])\n            else:\n                out = mole.translate(translation)\n                if Mole.position in out.features.columns:\n                    # spline position is not predictable.\n                    out = out.drop_features([Mole.position])\n            source = layer.source_component if inherit_source else None\n            new = self.add_molecules(out, name=f\"{layer.name}-Shift\", source=source)\n            new_layers.append(new)\n            _Logger.print_html(f\"{layer.name!r} &amp;#8594; {new.name!r}\")\n        return self._undo_callback_for_layer(new_layers)\n\n    @set_design(text=capitalize, location=_sw.MoleculesMenu)\n    def rotate_molecules(\n        self,\n        layers: MoleculesLayersType,\n        degrees: Annotated[\n            list[tuple[Literal[\"z\", \"y\", \"x\"], float]],\n            {\"layout\": \"vertical\", \"options\": {\"widget_type\": SingleRotationEdit}},\n        ],\n        inherit_source: Annotated[bool, {\"label\": \"Inherit source spline\"}] = True,\n    ):\n        \"\"\"Rotate molecules without changing their positions.\n\n        Output molecules layer will be named as \"&lt;original name&gt;-Rot\".\n\n        Parameters\n        ----------\n        {layers}\n        degrees : list of (str, float)\n            Rotation axes and degrees. For example, `[(\"z\", 20), (\"y\", -10)]` means\n            rotation by 20 degrees around the molecule Z axis and then by -10 degrees\n            around the Y axis.\n        {inherit_source}\n        \"\"\"\n        layers = assert_list_of_layers(layers, self.parent_viewer)\n        new_layers = list[MoleculesLayer]()\n        rotvec = degrees_to_rotator(degrees).as_rotvec()\n        for layer in layers:\n            mole = layer.molecules.rotate_by_rotvec_internal(rotvec)\n            source = layer.source_component if inherit_source else None\n            new = self.add_molecules(mole, name=f\"{layer.name}-Rot\", source=source)\n            new_layers.append(new)\n            _Logger.print_html(f\"{layer.name!r} &amp;#8594; {new.name!r}\")\n        return self._undo_callback_for_layer(new_layers)\n\n    @set_design(text=capitalize, location=_sw.MoleculesMenu)\n    def rotate_molecule_toward_spline(\n        self,\n        layer: MoleculesLayerType,\n        spline: Annotated[int, {\"choices\": _get_splines}],\n        inherit_source: Annotated[bool, {\"label\": \"Inherit source spline\"}] = True,\n        orientation: Literal[None, \"PlusToMinus\", \"MinusToPlus\"] = None,\n    ):\n        \"\"\"Rotate molecules to align its orientation to the spline.\n\n        This method is useful to rotate picked binding proteins so that they faces to\n        the cylinder. Output molecules layer will be named as \"&lt;original name&gt;-Rot\".\n\n        Parameters\n        ----------\n        {layer}{spline}{inherit_source}{orientation}\n        \"\"\"\n        layer = assert_layer(layer, self.parent_viewer)\n        spl = self.tomogram.splines[spline]\n        mole_rot = align_molecules_to_spline(layer.molecules, spl)\n        if spl._need_rotation(orientation):\n            mole_rot = mole_rot.rotate_by_rotvec_internal([np.pi, 0, 0])\n        source = layer.source_component if inherit_source else None\n        new = self.add_molecules(mole_rot, name=f\"{layer.name}-Rot\", source=source)\n        return self._undo_callback_for_layer(new)\n\n    @set_design(text=\"Rename molecule layers\", location=_sw.MoleculesMenu)\n    @do_not_record(recursive=False)\n    def rename_molecules(\n        self,\n        old: str,\n        new: str,\n        include: str = \"\",\n        exclude: str = \"\",\n        pattern: str = \"\",\n    ):\n        \"\"\"Rename multiple molecules layers at once.\n\n        Parameters\n        ----------\n        old : str\n            Old string to be replaced.\n        new : str\n            New string to replace `old`.\n        include : str, optional\n            Delete layers whose names contain this string.\n        exclude : str, optional\n            Delete layers whose names do not contain this string.\n        pattern : str, optional\n            String pattern to match the layer names. Use `*` as wildcard.\n        \"\"\"\n        if old == \"\":\n            raise ValueError(\"`old` is not given.\")\n        if new == \"\":\n            raise ValueError(\"`new` is not given.\")\n        return self.mole_layers.rename(\n            old, new, include=include, exclude=exclude, pattern=pattern\n        )\n\n    @set_design(text=\"Delete molecule layers\", location=_sw.MoleculesMenu)\n    @do_not_record(recursive=False)\n    def delete_molecules(\n        self,\n        include: str = \"\",\n        exclude: str = \"\",\n        pattern: str = \"\",\n    ):\n        \"\"\"Delete molecules by the layer names.\n\n        Parameters\n        ----------\n        include : str, optional\n            Delete layers whose names contain this string.\n        exclude : str, optional\n            Delete layers whose names do not contain this string.\n        pattern : str, optional\n            String pattern to match the layer names. Use `*` as wildcard.\n        \"\"\"\n        self.mole_layers.delete(include=include, exclude=exclude, pattern=pattern)\n\n    @set_design(text=capitalize, location=_sw.MoleculesMenu)\n    def filter_molecules(\n        self,\n        layer: MoleculesLayerType,\n        predicate: PolarsExprStr,\n        inherit_source: Annotated[bool, {\"label\": \"Inherit source spline\"}] = True,\n    ):\n        \"\"\"Filter molecules by their features.\n\n        Parameters\n        ----------\n        {layer}\n        predicate : ExprStr\n            A polars-style filter predicate, such as `pl.col(\"pf-id\") == 3`\n        {inherit_source}\n        \"\"\"\n        layer = assert_layer(layer, self.parent_viewer)\n        mole = layer.molecules\n        out = mole.filter(widget_utils.norm_expr(predicate))\n        _Logger.print(f\"Filter molecules resulted in {out.count()} molecules.\")\n        source = layer.source_component if inherit_source else None\n        new = self.add_molecules(out, name=f\"{layer.name}-Filt\", source=source)\n        _Logger.print_html(f\"{layer.name!r} &amp;#8594; {new.name!r}\")\n        return self._undo_callback_for_layer(new)\n\n    @set_design(text=capitalize, location=_sw.MoleculesMenu)\n    def drop_molecules(\n        self,\n        layer: MoleculesLayerType,\n        indices: Annotated[str | Sequence[int | slice], {\"widget_type\": IndexEdit}] = \"\",\n        inherit_source: Annotated[bool, {\"label\": \"Inherit source spline\"}] = True,\n    ):  # fmt: skip\n        \"\"\"Drop a subset of molecules from a molecules layer by indices.\n\n        Note that the indices start from 0. `ui.drop_molecules(layer, [0, 2, 6])` will\n        drop 0th, 2nd, and 6th molecules.\n\n        Parameters\n        ----------\n        {layer}\n        indices : str, int, slice or sequence of int or slice, optional\n            A sequence of molecule indices to drop. You can use `npf` for the number\n            of protofilaments and `N` for the number of molecules. `slice` is also\n            allowed for dropping a range of indices. In GUI, this parameter must a\n            string of comma-separated integers/slices (e.g. `3, N - 3`,\n            `1, slice(12, 12 + npf)`).\n        {inherit_source}\n        \"\"\"\n        layer = assert_layer(layer, self.parent_viewer)\n        mole = layer.molecules\n        _to_drop = set[int]()\n        if isinstance(indices, str):\n            if spl := layer.source_spline:\n                npf = spl.props.get_glob(H.npf, None)\n            else:\n                npf = None\n            indices = IndexEdit.eval(indices, npf=npf, N=mole.count())\n        for i in indices:\n            if isinstance(i, slice):\n                _to_drop.update(range(*i.indices(mole.count())))\n            elif isinstance(i, int | np.integer):\n                _to_drop.add(int(i))\n            else:\n                raise ValueError(f\"Indices must be integers, got {type(i)!r}.\")\n        sl = np.array([i for i in range(mole.count()) if i not in _to_drop])\n        out = mole.subset(sl)\n        source = layer.source_component if inherit_source else None\n        new = self.add_molecules(out, name=f\"{layer.name}-Drop\", source=source)\n        return self._undo_callback_for_layer(new)\n\n    @set_design(text=capitalize, location=_sw.MoleculesMenu.View)\n    @bind_key(\"Ctrl+K, C\")\n    def paint_molecules(\n        self,\n        layer: MoleculesLayerType,\n        color_by: Annotated[str, {\"choices\": _choice_getter(\"paint_molecules\")}],\n        cmap: _CmapType = DEFAULT_COLORMAP,\n        limits: Annotated[tuple[float, float], {\"options\": {\"min\": -20, \"max\": 20, \"step\": 0.01}}] = (4.00, 4.24),\n    ):  # fmt: skip\n        \"\"\"Paint molecules by a feature.\n\n        Parameters\n        ----------\n        {layer}{color_by}{cmap}{limits}\n        \"\"\"\n        layer = assert_layer(layer, self.parent_viewer)\n        info = layer.colormap_info\n        layer.set_colormap(color_by, limits, cmap)\n\n        match info:\n            case str(color):\n                return undo_callback(layer.face_color_setter).with_args(color)\n            case info:\n                return undo_callback(layer.set_colormap).with_args(\n                    by=info.name, limits=info.clim, cmap=info.cmap\n                )\n\n    @set_design(text=capitalize, location=_sw.MoleculesMenu.Features)\n    @confirm(\n        text=\"Column already exists. Overwrite?\",\n        condition=\"column_name in layer.molecules.features.columns\",\n    )\n    def calculate_molecule_features(\n        self,\n        layer: MoleculesLayerType,\n        column_name: str,\n        expression: PolarsExprStr,\n    ):\n        \"\"\"Calculate a new feature from the existing features.\n\n        This method is identical to running `with_columns` on the features dataframe\n        as a `polars.DataFrame`. For example,\n        &gt;&gt;&gt; ui.calculate_molecule_features(layer, \"Y\", \"pl.col('X') + 1\")\n        is equivalent to\n        &gt;&gt;&gt; layer.features = layer.features.with_columns([(pl.col(\"X\") + 1).alias(\"Y\")])\n\n        Parameters\n        ----------\n        {layer}\n        column_name : str\n            Name of the new column.\n        expression : pl.Expr or str\n            polars expression to calculate the new column.\n        \"\"\"\n        layer = assert_layer(layer, self.parent_viewer)\n        feat = layer.molecules.features\n        expr = widget_utils.norm_expr(expression)\n        new_feat = feat.with_columns(expr.alias(column_name))\n        layer.features = new_feat\n        self.reset_choices()  # choices regarding to features need update\n        return undo_callback(layer.feature_setter(feat, layer.colormap_info))\n\n    @set_design(text=capitalize, location=_sw.MoleculesMenu.Features)\n    def interpolate_spline_properties(\n        self,\n        layer: MoleculesLayerType,\n        interpolation: int = 3,\n        suffix: str = \"_spl\",\n    ):\n        \"\"\"Add new features by interpolating spline local properties.\n\n        Parameters\n        ----------\n        {layer}{interpolation}\n        suffix : str, default \"_spl\"\n            Suffix of the new feature column names.\n        \"\"\"\n        layer = assert_layer(layer, self.parent_viewer)\n        spl = _assert_source_spline_exists(layer)\n        feat = layer.molecules.features\n        anc = spl.anchors\n        interp = utils.interp(\n            anc, spl.props.loc.to_numpy(), order=interpolation, axis=0\n        )\n        pos_nm = feat[Mole.position].to_numpy()\n        values = interp(spl.y_to_position(pos_nm).clip(anc.min(), anc.max()))\n        layer.molecules = layer.molecules.with_features(\n            [\n                pl.Series(f\"{c}{suffix}\", values[:, i])\n                for i, c in enumerate(spl.props.loc.columns)\n            ]\n        )\n        self.reset_choices()  # choices regarding of features need update\n        return undo_callback(layer.feature_setter(feat, layer.colormap_info))\n\n    @set_design(text=capitalize, location=_sw.MoleculesMenu.Features)\n    def calculate_lattice_structure(\n        self,\n        layer: MoleculesLayerType,\n        props: Annotated[list[str], {\"widget_type\": CheckBoxes, \"choices\": cylmeasure.LatticeParameters.choices()}] = (\"spacing\",),\n    ):  # fmt: skip\n        \"\"\"Calculate lattice structures and store the results as new feature columns.\n\n        Parameters\n        ----------\n        {layer}\n        props : list of str, optional\n            Properties to calculate.\n        \"\"\"\n        layer = assert_layer(layer, self.parent_viewer)\n        spl = _assert_source_spline_exists(layer)\n        mole = layer.molecules\n        feat = mole.features\n\n        def _calculate(p: str):\n            return cylmeasure.LatticeParameters(p).calculate(mole, spl)\n\n        layer.molecules = layer.molecules.with_features([_calculate(p) for p in props])\n        self.reset_choices()  # choices regarding of features need update\n        return undo_callback(layer.feature_setter(feat))\n\n    @set_design(text=capitalize, location=_sw.MoleculesMenu.Features)\n    def convolve_feature(\n        self,\n        layer: MoleculesLayerType,\n        target: Annotated[str, {\"choices\": _choice_getter(\"convolve_feature\", dtype_kind=\"uifb\")}],\n        method: Literal[\"mean\", \"max\", \"min\", \"median\"] = \"mean\",\n        footprint: Annotated[Any, {\"widget_type\": KernelEdit}] = [[0, 1, 0], [1, 1, 1], [0, 1, 0]],\n    ):  # fmt: skip\n        \"\"\"Run a convolution on the lattice.\n\n        The convolution is similar to that in the context of image analysis, except for\n        the cylindric boundary. During the convolution, the edges will not be considered,\n        i.e., NaN value will be ignored and convolution will be the convolution of valid\n        regions.\n\n        Parameters\n        ----------\n        {layer}\n        method : str\n            Convolution method.\n        {target}{footprint}\n        \"\"\"\n        from cylindra import cylfilters\n\n        layer = assert_layer(layer, self.parent_viewer)\n        utils.assert_column_exists(layer.molecules.features, target)\n        feat, cmap_info = layer.molecules.features, layer.colormap_info\n        nrise = _assert_source_spline_exists(layer).nrise()\n        out = cylfilters.run_filter(\n            layer.molecules.features, footprint, target, nrise, method\n        )\n        feature_name = f\"{target}_{method}\"\n        layer.molecules = layer.molecules.with_features(out.alias(feature_name))\n        self.reset_choices()\n        match layer.colormap_info:\n            case str(color):\n                layer.face_color = color\n            case info:\n                layer.set_colormap(feature_name, info.clim, info.cmap)\n        return undo_callback(layer.feature_setter(feat, cmap_info))\n\n    @set_design(text=capitalize, location=_sw.MoleculesMenu.Features)\n    def count_neighbors(\n        self,\n        layer: MoleculesLayerType,\n        footprint: Annotated[Any, {\"widget_type\": KernelEdit}] = [[0, 1, 0], [1, 0, 1], [0, 1, 0]],\n        column_name: str = \"neighbor_count\",\n    ):  # fmt: skip\n        \"\"\"Count the number of neighbors for each molecules.\n\n        Parameters\n        ----------\n        {layer}{footprint}\n        column_name : str\n            Name of the new column that stores the number of counts.\n        \"\"\"\n        from cylindra import cylfilters\n\n        layer = assert_layer(layer, self.parent_viewer)\n        feat, cmap_info = layer.molecules.features, layer.colormap_info\n        nrise = _assert_source_spline_exists(layer).nrise()\n        out = cylfilters.count_neighbors(layer.molecules.features, footprint, nrise)\n        layer.molecules = layer.molecules.with_features(out.alias(column_name))\n        self.reset_choices()\n        return undo_callback(layer.feature_setter(feat, cmap_info))\n\n    @set_design(text=capitalize, location=_sw.MoleculesMenu.Features)\n    def distance_from_spline(\n        self,\n        layer: MoleculesLayerType,\n        spline: Annotated[int, {\"choices\": _get_splines}],\n        column_name: str = \"distance\",\n        interval: nm = 1.0,\n        extrapolation: tuple[nm, nm] = (0.0, 0.0),\n    ):\n        \"\"\"Add a new column that stores the shortest distance from the given spline.\n\n        Parameters\n        ----------\n        {layer}{spline}\n        column_name : str, default \"distance\"\n            Name of the new column.\n        interval: nm, default 1.0\n            Sampling interval along the spline. Note that small value will increase the\n            memory usage and computation time.\n        extrapolation : tuple of float, default (0.0, 0.0)\n            Extrapolation distance at the start and end of the spline.\n        \"\"\"\n        spl = self.tomogram.splines[spline]\n        layer = assert_layer(layer, self.parent_viewer)\n        ext_0, ext_1 = extrapolation\n        if interval &lt;= 0:\n            raise ValueError(\"`interval` must be positive.\")\n        feat, cmap_info = layer.molecules.features, layer.colormap_info\n        length = spl.length()\n        npartitions = utils.ceilint((length + ext_0 + ext_1) / interval)\n        sample_points = spl.map(\n            np.linspace(-ext_0 / length, 1 + ext_1 / length, npartitions)\n        )\n        dist = utils.distance_matrix(layer.molecules.pos, sample_points)\n        dist_min = pl.Series(column_name, np.min(dist, axis=1))\n        layer.molecules = layer.molecules.with_features(dist_min)\n        self.reset_choices()  # choices regarding of features need update\n        return undo_callback(layer.feature_setter(feat, cmap_info))\n\n    @set_design(text=capitalize, location=_sw.MoleculesMenu.Features)\n    def distance_from_closest_molecule(\n        self,\n        layer: MoleculesLayerType,\n        other_layers: MoleculesLayersType,\n        column_name: str = \"distance\",\n    ):\n        \"\"\"Add a new column that stores the distance from the closest molecule.\n\n        Parameters\n        ----------\n        {layer}\n        column_name : str, default \"distance\"\n            Name of the new column.\n        \"\"\"\n        layer = assert_layer(layer, self.parent_viewer)\n        other_layers = assert_list_of_layers(other_layers, self.parent_viewer)\n        feat, cmap_info = layer.molecules.features, layer.colormap_info\n        other_moles = Molecules.concat([l.molecules for l in other_layers])\n        net = InterMoleculeNet.from_molecules_closest(layer.molecules, other_moles)\n        dist = net.distances()\n        layer.molecules = layer.molecules.with_features(pl.Series(column_name, dist))\n        self.reset_choices()  # choices regarding of features need update\n        return undo_callback(layer.feature_setter(feat, cmap_info))\n\n    @set_design(text=capitalize, location=_sw.MoleculesMenu.Features)\n    def binarize_feature(\n        self,\n        layer: MoleculesLayerType,\n        target: Annotated[str, {\"choices\": _choice_getter(\"binarize_feature\", dtype_kind=\"uif\")}],\n        threshold: Annotated[float, {\"widget_type\": \"FloatSlider\"}] = 0.0,\n        larger_true: bool = True,\n        suffix: str = \"_binarize\",\n    ):  # fmt: skip\n        \"\"\"Binarization of a layer feature by thresholding.\n\n        Parameters\n        ----------\n        {layer}{target}\n        threshold : float, optional\n            Threshold value used for binarization.\n        larger_true : bool, optional\n            If true, values larger than `threshold` will be True.\n        suffix : str, default \"_binarize\"\n            Suffix of the new feature column name.\n        \"\"\"\n        from cylindra import cylfilters\n\n        layer = assert_layer(layer, self.parent_viewer)\n        utils.assert_column_exists(layer.molecules.features, target)\n        if suffix == \"\":\n            raise ValueError(\"`suffix` cannot be empty.\")\n        feat, cmap_info = layer.molecules.features, layer.colormap_info\n        ser = cylfilters.binarize(layer.molecules.features, threshold, target)\n        if not larger_true:\n            ser = -ser\n        feature_name = f\"{target}{suffix}\"\n        layer.molecules = layer.molecules.with_features(\n            ser.alias(feature_name).cast(pl.Boolean)\n        )\n        self.reset_choices()\n        layer.set_colormap(feature_name, (0, 1), {0: \"#A5A5A5\", 1: \"#FF0000\"})\n        return undo_callback(layer.feature_setter(feat, cmap_info))\n\n    @set_design(text=capitalize, location=_sw.MoleculesMenu.Features)\n    def label_feature_clusters(\n        self,\n        layer: MoleculesLayerType,\n        target: Annotated[str, {\"choices\": _choice_getter(\"label_feature_clusters\", dtype_kind=\"b\")}],\n        suffix: str = \"_label\",\n    ):  # fmt: skip\n        \"\"\"Label a binarized feature column based on the molecules structure.\n\n        This method does the similar task as `scipy.ndimage.label`, where the isolated\n        \"islands\" of True values will be labeled by position integers.\n\n        Parameters\n        ----------\n        {layer}{target}\n        suffix : str, default \"_binarize\"\n            Suffix of the new feature column name.\n        \"\"\"\n        from napari.utils.colormaps import label_colormap\n\n        layer = assert_layer(layer, self.parent_viewer)\n        utils.assert_column_exists(layer.molecules.features, target)\n        if suffix == \"\":\n            raise ValueError(\"`suffix` cannot be empty.\")\n        feat, cmap_info = layer.molecules.features, layer.colormap_info\n        nrise = _assert_source_spline_exists(layer).nrise()\n        out = cylfilters.label(layer.molecules.features, target, nrise)\n        feature_name = f\"{target}{suffix}\"\n        layer.molecules = layer.molecules.with_features(out.alias(feature_name))\n        self.reset_choices()\n        label_max = int(out.max())\n        cmap = label_colormap(label_max, seed=0.9414)\n        layer.set_colormap(feature_name, (0, label_max), cmap)\n        self.reset_choices()  # choices regarding of features need update\n        return undo_callback(layer.feature_setter(feat, cmap_info))\n\n    @set_design(text=\"Analyze region properties\", location=_sw.MoleculesMenu.Features)\n    def regionprops_features(\n        self,\n        layer: MoleculesLayerType,\n        target: Annotated[str, {\"choices\": _choice_getter(\"regionprops_features\", dtype_kind=\"uif\")}],\n        label: Annotated[str, {\"choices\": _choice_getter(\"regionprops_features\", dtype_kind=\"ui\")}],\n        properties: Annotated[list[str], {\"choices\": cylmeasure.RegionProfiler.CHOICES, \"widget_type\": CheckBoxes}] = (\"area\", \"mean\"),\n    ):  # fmt: skip\n        \"\"\"Analyze region properties using another feature column as the labels.\n\n        For instance, if the target data is [0, 1, 2, 3, 4] and the labels are [0, 1, 1, 2, 2],\n        the the property \"mean\" will be [1.5, 3.5]. For some properties such as \"length\" and\n        \"width\", the monomer connection will be considered.\n\n        Parameters\n        ----------\n        {layer}{target}\n        label: str\n            The feature name that will be used as the labels.\n        properties : list of str\n            Properties to calculate.\n        \"\"\"\n        from magicclass.ext.polars import DataFrameView\n\n        layer = assert_layer(layer, self.parent_viewer)\n        utils.assert_column_exists(\n            layer.molecules.features, [target, label, Mole.nth, Mole.pf]\n        )\n        spl = _assert_source_spline_exists(layer)\n        reg = cylmeasure.RegionProfiler.from_components(\n            layer.molecules, spl, target, label\n        )\n        df = reg.calculate(properties)\n        view = DataFrameView(value=df)\n        dock = self.parent_viewer.window.add_dock_widget(view, name=\"Region properties\")\n        dock.setFloating(True)\n        self.reset_choices()  # choices regarding of features need update\n        return undo_callback(dock.close).with_redo(dock.show)\n\n    @set_design(text=\"Update pixel scale\", location=_sw.ImageMenu)\n    def update_scale(\n        self,\n        new_scale: Annotated[nm, {\"min\": 0.01, \"step\": 0.0001}] = 1.0,\n        drop_unsafe_props: bool = True,\n    ):\n        \"\"\"Update the scale of the tomogram and rescale all related components.\n\n        Parameters\n        ----------\n        new_scale : nm, default 1.0\n            New scale of the tomogram in nm/pixel.\n        drop_unsafe_props : bool, default True\n            If True, all the spline properties and molecule features that may be\n            affected by this operation will be dropped.\n        \"\"\"\n        if new_scale &lt;= 0:\n            raise ValueError(\"New scale must be greater than zero.\")\n        factor = new_scale / self.tomogram.scale\n        new_splines = [spl.rescale(factor) for spl in self.tomogram.splines]\n        new_splines: list[CylSpline] = []\n        # udpate spline scales\n        for spl in self.tomogram.splines:\n            new_spl = spl.rescale(factor)\n            if drop_unsafe_props:\n                new_spl.props.clear_loc()\n                new_spl.props.clear_glob()\n            new_splines.append(new_spl)\n        # update molecules, landscape and interaction layers\n        for layer in self.parent_viewer.layers:\n            if isinstance(layer, MoleculesLayer):\n                mole_new = rescale_molecules(layer.molecules, factor, drop_unsafe_props)\n                layer.molecules = mole_new\n            elif isinstance(layer, LandscapeSurface):\n                verts, faces, values = layer.data\n                layer.data = verts * factor, faces, values\n                layer.landscape = Landscape(\n                    energies=layer.landscape.energies,\n                    molecules=rescale_molecules(\n                        layer.landscape.molecules, factor, drop_unsafe_props\n                    ),\n                    argmax=layer.landscape.argmax,\n                    quaternions=layer.landscape.quaternions,\n                    scale_factor=layer.landscape.scale_factor * factor,\n                    num_templates=layer.landscape.num_templates,\n                )\n            elif isinstance(layer, InteractionVector):\n                layer.net = InterMoleculeNet(\n                    rescale_molecules(\n                        layer.net.molecules_origin, factor, drop_unsafe_props\n                    ),\n                    rescale_molecules(\n                        layer.net.molecules_target, factor, drop_unsafe_props\n                    ),\n                    layer.net.indices_origin,\n                    layer.net.indices_target,\n                    features=layer.net.features,\n                )\n        self.tomogram.splines.clear()\n        self.tomogram.splines.extend(new_splines)\n        self.tomogram.update_scale(new_scale)\n        self._reserved_layers.rescale_layers(factor)\n        self.GeneralInfo._refer_tomogram(self.tomogram)\n\n    # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #\n    #   Non-GUI methods\n    # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #\n\n    @nogui\n    @do_not_record\n    def add_molecules(\n        self,\n        molecules: Molecules,\n        name: \"str | None\" = None,\n        source: \"BaseComponent | None\" = None,\n        metadata: \"dict[str, Any]\" = {},\n        cmap=None,\n        **kwargs,\n    ) -&gt; MoleculesLayer:\n        \"\"\"Add molecules as a points layer to the viewer.\"\"\"\n        return add_molecules(\n            self.parent_viewer,\n            molecules,\n            name,\n            source=source,\n            metadata=metadata,\n            cmap=cmap,\n            **kwargs,\n        )\n\n    @nogui\n    @do_not_record\n    def get_loader(\n        self,\n        name: str,\n        output_shape: \"tuple[nm, nm, nm] | None\" = None,\n        order: int = 1,\n    ) -&gt; SubtomogramLoader:\n        \"\"\"Create a subtomogram loader using current tomogram and a molecules layer.\n\n        Parameters\n        ----------\n        name : str, optional\n            Name of the molecules layer.\n        order : int, default 1\n            Interpolation order of the subtomogram loader.\n        \"\"\"\n        mole = self.mole_layers[name].molecules\n        return self.tomogram.get_subtomogram_loader(mole, output_shape, order=order)\n\n    def _init_widget_state(self, _=None):\n        \"\"\"Initialize widget state of spline control and local properties for new plot.\"\"\"\n        self.SplineControl._init_widget()\n        self.LocalProperties._init_text()\n        self.LocalProperties._init_plot()\n\n    def _try_removing_layer(self, layer: Layer):\n        try:\n            self.parent_viewer.layers.remove(layer)\n        except ValueError as e:\n            _Logger.print(f\"ValueError: {e}\")\n\n    def _try_removing_layers(self, layers: \"Layer | list[Layer]\"):\n        if isinstance(layers, Layer):\n            layers = [layers]\n        for layer in layers:\n            self._try_removing_layer(layer)\n\n    def _add_layers_future(self, layers: \"Layer | list[Layer]\"):\n        def future_func():\n            nonlocal layers\n            if isinstance(layers, Layer):\n                layers = [layers]\n            with self._pend_reset_choices():\n                for layer in layers:\n                    self.parent_viewer.add_layer(layer)\n            self.reset_choices()\n\n        return future_func\n\n    def _undo_callback_for_layer(self, layer: \"Layer | list[Layer]\"):\n        return (\n            undo_callback(self._try_removing_layers)\n            .with_args(layer)\n            .with_redo(self._add_layers_future(layer))\n        )\n\n    @thread_worker.callback\n    def _reference_updated_callback(self, ref: np.ndarray):\n        contrast_limits = fast_percentile(ref, [1, 99.9])\n        self._reserved_layers.image.data = ref\n        self._reserved_layers.image.contrast_limits = contrast_limits\n        proj = self._reserved_layers.image.data.mean(axis=\"z\")\n        self.Overview.image = proj\n        self.Overview.contrast_limits = contrast_limits\n\n    @thread_worker.callback\n    def _send_tomogram_to_viewer(\n        self,\n        tomo: CylTomogram,\n        filt: \"ImageFilter | None\" = None,\n        invert: bool = False,\n    ):\n        viewer = self.parent_viewer\n        old_tomo = self._tomogram\n        self._tomogram = tomo\n        self.GeneralInfo._refer_tomogram(tomo)\n\n        bin_size = max(x[0] for x in tomo.multiscaled)\n        self._current_binsize = bin_size\n        imgb = tomo.get_multiscale(bin_size)\n        self._update_reference_image(imgb)\n        if old_tomo.metadata.get(\"cache_image\", False):\n            # delete old cache, because it will not be used anymore.\n            _config.uncache_tomogram(old_tomo.source)\n\n        # update viewer dimensions\n        viewer.scale_bar.unit = imgb.scale_unit\n        viewer.dims.axis_labels = (\"z\", \"y\", \"x\")\n        change_viewer_focus(viewer, np.asarray(imgb.shape) / 2, imgb.scale.x)\n\n        if fp := tomo._orig_or_read_path():\n            parts = fp.parts\n            if len(parts) &gt; 2:\n                _name = \"\u2026/\" + Path(*parts[-2:]).as_posix()\n            else:\n                _name = tomo.source.as_posix()\n        else:\n            _name = f\"Tomogram&lt;{hex(id(tomo))}&gt;\"\n        _Logger.print_html(\"&lt;hr&gt;\")\n        _Logger.print_html(f\"&lt;h2&gt;{_name}&lt;/h2&gt;\")\n\n        self.macro.clear_undo_stack()\n        self.Overview.layers.clear()\n        with self._pend_reset_choices():\n            self._init_widget_state()\n            self._init_layers()\n\n            # backward compatibility\n            if isinstance(filt, bool):\n                if filt:\n                    filt = ImageFilter.Lowpass\n                else:\n                    filt = None\n            if filt is not None and not isinstance(imgb, ip.LazyImgArray):\n                self.filter_reference_image(method=filt)\n            if invert:\n                self.invert_image()\n        self.reset_choices()\n        self.GeneralInfo.project_desc.value = \"\"  # clear the project description\n        self._need_save = False\n        self._macro_image_load_offset = len(self.macro)\n\n    def _update_reference_image(\n        self,\n        img: ip.ImgArray | ip.LazyImgArray,\n        bin_size: int | None = None,\n    ):\n        viewer = self.parent_viewer\n        if bin_size is None:\n            bin_size = img.scale.x / self.tomogram.scale\n        _is_lazy = isinstance(img, ip.LazyImgArray)\n        self._reserved_layers.is_lazy = _is_lazy\n        if _is_lazy:\n            img = ip.zeros(img.shape, dtype=np.int8, like=img)\n            img[0, [0, 0, 1, 1], [0, 1, 0, 1]] = 1\n            img[1, [0, 0, 1, 1], [0, 1, 0, 1]] = 1\n        tr = self.tomogram.multiscale_translation(bin_size)\n        # update image layer\n        if self._reserved_layers.image not in viewer.layers:\n            self._reserved_layers.reset_image(img, tr)\n            with self._pend_reset_choices():\n                viewer.add_layer(self._reserved_layers.image)\n        else:\n            self._reserved_layers.update_image(img, tr)\n        for _layer in [self._reserved_layers.highlight, self._reserved_layers.plane]:\n            if _layer in viewer.layers:\n                viewer.layers.remove(_layer)\n        self._reserved_layers.image.bounding_box.visible = _is_lazy\n\n        # update overview\n        if _is_lazy:\n            self.Overview.image = np.zeros((1, 1), dtype=np.float32)\n        else:\n            self.Overview.image = img.mean(axis=\"z\")\n        self.Overview.ylim = (0, img.shape[1])\n\n    def _on_layer_removing(self, event: \"Event\"):\n        # NOTE: To make recorded macro completely reproducible, removing molecules\n        # from the viewer layer list must always be monitored.\n        if self.parent_viewer is None:\n            return  # may happen during cleanup\n        layer: Layer = self.parent_viewer.layers[event.index]\n        if (\n            isinstance(layer, MoleculesLayer)\n            and self.macro.active\n            and layer.name != PREVIEW_LAYER_NAME  # ignore preview layer\n        ):\n            expr = mk.Mock(mk.symbol(self)).parent_viewer.layers[layer.name].expr\n            undo = self._add_layers_future(layer)\n            self.macro.append_with_undo(mk.Expr(\"del\", [expr]), undo)\n\n    def _on_molecules_layer_renamed(self, event: \"Event\"):\n        \"\"\"When layer name is renamed, record `ui.parent_viewer[\"old\"].name = \"new\"`\"\"\"\n        layer: MoleculesLayer = event.source\n        if layer._undo_renaming or not self.macro.active:\n            return\n        old_name = layer._old_name\n        new_name = layer.name\n        assert old_name is not None\n        viewer_ = mk.Mock(mk.symbol(self)).parent_viewer\n        expr = mk.Expr(mk.Head.assign, [viewer_.layers[old_name].name.expr, layer.name])\n        return self.macro.append_with_undo(\n            expr,\n            undo=lambda: layer._rename(old_name),\n            redo=lambda: layer._rename(new_name),\n        )\n\n    def _on_layer_inserted(self, event: \"Event\"):\n        layer: Layer = event.value\n        layer.events.name.connect(self.reset_choices)\n        if isinstance(layer, MoleculesLayer):\n            layer.events.name.connect(self._on_molecules_layer_renamed)\n\n    def _disconnect_layerlist_events(self):\n        viewer = self.parent_viewer\n        viewer.layers.events.removing.disconnect(self._on_layer_removing)\n        viewer.layers.events.inserted.disconnect(self._on_layer_inserted)\n\n    def _init_layers(self):\n        viewer = self.parent_viewer\n        self._disconnect_layerlist_events()\n\n        # remove all the molecules layers\n        _layers_to_remove = list[str]()\n        for layer in viewer.layers:\n            if isinstance(layer, MoleculesLayer | LandscapeSurface | InteractionVector):\n                _layers_to_remove.append(layer.name)\n            elif layer in (self._reserved_layers.prof, self._reserved_layers.work):\n                _layers_to_remove.append(layer.name)\n\n        with self._pend_reset_choices():\n            for name in _layers_to_remove:\n                layer: Layer = viewer.layers[name]\n                viewer.layers.remove(layer)\n\n            self._reserved_layers.init_layers()\n            for layer in self._reserved_layers.to_be_removed:\n                if layer in viewer.layers:\n                    viewer.layers.remove(layer)\n            viewer.add_layer(self._reserved_layers.prof)\n            viewer.add_layer(self._reserved_layers.work)\n        self.GlobalProperties._init_text()\n        self.reset_choices()\n\n        # Connect layer events.\n        viewer.layers.events.removing.connect(self._on_layer_removing)\n        viewer.layers.events.inserted.connect(self._on_layer_inserted)\n\n    @contextmanager\n    def _pend_reset_choices(self):\n        \"\"\"Temporarily disable the reset_choices method for better performance.\"\"\"\n        reset_choices = self.reset_choices\n        self.reset_choices = lambda *_: None\n        try:\n            yield\n        finally:\n            self.reset_choices = reset_choices\n\n    def _highlight_spline(self):\n        i = self.SplineControl.num\n        if i is None:\n            return\n\n        for layer in self.Overview.layers:\n            if f\"spline-{i}\" in layer.name:\n                layer.color = SplineColor.SELECTED\n            else:\n                layer.color = SplineColor.DEFAULT\n\n        self._reserved_layers.highlight_spline(i)\n\n    def _update_global_properties_in_widget(self):\n        \"\"\"Show global property values in widgets.\"\"\"\n        i = self.SplineControl.num\n        if i is None:\n            return\n        self.GlobalProperties._set_text(self.splines[i])\n\n    def _update_local_properties_in_widget(self, *, replot: bool = False):\n        i = self.SplineControl.num\n        tomo = self.tomogram\n        if i is None or i &gt;= len(tomo.splines):\n            return\n        j = self.SplineControl.pos\n        spl = tomo.splines[i]\n        if spl.props.has_loc([H.spacing, H.twist, H.npf, H.start]):\n            self.LocalProperties._set_text(spl, j)\n        else:\n            self.LocalProperties._init_plot()\n            self.LocalProperties._init_text()\n        if replot:\n            self.LocalProperties._plot_properties(spl)\n\n    def _add_spline_to_images(self, spl: CylSpline, i: int):\n        scale = self._reserved_layers.scale\n        fit = self._reserved_layers.add_spline(i, spl)\n        self.Overview.add_curve(\n            fit[:, 2] / scale,\n            fit[:, 1] / scale,\n            color=SplineColor.DEFAULT,\n            lw=2,\n            name=f\"spline-{i}\",\n            antialias=True,\n        )\n        self._set_orientation_marker(i)\n\n    def _set_orientation_marker(self, idx: int):\n        spl = self.tomogram.splines[idx]\n        return self._reserved_layers.set_orientation(idx, spl.orientation)\n\n    def _update_splines_in_images(self, _=None):\n        \"\"\"Refresh splines in overview canvas and napari canvas.\"\"\"\n        self.Overview.layers.clear()\n        self._reserved_layers.prof.data = []\n        scale = self._reserved_layers.scale\n        for i, spl in enumerate(self.tomogram.splines):\n            self._add_spline_to_images(spl, i)\n            if spl._anchors is None:\n                continue\n            coords = spl.map()\n            self.Overview.add_scatter(\n                coords[:, 2] / scale,\n                coords[:, 1] / scale,\n                color=SplineColor.DEFAULT,\n                symbol=\"x\",\n                lw=2,\n                size=10,\n                name=f\"spline-{i}-anc\",\n            )\n        self._highlight_spline()\n\n    def _refer_spline_config(self, cfg: SplineConfig):\n        \"\"\"Update GUI states that are related to global variables.\"\"\"\n        self.config_edit.Header.config_current.value = cfg\n        fgui = get_function_gui(self.set_spline_props)\n        fgui.npf.min, fgui.npf.max = cfg.npf_range.astuple()\n        fgui.npf.value = int(cfg.npf_range.center)\n        fgui.npf.value = None\n\n        # update GUI default values\n        fgui = get_function_gui(self.simulator.generate_molecules)\n        fgui.spacing.value = cfg.spacing_range.center\n        fgui.twist.value = cfg.twist_range.center\n        fgui.npf.value = int(cfg.npf_range.center)\n\n        for method in [\n            self.map_monomers,\n            self.map_monomers_with_extensions,\n            self.map_along_pf,\n            self.map_along_spline,\n            self.map_along_spline_helical_symmetry,\n        ]:\n            get_function_gui(method)[\"orientation\"].value = cfg.clockwise\n</code></pre>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.batch","title":"<code>batch</code>  <code>property</code>","text":"<p>Return the batch analyzer.</p>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.default_config","title":"<code>default_config</code>  <code>property</code> <code>writable</code>","text":"<p>Default spline configuration.</p>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.logger","title":"<code>logger</code>  <code>property</code>","text":"<p>The logger instance.</p>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.project_dir","title":"<code>project_dir</code>  <code>property</code>","text":"<p>The project directory.</p>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.project_metadata","title":"<code>project_metadata</code>  <code>property</code>","text":"<p>The project metadata.</p>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.splines","title":"<code>splines</code>  <code>property</code>","text":"<p>The spline list.</p>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.sub_viewer","title":"<code>sub_viewer</code>  <code>property</code>","text":"<p>The sub-viewer for subtomogram averages.</p>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.tomogram","title":"<code>tomogram</code>  <code>property</code>","text":"<p>The current tomogram instance.</p>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.add_anchors","title":"<code>add_anchors(splines=None, interval=25.0, how='pack')</code>","text":"<p>Add anchors to splines.</p> <p>Parameters:</p> Name Type Description Default <code>splines</code> <code>list of int</code> <p>Indices of splines to be used.</p> <code>None</code> <code>interval</code> <code>nm</code> <p>Interval (nm) between spline anchors. Please note that resetting interval will discard all the existing local properties.</p> <code>25.0</code> <code>how</code> <code>str</code> <p>How to add anchors.</p> <ul> <li>\"pack\": (x\u2014\u2014\u2014x\u2014\u2014\u2014x\u2014) Pack anchors from the starting point of splines.</li> <li>\"equal\": (x\u2014\u2014x\u2014\u2014x\u2014\u2014x) Equally distribute anchors between the starting   point and the end point of splines. Actual intervals will be smaller.</li> </ul> <code>\"pack\"</code> Source code in <code>cylindra/widgets/main.py</code> <pre><code>@set_design(text=capitalize, location=_sw.SplinesMenu)\ndef add_anchors(\n    self,\n    splines: SplinesType = None,\n    interval: Annotated[nm, {\"label\": \"Interval between anchors (nm)\", \"min\": 1.0}] = 25.0,\n    how: Literal[\"pack\", \"equal\"] = \"pack\",\n):  # fmt: skip\n    \"\"\"Add anchors to splines.\n\n    Parameters\n    ----------\n    {splines}{interval}\n    how : str, default \"pack\"\n        How to add anchors.\n\n        - \"pack\": (x\u2014\u2014\u2014x\u2014\u2014\u2014x\u2014) Pack anchors from the starting point of splines.\n        - \"equal\": (x\u2014\u2014x\u2014\u2014x\u2014\u2014x) Equally distribute anchors between the starting\n          point and the end point of splines. Actual intervals will be smaller.\n    \"\"\"\n    tomo = self.tomogram\n    splines = self._norm_splines(splines)\n    with SplineTracker(widget=self, indices=splines) as tracker:\n        match how:\n            case \"pack\":\n                tomo.make_anchors(splines, interval=interval)\n            case \"equal\":\n                tomo.make_anchors(splines, max_interval=interval)\n            case _:  # pragma: no cover\n                raise ValueError(f\"Unknown method: {how}\")\n\n        self._update_splines_in_images()\n        return tracker.as_undo_callback()\n</code></pre>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.add_molecules","title":"<code>add_molecules(molecules, name=None, source=None, metadata={}, cmap=None, **kwargs)</code>","text":"<p>Add molecules as a points layer to the viewer.</p> Source code in <code>cylindra/widgets/main.py</code> <pre><code>@nogui\n@do_not_record\ndef add_molecules(\n    self,\n    molecules: Molecules,\n    name: \"str | None\" = None,\n    source: \"BaseComponent | None\" = None,\n    metadata: \"dict[str, Any]\" = {},\n    cmap=None,\n    **kwargs,\n) -&gt; MoleculesLayer:\n    \"\"\"Add molecules as a points layer to the viewer.\"\"\"\n    return add_molecules(\n        self.parent_viewer,\n        molecules,\n        name,\n        source=source,\n        metadata=metadata,\n        cmap=cmap,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.add_multiscale","title":"<code>add_multiscale(bin_size=4)</code>","text":"<p>Add a new multi-scale image of current tomogram.</p> <p>Parameters:</p> Name Type Description Default <code>bin_size</code> <code>int</code> <p>Bin size of the new image</p> <code>4</code> Source code in <code>cylindra/widgets/main.py</code> <pre><code>@set_design(text=\"Add multi-scale\", location=_sw.ImageMenu)\n@dask_thread_worker.with_progress(desc=lambda bin_size: f\"Adding multiscale (bin = {bin_size})\")  # fmt: skip\ndef add_multiscale(\n    self,\n    bin_size: Annotated[int, {\"choices\": list(range(2, 17))}] = 4,\n):\n    \"\"\"Add a new multi-scale image of current tomogram.\n\n    Parameters\n    ----------\n    bin_size : int, default 4\n        Bin size of the new image\n    \"\"\"\n    tomo = self.tomogram\n    tomo.get_multiscale(binsize=bin_size, add=True)\n    return thread_worker.callback(self.set_multiscale).with_args(bin_size)\n</code></pre>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.align_to_polarity","title":"<code>align_to_polarity(orientation='MinusToPlus')</code>","text":"<p>Align all the splines in the direction parallel to the cylinder polarity.</p> <p>Parameters:</p> Name Type Description Default <code>orientation</code> <code>Ori</code> <p>To which direction splines will be aligned.</p> <code>Ori.MinusToPlus</code> Source code in <code>cylindra/widgets/main.py</code> <pre><code>@set_design(text=capitalize, location=_sw.SplinesMenu.Orientation)\ndef align_to_polarity(\n    self, orientation: Literal[\"MinusToPlus\", \"PlusToMinus\"] = \"MinusToPlus\"\n):\n    \"\"\"Align all the splines in the direction parallel to the cylinder polarity.\n\n    Parameters\n    ----------\n    orientation : Ori, default Ori.MinusToPlus\n        To which direction splines will be aligned.\n    \"\"\"\n    need_resample = self.SplineControl.need_resample\n    _old_orientations = [spl.orientation for spl in self.tomogram.splines]\n    self.tomogram.align_to_polarity(orientation=orientation)\n    self._update_splines_in_images()\n    self._init_widget_state()\n    self.reset_choices()\n    if need_resample:\n        self.sample_subtomograms()\n    for i in range(len(self.tomogram.splines)):\n        self._set_orientation_marker(i)\n    _new_orientations = [spl.orientation for spl in self.tomogram.splines]\n    return (\n        undo_callback(self._set_orientations)\n        .with_args(_old_orientations, need_resample)\n        .with_redo(lambda: self._set_orientations(_new_orientations))\n    )\n</code></pre>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.binarize_feature","title":"<code>binarize_feature(layer, target, threshold=0.0, larger_true=True, suffix='_binarize')</code>","text":"<p>Binarization of a layer feature by thresholding.</p> <p>Parameters:</p> Name Type Description Default <code>layer</code> <code>MoleculesLayer</code> <p>Points layer of molecules to be used.</p> required <code>target</code> <code>str</code> <p>Target column name on which calculation will run.</p> required <code>threshold</code> <code>float</code> <p>Threshold value used for binarization.</p> <code>0.0</code> <code>larger_true</code> <code>bool</code> <p>If true, values larger than <code>threshold</code> will be True.</p> <code>True</code> <code>suffix</code> <code>str</code> <p>Suffix of the new feature column name.</p> <code>\"_binarize\"</code> Source code in <code>cylindra/widgets/main.py</code> <pre><code>@set_design(text=capitalize, location=_sw.MoleculesMenu.Features)\ndef binarize_feature(\n    self,\n    layer: MoleculesLayerType,\n    target: Annotated[str, {\"choices\": _choice_getter(\"binarize_feature\", dtype_kind=\"uif\")}],\n    threshold: Annotated[float, {\"widget_type\": \"FloatSlider\"}] = 0.0,\n    larger_true: bool = True,\n    suffix: str = \"_binarize\",\n):  # fmt: skip\n    \"\"\"Binarization of a layer feature by thresholding.\n\n    Parameters\n    ----------\n    {layer}{target}\n    threshold : float, optional\n        Threshold value used for binarization.\n    larger_true : bool, optional\n        If true, values larger than `threshold` will be True.\n    suffix : str, default \"_binarize\"\n        Suffix of the new feature column name.\n    \"\"\"\n    from cylindra import cylfilters\n\n    layer = assert_layer(layer, self.parent_viewer)\n    utils.assert_column_exists(layer.molecules.features, target)\n    if suffix == \"\":\n        raise ValueError(\"`suffix` cannot be empty.\")\n    feat, cmap_info = layer.molecules.features, layer.colormap_info\n    ser = cylfilters.binarize(layer.molecules.features, threshold, target)\n    if not larger_true:\n        ser = -ser\n    feature_name = f\"{target}{suffix}\"\n    layer.molecules = layer.molecules.with_features(\n        ser.alias(feature_name).cast(pl.Boolean)\n    )\n    self.reset_choices()\n    layer.set_colormap(feature_name, (0, 1), {0: \"#A5A5A5\", 1: \"#FF0000\"})\n    return undo_callback(layer.feature_setter(feat, cmap_info))\n</code></pre>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.calculate_lattice_structure","title":"<code>calculate_lattice_structure(layer, props=('spacing',))</code>","text":"<p>Calculate lattice structures and store the results as new feature columns.</p> <p>Parameters:</p> Name Type Description Default <code>layer</code> <code>MoleculesLayer</code> <p>Points layer of molecules to be used.</p> required <code>props</code> <code>list of str</code> <p>Properties to calculate.</p> <code>('spacing',)</code> Source code in <code>cylindra/widgets/main.py</code> <pre><code>@set_design(text=capitalize, location=_sw.MoleculesMenu.Features)\ndef calculate_lattice_structure(\n    self,\n    layer: MoleculesLayerType,\n    props: Annotated[list[str], {\"widget_type\": CheckBoxes, \"choices\": cylmeasure.LatticeParameters.choices()}] = (\"spacing\",),\n):  # fmt: skip\n    \"\"\"Calculate lattice structures and store the results as new feature columns.\n\n    Parameters\n    ----------\n    {layer}\n    props : list of str, optional\n        Properties to calculate.\n    \"\"\"\n    layer = assert_layer(layer, self.parent_viewer)\n    spl = _assert_source_spline_exists(layer)\n    mole = layer.molecules\n    feat = mole.features\n\n    def _calculate(p: str):\n        return cylmeasure.LatticeParameters(p).calculate(mole, spl)\n\n    layer.molecules = layer.molecules.with_features([_calculate(p) for p in props])\n    self.reset_choices()  # choices regarding of features need update\n    return undo_callback(layer.feature_setter(feat))\n</code></pre>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.calculate_molecule_features","title":"<code>calculate_molecule_features(layer, column_name, expression)</code>","text":"<p>Calculate a new feature from the existing features.</p> <p>This method is identical to running <code>with_columns</code> on the features dataframe as a <code>polars.DataFrame</code>. For example, <pre><code>ui.calculate_molecule_features(layer, \"Y\", \"pl.col('X') + 1\")\n</code></pre> is equivalent to <pre><code>layer.features = layer.features.with_columns([(pl.col(\"X\") + 1).alias(\"Y\")])\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>layer</code> <code>MoleculesLayer</code> <p>Points layer of molecules to be used.</p> required <code>column_name</code> <code>str</code> <p>Name of the new column.</p> required <code>expression</code> <code>Expr or str</code> <p>polars expression to calculate the new column.</p> required Source code in <code>cylindra/widgets/main.py</code> <pre><code>@set_design(text=capitalize, location=_sw.MoleculesMenu.Features)\n@confirm(\n    text=\"Column already exists. Overwrite?\",\n    condition=\"column_name in layer.molecules.features.columns\",\n)\ndef calculate_molecule_features(\n    self,\n    layer: MoleculesLayerType,\n    column_name: str,\n    expression: PolarsExprStr,\n):\n    \"\"\"Calculate a new feature from the existing features.\n\n    This method is identical to running `with_columns` on the features dataframe\n    as a `polars.DataFrame`. For example,\n    &gt;&gt;&gt; ui.calculate_molecule_features(layer, \"Y\", \"pl.col('X') + 1\")\n    is equivalent to\n    &gt;&gt;&gt; layer.features = layer.features.with_columns([(pl.col(\"X\") + 1).alias(\"Y\")])\n\n    Parameters\n    ----------\n    {layer}\n    column_name : str\n        Name of the new column.\n    expression : pl.Expr or str\n        polars expression to calculate the new column.\n    \"\"\"\n    layer = assert_layer(layer, self.parent_viewer)\n    feat = layer.molecules.features\n    expr = widget_utils.norm_expr(expression)\n    new_feat = feat.with_columns(expr.alias(column_name))\n    layer.features = new_feat\n    self.reset_choices()  # choices regarding to features need update\n    return undo_callback(layer.feature_setter(feat, layer.colormap_info))\n</code></pre>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.clear_all","title":"<code>clear_all()</code>","text":"<p>Clear all the splines and results.</p> Source code in <code>cylindra/widgets/main.py</code> <pre><code>@set_design(icon=\"material-symbols:bomb\", location=Toolbar)\n@confirm(text=\"Are you sure to clear all?\\nYou cannot undo this.\")\n@do_not_record\ndef clear_all(self):\n    \"\"\"Clear all the splines and results.\"\"\"\n    self.macro.clear_undo_stack()\n    self.Overview.layers.clear()\n    self.tomogram.splines.clear()\n    self._init_widget_state()\n    self._init_layers()\n    del self.macro[self._macro_image_load_offset + 1 :]\n    self._need_save = False\n    self.reset_choices()\n</code></pre>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.clear_current","title":"<code>clear_current()</code>","text":"<p>Clear current selection.</p> Source code in <code>cylindra/widgets/main.py</code> <pre><code>@set_design(icon=\"solar:eraser-bold\", location=Toolbar)\n@confirm(text=\"Spline has properties. Are you sure to delete it?\", condition=_confirm_delete)  # fmt: skip\n@do_not_record(recursive=False)\ndef clear_current(self):\n    \"\"\"Clear current selection.\"\"\"\n    if self._reserved_layers.work.data.size &gt; 0:\n        self._reserved_layers.work.data = []\n    else:\n        self.delete_spline(self.SplineControl.num)\n</code></pre>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.clip_spline","title":"<code>clip_spline(spline, lengths=(0.0, 0.0))</code>","text":"<p>Clip selected spline at its edges by given lengths.</p> <p>Parameters:</p> Name Type Description Default <code>spline</code> <code>int</code> <p>The ID of spline to be clipped.</p> required <code>lengths</code> <code>tuple of float</code> <p>The length in nm to be clipped at the start and end of the spline.</p> <code>(0., 0.)</code> Source code in <code>cylindra/widgets/main.py</code> <pre><code>@set_design(text=capitalize, location=_sw.SplinesMenu)\n@bind_key(\"Ctrl+K, Ctrl+X\")\ndef clip_spline(\n    self,\n    spline: Annotated[int, {\"choices\": _get_splines}],\n    lengths: Annotated[tuple[nm, nm], {\"options\": {\"min\": -1000.0, \"max\": 1000.0, \"step\": 0.1, \"label\": \"clip length (nm)\"}}] = (0.0, 0.0),\n):  # fmt: skip\n    \"\"\"Clip selected spline at its edges by given lengths.\n\n    Parameters\n    ----------\n    spline : int\n        The ID of spline to be clipped.\n    lengths : tuple of float, default (0., 0.)\n        The length in nm to be clipped at the start and end of the spline.\n    \"\"\"\n    if spline is None:\n        return\n    spl = self.tomogram.splines[spline]\n    _old_spl = spl.copy()\n    length = spl.length()\n    start, stop = np.array(lengths) / length\n    self.tomogram.splines[spline] = spl.clip(start, 1 - stop)\n    self._update_splines_in_images()\n    # current layer will be removed. Select another layer.\n    self.parent_viewer.layers.selection = {self._reserved_layers.work}\n\n    @undo_callback\n    def out():\n        self.tomogram.splines[spline] = _old_spl\n        self._update_splines_in_images()\n\n    return out\n</code></pre>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.concatenate_molecules","title":"<code>concatenate_molecules(layers, name='Mole-concat')</code>","text":"<p>Concatenate selected molecules and create a new ones.</p> <p>Parameters:</p> Name Type Description Default <code>layers</code> <code>list of MoleculesLayer</code> <p>All the points layers of molecules to be used.</p> required <code>name</code> <code>str</code> <p>Name of the new molecules layer.</p> <code>\"Mole-concat\"</code> Source code in <code>cylindra/widgets/main.py</code> <pre><code>@set_design(text=capitalize, location=_sw.MoleculesMenu.Combine)\ndef concatenate_molecules(\n    self,\n    layers: MoleculesLayersType,\n    name: str = \"Mole-concat\",\n):  # fmt: skip\n    \"\"\"Concatenate selected molecules and create a new ones.\n\n    Parameters\n    ----------\n    {layers}\n    name : str, default \"Mole-concat\"\n        Name of the new molecules layer.\n    \"\"\"\n    layers = assert_list_of_layers(layers, self.parent_viewer)\n    all_molecules = Molecules.concat([layer.molecules for layer in layers])\n    points = add_molecules(self.parent_viewer, all_molecules, name=name)\n\n    # logging\n    layer_names = list[str]()\n    for layer in layers:\n        layer.visible = False\n        layer_names.append(layer.name)\n\n    _Logger.print_html(\"&lt;code&gt;concatenate_molecules&lt;/code&gt;\")\n    _Logger.print(\"Concatenated:\", \", \".join(layer_names))\n    _Logger.print(f\"{points.name!r}: n = {len(all_molecules)}\")\n    return self._undo_callback_for_layer(points)\n</code></pre>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.construct_closest_molecule_interaction","title":"<code>construct_closest_molecule_interaction(origin_molecules, target_molecules, layer_name='Interaction', standard_features=True)</code>","text":"<p>Construct the closest inter-molecule interaction network.</p> Source code in <code>cylindra/widgets/main.py</code> <pre><code>@set_design(text=capitalize, location=_sw.AnalysisMenu.Interaction)\ndef construct_closest_molecule_interaction(\n    self,\n    origin_molecules: MoleculesLayerType,\n    target_molecules: MoleculesLayerType,\n    layer_name: str = \"Interaction\",\n    standard_features: bool = True,\n):\n    \"\"\"Construct the closest inter-molecule interaction network.\"\"\"\n    origin_molecules = assert_layer(origin_molecules, self.parent_viewer)\n    target_molecules = assert_layer(target_molecules, self.parent_viewer)\n    net = InterMoleculeNet.from_molecules_closest(\n        origin_molecules.molecules, target_molecules.molecules\n    )\n    if standard_features:\n        net = net.with_standard_features()\n    layer = InteractionVector(net, name=layer_name)\n    _Logger.print(f\"{net.count()} interactions constructed.\")\n    return self._undo_callback_for_layer(self.parent_viewer.add_layer(layer))\n</code></pre>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.construct_molecule_interaction","title":"<code>construct_molecule_interaction(origin_molecules, target_molecules, dist_range=(0.2, 10.0), layer_name='Interactions', standard_features=True)</code>","text":"<p>Construct all the possible inter-molecule interaction network.</p> <p>All the possible interactions between the origin and target molecule layers will be added. Alternatively, you can set both origin and target layers to the same layer to get the self-interaction.</p> <p>Parameters:</p> Name Type Description Default <code>origin_molecules</code> <code>MoleculesLayer</code> <p>The layer of origin molecules. Interactions are defined by origin-&gt;target.</p> required <code>target_molecules</code> <code>MoleculesLayer</code> <p>The layer of target molecules. Interactions are defined by origin-&gt;target.</p> required <code>dist_range</code> <code>tuple of float</code> <p>The range of distance to consider for the interaction. Note that wide distance range may cause a very dense interaction map.</p> <code>(0.2, 10.0)</code> <code>layer_name</code> <code>str</code> <p>Name of the returned layer.</p> <code>\"Interactions\"</code> <code>standard_features</code> <code>bool</code> <p>If True, add standard features to the interaction network.</p> <code>True</code> Source code in <code>cylindra/widgets/main.py</code> <pre><code>@set_design(text=capitalize, location=_sw.AnalysisMenu.Interaction)\ndef construct_molecule_interaction(\n    self,\n    origin_molecules: MoleculesLayerType,\n    target_molecules: MoleculesLayerType,\n    dist_range: Annotated[tuple[nm, nm], {\"label\": \"distance between (nm)\", \"options\": {\"min\": 0.0, \"step\": 0.01}}] = (0.2, 10.0),\n    layer_name: str = \"Interactions\",\n    standard_features: bool = True,\n):  # fmt: skip\n    \"\"\"Construct all the possible inter-molecule interaction network.\n\n    All the possible interactions between the origin and target molecule layers will\n    be added. Alternatively, you can set both origin and target layers to the same\n    layer to get the self-interaction.\n\n    Parameters\n    ----------\n    origin_molecules : MoleculesLayer\n        The layer of origin molecules. Interactions are defined by origin-&gt;target.\n    target_molecules : MoleculesLayer\n        The layer of target molecules. Interactions are defined by origin-&gt;target.\n    dist_range : tuple of float, default (0.2, 10.0)\n        The range of distance to consider for the interaction. Note that wide\n        distance range may cause a very dense interaction map.\n    layer_name : str, default \"Interactions\"\n        Name of the returned layer.\n    standard_features : bool, default True\n        If True, add standard features to the interaction network.\n    \"\"\"\n    origin_molecules = assert_layer(origin_molecules, self.parent_viewer)\n    target_molecules = assert_layer(target_molecules, self.parent_viewer)\n    net = InterMoleculeNet.from_molecules(\n        origin_molecules.molecules,\n        target_molecules.molecules,\n        min_distance=dist_range[0],\n        max_distance=dist_range[1],\n    )\n    if standard_features:\n        net = net.with_standard_features()\n    layer = InteractionVector(net, name=layer_name)\n    _Logger.print(f\"{net.count()} interactions constructed.\")\n    return self._undo_callback_for_layer(self.parent_viewer.add_layer(layer))\n</code></pre>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.convolve_feature","title":"<code>convolve_feature(layer, target, method='mean', footprint=[[0, 1, 0], [1, 1, 1], [0, 1, 0]])</code>","text":"<p>Run a convolution on the lattice.</p> <p>The convolution is similar to that in the context of image analysis, except for the cylindric boundary. During the convolution, the edges will not be considered, i.e., NaN value will be ignored and convolution will be the convolution of valid regions.</p> <p>Parameters:</p> Name Type Description Default <code>layer</code> <code>MoleculesLayer</code> <p>Points layer of molecules to be used.</p> required <code>method</code> <code>str</code> <p>Convolution method.</p> <code>'mean'</code> <code>target</code> <code>str</code> <p>Target column name on which calculation will run.</p> required <code>footprint</code> <code>array - like</code> <p>2D binary array that define the convolution kernel structure.</p> <code>[[0, 1, 0], [1, 1, 1], [0, 1, 0]]</code> Source code in <code>cylindra/widgets/main.py</code> <pre><code>@set_design(text=capitalize, location=_sw.MoleculesMenu.Features)\ndef convolve_feature(\n    self,\n    layer: MoleculesLayerType,\n    target: Annotated[str, {\"choices\": _choice_getter(\"convolve_feature\", dtype_kind=\"uifb\")}],\n    method: Literal[\"mean\", \"max\", \"min\", \"median\"] = \"mean\",\n    footprint: Annotated[Any, {\"widget_type\": KernelEdit}] = [[0, 1, 0], [1, 1, 1], [0, 1, 0]],\n):  # fmt: skip\n    \"\"\"Run a convolution on the lattice.\n\n    The convolution is similar to that in the context of image analysis, except for\n    the cylindric boundary. During the convolution, the edges will not be considered,\n    i.e., NaN value will be ignored and convolution will be the convolution of valid\n    regions.\n\n    Parameters\n    ----------\n    {layer}\n    method : str\n        Convolution method.\n    {target}{footprint}\n    \"\"\"\n    from cylindra import cylfilters\n\n    layer = assert_layer(layer, self.parent_viewer)\n    utils.assert_column_exists(layer.molecules.features, target)\n    feat, cmap_info = layer.molecules.features, layer.colormap_info\n    nrise = _assert_source_spline_exists(layer).nrise()\n    out = cylfilters.run_filter(\n        layer.molecules.features, footprint, target, nrise, method\n    )\n    feature_name = f\"{target}_{method}\"\n    layer.molecules = layer.molecules.with_features(out.alias(feature_name))\n    self.reset_choices()\n    match layer.colormap_info:\n        case str(color):\n            layer.face_color = color\n        case info:\n            layer.set_colormap(feature_name, info.clim, info.cmap)\n    return undo_callback(layer.feature_setter(feat, cmap_info))\n</code></pre>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.copy_molecules_features","title":"<code>copy_molecules_features(source, destinations, column, alias='')</code>","text":"<p>Copy molecules features from one layer to another.</p> <p>This method is useful when a layer feature (such as seam search result) should be shared by multiple molecules layers that were aligned in a different parameters.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>MoleculesLayer</code> <p>Layer whose features will be copied.</p> required <code>destinations</code> <code>MoleculesLayersType</code> <p>To which layers the features should be copied.</p> required <code>column</code> <code>str</code> <p>Column name of the feature to be copied.</p> required <code>alias</code> <code>str</code> <p>If given, the copied feature will be renamed to this name.</p> <code>''</code> Source code in <code>cylindra/widgets/main.py</code> <pre><code>@set_design(text=capitalize, location=_sw.MoleculesMenu.Combine)\ndef copy_molecules_features(\n    self,\n    source: MoleculesLayerType,\n    destinations: MoleculesLayersType,\n    column: Annotated[str, {\"choices\": _choice_getter(\"copy_molecules_features\")}],\n    alias: str = \"\",\n):  # fmt: skip\n    \"\"\"\n    Copy molecules features from one layer to another.\n\n    This method is useful when a layer feature (such as seam search result) should be\n    shared by multiple molecules layers that were aligned in a different parameters.\n\n    Parameters\n    ----------\n    source : MoleculesLayer\n        Layer whose features will be copied.\n    destinations : MoleculesLayersType\n        To which layers the features should be copied.\n    column : str\n        Column name of the feature to be copied.\n    alias : str, optional\n        If given, the copied feature will be renamed to this name.\n    \"\"\"\n    source = assert_layer(source, self.parent_viewer)\n    destinations = assert_list_of_layers(destinations, self.parent_viewer)\n    series = source.molecules.features[column]\n    if alias:\n        series = series.alias(alias)\n    for dest in destinations:\n        dest.molecules = dest.molecules.with_features([series])\n    return None\n</code></pre>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.copy_spline","title":"<code>copy_spline(i)</code>","text":"<p>Make a copy of the current spline</p> Source code in <code>cylindra/widgets/main.py</code> <pre><code>@set_design(text=capitalize, location=_sw.SplinesMenu)\ndef copy_spline(self, i: Annotated[int, {\"bind\": _get_spline_idx}]):\n    \"\"\"Make a copy of the current spline\"\"\"\n    spl = self.tomogram.splines[i]\n    self.tomogram.splines.append(spl.copy())\n    self.reset_choices()\n    self.SplineControl.num = len(self.tomogram.splines) - 1\n    return undo_callback(self.delete_spline).with_args(-1)\n</code></pre>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.count_neighbors","title":"<code>count_neighbors(layer, footprint=[[0, 1, 0], [1, 0, 1], [0, 1, 0]], column_name='neighbor_count')</code>","text":"<p>Count the number of neighbors for each molecules.</p> <p>Parameters:</p> Name Type Description Default <code>layer</code> <code>MoleculesLayer</code> <p>Points layer of molecules to be used.</p> required <code>footprint</code> <code>array - like</code> <p>2D binary array that define the convolution kernel structure.</p> <code>[[0, 1, 0], [1, 0, 1], [0, 1, 0]]</code> <code>column_name</code> <code>str</code> <p>Name of the new column that stores the number of counts.</p> <code>'neighbor_count'</code> Source code in <code>cylindra/widgets/main.py</code> <pre><code>@set_design(text=capitalize, location=_sw.MoleculesMenu.Features)\ndef count_neighbors(\n    self,\n    layer: MoleculesLayerType,\n    footprint: Annotated[Any, {\"widget_type\": KernelEdit}] = [[0, 1, 0], [1, 0, 1], [0, 1, 0]],\n    column_name: str = \"neighbor_count\",\n):  # fmt: skip\n    \"\"\"Count the number of neighbors for each molecules.\n\n    Parameters\n    ----------\n    {layer}{footprint}\n    column_name : str\n        Name of the new column that stores the number of counts.\n    \"\"\"\n    from cylindra import cylfilters\n\n    layer = assert_layer(layer, self.parent_viewer)\n    feat, cmap_info = layer.molecules.features, layer.colormap_info\n    nrise = _assert_source_spline_exists(layer).nrise()\n    out = cylfilters.count_neighbors(layer.molecules.features, footprint, nrise)\n    layer.molecules = layer.molecules.with_features(out.alias(column_name))\n    self.reset_choices()\n    return undo_callback(layer.feature_setter(feat, cmap_info))\n</code></pre>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.deconvolve_reference_image","title":"<code>deconvolve_reference_image(kv=300.0, cs=2.7, defocus=-3.0, bfactor=0.0, snr_falloff=0.7, phase_flipped=True)</code>","text":"<p>Deconvolve the reference image using CTF info with Wiener filter.</p> <p>Parameters:</p> Name Type Description Default <code>kv</code> <code>float</code> <p>Accelerating voltage in kV.</p> <code>300.0</code> <code>cs</code> <code>float</code> <p>Spherical aberration in mm.</p> <code>2.7</code> <code>defocus</code> <code>float</code> <p>Defocus value in micrometers. For the standard image acquisition method, this value should be negative.</p> <code>-3.0</code> <code>bfactor</code> <code>float</code> <p>B-factor for the decay of the CTF amplitude.</p> <code>0.0</code> <code>snr_falloff</code> <code>float</code> <p>SNR fall-off factor, for the Wiener filter. Larger value means more smoothing.</p> <code>0.7</code> <code>phase_flipped</code> <code>bool</code> <p>If the tomogram is reconstructed from phase-flipped tilt series, check this.</p> <code>True</code> Source code in <code>cylindra/widgets/main.py</code> <pre><code>@set_design(text=capitalize, location=_sw.ImageMenu)\n@thread_worker.with_progress(desc=\"Deconvolving reference image ...\")\n@do_not_record\ndef deconvolve_reference_image(\n    self,\n    kv: Annotated[float, {\"label\": \"Voltage [kV]\"}] = 300.0,\n    cs: Annotated[float, {\"label\": \"Cs [mm]\"}] = 2.7,\n    defocus: Annotated[float, {\"label\": \"Defocus [um]\", \"min\": -100, \"max\": 100}] = -3.0,\n    bfactor: Annotated[float, {\"label\": \"B-factor\"}] = 0.0,\n    snr_falloff: Annotated[float, {\"label\": \"SNR fall-off\", \"max\": 10.0}] = 0.7,\n    phase_flipped: Annotated[bool, {\"text\": \"Phase flipped\"}] = True,\n):  # fmt: skip\n    \"\"\"Deconvolve the reference image using CTF info with Wiener filter.\n\n    Parameters\n    ----------\n    kv : float, default 300.0\n        Accelerating voltage in kV.\n    cs : float, default 2.7\n        Spherical aberration in mm.\n    defocus : float, default -3.0\n        Defocus value in micrometers. For the standard image acquisition method,\n        this value should be negative.\n    bfactor : float, default 0.0\n        B-factor for the decay of the CTF amplitude.\n    snr_falloff : float, default 0.7\n        SNR fall-off factor, for the Wiener filter. Larger value means more\n        smoothing.\n    phase_flipped : bool, default True\n        If the tomogram is reconstructed from phase-flipped tilt series, check this.\n    \"\"\"\n    if _is_dummy_tomogram(self):\n        return\n    t0 = timer()\n    ctf = CTFModel.from_kv(kv, cs, defocus=defocus, bfactor=bfactor)\n    scale = self._reserved_layers.scale\n    yield on_ctf_finished.with_args(ctf, scale)\n    img_deconv = ctf.deconvolve(\n        self._reserved_layers.image_data.value,\n        scale=scale,\n        snr_falloff=snr_falloff,\n        phaseflipped=phase_flipped,\n    )\n    img_deconv = ip.asarray(img_deconv, axes=\"zyx\").set_scale(zyx=scale)\n\n    t0.toc()\n    return self._reference_updated_callback.with_args(img_deconv)\n</code></pre>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.delete_molecules","title":"<code>delete_molecules(include='', exclude='', pattern='')</code>","text":"<p>Delete molecules by the layer names.</p> <p>Parameters:</p> Name Type Description Default <code>include</code> <code>str</code> <p>Delete layers whose names contain this string.</p> <code>''</code> <code>exclude</code> <code>str</code> <p>Delete layers whose names do not contain this string.</p> <code>''</code> <code>pattern</code> <code>str</code> <p>String pattern to match the layer names. Use <code>*</code> as wildcard.</p> <code>''</code> Source code in <code>cylindra/widgets/main.py</code> <pre><code>@set_design(text=\"Delete molecule layers\", location=_sw.MoleculesMenu)\n@do_not_record(recursive=False)\ndef delete_molecules(\n    self,\n    include: str = \"\",\n    exclude: str = \"\",\n    pattern: str = \"\",\n):\n    \"\"\"Delete molecules by the layer names.\n\n    Parameters\n    ----------\n    include : str, optional\n        Delete layers whose names contain this string.\n    exclude : str, optional\n        Delete layers whose names do not contain this string.\n    pattern : str, optional\n        String pattern to match the layer names. Use `*` as wildcard.\n    \"\"\"\n    self.mole_layers.delete(include=include, exclude=exclude, pattern=pattern)\n</code></pre>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.delete_spline","title":"<code>delete_spline(i)</code>","text":"<p>Delete currently selected spline.</p> Source code in <code>cylindra/widgets/main.py</code> <pre><code>@set_design(text=capitalize, location=_sw.SplinesMenu)\n@confirm(\n    text=\"Spline has properties. Are you sure to delete it?\",\n    condition=_confirm_delete,\n)\ndef delete_spline(self, i: Annotated[int, {\"bind\": _get_spline_idx}]):\n    \"\"\"Delete currently selected spline.\"\"\"\n    if i &lt; 0:\n        i = len(self.tomogram.splines) - 1\n    spl = self.tomogram.splines.pop(i)\n    self.reset_choices()\n\n    # update layer\n    features = self._reserved_layers.prof.features\n    old_data = self._reserved_layers.prof.data\n    self._reserved_layers.select_spline(i, len(self.tomogram.splines))\n    self._update_splines_in_images()\n    if self.SplineControl.need_resample and len(self.tomogram.splines) &gt; 0:\n        self.sample_subtomograms()\n\n    @undo_callback\n    def out():\n        self.tomogram.splines.insert(i, spl)\n        self._reserved_layers.prof.data = old_data\n        self._reserved_layers.prof.features = features\n        self._add_spline_to_images(spl, i)\n        self._update_splines_in_images()\n        self.reset_choices()\n\n    return out\n</code></pre>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.distance_from_closest_molecule","title":"<code>distance_from_closest_molecule(layer, other_layers, column_name='distance')</code>","text":"<p>Add a new column that stores the distance from the closest molecule.</p> <p>Parameters:</p> Name Type Description Default <code>layer</code> <code>MoleculesLayer</code> <p>Points layer of molecules to be used.</p> required <code>column_name</code> <code>str</code> <p>Name of the new column.</p> <code>\"distance\"</code> Source code in <code>cylindra/widgets/main.py</code> <pre><code>@set_design(text=capitalize, location=_sw.MoleculesMenu.Features)\ndef distance_from_closest_molecule(\n    self,\n    layer: MoleculesLayerType,\n    other_layers: MoleculesLayersType,\n    column_name: str = \"distance\",\n):\n    \"\"\"Add a new column that stores the distance from the closest molecule.\n\n    Parameters\n    ----------\n    {layer}\n    column_name : str, default \"distance\"\n        Name of the new column.\n    \"\"\"\n    layer = assert_layer(layer, self.parent_viewer)\n    other_layers = assert_list_of_layers(other_layers, self.parent_viewer)\n    feat, cmap_info = layer.molecules.features, layer.colormap_info\n    other_moles = Molecules.concat([l.molecules for l in other_layers])\n    net = InterMoleculeNet.from_molecules_closest(layer.molecules, other_moles)\n    dist = net.distances()\n    layer.molecules = layer.molecules.with_features(pl.Series(column_name, dist))\n    self.reset_choices()  # choices regarding of features need update\n    return undo_callback(layer.feature_setter(feat, cmap_info))\n</code></pre>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.distance_from_spline","title":"<code>distance_from_spline(layer, spline, column_name='distance', interval=1.0, extrapolation=(0.0, 0.0))</code>","text":"<p>Add a new column that stores the shortest distance from the given spline.</p> <p>Parameters:</p> Name Type Description Default <code>layer</code> <code>MoleculesLayer</code> <p>Points layer of molecules to be used.</p> required <code>spline</code> <code>int</code> <p>Index of splines to be used.</p> required <code>column_name</code> <code>str</code> <p>Name of the new column.</p> <code>\"distance\"</code> <code>interval</code> <code>nm</code> <p>Sampling interval along the spline. Note that small value will increase the memory usage and computation time.</p> <code>1.0</code> <code>extrapolation</code> <code>tuple of float</code> <p>Extrapolation distance at the start and end of the spline.</p> <code>(0.0, 0.0)</code> Source code in <code>cylindra/widgets/main.py</code> <pre><code>@set_design(text=capitalize, location=_sw.MoleculesMenu.Features)\ndef distance_from_spline(\n    self,\n    layer: MoleculesLayerType,\n    spline: Annotated[int, {\"choices\": _get_splines}],\n    column_name: str = \"distance\",\n    interval: nm = 1.0,\n    extrapolation: tuple[nm, nm] = (0.0, 0.0),\n):\n    \"\"\"Add a new column that stores the shortest distance from the given spline.\n\n    Parameters\n    ----------\n    {layer}{spline}\n    column_name : str, default \"distance\"\n        Name of the new column.\n    interval: nm, default 1.0\n        Sampling interval along the spline. Note that small value will increase the\n        memory usage and computation time.\n    extrapolation : tuple of float, default (0.0, 0.0)\n        Extrapolation distance at the start and end of the spline.\n    \"\"\"\n    spl = self.tomogram.splines[spline]\n    layer = assert_layer(layer, self.parent_viewer)\n    ext_0, ext_1 = extrapolation\n    if interval &lt;= 0:\n        raise ValueError(\"`interval` must be positive.\")\n    feat, cmap_info = layer.molecules.features, layer.colormap_info\n    length = spl.length()\n    npartitions = utils.ceilint((length + ext_0 + ext_1) / interval)\n    sample_points = spl.map(\n        np.linspace(-ext_0 / length, 1 + ext_1 / length, npartitions)\n    )\n    dist = utils.distance_matrix(layer.molecules.pos, sample_points)\n    dist_min = pl.Series(column_name, np.min(dist, axis=1))\n    layer.molecules = layer.molecules.with_features(dist_min)\n    self.reset_choices()  # choices regarding of features need update\n    return undo_callback(layer.feature_setter(feat, cmap_info))\n</code></pre>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.drop_molecules","title":"<code>drop_molecules(layer, indices='', inherit_source=True)</code>","text":"<p>Drop a subset of molecules from a molecules layer by indices.</p> <p>Note that the indices start from 0. <code>ui.drop_molecules(layer, [0, 2, 6])</code> will drop 0th, 2nd, and 6th molecules.</p> <p>Parameters:</p> Name Type Description Default <code>layer</code> <code>MoleculesLayer</code> <p>Points layer of molecules to be used.</p> required <code>indices</code> <code>str, int, slice or sequence of int or slice</code> <p>A sequence of molecule indices to drop. You can use <code>npf</code> for the number of protofilaments and <code>N</code> for the number of molecules. <code>slice</code> is also allowed for dropping a range of indices. In GUI, this parameter must a string of comma-separated integers/slices (e.g. <code>3, N - 3</code>, <code>1, slice(12, 12 + npf)</code>).</p> <code>''</code> <code>inherit_source</code> <code>bool</code> <p>If True and the input molecules layer has its spline source, the new layer will inherit it.</p> <code>True</code> Source code in <code>cylindra/widgets/main.py</code> <pre><code>@set_design(text=capitalize, location=_sw.MoleculesMenu)\ndef drop_molecules(\n    self,\n    layer: MoleculesLayerType,\n    indices: Annotated[str | Sequence[int | slice], {\"widget_type\": IndexEdit}] = \"\",\n    inherit_source: Annotated[bool, {\"label\": \"Inherit source spline\"}] = True,\n):  # fmt: skip\n    \"\"\"Drop a subset of molecules from a molecules layer by indices.\n\n    Note that the indices start from 0. `ui.drop_molecules(layer, [0, 2, 6])` will\n    drop 0th, 2nd, and 6th molecules.\n\n    Parameters\n    ----------\n    {layer}\n    indices : str, int, slice or sequence of int or slice, optional\n        A sequence of molecule indices to drop. You can use `npf` for the number\n        of protofilaments and `N` for the number of molecules. `slice` is also\n        allowed for dropping a range of indices. In GUI, this parameter must a\n        string of comma-separated integers/slices (e.g. `3, N - 3`,\n        `1, slice(12, 12 + npf)`).\n    {inherit_source}\n    \"\"\"\n    layer = assert_layer(layer, self.parent_viewer)\n    mole = layer.molecules\n    _to_drop = set[int]()\n    if isinstance(indices, str):\n        if spl := layer.source_spline:\n            npf = spl.props.get_glob(H.npf, None)\n        else:\n            npf = None\n        indices = IndexEdit.eval(indices, npf=npf, N=mole.count())\n    for i in indices:\n        if isinstance(i, slice):\n            _to_drop.update(range(*i.indices(mole.count())))\n        elif isinstance(i, int | np.integer):\n            _to_drop.add(int(i))\n        else:\n            raise ValueError(f\"Indices must be integers, got {type(i)!r}.\")\n    sl = np.array([i for i in range(mole.count()) if i not in _to_drop])\n    out = mole.subset(sl)\n    source = layer.source_component if inherit_source else None\n    new = self.add_molecules(out, name=f\"{layer.name}-Drop\", source=source)\n    return self._undo_callback_for_layer(new)\n</code></pre>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.filament_to_spline","title":"<code>filament_to_spline(layer, err_max=0.8, config=None)</code>","text":"<p>Convert a filament to splines.</p> <p>Parameters:</p> Name Type Description Default <code>layer</code> <code>MoleculesLayer</code> <p>Points layer of molecules to be used.</p> required <code>err_max</code> <code>float</code> <p>S.D. allowed for spline fitting. Larger value will result in smoother spline, i.e. fewer spline knots.</p> <code>0.8</code> Source code in <code>cylindra/widgets/main.py</code> <pre><code>@set_design(text=capitalize, location=_sw.MoleculesMenu.FromToSpline)\ndef filament_to_spline(\n    self,\n    layer: MoleculesLayerType,\n    err_max: Annotated[nm, {\"label\": \"Max fit error (nm)\", \"step\": 0.1}] = 0.8,\n    config: Annotated[dict[str, Any] | SplineConfig, {\"validator\": _get_default_config}] = None,\n):  # fmt: skip\n    \"\"\"Convert a filament to splines.\n\n    Parameters\n    ----------\n    {layer}{err_max}\n    \"\"\"\n    return self.protofilaments_to_spline(\n        layer, err_max=err_max, ids=(), config=config\n    )\n</code></pre>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.filter_molecule_interaction","title":"<code>filter_molecule_interaction(interaction, predicate)</code>","text":"<p>Filter the interaction network by the feature.</p> <p>Parameters:</p> Name Type Description Default <code>interaction</code> <code>InteractionVector</code> <p>The layer of interaction network.</p> required <code>predicate</code> <code>ExprStr</code> <p>A polars-style filter predicate, such as <code>col(\"projection-origin-x\") &gt; 0</code>.</p> required Source code in <code>cylindra/widgets/main.py</code> <pre><code>@set_design(text=capitalize, location=_sw.AnalysisMenu.Interaction)\ndef filter_molecule_interaction(\n    self,\n    interaction: _InteractionNetType,\n    predicate: PolarsExprStr,\n):\n    \"\"\"Filter the interaction network by the feature.\n\n    Parameters\n    ----------\n    interaction : InteractionVector\n        The layer of interaction network.\n    predicate : ExprStr\n        A polars-style filter predicate, such as `col(\"projection-origin-x\") &gt; 0`.\n    \"\"\"\n    layer = assert_interaction_vectors(interaction, self.parent_viewer)\n    out_net = layer.net.filter(widget_utils.norm_expr(predicate))\n    new_layer = InteractionVector(out_net, name=f\"{layer.name}-Filt\")\n    _Logger.print(f\"{out_net.count()} interactions left after filtering.\")\n    _Logger.print_html(f\"{layer.name} &amp;#8594; {new_layer.name}\")\n    return self._undo_callback_for_layer(self.parent_viewer.add_layer(new_layer))\n</code></pre>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.filter_molecules","title":"<code>filter_molecules(layer, predicate, inherit_source=True)</code>","text":"<p>Filter molecules by their features.</p> <p>Parameters:</p> Name Type Description Default <code>layer</code> <code>MoleculesLayer</code> <p>Points layer of molecules to be used.</p> required <code>predicate</code> <code>ExprStr</code> <p>A polars-style filter predicate, such as <code>pl.col(\"pf-id\") == 3</code></p> required <code>inherit_source</code> <code>bool</code> <p>If True and the input molecules layer has its spline source, the new layer will inherit it.</p> <code>True</code> Source code in <code>cylindra/widgets/main.py</code> <pre><code>@set_design(text=capitalize, location=_sw.MoleculesMenu)\ndef filter_molecules(\n    self,\n    layer: MoleculesLayerType,\n    predicate: PolarsExprStr,\n    inherit_source: Annotated[bool, {\"label\": \"Inherit source spline\"}] = True,\n):\n    \"\"\"Filter molecules by their features.\n\n    Parameters\n    ----------\n    {layer}\n    predicate : ExprStr\n        A polars-style filter predicate, such as `pl.col(\"pf-id\") == 3`\n    {inherit_source}\n    \"\"\"\n    layer = assert_layer(layer, self.parent_viewer)\n    mole = layer.molecules\n    out = mole.filter(widget_utils.norm_expr(predicate))\n    _Logger.print(f\"Filter molecules resulted in {out.count()} molecules.\")\n    source = layer.source_component if inherit_source else None\n    new = self.add_molecules(out, name=f\"{layer.name}-Filt\", source=source)\n    _Logger.print_html(f\"{layer.name!r} &amp;#8594; {new.name!r}\")\n    return self._undo_callback_for_layer(new)\n</code></pre>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.filter_reference_image","title":"<code>filter_reference_image(method=ImageFilter.Lowpass)</code>","text":"<p>Apply filter to enhance contrast of the reference image.</p> Source code in <code>cylindra/widgets/main.py</code> <pre><code>@set_design(text=capitalize, location=_sw.ImageMenu)\n@dask_thread_worker.with_progress(desc=_pdesc.filter_image_fmt)\n@do_not_record\ndef filter_reference_image(\n    self,\n    method: ImageFilter = ImageFilter.Lowpass,\n):  # fmt: skip\n    \"\"\"Apply filter to enhance contrast of the reference image.\"\"\"\n    if _is_dummy_tomogram(self):\n        return\n    method = ImageFilter(method)\n    t0 = timer()\n    with utils.set_gpu():\n        img = self._reserved_layers.image_data\n        overlap = [min(s, 32) for s in img.shape]\n        _tiled = img.tiled(chunks=(224, 224, 224), overlap=overlap)\n        sigma = 1.6 / self._reserved_layers.scale\n        match method:\n            case ImageFilter.Lowpass:\n                img_filt = _tiled.lowpass_filter(cutoff=0.2)\n            case ImageFilter.Gaussian:\n                img_filt = _tiled.gaussian_filter(sigma=sigma, fourier=True)\n            case ImageFilter.DoG:\n                img_filt = _tiled.dog_filter(low_sigma=sigma, fourier=True)\n            case ImageFilter.LoG:\n                img_filt = _tiled.log_filter(sigma=sigma)\n            case _:  # pragma: no cover\n                raise ValueError(f\"No method matches {method!r}\")\n\n    t0.toc()\n    return self._reference_updated_callback.with_args(img_filt)\n</code></pre>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.fit_splines","title":"<code>fit_splines(splines=None, max_interval=30, bin_size=1.0, err_max=1.0, degree_precision=0.5, edge_sigma=2.0, max_shift=5.0)</code>","text":"<p>Fit splines to the cylinder by auto-correlation.</p> <p>Parameters:</p> Name Type Description Default <code>splines</code> <code>list of int</code> <p>Indices of splines to be used.</p> <code>None</code> <code>max_interval</code> <code>nm</code> <p>Maximum interval (nm) between spline anchors.</p> <code>30</code> <code>bin_size</code> <code>int</code> <p>Bin size of multiscale image to be used. Set to &gt;1 to boost performance.</p> <code>1.0</code> <code>err_max</code> <code>float</code> <p>S.D. allowed for spline fitting. Larger value will result in smoother spline, i.e. fewer spline knots.</p> <code>1.0</code> <code>degree_precision</code> <code>float</code> <p>Precision of xy-tilt degree in angular correlation.</p> <code>0.5</code> <code>edge_sigma</code> <code>bool</code> <p>Check if cylindric structures are densely packed. Initial spline position must be \"almost\" fitted in dense mode.</p> <code>2.0</code> <code>max_shift</code> <code>nm</code> <p>Maximum shift to be applied to each point of splines.</p> <code>5.0</code> Source code in <code>cylindra/widgets/main.py</code> <pre><code>@set_design(text=capitalize, location=_sw.SplinesMenu.Fitting)\n@thread_worker.with_progress(desc=\"Spline Fitting\", total=_NSPLINES)\ndef fit_splines(\n    self,\n    splines: SplinesType = None,\n    max_interval: Annotated[nm, {\"label\": \"max interval (nm)\"}] = 30,\n    bin_size: Annotated[int, {\"choices\": _get_available_binsize}] = 1.0,\n    err_max: Annotated[nm, {\"label\": \"max fit error (nm)\", \"step\": 0.1}] = 1.0,\n    degree_precision: float = 0.5,\n    edge_sigma: Annotated[Optional[nm], {\"text\": \"Do not mask image\", \"label\": \"edge \u03c3\"}] = 2.0,\n    max_shift: nm = 5.0,\n):  # fmt: skip\n    \"\"\"Fit splines to the cylinder by auto-correlation.\n\n    Parameters\n    ----------\n    {splines}{max_interval}{bin_size}{err_max}\n    degree_precision : float, default 0.5\n        Precision of xy-tilt degree in angular correlation.\n    edge_sigma : bool, default 2.0\n        Check if cylindric structures are densely packed. Initial spline position\n        must be \"almost\" fitted in dense mode.\n    max_shift : nm, default 5.0\n        Maximum shift to be applied to each point of splines.\n    \"\"\"\n    tomo = self.tomogram\n    splines = self._norm_splines(splines)\n    with SplineTracker(widget=self, indices=splines) as tracker:\n        for i in splines:\n            tomo.fit(\n                i,\n                max_interval=max_interval,\n                binsize=bin_size,\n                err_max=err_max,\n                degree_precision=degree_precision,\n                edge_sigma=edge_sigma,\n                max_shift=max_shift,\n            )\n            yield thread_worker.callback(self._update_splines_in_images)\n\n        @thread_worker.callback\n        def out():\n            self._init_widget_state()\n            self._update_splines_in_images()\n            return tracker.as_undo_callback()\n\n    return out\n</code></pre>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.fit_splines_by_centroid","title":"<code>fit_splines_by_centroid(splines=None, max_interval=30, bin_size=1.0, err_max=1.0, max_shift=5.0)</code>","text":"<p>Fit splines to the cylinder by centroid of sub-volumes.</p> <p>Parameters:</p> Name Type Description Default <code>splines</code> <code>list of int</code> <p>Indices of splines to be used.</p> <code>None</code> <code>max_interval</code> <code>nm</code> <p>Maximum interval (nm) between spline anchors.</p> <code>30</code> <code>bin_size</code> <code>int</code> <p>Bin size of multiscale image to be used. Set to &gt;1 to boost performance.</p> <code>1.0</code> <code>err_max</code> <code>float</code> <p>S.D. allowed for spline fitting. Larger value will result in smoother spline, i.e. fewer spline knots.</p> <code>1.0</code> <code>max_shift</code> <code>nm</code> <p>Maximum shift to be applied to each point of splines.</p> <code>5.0</code> Source code in <code>cylindra/widgets/main.py</code> <pre><code>@set_design(text=capitalize, location=_sw.SplinesMenu.Fitting)\n@thread_worker.with_progress(desc=\"Spline Fitting\", total=_NSPLINES)\ndef fit_splines_by_centroid(\n    self,\n    splines: SplinesType = None,\n    max_interval: Annotated[nm, {\"label\": \"max interval (nm)\"}] = 30,\n    bin_size: Annotated[int, {\"choices\": _get_available_binsize}] = 1.0,\n    err_max: Annotated[nm, {\"label\": \"max fit error (nm)\", \"step\": 0.1}] = 1.0,\n    max_shift: nm = 5.0,\n):  # fmt: skip\n    \"\"\"Fit splines to the cylinder by centroid of sub-volumes.\n\n    Parameters\n    ----------\n    {splines}{max_interval}{bin_size}{err_max}\n    max_shift : nm, default 5.0\n        Maximum shift to be applied to each point of splines.\n    \"\"\"\n    tomo = self.tomogram\n    splines = self._norm_splines(splines)\n    with SplineTracker(widget=self, indices=splines) as tracker:\n        for i in splines:\n            tomo.fit_centroid(\n                i,\n                max_interval=max_interval,\n                binsize=bin_size,\n                err_max=err_max,\n                max_shift=max_shift,\n            )\n            yield thread_worker.callback(self._update_splines_in_images)\n\n        @thread_worker.callback\n        def out():\n            self._init_widget_state()\n            self._update_splines_in_images()\n            return tracker.as_undo_callback()\n\n    return out\n</code></pre>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.get_loader","title":"<code>get_loader(name, output_shape=None, order=1)</code>","text":"<p>Create a subtomogram loader using current tomogram and a molecules layer.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the molecules layer.</p> required <code>order</code> <code>int</code> <p>Interpolation order of the subtomogram loader.</p> <code>1</code> Source code in <code>cylindra/widgets/main.py</code> <pre><code>@nogui\n@do_not_record\ndef get_loader(\n    self,\n    name: str,\n    output_shape: \"tuple[nm, nm, nm] | None\" = None,\n    order: int = 1,\n) -&gt; SubtomogramLoader:\n    \"\"\"Create a subtomogram loader using current tomogram and a molecules layer.\n\n    Parameters\n    ----------\n    name : str, optional\n        Name of the molecules layer.\n    order : int, default 1\n        Interpolation order of the subtomogram loader.\n    \"\"\"\n    mole = self.mole_layers[name].molecules\n    return self.tomogram.get_subtomogram_loader(mole, output_shape, order=order)\n</code></pre>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.global_cft_analysis","title":"<code>global_cft_analysis(splines=None, bin_size=1)</code>","text":"<p>Determine cylindrical global structural parameters by Fourier transformation.</p> <p>Parameters:</p> Name Type Description Default <code>splines</code> <code>list of int</code> <p>Indices of splines to be used.</p> <code>None</code> <code>bin_size</code> <code>int</code> <p>Bin size of multiscale image to be used. Set to &gt;1 to boost performance.</p> <code>1</code> Source code in <code>cylindra/widgets/main.py</code> <pre><code>@set_design(text=\"Global CFT analysis\", location=_sw.AnalysisMenu)\n@thread_worker.with_progress(desc=\"Global Cylindric Fourier transform\", total=_NSPLINES)  # fmt: skip\ndef global_cft_analysis(\n    self,\n    splines: SplinesType = None,\n    bin_size: Annotated[int, {\"choices\": _get_available_binsize}] = 1,\n):  # fmt: skip\n    \"\"\"Determine cylindrical global structural parameters by Fourier transformation.\n\n    Parameters\n    ----------\n    {splines}{bin_size}\n    \"\"\"\n    tomo = self.tomogram\n    splines = self._norm_splines(splines)\n\n    with SplineTracker(widget=self, indices=splines, sample=True) as tracker:\n        for i in splines:\n            spl = tomo.splines[i]\n            if spl.radius is None:\n                tomo.measure_radius(i=i)\n            tomo.global_cft_params(i=i, binsize=bin_size)\n            yield\n\n        # show all in a table\n        @thread_worker.callback\n        def _global_cft_analysis_on_return():\n            df = (\n                pl.concat(\n                    [tomo.splines[i].props.glob for i in splines],\n                    how=\"vertical_relaxed\",\n                )\n                .to_pandas()\n                .transpose()\n            )\n            df.columns = [f\"Spline-{i}\" for i in range(len(df.columns))]\n            self.sample_subtomograms()\n            _Logger.print_table(df, precision=3)\n            self._update_global_properties_in_widget()\n\n            return tracker.as_undo_callback()\n\n    return _global_cft_analysis_on_return\n</code></pre>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.infer_polarity","title":"<code>infer_polarity(splines=None, depth=40, bin_size=1)</code>","text":"<p>Automatically detect the cylinder polarities.</p> <p>This function uses Fourier vorticity to detect the polarities of the splines. The subtomogram at the center of the spline will be sampled in the cylindric coordinate and the power spectra in (radius, angle) space will be calculated. The peak position of the <code>angle = nPF</code> line scan will be used to detect the polarity of the spline.</p> <p>Parameters:</p> Name Type Description Default <code>splines</code> <code>list of int</code> <p>Indices of splines to be used.</p> <code>None</code> <code>depth</code> <code>nm</code> <p>Depth (length parallel to the spline tangent) of the subtomograms to be sampled.</p> <code>40</code> <code>bin_size</code> <code>int</code> <p>Bin size of multiscale image to be used. Set to &gt;1 to boost performance.</p> <code>1</code> Source code in <code>cylindra/widgets/main.py</code> <pre><code>@set_design(text=capitalize, location=_sw.SplinesMenu.Orientation)\n@thread_worker.with_progress(desc=\"Auto-detecting polarities...\", total=_NSPLINES)\ndef infer_polarity(\n    self,\n    splines: SplinesType = None,\n    depth: Annotated[nm, {\"min\": 5.0, \"max\": 500.0, \"step\": 5.0}] = 40,\n    bin_size: Annotated[int, {\"choices\": _get_available_binsize}] = 1,\n):  # fmt: skip\n    \"\"\"Automatically detect the cylinder polarities.\n\n    This function uses Fourier vorticity to detect the polarities of the splines.\n    The subtomogram at the center of the spline will be sampled in the cylindric\n    coordinate and the power spectra in (radius, angle) space will be calculated.\n    The peak position of the `angle = nPF` line scan will be used to detect the\n    polarity of the spline.\n\n    Parameters\n    ----------\n    {splines}{depth}{bin_size}\n    \"\"\"\n    tomo = self.tomogram\n    _old_orientations = [spl.orientation for spl in self.tomogram.splines]\n    for i in self._norm_splines(splines):\n        tomo.infer_polarity(i=i, binsize=bin_size, depth=depth, update=True)\n        yield\n    _new_orientations = [spl.orientation for spl in self.tomogram.splines]\n\n    @thread_worker.callback\n    def _on_return():\n        self._update_splines_in_images()\n        for i in range(len(tomo.splines)):\n            self._set_orientation_marker(i)\n\n        self.SplineControl._update_canvas()\n        return (\n            undo_callback(self._set_orientations)\n            .with_args(_old_orientations)\n            .with_redo(lambda: self._set_orientations(_new_orientations))\n        )\n\n    return _on_return\n</code></pre>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.interaction_to_molecules","title":"<code>interaction_to_molecules(interaction, which='origin')</code>","text":"<p>Make a molecules layer from the interaction network.</p> <p>Parameters:</p> Name Type Description Default <code>interaction</code> <code>InteractionVector</code> <p>The layer of interaction network.</p> required <code>which</code> <code>(origin, target or both)</code> <p>Specify which molecules will be added.</p> <code>'origin'</code> Source code in <code>cylindra/widgets/main.py</code> <pre><code>@set_design(text=capitalize, location=_sw.AnalysisMenu.Interaction)\ndef interaction_to_molecules(\n    self,\n    interaction: _InteractionNetType,\n    which: Literal[\"origin\", \"target\", \"both\"] = \"origin\",\n):\n    \"\"\"Make a molecules layer from the interaction network.\n\n    Parameters\n    ----------\n    interaction : InteractionVector\n        The layer of interaction network.\n    which : \"origin\", \"target\" or \"both\", optional\n        Specify which molecules will be added.\n    \"\"\"\n    layer = assert_interaction_vectors(interaction, self.parent_viewer)\n    m0 = layer.net.molecules_origin.subset(layer.net.indices_origin)\n    m1 = layer.net.molecules_target.subset(layer.net.indices_target)\n    match which:\n        case \"origin\":\n            mole = m0\n        case \"target\":\n            mole = m1\n        case \"both\":\n            mole = m0.concat_with(m1)\n        case _:  # pragma: no cover\n            raise ValueError(f\"Unknown option: {which!r}.\")\n    return self.add_molecules(mole, name=f\"{which} of {layer.name}\")\n</code></pre>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.interpolate_spline_properties","title":"<code>interpolate_spline_properties(layer, interpolation=3, suffix='_spl')</code>","text":"<p>Add new features by interpolating spline local properties.</p> <p>Parameters:</p> Name Type Description Default <code>layer</code> <code>MoleculesLayer</code> <p>Points layer of molecules to be used.</p> required <code>interpolation</code> <code>int</code> <p>Interpolation order.</p> <code>3</code> <code>suffix</code> <code>str</code> <p>Suffix of the new feature column names.</p> <code>\"_spl\"</code> Source code in <code>cylindra/widgets/main.py</code> <pre><code>@set_design(text=capitalize, location=_sw.MoleculesMenu.Features)\ndef interpolate_spline_properties(\n    self,\n    layer: MoleculesLayerType,\n    interpolation: int = 3,\n    suffix: str = \"_spl\",\n):\n    \"\"\"Add new features by interpolating spline local properties.\n\n    Parameters\n    ----------\n    {layer}{interpolation}\n    suffix : str, default \"_spl\"\n        Suffix of the new feature column names.\n    \"\"\"\n    layer = assert_layer(layer, self.parent_viewer)\n    spl = _assert_source_spline_exists(layer)\n    feat = layer.molecules.features\n    anc = spl.anchors\n    interp = utils.interp(\n        anc, spl.props.loc.to_numpy(), order=interpolation, axis=0\n    )\n    pos_nm = feat[Mole.position].to_numpy()\n    values = interp(spl.y_to_position(pos_nm).clip(anc.min(), anc.max()))\n    layer.molecules = layer.molecules.with_features(\n        [\n            pl.Series(f\"{c}{suffix}\", values[:, i])\n            for i, c in enumerate(spl.props.loc.columns)\n        ]\n    )\n    self.reset_choices()  # choices regarding of features need update\n    return undo_callback(layer.feature_setter(feat, layer.colormap_info))\n</code></pre>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.invert_image","title":"<code>invert_image()</code>","text":"<p>Invert the intensity of the images.</p> Source code in <code>cylindra/widgets/main.py</code> <pre><code>@thread_worker.with_progress(desc=\"Inverting image\")\n@set_design(text=capitalize, location=_sw.ImageMenu)\ndef invert_image(self):\n    \"\"\"Invert the intensity of the images.\"\"\"\n    t0 = timer()\n    self.tomogram.invert()\n    if self._reserved_layers.is_lazy:\n\n        @thread_worker.callback\n        def _invert_image_on_return():\n            return undo_callback(self.invert_image)\n\n    else:\n        img_inv = -self._reserved_layers.image.data\n        cmin, cmax = fast_percentile(img_inv, [1, 99.9])\n        if cmin &gt;= cmax:\n            cmax = cmin + 1\n\n        @thread_worker.callback\n        def _invert_image_on_return():\n            self._reserved_layers.image.data = img_inv\n            self._reserved_layers.image.contrast_limits = (cmin, cmax)\n            clow, chigh = self.Overview.contrast_limits\n            self.Overview.image = -self.Overview.image\n            self.Overview.contrast_limits = -chigh, -clow\n            return undo_callback(self.invert_image)\n\n    t0.toc()\n    return _invert_image_on_return\n</code></pre>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.invert_spline","title":"<code>invert_spline(spline=None)</code>","text":"<p>Invert current displayed spline in place.</p> <p>Parameters:</p> Name Type Description Default <code>spline</code> <code>int</code> <p>ID of splines to be inverted.</p> <code>None</code> Source code in <code>cylindra/widgets/main.py</code> <pre><code>@set_design(text=capitalize, location=_sw.SplinesMenu.Orientation)\ndef invert_spline(self, spline: Annotated[int, {\"bind\": _get_spline_idx}] = None):\n    \"\"\"Invert current displayed spline **in place**.\n\n    Parameters\n    ----------\n    spline : int, optional\n        ID of splines to be inverted.\n    \"\"\"\n    if spline is None:\n        return\n    spl = self.tomogram.splines[spline]\n    self.tomogram.splines[spline] = spl.invert()\n    self._update_splines_in_images()\n    self.reset_choices()\n\n    need_resample = self.SplineControl.need_resample\n    self._init_widget_state()\n    if need_resample:\n        self.sample_subtomograms()\n    self._set_orientation_marker(spline)\n    return undo_callback(self.invert_spline).with_args(spline)\n</code></pre>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.label_feature_clusters","title":"<code>label_feature_clusters(layer, target, suffix='_label')</code>","text":"<p>Label a binarized feature column based on the molecules structure.</p> <p>This method does the similar task as <code>scipy.ndimage.label</code>, where the isolated \"islands\" of True values will be labeled by position integers.</p> <p>Parameters:</p> Name Type Description Default <code>layer</code> <code>MoleculesLayer</code> <p>Points layer of molecules to be used.</p> required <code>target</code> <code>str</code> <p>Target column name on which calculation will run.</p> required <code>suffix</code> <code>str</code> <p>Suffix of the new feature column name.</p> <code>\"_binarize\"</code> Source code in <code>cylindra/widgets/main.py</code> <pre><code>@set_design(text=capitalize, location=_sw.MoleculesMenu.Features)\ndef label_feature_clusters(\n    self,\n    layer: MoleculesLayerType,\n    target: Annotated[str, {\"choices\": _choice_getter(\"label_feature_clusters\", dtype_kind=\"b\")}],\n    suffix: str = \"_label\",\n):  # fmt: skip\n    \"\"\"Label a binarized feature column based on the molecules structure.\n\n    This method does the similar task as `scipy.ndimage.label`, where the isolated\n    \"islands\" of True values will be labeled by position integers.\n\n    Parameters\n    ----------\n    {layer}{target}\n    suffix : str, default \"_binarize\"\n        Suffix of the new feature column name.\n    \"\"\"\n    from napari.utils.colormaps import label_colormap\n\n    layer = assert_layer(layer, self.parent_viewer)\n    utils.assert_column_exists(layer.molecules.features, target)\n    if suffix == \"\":\n        raise ValueError(\"`suffix` cannot be empty.\")\n    feat, cmap_info = layer.molecules.features, layer.colormap_info\n    nrise = _assert_source_spline_exists(layer).nrise()\n    out = cylfilters.label(layer.molecules.features, target, nrise)\n    feature_name = f\"{target}{suffix}\"\n    layer.molecules = layer.molecules.with_features(out.alias(feature_name))\n    self.reset_choices()\n    label_max = int(out.max())\n    cmap = label_colormap(label_max, seed=0.9414)\n    layer.set_colormap(feature_name, (0, label_max), cmap)\n    self.reset_choices()  # choices regarding of features need update\n    return undo_callback(layer.feature_setter(feat, cmap_info))\n</code></pre>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.label_molecules_by_interaction","title":"<code>label_molecules_by_interaction(layer, interaction, column_name='interacting', label_id=1)</code>","text":"<p>Label molecules by the interaction network.</p> <p>Parameters:</p> Name Type Description Default <code>layer</code> <code>MoleculesLayer</code> <p>The layer of molecules to be labeled.</p> required <code>interaction</code> <code>InteractionVector</code> <p>The layer of interaction network.</p> required <code>column_name</code> <code>str</code> <p>Name of the new feature column.</p> <code>\"interacting\"</code> <code>label_id</code> <code>int</code> <p>The label ID to be assigned to the interacting molecules.</p> <code>1</code> Source code in <code>cylindra/widgets/main.py</code> <pre><code>@set_design(text=capitalize, location=_sw.AnalysisMenu.Interaction)\ndef label_molecules_by_interaction(\n    self,\n    layer: MoleculesLayerType,\n    interaction: _InteractionNetType,\n    column_name: str = \"interacting\",\n    label_id: Annotated[int, {\"min\": 1}] = 1,\n):\n    \"\"\"Label molecules by the interaction network.\n\n    Parameters\n    ----------\n    layer : MoleculesLayer\n        The layer of molecules to be labeled.\n    interaction : InteractionVector\n        The layer of interaction network.\n    column_name : str, default \"interacting\"\n        Name of the new feature column.\n    label_id : int, default 1\n        The label ID to be assigned to the interacting molecules.\n    \"\"\"\n    layer = assert_layer(layer, self.parent_viewer)\n    net = assert_interaction_vectors(interaction, self.parent_viewer).net\n    if net.molecules_origin is layer.molecules:\n        indices = net.indices_origin\n    elif net.molecules_target is layer.molecules:\n        indices = net.indices_target\n    else:\n        raise ValueError(\n            \"Neither origin nor target of the interaction are the molecules from \"\n            \"the molecules layer. Two layers must share the reference to the same \"\n            \"molecules.\"\n        )\n    feat = layer.molecules.features\n    if column_name in feat:\n        new_column = feat[column_name].to_numpy()\n    else:\n        new_column = np.zeros(len(layer.molecules), dtype=np.uint8)\n    new_column[indices] = label_id\n    new_feat = pl.Series(column_name, new_column)\n    layer.molecules = layer.molecules.with_features(new_feat)\n    self.reset_choices()  # choices regarding of features need update\n    return undo_callback(layer.feature_setter(feat))\n</code></pre>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.load_molecules","title":"<code>load_molecules(paths)</code>","text":"<p>Load molecules from a csv file.</p> Source code in <code>cylindra/widgets/main.py</code> <pre><code>@set_design(text=capitalize, location=_sw.FileMenu)\ndef load_molecules(self, paths: Path.Multiple[FileFilter.MOLE]):\n    \"\"\"Load molecules from a csv file.\"\"\"\n    if isinstance(paths, str | Path | bytes):\n        paths = [paths]\n    moles = [Molecules.from_file(path) for path in paths]\n    for mole, path in zip(moles, paths, strict=False):\n        name = Path(path).stem\n        add_molecules(self.parent_viewer, mole, name)\n</code></pre>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.load_project","title":"<code>load_project(path, filter=ImageFilter.Lowpass, read_image=True, read_reference=True, update_config=False)</code>","text":"<p>Load a project file (project.json, tar file or zip file).</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>path - like or CylindraProject</code> <p>Path to the project file, or the project directory that contains a project file, or a CylindraProject object.</p> required <code>filter</code> <code>ImageFilter</code> <p>Filter to be applied to the reference image. This does not affect the image data itself.</p> <ul> <li>Lowpass: butterworth low-pass filter.</li> <li>Gaussian: Gaussian blur.</li> <li>DoG: difference of Gaussian.</li> <li>LoG: Laplacian of Gaussian.</li> </ul> <code>Lowpass</code> <code>read_image</code> <code>bool</code> <p>Whether to read image data from the project directory. If false, image data will be memory-mapped and will not be shown in the viewer, or the reference image will be shown instead if <code>read_reference</code> is true. Unchecking this is useful to decrease loading time.</p> <code>True</code> <code>read_reference</code> <code>bool</code> <p>Whether to read the reference image instead of calculating it from the loaded image data, if available.</p> <code>True</code> <code>update_config</code> <code>bool</code> <p>Whether to update the default spline configuration with the one described in the project.</p> <code>False</code> Source code in <code>cylindra/widgets/main.py</code> <pre><code>@set_design(text=capitalize, location=_sw.FileMenu)\n@thread_worker.with_progress(desc=\"Reading project\", total=0)\n@confirm(text=\"You may have unsaved data. Open a new project?\", condition=\"self._need_save\")  # fmt: skip\n@do_not_record\n@bind_key(\"Ctrl+K, Ctrl+P\")\ndef load_project(\n    self,\n    path: Path.Read[FileFilter.PROJECT],\n    filter: ImageFilter | None = ImageFilter.Lowpass,\n    read_image: Annotated[bool, {\"label\": \"read image data\"}] = True,\n    read_reference: Annotated[bool, {\"label\": \"read reference image\"}] = True,\n    update_config: bool = False,\n):\n    \"\"\"Load a project file (project.json, tar file or zip file).\n\n    Parameters\n    ----------\n    path : path-like or CylindraProject\n        Path to the project file, or the project directory that contains a project\n        file, or a CylindraProject object.\n    {filter}\n    read_image : bool, default True\n        Whether to read image data from the project directory. If false, image data\n        will be memory-mapped and will not be shown in the viewer, or the reference\n        image will be shown instead if `read_reference` is true. Unchecking this is\n        useful to decrease loading time.\n    read_reference : bool, default True\n        Whether to read the reference image instead of calculating it from the\n        loaded image data, if available.\n    update_config : bool, default False\n        Whether to update the default spline configuration with the one described\n        in the project.\n    \"\"\"\n    if isinstance(path, CylindraProject):\n        project = path\n        project_path = project.project_path\n    else:\n        project = CylindraProject.from_file(path)\n        project_path = project.project_path\n    _Logger.print_html(\n        f\"&lt;code&gt;ui.load_project('{Path(project_path).as_posix()}', \"\n        f\"filter={str(filter)!r}, {read_image=}, {read_reference=}, \"\n        f\"{update_config=})&lt;/code&gt;\"\n    )\n    yield from project._to_gui(\n        self,\n        filter=filter,\n        read_image=read_image,\n        read_reference=read_reference,\n        update_config=update_config,\n    )\n    if project_path is not None:\n        self._project_dir = project_path\n    _Logger.print(f\"Project loaded: {project_path.as_posix()}\")\n</code></pre>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.load_project_for_reanalysis","title":"<code>load_project_for_reanalysis(path)</code>","text":"<p>Load a project file to re-analyze the data.</p> <p>This method will extract the first manual operations from a project file and run them. This is useful when you want to re-analyze the data with a different parameter set, or when there were some improvements in cylindra.</p> Source code in <code>cylindra/widgets/main.py</code> <pre><code>@set_design(text=\"Re-analyze project\", location=_sw.AnalysisMenu)\n@do_not_record\n@bind_key(\"Ctrl+K, Ctrl+L\")\ndef load_project_for_reanalysis(self, path: Path.Read[FileFilter.PROJECT]):\n    \"\"\"Load a project file to re-analyze the data.\n\n    This method will extract the first manual operations from a project file and\n    run them. This is useful when you want to re-analyze the data with a different\n    parameter set, or when there were some improvements in cylindra.\n    \"\"\"\n    macro = self._get_reanalysis_macro(path)\n    macro.eval({mk.symbol(self): self})\n    return self.macro.clear_undo_stack()\n</code></pre>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.load_splines","title":"<code>load_splines(paths)</code>","text":"<p>Load splines from a list of json paths.</p> <p>Parameters:</p> Name Type Description Default <code>paths</code> <code>list of path-like objects</code> <p>Paths to json files that describe spline parameters in the correct format.</p> required Source code in <code>cylindra/widgets/main.py</code> <pre><code>@set_design(text=capitalize, location=_sw.FileMenu)\ndef load_splines(self, paths: Path.Multiple[FileFilter.JSON]):\n    \"\"\"Load splines from a list of json paths.\n\n    Parameters\n    ----------\n    paths : list of path-like objects\n        Paths to json files that describe spline parameters in the correct format.\n    \"\"\"\n    if isinstance(paths, str | Path | bytes):\n        paths = [paths]\n    splines = [CylSpline.from_json(path) for path in paths]\n    self.tomogram.splines.extend(splines)\n    self._update_splines_in_images()\n    self.reset_choices()\n</code></pre>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.load_volumes","title":"<code>load_volumes(paths)</code>","text":"<p>Load 3D volume(s) to the sub-viewer.</p> Source code in <code>cylindra/widgets/main.py</code> <pre><code>@set_design(text=capitalize, location=_sw.FileMenu)\ndef load_volumes(self, paths: Path.Multiple[FileFilter.IMAGE]):\n    \"\"\"Load 3D volume(s) to the sub-viewer.\"\"\"\n    for path in paths:\n        img = ip.imread(path)\n        if img.ndim != 3:\n            raise ValueError(\"Input image must be 3-D.\")\n        self.sta._show_rec(img, name=img.name)\n</code></pre>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.local_cft_analysis","title":"<code>local_cft_analysis(splines=None, interval=None, depth=50.0, bin_size=1, radius='global', update_glob=False)</code>","text":"<p>Determine local lattice parameters by local cylindric Fourier transformation.</p> <p>This method will sample subtomograms at given intervals and calculate the power spectra in a cylindrical coordinate. The peak position of the power spectra will be used to determine the lattice parameters. Note that if the interval differs from the current spline anchors, the old local properties will be dropped.</p> <p>Parameters:</p> Name Type Description Default <code>splines</code> <code>list of int</code> <p>Indices of splines to be used.</p> <code>None</code> <code>interval</code> <code>nm</code> <p>Interval (nm) between spline anchors. Please note that resetting interval will discard all the existing local properties.</p> <code>None</code> <code>depth</code> <code>nm</code> <p>Depth (length parallel to the spline tangent) of the subtomograms to be sampled.</p> <code>50.0</code> <code>bin_size</code> <code>int</code> <p>Bin size of multiscale image to be used. Set to &gt;1 to boost performance.</p> <code>1</code> <code>radius</code> <code>str</code> <p>If \"local\", use the local radius for the analysis. If \"global\", use the global radius.</p> <code>\"global\"</code> <code>update_glob</code> <code>bool</code> <p>If true, also update the global property to the mean of local properties.</p> <code>False</code> Source code in <code>cylindra/widgets/main.py</code> <pre><code>@set_design(text=\"Local CFT analysis\", location=_sw.AnalysisMenu)\n@thread_worker.with_progress(desc=\"Local Cylindric Fourier transform\", total=_NSPLINES)  # fmt: skip\ndef local_cft_analysis(\n    self,\n    splines: SplinesType = None,\n    interval: _Interval = None,\n    depth: Annotated[nm, {\"min\": 2.0, \"step\": 0.5}] = 50.0,\n    bin_size: Annotated[int, {\"choices\": _get_available_binsize}] = 1,\n    radius: Literal[\"local\", \"global\"] = \"global\",\n    update_glob: Annotated[bool, {\"text\": \"Also update the global properties\"}] = False,\n):  # fmt: skip\n    \"\"\"Determine local lattice parameters by local cylindric Fourier transformation.\n\n    This method will sample subtomograms at given intervals and calculate the power\n    spectra in a cylindrical coordinate. The peak position of the power spectra will\n    be used to determine the lattice parameters. Note that if the interval differs\n    from the current spline anchors, the old local properties will be dropped.\n\n    Parameters\n    ----------\n    {splines}{interval}{depth}{bin_size}\n    radius : str, default \"global\"\n        If \"local\", use the local radius for the analysis. If \"global\", use the\n        global radius.\n    {update_glob}\n    \"\"\"\n    tomo = self.tomogram\n    splines = self._norm_splines(splines)\n\n    # first check radius\n    match radius:\n        case \"global\":\n            for i in splines:\n                if tomo.splines[i].radius is None:\n                    raise ValueError(\n                        f\"Global Radius of {i}-th spline is not measured yet. Please \"\n                        \"measure the radius first from `Analysis &gt; Radius`.\"\n                    )\n        case \"local\":\n            for i in splines:\n                if not tomo.splines[i].props.has_loc(H.radius):\n                    raise ValueError(\n                        f\"Local Radius of {i}-th spline is not measured yet. Please \"\n                        \"measure the radius first from `Analysis &gt; Radius`.\"\n                    )\n            if interval is not None:\n                raise ValueError(\n                    \"With `interval`, local radius values will be dropped. Please \"\n                    \"set `radius='global'` or `interval=None`.\"\n                )\n        case _:\n            raise ValueError(f\"radius must be 'local' or 'global', got {radius!r}.\")\n\n    @thread_worker.callback\n    def _local_cft_analysis_on_yield(i: int):\n        self._update_splines_in_images()\n        if i == self.SplineControl.num:\n            self.sample_subtomograms()\n\n    with SplineTracker(widget=self, indices=splines, sample=True) as tracker:\n        for i in splines:\n            if interval is not None:\n                tomo.make_anchors(i=i, interval=interval)\n            tomo.local_cft_params(\n                i=i,\n                depth=depth,\n                binsize=bin_size,\n                radius=radius,\n                update_glob=update_glob,\n            )\n            yield _local_cft_analysis_on_yield.with_args(i)\n        return tracker.as_undo_callback()\n</code></pre>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.map_along_pf","title":"<code>map_along_pf(spline, molecule_interval=\"col('spacing')\", offsets=None, orientation=None, prefix='PF')</code>","text":"<p>Map molecules along the line of a protofilament.</p> <p>Parameters:</p> Name Type Description Default <code>spline</code> <code>int</code> <p>Index of splines to be used.</p> required <code>molecule_interval</code> <code>nm</code> <p>Interval (nm) between molecules. <code>col</code> is available in this namespace to refer to the spline global properties. For example, <code>col('spacing') * 2</code> means twice the spacing of the spline.</p> <code>\"col('spacing')\"</code> <code>offsets</code> <code>(float, float)</code> <p>Offset values that will be used to define molecule positions.</p> <code>None</code> <code>orientation</code> <code>(None, PlusToMinus, MinusToPlus)</code> <p>Orientation of molecules' y-axis. If none, use the current spline orientation as is.</p> <code>None</code> <code>prefix</code> <code>str</code> <p>Prefix of the new molecules layer(s).</p> <code>'PF'</code> Source code in <code>cylindra/widgets/main.py</code> <pre><code>@set_design(text=\"Map alogn PF\", location=_sw.MoleculesMenu.FromToSpline)\ndef map_along_pf(\n    self,\n    spline: Annotated[int, {\"choices\": _get_splines}],\n    molecule_interval: PolarsExprStrOrScalar = \"col('spacing')\",\n    offsets: _OffsetType = None,\n    orientation: Literal[None, \"PlusToMinus\", \"MinusToPlus\"] = None,\n    prefix: str = \"PF\",\n):  # fmt: skip\n    \"\"\"Map molecules along the line of a protofilament.\n\n    Parameters\n    ----------\n    {spline}{molecule_interval}{offsets}{orientation}{prefix}\n    \"\"\"\n    tomo = self.tomogram\n    interv_expr = widget_utils.norm_scalar_expr(molecule_interval)\n    spl = tomo.splines[spline]\n    _Logger.print_html(\"&lt;code&gt;map_along_PF&lt;/code&gt;\")\n    mol = tomo.map_pf_line(\n        i=spline,\n        interval=spl.props.get_glob(interv_expr),\n        offsets=normalize_offsets(offsets, spl),\n        orientation=orientation,\n    )\n    _name = f\"{prefix}-{spline}\"\n    layer = self.add_molecules(mol, _name, source=spl)\n    _Logger.print(f\"{_name!r}: n = {len(mol)}\")\n    return self._undo_callback_for_layer(layer)\n</code></pre>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.map_along_spline","title":"<code>map_along_spline(splines=None, molecule_interval=\"col('spacing')\", orientation=None, rotate_molecules=True, prefix='Center')</code>","text":"<p>Map molecules along splines. Each molecule is rotated by skewing.</p> <p>Parameters:</p> Name Type Description Default <code>splines</code> <code>list of int</code> <p>Indices of splines to be used.</p> <code>None</code> <code>molecule_interval</code> <code>nm</code> <p>Interval (nm) between molecules. <code>col</code> is available in this namespace to refer to the spline global properties. For example, <code>col('spacing') * 2</code> means twice the spacing of the spline.</p> <code>\"col('spacing')\"</code> <code>orientation</code> <code>(None, PlusToMinus, MinusToPlus)</code> <p>Orientation of molecules' y-axis. If none, use the current spline orientation as is.</p> <code>None</code> <code>rotate_molecules</code> <code>bool</code> <p>If True, rotate molecules by the \"twist\" parameter of each spline.</p> <code>True</code> <code>prefix</code> <code>str</code> <p>Prefix of the new molecules layer(s).</p> <code>'Center'</code> Source code in <code>cylindra/widgets/main.py</code> <pre><code>@set_design(text=capitalize, location=_sw.MoleculesMenu.FromToSpline)\ndef map_along_spline(\n    self,\n    splines: SplinesType = None,\n    molecule_interval: PolarsExprStrOrScalar = \"col('spacing')\",\n    orientation: Literal[None, \"PlusToMinus\", \"MinusToPlus\"] = None,\n    rotate_molecules: bool = True,\n    prefix: str = \"Center\",\n):  # fmt: skip\n    \"\"\"Map molecules along splines. Each molecule is rotated by skewing.\n\n    Parameters\n    ----------\n    {splines}{molecule_interval}{orientation}\n    rotate_molecules : bool, default True\n        If True, rotate molecules by the \"twist\" parameter of each spline.\n    {prefix}\n    \"\"\"\n    tomo = self.tomogram\n    interv_expr = widget_utils.norm_scalar_expr(molecule_interval)\n    splines = self._norm_splines(splines)\n    _Logger.print_html(\"&lt;code&gt;map_along_spline&lt;/code&gt;\")\n    _added_layers = list[MoleculesLayer]()\n    for idx in splines:\n        spl = tomo.splines[idx]\n        interv = spl.props.get_glob(interv_expr)\n        mole = tomo.map_centers(\n            i=idx,\n            interval=interv,\n            orientation=orientation,\n            rotate_molecules=rotate_molecules,\n        )\n        _name = f\"{prefix}-{idx}\"\n        layer = self.add_molecules(mole, _name, source=spl)\n        _added_layers.append(layer)\n        _Logger.print(f\"{_name!r}: n = {mole.count()}\")\n    return self._undo_callback_for_layer(_added_layers)\n</code></pre>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.map_along_spline_helical_symmetry","title":"<code>map_along_spline_helical_symmetry(splines=None, orientation=None, prefix='Center')</code>","text":"<p>Map molecules along splines considering helical symmetry.</p> <p>This method is mainly used for subtomogram averaging of a structure with helical symmetry. For example, if the cylindrical structure is a 14_3 microtubule, this method will map molecules at 4 nm / 14 interval with proper rotations.</p> <p>Parameters:</p> Name Type Description Default <code>splines</code> <code>list of int</code> <p>Indices of splines to be used.</p> <code>None</code> <code>orientation</code> <code>(None, PlusToMinus, MinusToPlus)</code> <p>Orientation of molecules' y-axis. If none, use the current spline orientation as is.</p> <code>None</code> <code>prefix</code> <code>str</code> <p>Prefix of the new molecules layer(s).</p> <code>'Center'</code> Source code in <code>cylindra/widgets/main.py</code> <pre><code>@set_design(\n    text=\"Map along spline (helical symmetry)\",\n    location=_sw.MoleculesMenu.FromToSpline,\n)\ndef map_along_spline_helical_symmetry(\n    self,\n    splines: SplinesType = None,\n    orientation: Literal[None, \"PlusToMinus\", \"MinusToPlus\"] = None,\n    prefix: str = \"Center\",\n):\n    \"\"\"Map molecules along splines considering helical symmetry.\n\n    This method is mainly used for subtomogram averaging of a structure with helical\n    symmetry. For example, if the cylindrical structure is a 14_3 microtubule, this\n    method will map molecules at 4 nm / 14 interval with proper rotations.\n\n    Parameters\n    ----------\n    {splines}{orientation}{prefix}\n    \"\"\"\n    tomo = self.tomogram\n    splines = self._norm_splines(splines)\n    _Logger.print_html(\"&lt;code&gt;map_along_spline_helical_symmetry&lt;/code&gt;\")\n    _added_layers = list[MoleculesLayer]()\n    for idx in splines:\n        spl = tomo.splines[idx]\n        mole = tomo.map_centers_helical_symmetry(i=idx, orientation=orientation)\n        _name = f\"{prefix}-{idx}\"\n        layer = self.add_molecules(mole, _name, source=spl)\n        _added_layers.append(layer)\n        _Logger.print(f\"{_name!r}: n = {mole.count()}\")\n    return self._undo_callback_for_layer(_added_layers)\n</code></pre>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.map_monomers","title":"<code>map_monomers(splines=None, orientation=None, offsets=None, radius=None, extensions=(0, 0), prefix='Mole')</code>","text":"<p>Map monomers as a regular cylindric grid assembly.</p> <p>This method uses the spline global properties.</p> <p>Parameters:</p> Name Type Description Default <code>splines</code> <code>list of int</code> <p>Indices of splines to be used.</p> <code>None</code> <code>orientation</code> <code>(None, PlusToMinus, MinusToPlus)</code> <p>Orientation of molecules' y-axis. If none, use the current spline orientation as is.</p> <code>None</code> <code>offsets</code> <code>(float, float)</code> <p>Offset values that will be used to define molecule positions.</p> <code>None</code> <code>radius</code> <code>nm</code> <p>Radius of the cylinder to position monomers.</p> <code>None</code> <code>extensions</code> <code>(int, int)</code> <p>Number of molecules to extend. Should be a tuple of (prepend, append). Negative values will remove molecules.</p> <code>(0, 0)</code> <code>prefix</code> <code>str</code> <p>Prefix of the new molecules layer(s).</p> <code>'Mole'</code> Source code in <code>cylindra/widgets/main.py</code> <pre><code>@set_design(text=capitalize, location=_sw.MoleculesMenu.FromToSpline)\n@bind_key(\"M\")\n@thread_worker.with_progress(desc=\"Mapping monomers\", total=_NSPLINES)\ndef map_monomers(\n    self,\n    splines: SplinesType = None,\n    orientation: Literal[None, \"PlusToMinus\", \"MinusToPlus\"] = None,\n    offsets: _OffsetType = None,\n    radius: Optional[nm] = None,\n    extensions: Annotated[tuple[int, int], {\"options\": {\"min\": -100}}] = (0, 0),\n    prefix: str = \"Mole\",\n):  # fmt: skip\n    \"\"\"Map monomers as a regular cylindric grid assembly.\n\n    This method uses the spline global properties.\n\n    Parameters\n    ----------\n    {splines}{orientation}{offsets}\n    radius : nm, optional\n        Radius of the cylinder to position monomers.\n    extensions : (int, int), default (0, 0)\n        Number of molecules to extend. Should be a tuple of (prepend, append).\n        Negative values will remove molecules.\n    {prefix}\n    \"\"\"\n    tomo = self.tomogram\n\n    _Logger.print_html(\"&lt;code&gt;map_monomers&lt;/code&gt;\")\n    _added_layers = list[MoleculesLayer]()\n\n    @thread_worker.callback\n    def _add_molecules(mol: Molecules, name: str, spl: CylSpline):\n        layer = self.add_molecules(mol, name, source=spl)\n        _added_layers.append(layer)\n        _Logger.print(f\"{name!r}: n = {len(mol)}\")\n\n    for i in self._norm_splines(splines):\n        spl = tomo.splines[i]\n        mol = tomo.map_monomers(\n            i=i,\n            orientation=orientation,\n            offsets=normalize_offsets(offsets, spl),\n            radius=normalize_radius(radius, spl),\n            extensions=extensions,\n        )\n\n        cb = _add_molecules.with_args(mol, f\"{prefix}-{i}\", spl)\n        yield cb\n        cb.await_call()\n\n    return self._undo_callback_for_layer(_added_layers)\n</code></pre>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.map_monomers_with_extensions","title":"<code>map_monomers_with_extensions(spline, n_extend={}, orientation=None, offsets=None, radius=None, prefix='Mole')</code>","text":"<p>Map monomers as a regular cylindric grid assembly.</p> <p>This method uses the spline global properties.</p> <p>Parameters:</p> Name Type Description Default <code>spline</code> <code>int</code> <p>Index of splines to be used.</p> required <code>n_extend</code> <code>dict[int, (int, int)]</code> <p>Number of molecules to extend. Should be mapping from the PF index to the (prepend, append) number of molecules to add. Remove molecules if negative values are given.</p> <code>{}</code> <code>orientation</code> <code>(None, PlusToMinus, MinusToPlus)</code> <p>Orientation of molecules' y-axis. If none, use the current spline orientation as is.</p> <code>None</code> <code>offsets</code> <code>(float, float)</code> <p>Offset values that will be used to define molecule positions.</p> <code>None</code> <code>radius</code> <code>nm</code> <p>Radius of the cylinder to position monomers.</p> <code>None</code> <code>prefix</code> <code>str</code> <p>Prefix of the new molecules layer(s).</p> <code>'Mole'</code> Source code in <code>cylindra/widgets/main.py</code> <pre><code>@set_design(text=capitalize, location=_sw.MoleculesMenu.FromToSpline)\ndef map_monomers_with_extensions(\n    self,\n    spline: Annotated[int, {\"choices\": _get_splines}],\n    n_extend: Annotated[dict[int, tuple[int, int]], {\"label\": \"prepend/append\", \"widget_type\": ProtofilamentEdit}] = {},\n    orientation: Literal[None, \"PlusToMinus\", \"MinusToPlus\"] = None,\n    offsets: _OffsetType = None,\n    radius: Optional[nm] = None,\n    prefix: str = \"Mole\",\n):  # fmt: skip\n    \"\"\"Map monomers as a regular cylindric grid assembly.\n\n    This method uses the spline global properties.\n\n    Parameters\n    ----------\n    {spline}\n    n_extend : dict[int, (int, int)]\n        Number of molecules to extend. Should be mapping from the PF index to the (prepend,\n        append) number of molecules to add. Remove molecules if negative values are given.\n    {orientation}{offsets}\n    radius : nm, optional\n        Radius of the cylinder to position monomers.\n    {prefix}\n    \"\"\"\n    tomo = self.tomogram\n    spl = tomo.splines[spline]\n    coords = widget_utils.coordinates_with_extensions(spl, n_extend)\n    mole = tomo.map_on_grid(\n        i=spline,\n        coords=coords,\n        orientation=orientation,\n        offsets=normalize_offsets(offsets, spl),\n        radius=normalize_radius(radius, spl),\n    )\n    layer = self.add_molecules(mole, f\"{prefix}-{spline}\", source=spl)\n    return self._undo_callback_for_layer(layer)\n</code></pre>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.measure_local_radius","title":"<code>measure_local_radius(splines=None, interval=None, depth=50.0, bin_size=1, min_radius=1.0, max_radius=100.0, update_glob=True)</code>","text":"<p>Measure radius for each local region along splines.</p> <p>Parameters:</p> Name Type Description Default <code>splines</code> <code>list of int</code> <p>Indices of splines to be used.</p> <code>None</code> <code>interval</code> <code>nm</code> <p>Interval (nm) between spline anchors. Please note that resetting interval will discard all the existing local properties.</p> <code>None</code> <code>depth</code> <code>nm</code> <p>Depth (length parallel to the spline tangent) of the subtomograms to be sampled.</p> <code>50.0</code> <code>bin_size</code> <code>int</code> <p>Bin size of multiscale image to be used. Set to &gt;1 to boost performance.</p> <code>1</code> <code>min_radius</code> <code>nm</code> <p>Minimum possible radius in nm.</p> <code>1.0</code> <code>max_radius</code> <code>nm</code> <p>Maximum possible radius in nm.</p> <code>100.0</code> <code>update_glob</code> <code>bool</code> <p>If true, also update the global property to the mean of local properties.</p> <code>True</code> Source code in <code>cylindra/widgets/main.py</code> <pre><code>@set_design(text=capitalize, location=_sw.AnalysisMenu.Radius)\n@thread_worker.with_progress(desc=\"Measuring local radii\", total=_NSPLINES)\ndef measure_local_radius(\n    self,\n    splines: SplinesType = None,\n    interval: _Interval = None,\n    depth: Annotated[nm, {\"min\": 2.0, \"step\": 0.5}] = 50.0,\n    bin_size: Annotated[int, {\"choices\": _get_available_binsize}] = 1,\n    min_radius: Annotated[nm, {\"min\": 0.1, \"step\": 0.1}] = 1.0,\n    max_radius: Annotated[nm, {\"min\": 0.1, \"step\": 0.1}] = 100.0,\n    update_glob: Annotated[bool, {\"text\": \"Also update the global radius\"}] = True,\n):  # fmt: skip\n    \"\"\"Measure radius for each local region along splines.\n\n    Parameters\n    ----------\n    {splines}{interval}{depth}{bin_size}{min_radius}{max_radius}{update_glob}\n    \"\"\"\n    tomo = self.tomogram\n    splines = self._norm_splines(splines)\n\n    @thread_worker.callback\n    def _on_yield():\n        self._update_local_properties_in_widget(replot=True)\n\n    with SplineTracker(widget=self, indices=splines) as tracker:\n        for i in splines:\n            if interval is not None:\n                tomo.make_anchors(i=i, interval=interval)\n            tomo.local_radii(\n                i=i,\n                depth=depth,\n                binsize=bin_size,\n                min_radius=min_radius,\n                max_radius=max_radius,\n                update_glob=update_glob,\n            )\n            if i == splines[-1]:\n                yield _on_yield\n            else:\n                yield\n\n        return tracker.as_undo_callback()\n</code></pre>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.measure_radius","title":"<code>measure_radius(splines=None, bin_size=1, min_radius=1.0, max_radius=100.0)</code>","text":"<p>Measure cylinder radius for each spline curve.</p> <p>Parameters:</p> Name Type Description Default <code>splines</code> <code>list of int</code> <p>Indices of splines to be used.</p> <code>None</code> <code>bin_size</code> <code>int</code> <p>Bin size of multiscale image to be used. Set to &gt;1 to boost performance.</p> <code>1</code> <code>min_radius</code> <code>nm</code> <p>Minimum possible radius in nm.</p> <code>1.0</code> <code>max_radius</code> <code>nm</code> <p>Maximum possible radius in nm.</p> <code>100.0</code> Source code in <code>cylindra/widgets/main.py</code> <pre><code>@set_design(text=capitalize, location=_sw.AnalysisMenu.Radius)\n@thread_worker.with_progress(desc=\"Measuring Radius\", total=_NSPLINES)\ndef measure_radius(\n    self,\n    splines: SplinesType = None,\n    bin_size: Annotated[int, {\"choices\": _get_available_binsize}] = 1,\n    min_radius: Annotated[nm, {\"min\": 0.1, \"step\": 0.1}] = 1.0,\n    max_radius: Annotated[nm, {\"min\": 0.1, \"step\": 0.1}] = 100.0,\n):  # fmt: skip\n    \"\"\"Measure cylinder radius for each spline curve.\n\n    Parameters\n    ----------\n    {splines}{bin_size}{min_radius}{max_radius}\n    \"\"\"\n    splines = self._norm_splines(splines)\n    with SplineTracker(widget=self, indices=splines, sample=True) as tracker:\n        for i in splines:\n            self.tomogram.measure_radius(\n                i, binsize=bin_size, min_radius=min_radius, max_radius=max_radius\n            )\n            yield\n\n        return tracker.as_undo_callback()\n</code></pre>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.measure_radius_by_molecules","title":"<code>measure_radius_by_molecules(layers=(), interval=None, depth=50.0, update_glob=True)</code>","text":"<p>Measure local and global radius for each layer.</p> <p>Please note that the radius defined by the peak of the radial profile is not always the same as the radius measured by this method. If the molecules are aligned using a template image whose mass density is not centered, these radii may differ a lot.</p> <p>Parameters:</p> Name Type Description Default <code>layers</code> <code>list of MoleculesLayer</code> <p>All the points layers of molecules to be used.</p> <code>()</code> <code>interval</code> <code>nm</code> <p>Interval (nm) between spline anchors. Please note that resetting interval will discard all the existing local properties.</p> <code>None</code> <code>depth</code> <code>nm</code> <p>Depth (length parallel to the spline tangent) of the subtomograms to be sampled.</p> <code>50.0</code> <code>update_glob</code> <code>bool</code> <p>If true, also update the global property to the mean of local properties.</p> <code>True</code> Source code in <code>cylindra/widgets/main.py</code> <pre><code>@set_design(text=capitalize, location=_sw.AnalysisMenu.Radius)\ndef measure_radius_by_molecules(\n    self,\n    layers: MoleculesLayersType = (),\n    interval: _Interval = None,\n    depth: Annotated[nm, {\"min\": 2.0, \"step\": 0.5}] = 50.0,\n    update_glob: Annotated[bool, {\"text\": \"Also update the global radius\"}] = True,\n):  # fmt: skip\n    \"\"\"Measure local and global radius for each layer.\n\n    Please note that the radius defined by the peak of the radial profile is not\n    always the same as the radius measured by this method. If the molecules are\n    aligned using a template image whose mass density is not centered, these radii\n    may differ a lot.\n\n    Parameters\n    ----------\n    {layers}{interval}{depth}{update_glob}\n    \"\"\"\n    layers = assert_list_of_layers(layers, self.parent_viewer)\n\n    # check duplicated spline sources\n    _splines = list[CylSpline]()\n    _radius_df = list[pl.DataFrame]()\n    _duplicated = list[CylSpline]()\n    for layer in layers:\n        spl = _assert_source_spline_exists(layer)\n        if any(spl is each for each in _splines):\n            _duplicated.append(spl)\n        _splines.append(spl)\n        mole = layer.molecules\n        df = mole.features\n        _radius_df.append(df.with_columns(cylmeasure.calc_radius(mole, spl)))\n\n    if _duplicated:\n        _layer_names = \", \".join(repr(l.name) for l in layers)\n        raise ValueError(f\"Layers {_layer_names} have duplicated spline sources.\")\n\n    indices = [self.tomogram.splines.index(spl) for spl in _splines]\n    with SplineTracker(widget=self, indices=indices) as tracker:\n        for i, spl, df in zip(indices, _splines, _radius_df, strict=True):\n            if interval is not None:\n                self.tomogram.make_anchors(i=i, interval=interval)\n            radii = list[float]()\n            for pos in spl.anchors * spl.length():\n                lower, upper = pos - depth / 2, pos + depth / 2\n                pred = pl.col(Mole.position).is_between(lower, upper, closed=\"left\")\n                radii.append(df.filter(pred)[Mole.radius].mean())\n            radii = pl.Series(H.radius, radii, dtype=pl.Float32)\n            if radii.is_nan().any():\n                _Logger.print_html(f\"&lt;b&gt;Spline-{i} contains NaN radius.&lt;/b&gt;\")\n            spl.props.update_loc([radii], depth, bin_size=1)\n            if update_glob:\n                spl.radius = df[Mole.radius].mean()\n        self._update_local_properties_in_widget(replot=True)\n        return tracker.as_undo_callback()\n</code></pre>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.merge_molecule_info","title":"<code>merge_molecule_info(pos, rotation, features)</code>","text":"<p>Merge molecule info from different molecules.</p> <p>Parameters:</p> Name Type Description Default <code>pos</code> <code>MoleculesLayer</code> <p>Molecules whose positions are used.</p> required <code>rotation</code> <code>MoleculesLayer</code> <p>Molecules whose rotations are used.</p> required <code>features</code> <code>MoleculesLayer</code> <p>Molecules whose features are used.</p> required Source code in <code>cylindra/widgets/main.py</code> <pre><code>@set_design(text=capitalize, location=_sw.MoleculesMenu.Combine)\ndef merge_molecule_info(\n    self,\n    pos: MoleculesLayerType,\n    rotation: MoleculesLayerType,\n    features: MoleculesLayerType,\n):\n    \"\"\"Merge molecule info from different molecules.\n\n    Parameters\n    ----------\n    pos : MoleculesLayer\n        Molecules whose positions are used.\n    rotation : MoleculesLayer\n        Molecules whose rotations are used.\n    features : MoleculesLayer\n        Molecules whose features are used.\n    \"\"\"\n    pos = assert_layer(pos, self.parent_viewer)\n    rotation = assert_layer(rotation, self.parent_viewer)\n    features = assert_layer(features, self.parent_viewer)\n    _pos = pos.molecules\n    _rot = rotation.molecules\n    _feat = features.molecules\n    mole = Molecules(_pos.pos, _rot.rotator, features=_feat.features)\n    layer = self.add_molecules(\n        mole, name=\"Mole-merged\", source=pos.source_component\n    )\n    return self._undo_callback_for_layer(layer)\n</code></pre>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.molecules_to_spline","title":"<code>molecules_to_spline(layers=(), err_max=0.8, delete_old=True, inherits=None, missing_ok=False, update_sources=True)</code>","text":"<p>Create splines from molecules.</p> <p>This function is useful to refine splines using results of subtomogram alignment. If the molecules layer alreadly has a source spline, replace it with the new one. Note that this function only works with molecules that is correctly assembled by such as :func:<code>map_monomers</code>.</p> <p>Parameters:</p> Name Type Description Default <code>layers</code> <code>list of MoleculesLayer</code> <p>All the points layers of molecules to be used.</p> <code>()</code> <code>err_max</code> <code>float</code> <p>S.D. allowed for spline fitting. Larger value will result in smoother spline, i.e. fewer spline knots.</p> <code>0.8</code> <code>delete_old</code> <code>bool</code> <p>If True, delete the old spline if the molecules has one. For instance, if \"Mole-0\" has the spline \"Spline-0\" as the source, and a spline \"Spline-1\" is created from \"Mole-0\", then \"Spline-0\" will be deleted from the list.</p> <code>True</code> <code>inherits</code> <code>bool</code> <p>Which global properties to be copied to the new one. If None, all the properties will be copied.</p> <code>None</code> <code>missing_ok</code> <code>bool</code> <p>If False, raise an error if the source spline is not found in the tomogram.</p> <code>False</code> <code>update_sources</code> <code>bool</code> <p>If True, all the molecules with the out-of-date source spline will be updated to the newly created splines. For instance, if \"Mole-0\" and \"Mole-1\" have the spline \"Spline-0\" as the source, and a spline \"Spline-1\" is created from \"Mole-1\", then the source of \"Mole-1\" will be updated to \"Spline-1\" as well.</p> <code>True</code> Source code in <code>cylindra/widgets/main.py</code> <pre><code>@set_design(text=capitalize, location=_sw.MoleculesMenu.FromToSpline)\ndef molecules_to_spline(\n    self,\n    layers: MoleculesLayersType = (),\n    err_max: Annotated[nm, {\"label\": \"Max fit error (nm)\", \"step\": 0.1}] = 0.8,\n    delete_old: Annotated[bool, {\"label\": \"Delete old splines\"}] = True,\n    inherits: Annotated[Optional[list[str]], {\"label\": \"Properties to inherit\", \"text\": \"All properties\"}] = None,\n    missing_ok: Annotated[bool, {\"label\": \"Missing OK\"}] = False,\n    update_sources: Annotated[bool, {\"label\": \"Update all the spline sources\"}] = True,\n):  # fmt: skip\n    \"\"\"Create splines from molecules.\n\n    This function is useful to refine splines using results of subtomogram\n    alignment. If the molecules layer alreadly has a source spline, replace\n    it with the new one.\n    Note that this function only works with molecules that is correctly\n    assembled by such as :func:`map_monomers`.\n\n    Parameters\n    ----------\n    {layers}{err_max}\n    delete_old : bool, default True\n        If True, delete the old spline if the molecules has one. For instance, if\n        \"Mole-0\" has the spline \"Spline-0\" as the source, and a spline \"Spline-1\" is\n        created from \"Mole-0\", then \"Spline-0\" will be deleted from the list.\n    inherits : bool, optional\n        Which global properties to be copied to the new one. If None, all the properties\n        will be copied.\n    missing_ok : bool, default False\n        If False, raise an error if the source spline is not found in the tomogram.\n    update_sources : bool, default True\n        If True, all the molecules with the out-of-date source spline will be updated\n        to the newly created splines. For instance, if \"Mole-0\" and \"Mole-1\" have the\n        spline \"Spline-0\" as the source, and a spline \"Spline-1\" is created from\n        \"Mole-1\", then the source of \"Mole-1\" will be updated to \"Spline-1\" as well.\n    \"\"\"\n    tomo = self.tomogram\n    layers = assert_list_of_layers(layers, self.parent_viewer)\n\n    # first check missing_ok=False case\n    if not missing_ok:\n        for layer in layers:\n            # NOTE: The source spline may not exist in the list\n            if _s := layer.source_spline:\n                tomo.splines.index(_s)  # raise error here if not found\n\n    for layer in layers:\n        if _s := layer.source_spline:\n            _config = _s.config\n        else:\n            _config = self.default_config\n        _shape = (*layer.regular_shape(), 3)\n        coords = layer.molecules.pos.reshape(_shape).mean(axis=1)\n        spl = CylSpline(config=_config).fit(coords, err_max=err_max)\n        try:\n            idx = tomo.splines.index(layer.source_spline)\n        except ValueError:\n            tomo.splines.append(spl)\n            idx = len(tomo.splines) - 1\n        else:\n            old_spl = tomo.splines[idx]\n            if inherits is None:\n                spl.props.glob = old_spl.props.glob.clone()\n            else:\n                glob = old_spl.props.glob\n                spl.props.glob = {k: glob[k] for k in glob.columns if k in inherits}\n\n            # Must be updated here, otherwise each.source_component may return\n            # None since GC may delete the old spline.\n            if update_sources:\n                for each in self.mole_layers:\n                    if each.source_component is old_spl:\n                        each.source_component = spl\n            if delete_old:\n                tomo.splines[idx] = spl\n            else:\n                tomo.splines.append(spl)\n        layer.source_component = spl\n        _Logger.print(f\"Layer {layer.name} generated spline-{idx}.\")\n\n    self.reset_choices()\n    self.sample_subtomograms()\n    self._update_splines_in_images()\n    return None\n</code></pre>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.open_image","title":"<code>open_image(path, scale=None, tilt_range=None, bin_size=[1], filter=ImageFilter.Lowpass, invert=False, eager=False, cache_image=False)</code>","text":"<p>Load an image file and process it before sending it to the viewer.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to the tomogram. Must be 3-D image.</p> required <code>scale</code> <code>float</code> <p>Pixel size in nm/pixel unit.</p> <code>1.0</code> <code>tilt_range</code> <code>tuple of float</code> <p>Range of tilt angles in degrees.</p> <code>None</code> <code>bin_size</code> <code>int or list of int</code> <p>Initial bin size of image. Binned image will be used for visualization in the viewer. You can use both binned and non-binned image for analysis.</p> <code>[1]</code> <code>filter</code> <code>ImageFilter</code> <p>Filter to be applied to the reference image. This does not affect the image data itself.</p> <ul> <li>Lowpass: butterworth low-pass filter.</li> <li>Gaussian: Gaussian blur.</li> <li>DoG: difference of Gaussian.</li> <li>LoG: Laplacian of Gaussian.</li> </ul> <code>Lowpass</code> <code>invert</code> <code>bool</code> <p>If true, invert the intensity of the image.</p> <code>False</code> <code>eager</code> <code>bool</code> <p>If true, the image will be loaded immediately. Otherwise, it will be loaded lazily.</p> <code>False</code> <code>cache_image</code> <code>bool</code> <p>If true, the image will first be copied to the cache directory before loading.</p> <code>False</code> Source code in <code>cylindra/widgets/main.py</code> <pre><code>@set_design(text=\"Open\", location=_image_loader)\n@dask_thread_worker.with_progress(desc=\"Reading image\")\n@confirm(text=\"You may have unsaved data. Open a new tomogram?\", condition=\"self._need_save\")  # fmt: skip\ndef open_image(\n    self,\n    path: Annotated[str | Path, {\"bind\": _image_loader.path}],\n    scale: Annotated[nm, {\"bind\": _image_loader.scale.scale_value}] = None,\n    tilt_range: Annotated[Any, {\"bind\": _image_loader.tilt_model}] = None,\n    bin_size: Annotated[int | Sequence[int], {\"bind\": _image_loader.bin_size}] = [1],\n    filter: Annotated[ImageFilter | None, {\"bind\": _image_loader.filter}] = ImageFilter.Lowpass,\n    invert: Annotated[bool, {\"bind\": _image_loader.invert}] = False,\n    eager: Annotated[bool, {\"bind\": _image_loader.eager}] = False,\n    cache_image: Annotated[bool, {\"bind\": _image_loader.cache_image}] = False,\n):  # fmt: skip\n    \"\"\"Load an image file and process it before sending it to the viewer.\n\n    Parameters\n    ----------\n    path : Path\n        Path to the tomogram. Must be 3-D image.\n    scale : float, default 1.0\n        Pixel size in nm/pixel unit.\n    tilt_range : tuple of float, default None\n        Range of tilt angles in degrees.\n    bin_size : int or list of int, default [1]\n        Initial bin size of image. Binned image will be used for visualization in\n        the viewer. You can use both binned and non-binned image for analysis.\n    {filter}\n    invert : bool, default False\n        If true, invert the intensity of the image.\n    eager : bool, default False\n        If true, the image will be loaded immediately. Otherwise, it will be loaded\n        lazily.\n    cache_image : bool, default False\n        If true, the image will first be copied to the cache directory before\n        loading.\n    \"\"\"\n    tomo = widget_utils.prep_tomogram(\n        path, scale, bin_size, tilt_range, eager, cache_image\n    )\n    self._init_macro_state()\n    self._project_dir = None\n    return self._send_tomogram_to_viewer.with_args(tomo, filter, invert=invert)\n</code></pre>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.open_image_with_reference","title":"<code>open_image_with_reference(path, reference_path, scale=None, tilt_range=None, bin_size=[1], filter=ImageFilter.Lowpass, invert=False, fix_reference_scale=True, cache_image=False)</code>","text":"<p>Load a raw image file and a user-supplied reference image file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to the tomogram. Must be 3-D image.</p> required <code>reference_path</code> <code>Path</code> <p>Path to the reference image. Must be a 3-D image.</p> required <code>scale</code> <code>float</code> <p>Pixel size in nm/pixel unit.</p> <code>1.0</code> <code>tilt_range</code> <code>tuple of float</code> <p>Range of tilt angles in degrees.</p> <code>None</code> <code>bin_size</code> <code>int or list of int</code> <p>Initial bin size of image. Binned image will be used for visualization in the viewer. You can use both binned and non-binned image for analysis.</p> <code>[1]</code> <code>filter</code> <code>ImageFilter</code> <p>Filter to be applied to the reference image. This does not affect the image data itself.</p> <ul> <li>Lowpass: butterworth low-pass filter.</li> <li>Gaussian: Gaussian blur.</li> <li>DoG: difference of Gaussian.</li> <li>LoG: Laplacian of Gaussian.</li> </ul> <code>Lowpass</code> <code>invert</code> <code>bool</code> <p>If true, invert the intensity of the raw image.</p> <code>False</code> <code>fix_reference_scale</code> <code>bool</code> <p>Fix the pixel size of the reference image if the scale of the raw tomogram was overridden.</p> <code>True</code> <code>cache_image</code> <code>bool</code> <p>If true, the image will first be copied to the cache directory before loading.</p> <code>False</code> Source code in <code>cylindra/widgets/main.py</code> <pre><code>@set_design(text=\"Open with reference\", location=_image_loader)\n@thread_worker.with_progress(desc=\"Reading image\")\ndef open_image_with_reference(\n    self,\n    path: Annotated[str | Path, {\"bind\": _image_loader.path}],\n    reference_path: Annotated[str | Path, {\"bind\": _image_loader.reference_path}],\n    scale: Annotated[nm, {\"bind\": _image_loader.scale.scale_value}] = None,\n    tilt_range: Annotated[Any, {\"bind\": _image_loader.tilt_model}] = None,\n    bin_size: Annotated[int | Sequence[int], {\"bind\": _image_loader.bin_size}] = [1],\n    filter: Annotated[ImageFilter | None, {\"bind\": _image_loader.filter}] = ImageFilter.Lowpass,\n    invert: Annotated[bool, {\"bind\": _image_loader.invert}] = False,\n    fix_reference_scale: Annotated[bool, {\"bind\": _image_loader.fix_reference_scale}] = True,\n    cache_image: Annotated[bool, {\"bind\": _image_loader.cache_image}] = False,\n):  # fmt: skip\n    \"\"\"Load a raw image file and a user-supplied reference image file.\n\n    Parameters\n    ----------\n    path : Path\n        Path to the tomogram. Must be 3-D image.\n    reference_path : Path\n        Path to the reference image. Must be a 3-D image.\n    scale : float, default 1.0\n        Pixel size in nm/pixel unit.\n    tilt_range : tuple of float, default None\n        Range of tilt angles in degrees.\n    bin_size : int or list of int, default [1]\n        Initial bin size of image. Binned image will be used for visualization in\n        the viewer. You can use both binned and non-binned image for analysis.\n    {filter}\n    invert : bool, default False\n        If true, invert the intensity of the raw image.\n    fix_reference_scale : bool, default True\n        Fix the pixel size of the reference image if the scale of the raw tomogram\n        was overridden.\n    cache_image : bool, default False\n        If true, the image will first be copied to the cache directory before\n        loading.\n    \"\"\"\n    tomo = widget_utils.prep_tomogram(\n        path, scale, bin_size, tilt_range, cache_image=cache_image, compute=False\n    )\n    self._init_macro_state()\n    cb = self._send_tomogram_to_viewer.with_args(tomo, filt=None, invert=invert)\n    yield cb\n    cb.await_call()\n    img_ref = ip.imread(reference_path)\n    if (\n        fix_reference_scale\n        and (orig_scale := tomo.metadata.get(\"orig_scale\", -1)) &gt; 0\n        and abs((scale_factor := tomo.scale / orig_scale) - 1) &gt; 1e-4\n    ):\n        _Logger.print(\n            f\"Original tomogram has scale {orig_scale:.4f} nm/pixel, while \"\n            f\"reference has scale {tomo.scale:.4f} nm/pixel. \"\n        )\n        img_ref = img_ref.set_scale(\n            **{str(k): v * scale_factor for k, v in img_ref.scale.items()},\n            unit=img_ref.scale_unit,\n        )\n    cb = thread_worker.callback(self._update_reference_image).with_args(img_ref)\n    yield cb\n    cb.await_call()\n    self._project_dir = None\n    if filter is not None:\n        yield from self.filter_reference_image.arun(filter)\n</code></pre>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.open_label_image","title":"<code>open_label_image(path)</code>","text":"<p>Open an image file as a label image of the current tomogram.</p> Source code in <code>cylindra/widgets/main.py</code> <pre><code>@set_design(text=capitalize, location=_sw.FileMenu)\n@do_not_record\ndef open_label_image(self, path: Path.Read[FileFilter.IMAGE]):\n    \"\"\"Open an image file as a label image of the current tomogram.\"\"\"\n    label = ip.imread(path)\n    if label.ndim != 3:\n        raise ValueError(\"Label image must be 3-D.\")\n    tr = self.tomogram.multiscale_translation(label.scale.x / self.tomogram.scale)\n    label_layer = widget_utils.add_labels(self.parent_viewer, label, tr)\n    self._reserved_layers.to_be_removed.add(label_layer)\n    return label_layer\n</code></pre>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.open_reference_image","title":"<code>open_reference_image(path)</code>","text":"<p>Open an image as a reference image of the current tomogram.</p> <p>The input image is usually a denoised image created by other softwares, or simply a filtered image. Please note that this method does not check that the input image is appropriate as a reference of the current tomogram, as potentially any 3D image can be used. Make sure that the input image is dark background.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>path - like</code> <p>Path to the image file. The image must be 3-D.</p> required Source code in <code>cylindra/widgets/main.py</code> <pre><code>@set_design(text=capitalize, location=_sw.FileMenu)\n@do_not_record\ndef open_reference_image(self, path: Path.Read[FileFilter.IMAGE]):\n    \"\"\"Open an image as a reference image of the current tomogram.\n\n    The input image is usually a denoised image created by other softwares, or\n    simply a filtered image. Please note that this method does not check that the\n    input image is appropriate as a reference of the current tomogram, as\n    potentially any 3D image can be used. Make sure that the input image is dark\n    background.\n\n    Parameters\n    ----------\n    path : path-like\n        Path to the image file. The image must be 3-D.\n    \"\"\"\n    img = ip.imread(path)\n    return self._update_reference_image(img)\n</code></pre>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.overwrite_project","title":"<code>overwrite_project()</code>","text":"<p>Overwrite currently opened project.</p> Source code in <code>cylindra/widgets/main.py</code> <pre><code>@set_design(text=capitalize, location=_sw.FileMenu)\n@do_not_record\n@bind_key(\"Ctrl+K, Ctrl+Shift+S\")\ndef overwrite_project(self):\n    \"\"\"Overwrite currently opened project.\"\"\"\n    if self._project_dir is None:\n        raise ValueError(\n            \"No project is loaded. You can use `Save project` \"\n            \"(ui.save_project(...)) to save the current session.\"\n        )\n    project = CylindraProject.from_file(self._project_dir)\n    if project.molecules_info:\n        ext = Path(project.molecules_info[0].name).suffix\n    else:\n        ext = \".csv\"\n    return self.save_project(self._project_dir, ext)\n</code></pre>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.paint_molecules","title":"<code>paint_molecules(layer, color_by, cmap=DEFAULT_COLORMAP, limits=(4.0, 4.24))</code>","text":"<p>Paint molecules by a feature.</p> <p>Parameters:</p> Name Type Description Default <code>layer</code> <code>MoleculesLayer</code> <p>Points layer of molecules to be used.</p> required <code>color_by</code> <code>str</code> <p>Name of the feature to paint by.</p> required <code>cmap</code> <code>colormap</code> <p>Colormap to be used for painting.</p> <code>DEFAULT_COLORMAP</code> <code>limits</code> <code>(float, float)</code> <p>Lower and upper limits of the colormap.</p> <code>(4.0, 4.24)</code> Source code in <code>cylindra/widgets/main.py</code> <pre><code>@set_design(text=capitalize, location=_sw.MoleculesMenu.View)\n@bind_key(\"Ctrl+K, C\")\ndef paint_molecules(\n    self,\n    layer: MoleculesLayerType,\n    color_by: Annotated[str, {\"choices\": _choice_getter(\"paint_molecules\")}],\n    cmap: _CmapType = DEFAULT_COLORMAP,\n    limits: Annotated[tuple[float, float], {\"options\": {\"min\": -20, \"max\": 20, \"step\": 0.01}}] = (4.00, 4.24),\n):  # fmt: skip\n    \"\"\"Paint molecules by a feature.\n\n    Parameters\n    ----------\n    {layer}{color_by}{cmap}{limits}\n    \"\"\"\n    layer = assert_layer(layer, self.parent_viewer)\n    info = layer.colormap_info\n    layer.set_colormap(color_by, limits, cmap)\n\n    match info:\n        case str(color):\n            return undo_callback(layer.face_color_setter).with_args(color)\n        case info:\n            return undo_callback(layer.set_colormap).with_args(\n                by=info.name, limits=info.clim, cmap=info.cmap\n            )\n</code></pre>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.protofilaments_to_spline","title":"<code>protofilaments_to_spline(layer, err_max=0.8, ids=(0,), config=None)</code>","text":"<p>Convert protofilaments to splines.</p> <p>If no IDs are given, all the molecules will be fitted to a spline, therefore essentially the same as manual filament picking. If IDs are given, selected protofilaments will be fitted to a spline separately.</p> <p>Parameters:</p> Name Type Description Default <code>layer</code> <code>MoleculesLayer</code> <p>Points layer of molecules to be used.</p> required <code>err_max</code> <code>float</code> <p>S.D. allowed for spline fitting. Larger value will result in smoother spline, i.e. fewer spline knots.</p> <code>0.8</code> <code>ids</code> <code>list of int</code> <p>Protofilament IDs to be converted.</p> <code>(0,)</code> Source code in <code>cylindra/widgets/main.py</code> <pre><code>@set_design(text=capitalize, location=_sw.MoleculesMenu.FromToSpline)\ndef protofilaments_to_spline(\n    self,\n    layer: MoleculesLayerType,\n    err_max: Annotated[nm, {\"label\": \"Max fit error (nm)\", \"step\": 0.1}] = 0.8,\n    ids: list[int] = (0,),\n    config: Annotated[dict[str, Any] | SplineConfig, {\"validator\": _get_default_config}] = None,\n):  # fmt: skip\n    \"\"\"Convert protofilaments to splines.\n\n    If no IDs are given, all the molecules will be fitted to a spline, therefore\n    essentially the same as manual filament picking. If IDs are given, selected\n    protofilaments will be fitted to a spline separately.\n\n    Parameters\n    ----------\n    {layer}{err_max}\n    ids : list of int, default (0,)\n        Protofilament IDs to be converted.\n    \"\"\"\n    layer = assert_layer(layer, self.parent_viewer)\n    tomo = self.tomogram\n    mole = layer.molecules\n    if len(ids) == 0:\n        tomo.add_spline(mole.pos, err_max=err_max, config=config)\n        _Logger.print(\n            f\"Layer {layer.name} generated spline-{len(tomo.splines) - 1}.\"\n        )\n    for i in ids:\n        sub = mole.filter(pl.col(Mole.pf) == i)\n        if sub.count() == 0:\n            continue\n        tomo.add_spline(sub.sort(Mole.nth).pos, err_max=err_max, config=config)\n        _Logger.print(\n            f\"{i}-th protofilament of layer {layer.name} generated spline-{len(tomo.splines) - 1}.\"\n        )\n    self.reset_choices()\n    self._update_splines_in_images()\n    return None\n</code></pre>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.reanalyze_image","title":"<code>reanalyze_image()</code>","text":"<p>Reanalyze the current tomogram.</p> <p>This method will extract the first manual operations from current session.</p> Source code in <code>cylindra/widgets/main.py</code> <pre><code>@set_design(text=\"Re-analyze current tomogram\", location=_sw.AnalysisMenu)\n@do_not_record\ndef reanalyze_image(self):\n    \"\"\"Reanalyze the current tomogram.\n\n    This method will extract the first manual operations from current session.\n    \"\"\"\n    _ui_sym = mk.symbol(self)\n    macro_expr = self._format_macro()[self._macro_image_load_offset :]\n    macro = _filter_macro_for_reanalysis(macro_expr, _ui_sym)\n    self.clear_all()\n    mk.Expr(mk.Head.block, macro.args[1:]).eval({_ui_sym: self})\n    return self.macro.clear_undo_stack()\n</code></pre>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.reanalyze_image_config_updated","title":"<code>reanalyze_image_config_updated()</code>","text":"<p>Reanalyze the current tomogram with newly set default spline config.</p> <p>This method is useful when you have mistakenly drawn splines with wrong spline config.</p> Source code in <code>cylindra/widgets/main.py</code> <pre><code>@set_design(text=\"Re-analyze with new config\", location=_sw.AnalysisMenu)\n@do_not_record\ndef reanalyze_image_config_updated(self):\n    \"\"\"Reanalyze the current tomogram with newly set default spline config.\n\n    This method is useful when you have mistakenly drawn splines with wrong spline\n    config.\n    \"\"\"\n    _ui_sym = mk.symbol(self)\n    macro_expr = self._format_macro()[self._macro_image_load_offset :]\n    macro = _filter_macro_for_reanalysis(macro_expr, _ui_sym)\n    macro = _remove_config_kwargs(macro)\n    self.clear_all()\n    mk.Expr(mk.Head.block, macro.args[1:]).eval({_ui_sym: self})\n    return self.macro.clear_undo_stack()\n</code></pre>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.refine_splines","title":"<code>refine_splines(splines=None, max_interval=30, err_max=0.8, corr_allowed=0.9, bin_size=1)</code>","text":"<p>Refine splines using the global cylindric structural parameters.</p> <p>Parameters:</p> Name Type Description Default <code>splines</code> <code>list of int</code> <p>Indices of splines to be used.</p> <code>None</code> <code>max_interval</code> <code>nm</code> <p>Maximum interval (nm) between spline anchors.</p> <code>30</code> <code>err_max</code> <code>float</code> <p>S.D. allowed for spline fitting. Larger value will result in smoother spline, i.e. fewer spline knots.</p> <code>0.8</code> <code>corr_allowed</code> <code>float</code> <p>How many images will be used to make template for alignment. If 0.9, then top 90% will be used.</p> <code>0.9</code> <code>bin_size</code> <code>int</code> <p>Bin size of multiscale image to be used. Set to &gt;1 to boost performance.</p> <code>1</code> Source code in <code>cylindra/widgets/main.py</code> <pre><code>@set_design(text=capitalize, location=_sw.SplinesMenu.Fitting)\n@thread_worker.with_progress(desc=\"Refining splines\", total=_NSPLINES)\ndef refine_splines(\n    self,\n    splines: SplinesType = None,\n    max_interval: Annotated[nm, {\"label\": \"maximum interval (nm)\"}] = 30,\n    err_max: Annotated[nm, {\"label\": \"max fit error (nm)\", \"step\": 0.1}] = 0.8,\n    corr_allowed: Annotated[float, {\"label\": \"correlation allowed\", \"max\": 1.0, \"step\": 0.1}] = 0.9,\n    bin_size: Annotated[int, {\"choices\": _get_available_binsize}] = 1,\n):  # fmt: skip\n    \"\"\"Refine splines using the global cylindric structural parameters.\n\n    Parameters\n    ----------\n    {splines}{max_interval}{err_max}\n    corr_allowed : float, default 0.9\n        How many images will be used to make template for alignment. If 0.9, then\n        top 90% will be used.\n    {bin_size}\n    \"\"\"\n    tomo = self.tomogram\n    splines = self._norm_splines(splines)\n    with SplineTracker(widget=self, indices=splines) as tracker:\n        for i in splines:\n            tomo.refine(\n                i,\n                max_interval=max_interval,\n                corr_allowed=corr_allowed,\n                err_max=err_max,\n                binsize=bin_size,\n            )\n            yield thread_worker.callback(self._update_splines_in_images)\n\n        @thread_worker.callback\n        def out():\n            self._init_widget_state()\n            self._update_splines_in_images()\n            self._update_local_properties_in_widget()\n            return tracker.as_undo_callback()\n\n    return out\n</code></pre>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.regionprops_features","title":"<code>regionprops_features(layer, target, label, properties=('area', 'mean'))</code>","text":"<p>Analyze region properties using another feature column as the labels.</p> <p>For instance, if the target data is [0, 1, 2, 3, 4] and the labels are [0, 1, 1, 2, 2], the the property \"mean\" will be [1.5, 3.5]. For some properties such as \"length\" and \"width\", the monomer connection will be considered.</p> <p>Parameters:</p> Name Type Description Default <code>layer</code> <code>MoleculesLayer</code> <p>Points layer of molecules to be used.</p> required <code>target</code> <code>str</code> <p>Target column name on which calculation will run.</p> required <code>label</code> <code>Annotated[str, {choices: _choice_getter(regionprops_features, dtype_kind=ui)}]</code> <p>The feature name that will be used as the labels.</p> required <code>properties</code> <code>list of str</code> <p>Properties to calculate.</p> <code>('area', 'mean')</code> Source code in <code>cylindra/widgets/main.py</code> <pre><code>@set_design(text=\"Analyze region properties\", location=_sw.MoleculesMenu.Features)\ndef regionprops_features(\n    self,\n    layer: MoleculesLayerType,\n    target: Annotated[str, {\"choices\": _choice_getter(\"regionprops_features\", dtype_kind=\"uif\")}],\n    label: Annotated[str, {\"choices\": _choice_getter(\"regionprops_features\", dtype_kind=\"ui\")}],\n    properties: Annotated[list[str], {\"choices\": cylmeasure.RegionProfiler.CHOICES, \"widget_type\": CheckBoxes}] = (\"area\", \"mean\"),\n):  # fmt: skip\n    \"\"\"Analyze region properties using another feature column as the labels.\n\n    For instance, if the target data is [0, 1, 2, 3, 4] and the labels are [0, 1, 1, 2, 2],\n    the the property \"mean\" will be [1.5, 3.5]. For some properties such as \"length\" and\n    \"width\", the monomer connection will be considered.\n\n    Parameters\n    ----------\n    {layer}{target}\n    label: str\n        The feature name that will be used as the labels.\n    properties : list of str\n        Properties to calculate.\n    \"\"\"\n    from magicclass.ext.polars import DataFrameView\n\n    layer = assert_layer(layer, self.parent_viewer)\n    utils.assert_column_exists(\n        layer.molecules.features, [target, label, Mole.nth, Mole.pf]\n    )\n    spl = _assert_source_spline_exists(layer)\n    reg = cylmeasure.RegionProfiler.from_components(\n        layer.molecules, spl, target, label\n    )\n    df = reg.calculate(properties)\n    view = DataFrameView(value=df)\n    dock = self.parent_viewer.window.add_dock_widget(view, name=\"Region properties\")\n    dock.setFloating(True)\n    self.reset_choices()  # choices regarding of features need update\n    return undo_callback(dock.close).with_redo(dock.show)\n</code></pre>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.register_molecules","title":"<code>register_molecules(coords=None)</code>","text":"<p>Register manually added points as molecules.</p> Source code in <code>cylindra/widgets/main.py</code> <pre><code>@set_design(text=capitalize, location=_sw.MoleculesMenu)\ndef register_molecules(\n    self,\n    coords: Annotated[np.ndarray, {\"validator\": _get_spline_coordinates}] = None,\n):\n    \"\"\"Register manually added points as molecules.\"\"\"\n    if coords is None or coords.size == 0:\n        raise ValueError(\"No points are given.\")\n    mole = Molecules(coords)\n    layer = self.add_molecules(mole, name=\"Mole-manual\")\n    self._reserved_layers.work.data = []\n    return self._undo_callback_for_layer(layer)\n</code></pre>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.register_path","title":"<code>register_path(coords=None, config=None, err_max=0.5)</code>","text":"<p>Register points as a spline path.</p> Source code in <code>cylindra/widgets/main.py</code> <pre><code>@set_design(icon=\"iconoir:curve-array\", location=Toolbar)\n@bind_key(\"F1\")\ndef register_path(\n    self,\n    coords: Annotated[np.ndarray, {\"validator\": _get_spline_coordinates}] = None,\n    config: Annotated[dict[str, Any] | SplineConfig, {\"validator\": _get_default_config}] = None,\n    err_max: Annotated[nm, {\"bind\": 0.5}] = 0.5,\n):  # fmt: skip\n    \"\"\"Register points as a spline path.\"\"\"\n    if coords is None or coords.size == 0:\n        raise ValueError(\"No points are given.\")\n\n    tomo = self.tomogram\n    tomo.add_spline(coords, config=config, err_max=err_max)\n    self._add_spline_instance(tomo.splines[-1])\n    return undo_callback(self.delete_spline).with_args(-1)\n</code></pre>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.rename_molecules","title":"<code>rename_molecules(old, new, include='', exclude='', pattern='')</code>","text":"<p>Rename multiple molecules layers at once.</p> <p>Parameters:</p> Name Type Description Default <code>old</code> <code>str</code> <p>Old string to be replaced.</p> required <code>new</code> <code>str</code> <p>New string to replace <code>old</code>.</p> required <code>include</code> <code>str</code> <p>Delete layers whose names contain this string.</p> <code>''</code> <code>exclude</code> <code>str</code> <p>Delete layers whose names do not contain this string.</p> <code>''</code> <code>pattern</code> <code>str</code> <p>String pattern to match the layer names. Use <code>*</code> as wildcard.</p> <code>''</code> Source code in <code>cylindra/widgets/main.py</code> <pre><code>@set_design(text=\"Rename molecule layers\", location=_sw.MoleculesMenu)\n@do_not_record(recursive=False)\ndef rename_molecules(\n    self,\n    old: str,\n    new: str,\n    include: str = \"\",\n    exclude: str = \"\",\n    pattern: str = \"\",\n):\n    \"\"\"Rename multiple molecules layers at once.\n\n    Parameters\n    ----------\n    old : str\n        Old string to be replaced.\n    new : str\n        New string to replace `old`.\n    include : str, optional\n        Delete layers whose names contain this string.\n    exclude : str, optional\n        Delete layers whose names do not contain this string.\n    pattern : str, optional\n        String pattern to match the layer names. Use `*` as wildcard.\n    \"\"\"\n    if old == \"\":\n        raise ValueError(\"`old` is not given.\")\n    if new == \"\":\n        raise ValueError(\"`new` is not given.\")\n    return self.mole_layers.rename(\n        old, new, include=include, exclude=exclude, pattern=pattern\n    )\n</code></pre>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.rotate_molecule_toward_spline","title":"<code>rotate_molecule_toward_spline(layer, spline, inherit_source=True, orientation=None)</code>","text":"<p>Rotate molecules to align its orientation to the spline.</p> <p>This method is useful to rotate picked binding proteins so that they faces to the cylinder. Output molecules layer will be named as \"-Rot\". <p>Parameters:</p> Name Type Description Default <code>layer</code> <code>MoleculesLayer</code> <p>Points layer of molecules to be used.</p> required <code>spline</code> <code>int</code> <p>Index of splines to be used.</p> required <code>inherit_source</code> <code>bool</code> <p>If True and the input molecules layer has its spline source, the new layer will inherit it.</p> <code>True</code> <code>orientation</code> <code>(None, PlusToMinus, MinusToPlus)</code> <p>Orientation of molecules' y-axis. If none, use the current spline orientation as is.</p> <code>None</code> Source code in <code>cylindra/widgets/main.py</code> <pre><code>@set_design(text=capitalize, location=_sw.MoleculesMenu)\ndef rotate_molecule_toward_spline(\n    self,\n    layer: MoleculesLayerType,\n    spline: Annotated[int, {\"choices\": _get_splines}],\n    inherit_source: Annotated[bool, {\"label\": \"Inherit source spline\"}] = True,\n    orientation: Literal[None, \"PlusToMinus\", \"MinusToPlus\"] = None,\n):\n    \"\"\"Rotate molecules to align its orientation to the spline.\n\n    This method is useful to rotate picked binding proteins so that they faces to\n    the cylinder. Output molecules layer will be named as \"&lt;original name&gt;-Rot\".\n\n    Parameters\n    ----------\n    {layer}{spline}{inherit_source}{orientation}\n    \"\"\"\n    layer = assert_layer(layer, self.parent_viewer)\n    spl = self.tomogram.splines[spline]\n    mole_rot = align_molecules_to_spline(layer.molecules, spl)\n    if spl._need_rotation(orientation):\n        mole_rot = mole_rot.rotate_by_rotvec_internal([np.pi, 0, 0])\n    source = layer.source_component if inherit_source else None\n    new = self.add_molecules(mole_rot, name=f\"{layer.name}-Rot\", source=source)\n    return self._undo_callback_for_layer(new)\n</code></pre>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.rotate_molecules","title":"<code>rotate_molecules(layers, degrees, inherit_source=True)</code>","text":"<p>Rotate molecules without changing their positions.</p> <p>Output molecules layer will be named as \"-Rot\". <p>Parameters:</p> Name Type Description Default <code>layers</code> <code>list of MoleculesLayer</code> <p>All the points layers of molecules to be used.</p> required <code>degrees</code> <code>list of (str, float)</code> <p>Rotation axes and degrees. For example, <code>[(\"z\", 20), (\"y\", -10)]</code> means rotation by 20 degrees around the molecule Z axis and then by -10 degrees around the Y axis.</p> required <code>inherit_source</code> <code>bool</code> <p>If True and the input molecules layer has its spline source, the new layer will inherit it.</p> <code>True</code> Source code in <code>cylindra/widgets/main.py</code> <pre><code>@set_design(text=capitalize, location=_sw.MoleculesMenu)\ndef rotate_molecules(\n    self,\n    layers: MoleculesLayersType,\n    degrees: Annotated[\n        list[tuple[Literal[\"z\", \"y\", \"x\"], float]],\n        {\"layout\": \"vertical\", \"options\": {\"widget_type\": SingleRotationEdit}},\n    ],\n    inherit_source: Annotated[bool, {\"label\": \"Inherit source spline\"}] = True,\n):\n    \"\"\"Rotate molecules without changing their positions.\n\n    Output molecules layer will be named as \"&lt;original name&gt;-Rot\".\n\n    Parameters\n    ----------\n    {layers}\n    degrees : list of (str, float)\n        Rotation axes and degrees. For example, `[(\"z\", 20), (\"y\", -10)]` means\n        rotation by 20 degrees around the molecule Z axis and then by -10 degrees\n        around the Y axis.\n    {inherit_source}\n    \"\"\"\n    layers = assert_list_of_layers(layers, self.parent_viewer)\n    new_layers = list[MoleculesLayer]()\n    rotvec = degrees_to_rotator(degrees).as_rotvec()\n    for layer in layers:\n        mole = layer.molecules.rotate_by_rotvec_internal(rotvec)\n        source = layer.source_component if inherit_source else None\n        new = self.add_molecules(mole, name=f\"{layer.name}-Rot\", source=source)\n        new_layers.append(new)\n        _Logger.print_html(f\"{layer.name!r} &amp;#8594; {new.name!r}\")\n    return self._undo_callback_for_layer(new_layers)\n</code></pre>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.run_workflow","title":"<code>run_workflow(filename, *args, **kwargs)</code>","text":"<p>Run a user-defined workflow.</p> <p>This method will run a .py file that was defined by the user from <code>Workflow &gt; Define workflow</code>. args and *kwargs follow the signature of the main function of the workflow.</p> Source code in <code>cylindra/widgets/main.py</code> <pre><code>@do_not_record(recursive=False)\n@nogui\ndef run_workflow(self, filename: str, *args, **kwargs):\n    \"\"\"Run a user-defined workflow.\n\n    This method will run a .py file that was defined by the user from\n    `Workflow &gt; Define workflow`. *args and **kwargs follow the signature of the\n    main function of the workflow.\n    \"\"\"\n    main = _config.get_main_function(filename)\n    out = main(self, *args, **kwargs)\n    return out\n</code></pre>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.sample_subtomograms","title":"<code>sample_subtomograms()</code>","text":"<p>Sample subtomograms at the anchor points on splines</p> Source code in <code>cylindra/widgets/main.py</code> <pre><code>@set_design(text=capitalize, location=_sw.ImageMenu)\ndef sample_subtomograms(self):\n    \"\"\"Sample subtomograms at the anchor points on splines\"\"\"\n    self.spline_fitter.close()\n\n    # initialize GUI\n    if len(self.tomogram.splines) == 0:\n        raise ValueError(\"No spline found.\")\n    spl = self.tomogram.splines[0]\n    if spl.has_anchors:\n        self.SplineControl[\"pos\"].max = spl.anchors.size - 1\n    self.SplineControl._num_changed()\n    self._reserved_layers.work.mode = \"pan_zoom\"\n\n    self._update_local_properties_in_widget()\n    self._update_global_properties_in_widget()\n    self._highlight_spline()\n\n    # reset contrast limits\n    self.SplineControl._reset_contrast_limits()\n</code></pre>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.save_molecules","title":"<code>save_molecules(layer, save_path)</code>","text":"<p>Save monomer coordinates, orientation and features to a file.</p> <p>Parameters:</p> Name Type Description Default <code>layer</code> <code>MoleculesLayer</code> <p>Points layer of molecules to be used.</p> required <code>save_path</code> <code>Path</code> <p>Where to save the molecules.</p> required Source code in <code>cylindra/widgets/main.py</code> <pre><code>@do_not_record\n@set_design(text=capitalize, location=_sw.FileMenu)\ndef save_molecules(\n    self, layer: MoleculesLayerType, save_path: Path.Save[FileFilter.MOLE]\n):\n    \"\"\"Save monomer coordinates, orientation and features to a file.\n\n    Parameters\n    ----------\n    {layer}\n    save_path : Path\n        Where to save the molecules.\n    \"\"\"\n    return assert_layer(layer, self.parent_viewer).molecules.to_csv(save_path)\n</code></pre>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.save_project","title":"<code>save_project(path, molecules_ext='.csv', save_landscape=False)</code>","text":"<p>Save current project state and the results in a directory.</p> <p>The json file contains paths of images and results, parameters of splines, scales and version. Local and global properties will be exported as csv files. Molecule coordinates and features will be exported as the <code>molecules_ext</code> format. If results are saved at the default directory, they will be written as relative paths in the project json file so that moving root directory does not affect the loading behavior.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path of json file.</p> required <code>molecules_ext</code> <code>str</code> <p>Extension of the molecule file. Can be \".csv\" or \".parquet\".</p> <code>\".csv\"</code> <code>save_landscape</code> <code>bool</code> <p>Save landscape layers if any. False by default because landscape layers are usually large.</p> <code>False</code> Source code in <code>cylindra/widgets/main.py</code> <pre><code>@set_design(text=capitalize, location=_sw.FileMenu)\n@do_not_record\n@bind_key(\"Ctrl+K, Ctrl+S\")\ndef save_project(\n    self,\n    path: Path.Save,\n    molecules_ext: Literal[\".csv\", \".parquet\"] = \".csv\",\n    save_landscape: Annotated[bool, {\"label\": \"Save landscape layers\"}] = False,\n):\n    \"\"\"Save current project state and the results in a directory.\n\n    The json file contains paths of images and results, parameters of splines,\n    scales and version. Local and global properties will be exported as csv files.\n    Molecule coordinates and features will be exported as the `molecules_ext`\n    format. If results are saved at the default directory, they will be\n    written as relative paths in the project json file so that moving root\n    directory does not affect the loading behavior.\n\n    Parameters\n    ----------\n    path : Path\n        Path of json file.\n    molecules_ext : str, default \".csv\"\n        Extension of the molecule file. Can be \".csv\" or \".parquet\".\n    save_landscape : bool, default False\n        Save landscape layers if any. False by default because landscape layers are\n        usually large.\n    \"\"\"\n    path = Path(path)\n    CylindraProject.save_gui(self, path, molecules_ext, save_landscape)\n    _Logger.print(f\"Project saved: {path.as_posix()}\")\n    self._need_save = False\n    self._project_dir = path\n    autosave_path = _config.autosave_path()\n    if autosave_path.exists():\n        with suppress(Exception):\n            autosave_path.unlink()\n\n    # update the spline/molecules list in the batch analyzer\n    if batch := self._batch:\n        for proj in batch.constructor.projects:\n            if self._project_dir and Path(proj.path).samefile(self._project_dir):\n                proj._update_from_project()\n\n    # if the drawing layer has non-registered points, notify the user\n    if self._reserved_layers.work.data.size &gt; 0:\n        _name = self._reserved_layers.work.name\n        _napari_show_info(f\"Points in the {_name!r} is not registered yet.\")\n</code></pre>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.save_reference_image","title":"<code>save_reference_image(path)</code>","text":"<p>Save the current reference image to a file.</p> Source code in <code>cylindra/widgets/main.py</code> <pre><code>@set_design(text=capitalize, location=_sw.FileMenu)\ndef save_reference_image(self, path: Path.Save[FileFilter.IMAGE]):\n    \"\"\"Save the current reference image to a file.\"\"\"\n    path = Path(path)\n    img_ref = self._reserved_layers.image_data\n    img_ref.imsave(path)\n    img_ref.source = path\n    _Logger.print(f\"Reference image saved: {path.as_posix()}\")\n</code></pre>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.save_spline","title":"<code>save_spline(spline, save_path)</code>","text":"<p>Save splines as a json file.</p> Source code in <code>cylindra/widgets/main.py</code> <pre><code>@set_design(text=capitalize, location=_sw.FileMenu)\n@do_not_record\ndef save_spline(\n    self,\n    spline: Annotated[int, {\"choices\": _get_splines}],\n    save_path: Path.Save[FileFilter.JSON],\n):\n    \"\"\"Save splines as a json file.\"\"\"\n    spl = self.tomogram.splines[spline]\n    spl.to_json(save_path)\n</code></pre>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.set_multiscale","title":"<code>set_multiscale(bin_size)</code>","text":"<p>Set multiscale used for image display.</p> <p>Parameters:</p> Name Type Description Default <code>bin_size</code> <code>Annotated[int, {choices: _get_available_binsize}]</code> <p>Bin size of multiscaled image.</p> required Source code in <code>cylindra/widgets/main.py</code> <pre><code>@set_design(text=\"Set multi-scale\", location=_sw.ImageMenu)\ndef set_multiscale(self, bin_size: Annotated[int, {\"choices\": _get_available_binsize}]):  # fmt: skip\n    \"\"\"Set multiscale used for image display.\n\n    Parameters\n    ----------\n    bin_size: int\n        Bin size of multiscaled image.\n    \"\"\"\n    tomo = self.tomogram\n    _old_bin_size = self._current_binsize\n    imgb = tomo.get_multiscale(bin_size)\n    factor = self._reserved_layers.scale / imgb.scale.x\n    self._reserved_layers.update_image(imgb, tomo.multiscale_translation(bin_size))\n    current_z = self.parent_viewer.dims.current_step[0]\n    self.parent_viewer.dims.set_current_step(axis=0, value=current_z * factor)\n\n    # update overview\n    self.Overview.image = imgb.mean(axis=\"z\")\n    self.Overview.xlim = [x * factor for x in self.Overview.xlim]\n    self.Overview.ylim = [y * factor for y in self.Overview.ylim]\n    self._current_binsize = bin_size\n    self.reset_choices()\n    return undo_callback(self.set_multiscale).with_args(_old_bin_size)\n</code></pre>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.set_radius","title":"<code>set_radius(splines=None, radius=10.0)</code>","text":"<p>Manually set radius of the splines.</p> <p>Parameters:</p> Name Type Description Default <code>splines</code> <code>list of int</code> <p>Indices of splines to be used.</p> <code>None</code> <code>radius</code> <code>float or str expression</code> <p>Radius of the spline. If a string expression is given, it will be evaluated to get the polars.Expr object. The returned expression will be evaluated with the global properties of the spline as the context.</p> <code>10.0</code> Source code in <code>cylindra/widgets/main.py</code> <pre><code>@set_design(text=capitalize, location=_sw.AnalysisMenu.Radius)\ndef set_radius(\n    self,\n    splines: SplinesType = None,\n    radius: PolarsExprStrOrScalar = 10.0,\n):  # fmt: skip\n    \"\"\"Manually set radius of the splines.\n\n    Parameters\n    ----------\n    {splines}\n    radius : float or str expression\n        Radius of the spline. If a string expression is given, it will be evaluated\n        to get the polars.Expr object. The returned expression will be evaluated\n        with the global properties of the spline as the context.\n    \"\"\"\n    radius_expr = widget_utils.norm_scalar_expr(radius)\n    splines = self._norm_splines(splines)\n    rdict = dict[int, float]()\n    for i in splines:\n        _radius = self.splines[i].props.get_glob(radius_expr)\n        if not isinstance(_radius, int | float):\n            raise ValueError(\n                f\"Radius must be converted into a number, got {_radius!r}.\"\n            )\n        if _radius &lt;= 0:\n            raise ValueError(f\"Radius must be positive, got {_radius}.\")\n        rdict[i] = _radius\n    with SplineTracker(widget=self, indices=splines, sample=True) as tracker:\n        for i in splines:\n            self.splines[i].radius = rdict[i]\n            _Logger.print(f\"Spline-{i} radius set to {rdict[i]:.2f} nm.\")\n        return tracker.as_undo_callback()\n</code></pre>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.set_source_spline","title":"<code>set_source_spline(layer, spline)</code>","text":"<p>Set source spline for a molecules layer.</p> <p>Parameters:</p> Name Type Description Default <code>layer</code> <code>MoleculesLayer</code> <p>Points layer of molecules to be used.</p> required <code>spline</code> <code>int</code> <p>Index of splines to be used.</p> required Source code in <code>cylindra/widgets/main.py</code> <pre><code>@set_design(text=capitalize, location=_sw.MoleculesMenu.FromToSpline)\ndef set_source_spline(\n    self,\n    layer: MoleculesLayerType,\n    spline: Annotated[int, {\"choices\": _get_splines}],\n):\n    \"\"\"Set source spline for a molecules layer.\n\n    Parameters\n    ----------\n    {layer}{spline}\n    \"\"\"\n    layer = assert_layer(layer, self.parent_viewer)\n    old_spl = layer.source_component\n    layer.source_component = self.tomogram.splines[spline]\n\n    @undo_callback\n    def _undo():\n        layer.source_component = old_spl\n\n    return _undo\n</code></pre>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.set_spline_props","title":"<code>set_spline_props(spline, npf=None, start=None, orientation=None)</code>","text":"<p>Set spline global properties.</p> <p>This method will overwrite spline properties with the user input. You should not call this method unless there's a good reason to do so, e.g. the number of protofilaments is obviously wrong.</p> <p>Parameters:</p> Name Type Description Default <code>npf</code> <code>int</code> <p>If given, update the number of protofilaments.</p> <code>None</code> <code>start</code> <code>int</code> <p>If given, update the start number of the spline.</p> <code>None</code> <code>orientation</code> <code>str</code> <p>If given, update the spline orientation.</p> <code>None</code> Source code in <code>cylindra/widgets/main.py</code> <pre><code>@set_design(text=\"Set spline properties\", location=_sw.SplinesMenu)\ndef set_spline_props(\n    self,\n    spline: Annotated[int, {\"bind\": _get_spline_idx}],\n    npf: Annotated[Optional[int], {\"label\": \"number of PF\", \"text\": \"Do not update\"}] = None,\n    start: Annotated[Optional[int], {\"label\": \"start number\", \"text\": \"Do not update\", \"options\": {\"min\": -100}}] = None,\n    orientation: Annotated[Optional[Literal[\"MinusToPlus\", \"PlusToMinus\"]], {\"text\": \"Do not update\"}] = None,\n):  # fmt: skip\n    \"\"\"Set spline global properties.\n\n    This method will overwrite spline properties with the user input. You should\n    not call this method unless there's a good reason to do so, e.g. the number\n    of protofilaments is obviously wrong.\n\n    Parameters\n    ----------\n    npf : int, optional\n        If given, update the number of protofilaments.\n    start : int, optional\n        If given, update the start number of the spline.\n    orientation : str, optional\n        If given, update the spline orientation.\n    \"\"\"\n    spl = self.tomogram.splines[spline]\n    old_spl = spl.copy()\n    spl.update_props(npf=npf, start=start, orientation=orientation)\n    self.sample_subtomograms()\n    self._update_splines_in_images()\n\n    @undo_callback\n    def out():\n        self.tomogram.splines[spline] = old_spl\n        self.sample_subtomograms()\n        self._update_splines_in_images()\n\n    return out\n</code></pre>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.split_molecules","title":"<code>split_molecules(layer, by)</code>","text":"<p>Split molecules by a feature column.</p> <p>Parameters:</p> Name Type Description Default <code>layer</code> <code>MoleculesLayer</code> <p>Points layer of molecules to be used.</p> required <code>by</code> <code>str</code> <p>Name of the feature to split by.</p> required Source code in <code>cylindra/widgets/main.py</code> <pre><code>@set_design(text=\"Split molecules by feature\", location=_sw.MoleculesMenu)\ndef split_molecules(\n    self,\n    layer: MoleculesLayerType,\n    by: Annotated[str, {\"choices\": _choice_getter(\"split_molecules\")}],\n):\n    \"\"\"Split molecules by a feature column.\n\n    Parameters\n    ----------\n    {layer}\n    by : str\n        Name of the feature to split by.\n    \"\"\"\n    layer = assert_layer(layer, self.parent_viewer)\n    utils.assert_column_exists(layer.molecules.features, by)\n    _added_layers = list[MoleculesLayer]()\n    for _key, mole in layer.molecules.groupby(by):\n        new = self.add_molecules(\n            mole, name=f\"{layer.name}_{_key}\", source=layer.source_component\n        )\n        _added_layers.append(new)\n    return self._undo_callback_for_layer(_added_layers)\n</code></pre>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.split_spline","title":"<code>split_spline(spline, at=100.0, from_start=True, trim=0.0)</code>","text":"<p>Split the spline into two at the given position.</p> <p>Parameters:</p> Name Type Description Default <code>spline</code> <code>int</code> <p>Index of splines to be used.</p> required <code>at</code> <code>float</code> <p>Position to split the spline in nm.</p> <code>100.0</code> <code>from_start</code> <code>bool</code> <p>If True, the split position will be measured from the start of the spline, otherwise from the end.</p> <code>True</code> <code>trim</code> <code>float</code> <p>Trim the split parts by this length (nm).</p> <code>0.0</code> Source code in <code>cylindra/widgets/main.py</code> <pre><code>@set_design(text=capitalize, location=_sw.SplinesMenu)\ndef split_spline(\n    self,\n    spline: Annotated[int, {\"choices\": _get_splines}],\n    at: Annotated[nm, {\"min\": 0.0, \"max\": 10000.0, \"step\": 0.1, \"label\": \"split at (nm)\"}] = 100.0,\n    from_start: bool = True,\n    trim: Annotated[nm, {\"min\": 0.0, \"max\": 100.0, \"step\": 0.1, \"label\": \"trim (nm)\"}] = 0.0,\n):  # fmt: skip\n    \"\"\"Split the spline into two at the given position.\n\n    Parameters\n    ----------\n    {spline}\n    at : float, default 100.0\n        Position to split the spline in nm.\n    from_start : bool, default True\n        If True, the split position will be measured from the start of the spline,\n        otherwise from the end.\n    trim : float, default 0.0\n        Trim the split parts by this length (nm).\n    \"\"\"\n    spl = self.splines[spline]\n    spls = spl.split(at, from_start=from_start, trim=trim)\n    self.splines.pop(spline)\n    for new_spl in reversed(spls):\n        self.splines.insert(spline, new_spl)\n    self._update_splines_in_images()\n    self.reset_choices()\n\n    @undo_callback\n    def _out():\n        del self.splines[-2:]\n        self.splines.insert(spline, spl)\n        self._update_splines_in_images()\n        self.reset_choices()\n\n    return _out\n</code></pre>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.split_splines_at_changing_point","title":"<code>split_splines_at_changing_point(splines=None, estimate_by='radius', diff_cutoff=0.4, trim=0.0)</code>","text":"<p>Detect the changing point of the spline and split it there.</p> <p>This method is useful when (1) there's a change in the protofilament number, or (2) microtubules were polymerized from seeds.</p> <p>Parameters:</p> Name Type Description Default <code>splines</code> <code>list of int</code> <p>Indices of splines to be used.</p> <code>None</code> <code>estimate_by</code> <code>str</code> <p>Local property to estimate the changing point. Must be one of the local property of the splines.</p> <code>\"radius\"</code> <code>diff_cutoff</code> <code>float</code> <p>The cutoff value of the absolute difference between the two regions to be considered as a changing point.</p> <code>2.0</code> <code>trim</code> <code>float</code> <p>Trim the split parts by this length (nm). If any of the split parts is shorter than this length, the part will be discarded.</p> <code>0.0</code> Source code in <code>cylindra/widgets/main.py</code> <pre><code>@set_design(text=capitalize, location=_sw.SplinesMenu)\ndef split_splines_at_changing_point(\n    self,\n    splines: SplinesType = None,\n    estimate_by: str = \"radius\",\n    diff_cutoff: Annotated[float, {\"min\": 0.0, \"max\": 1000.0, \"step\": 0.01}] = 0.4,\n    trim: Annotated[nm, {\"min\": 0.0, \"max\": 1000.0, \"step\": 0.1, \"label\": \"trim (nm)\"}] = 0.0,\n):  # fmt: skip\n    \"\"\"Detect the changing point of the spline and split it there.\n\n    This method is useful when (1) there's a change in the protofilament number, or\n    (2) microtubules were polymerized from seeds.\n\n    Parameters\n    ----------\n    {splines}\n    estimate_by : str, default \"radius\"\n        Local property to estimate the changing point. Must be one of the local\n        property of the splines.\n    diff_cutoff : float, default 2.0\n        The cutoff value of the absolute difference between the two regions to be\n        considered as a changing point.\n    trim : float, default 0.0\n        Trim the split parts by this length (nm). If any of the split parts is\n        shorter than this length, the part will be discarded.\n    \"\"\"\n    splines = self._norm_splines(splines)\n    spl_map = dict[int, list[CylSpline]]()\n    _Logger.print(\"`split_spine_at_changing_point`\")\n    for i in splines:\n        spl = self.splines[i]\n        if (loc := spl.props.get_loc(estimate_by, None)) is None:\n            raise ValueError(\n                f\"Spline-{i} does not have {estimate_by!r} local property. Call \"\n                \"`measure_local_radius` or `local_cft_analysis` first.\"\n            )\n        idx = utils.find_changing_point(loc)\n        mean_diff = float(abs(loc[:idx].mean() - loc[idx:].mean()))\n        _log = f\"spline-{i}: {mean_diff=:.3g}\"\n        if mean_diff &lt; diff_cutoff:\n            _Logger.print(f\"{_log} ==&gt; skip\")\n            continue\n        at = spl.length(0, (spl.anchors[idx - 1] + spl.anchors[idx]) / 2)\n        _Logger.print(f\"{_log} ==&gt; split at {at:.1f} nm\")\n        spl_map[i] = spl.split(at, from_start=True, trim=trim, allow_discard=True)\n\n    for i, new_spls in sorted(spl_map.items(), key=lambda x: x[0], reverse=True):\n        self.splines.pop(i)\n        for new_spl in reversed(new_spls):\n            self.splines.insert(i, new_spl)\n\n    self._update_splines_in_images()\n    self.reset_choices()\n    return None\n</code></pre>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.translate_molecules","title":"<code>translate_molecules(layers, translation, internal=True, inherit_source=True)</code>","text":"<p>Translate molecule coordinates without changing their rotations.</p> <p>Output molecules layer will be named as \"-Shift\". <p>Parameters:</p> Name Type Description Default <code>layers</code> <code>list of MoleculesLayer</code> <p>All the points layers of molecules to be used.</p> required <code>translation</code> <code>tuple of float</code> <p>Translation (nm) of the molecules in (Z, Y, X) order. Whether the world coordinate or the internal coordinate is used depends on the <code>internal</code> argument.</p> required <code>internal</code> <code>bool</code> <p>If true, the translation is applied to the internal coordinates, i.e. molecules with different rotations are translated differently.</p> <code>True</code> <code>inherit_source</code> <code>bool</code> <p>If True and the input molecules layer has its spline source, the new layer will inherit it.</p> <code>True</code> Source code in <code>cylindra/widgets/main.py</code> <pre><code>@set_design(text=capitalize, location=_sw.MoleculesMenu)\ndef translate_molecules(\n    self,\n    layers: MoleculesLayersType,\n    translation: Annotated[tuple[nm, nm, nm], {\"options\": {\"min\": -1000, \"max\": 1000, \"step\": 0.1}, \"label\": \"translation Z, Y, X (nm)\"}],\n    internal: bool = True,\n    inherit_source: Annotated[bool, {\"label\": \"Inherit source spline\"}] = True,\n):  # fmt: skip\n    \"\"\"Translate molecule coordinates without changing their rotations.\n\n    Output molecules layer will be named as \"&lt;original name&gt;-Shift\".\n\n    Parameters\n    ----------\n    {layers}\n    translation : tuple of float\n        Translation (nm) of the molecules in (Z, Y, X) order. Whether the world\n        coordinate or the internal coordinate is used depends on the `internal`\n        argument.\n    internal : bool, default True\n        If true, the translation is applied to the internal coordinates, i.e.\n        molecules with different rotations are translated differently.\n    {inherit_source}\n    \"\"\"\n    layers = assert_list_of_layers(layers, self.parent_viewer)\n    new_layers = list[MoleculesLayer]()\n    for layer in layers:\n        mole = layer.molecules\n        if internal:\n            out = mole.translate_internal(translation)\n            if Mole.position in out.features.columns:\n                # update spline position feature\n                dy = translation[1]\n                out = out.with_features([pl.col(Mole.position) + dy])\n        else:\n            out = mole.translate(translation)\n            if Mole.position in out.features.columns:\n                # spline position is not predictable.\n                out = out.drop_features([Mole.position])\n        source = layer.source_component if inherit_source else None\n        new = self.add_molecules(out, name=f\"{layer.name}-Shift\", source=source)\n        new_layers.append(new)\n        _Logger.print_html(f\"{layer.name!r} &amp;#8594; {new.name!r}\")\n    return self._undo_callback_for_layer(new_layers)\n</code></pre>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.update_scale","title":"<code>update_scale(new_scale=1.0, drop_unsafe_props=True)</code>","text":"<p>Update the scale of the tomogram and rescale all related components.</p> <p>Parameters:</p> Name Type Description Default <code>new_scale</code> <code>nm</code> <p>New scale of the tomogram in nm/pixel.</p> <code>1.0</code> <code>drop_unsafe_props</code> <code>bool</code> <p>If True, all the spline properties and molecule features that may be affected by this operation will be dropped.</p> <code>True</code> Source code in <code>cylindra/widgets/main.py</code> <pre><code>@set_design(text=\"Update pixel scale\", location=_sw.ImageMenu)\ndef update_scale(\n    self,\n    new_scale: Annotated[nm, {\"min\": 0.01, \"step\": 0.0001}] = 1.0,\n    drop_unsafe_props: bool = True,\n):\n    \"\"\"Update the scale of the tomogram and rescale all related components.\n\n    Parameters\n    ----------\n    new_scale : nm, default 1.0\n        New scale of the tomogram in nm/pixel.\n    drop_unsafe_props : bool, default True\n        If True, all the spline properties and molecule features that may be\n        affected by this operation will be dropped.\n    \"\"\"\n    if new_scale &lt;= 0:\n        raise ValueError(\"New scale must be greater than zero.\")\n    factor = new_scale / self.tomogram.scale\n    new_splines = [spl.rescale(factor) for spl in self.tomogram.splines]\n    new_splines: list[CylSpline] = []\n    # udpate spline scales\n    for spl in self.tomogram.splines:\n        new_spl = spl.rescale(factor)\n        if drop_unsafe_props:\n            new_spl.props.clear_loc()\n            new_spl.props.clear_glob()\n        new_splines.append(new_spl)\n    # update molecules, landscape and interaction layers\n    for layer in self.parent_viewer.layers:\n        if isinstance(layer, MoleculesLayer):\n            mole_new = rescale_molecules(layer.molecules, factor, drop_unsafe_props)\n            layer.molecules = mole_new\n        elif isinstance(layer, LandscapeSurface):\n            verts, faces, values = layer.data\n            layer.data = verts * factor, faces, values\n            layer.landscape = Landscape(\n                energies=layer.landscape.energies,\n                molecules=rescale_molecules(\n                    layer.landscape.molecules, factor, drop_unsafe_props\n                ),\n                argmax=layer.landscape.argmax,\n                quaternions=layer.landscape.quaternions,\n                scale_factor=layer.landscape.scale_factor * factor,\n                num_templates=layer.landscape.num_templates,\n            )\n        elif isinstance(layer, InteractionVector):\n            layer.net = InterMoleculeNet(\n                rescale_molecules(\n                    layer.net.molecules_origin, factor, drop_unsafe_props\n                ),\n                rescale_molecules(\n                    layer.net.molecules_target, factor, drop_unsafe_props\n                ),\n                layer.net.indices_origin,\n                layer.net.indices_target,\n                features=layer.net.features,\n            )\n    self.tomogram.splines.clear()\n    self.tomogram.splines.extend(new_splines)\n    self.tomogram.update_scale(new_scale)\n    self._reserved_layers.rescale_layers(factor)\n    self.GeneralInfo._refer_tomogram(self.tomogram)\n</code></pre>"},{"location":"api/widgets/main/#cylindra.widgets.main.CylindraMainWidget.z_project_reference_image","title":"<code>z_project_reference_image(method='max', colormap='twilight', overlay=True)</code>","text":"<p>Z-project the reference image and overlay it on the viewer.</p> <p>This method is useful to visualize the overall distribution of specific features in the tomogram during particle picking.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>str</code> <p>Method to use for z-projection. Can be \"max\", \"min\" or \"mean\".</p> <code>\"max\"</code> <code>colormap</code> <code>str</code> <p>Colormap to use for the projected image.</p> <code>\"twilight\"</code> <code>overlay</code> <code>bool</code> <p>If true, the new image layer will be setup to be overlayed on the tomogram.</p> <code>True</code> Source code in <code>cylindra/widgets/main.py</code> <pre><code>@set_design(text=\"Z-project reference image\", location=_sw.ImageMenu)\n@thread_worker.with_progress(desc=\"Projecting reference image\")\n@do_not_record\ndef z_project_reference_image(\n    self,\n    method: Literal[\"max\", \"min\", \"mean\"] = \"max\",\n    colormap: Literal[\"twilight\", \"cyan\", \"magenta\", \"gray\"] = \"twilight\",\n    overlay: bool = True,\n):\n    \"\"\"Z-project the reference image and overlay it on the viewer.\n\n    This method is useful to visualize the overall distribution of specific features\n    in the tomogram during particle picking.\n\n    Parameters\n    ----------\n    method : str, default \"max\"\n        Method to use for z-projection. Can be \"max\", \"min\" or \"mean\".\n    colormap : str, default \"twilight\"\n        Colormap to use for the projected image.\n    overlay : bool, default True\n        If true, the new image layer will be setup to be overlayed on the\n        tomogram.\n    \"\"\"\n    if _is_dummy_tomogram(self):\n        return\n    img_ref = self._reserved_layers.image_data\n    img_proj = img_ref.proj(axis=\"z\", method=method)\n\n    @thread_worker.callback\n    def _z_project_on_return(img_proj):\n        layer_proj = self.parent_viewer.add_image(\n            img_proj,\n            name=f\"Z-projection ({method})\",\n            scale=self._reserved_layers.image.scale[-2:],\n            translate=self._reserved_layers.image.translate[-2:],\n            opacity=0.5 if overlay else 1.0,\n            colormap=colormap,\n            blending=\"additive\" if overlay else \"translucent_no_depth\",\n        )\n        self._reserved_layers.to_be_removed.add(layer_proj)\n\n    return _z_project_on_return.with_args(img_proj)\n</code></pre>"},{"location":"api/widgets/sta/","title":"cylindra.widgets.sta.SubtomogramAveraging","text":"<p>Methods are available in the namespace <code>ui.sta</code>.</p> <p>Widget for subtomogram averaging.</p> Source code in <code>cylindra/widgets/sta.py</code> <pre><code>@magicclass(widget_type=\"scrollable\", use_native_menubar=False)\n@_shared_doc.update_cls\nclass SubtomogramAveraging(ChildWidget):\n    \"\"\"Widget for subtomogram averaging.\"\"\"\n\n    AveragingMenu = field(Averaging, name=\"Averaging\")\n    STAnalysisMenu = field(STAnalysis, name=\"Analysis\")\n    AlignmentMenu = field(Alignment, name=\"Alignment\")\n    LandscapeMenu = field(LandscapeMenu, name=\"Landscape\")\n    params = field(StaParameters)\n\n    @property\n    def sub_viewer(self) -&gt; \"napari.Viewer | None\":\n        \"\"\"The napari viewer for subtomogram averaging.\"\"\"\n        return StaParameters._viewer\n\n    def _template_param(self, *_) -&gt; Path | None:  # for bind\n        return self.params._get_template_input(allow_multiple=False)\n\n    def _template_params(self, *_) -&gt; Path | list[Path] | None:  # for bind\n        return self.params._get_template_input(allow_multiple=True)\n\n    def _get_mask_params(self, *_):  # for bind\n        return self.params._get_mask_params()\n\n    def _get_template_image(self) -&gt; ip.ImgArray:\n        scale = self._get_dummy_loader().scale\n        template = self.params._norm_template_param(\n            self._template_params(),\n            allow_none=False,\n            allow_multiple=True,\n        ).provide(scale)\n        if isinstance(template, list):\n            template = ip.asarray(np.stack(template, axis=0), axes=\"pzyx\")\n        else:\n            template = ip.asarray(template, axes=\"zyx\")\n        return template.set_scale(zyx=scale, unit=\"nm\")\n\n    def _get_mask_image(self, template_params) -&gt; ip.ImgArray:\n        loader = self._get_dummy_loader()\n        _, mask = loader.normalize_input(\n            self.params._norm_template_param(\n                template_params, allow_none=True, allow_multiple=True\n            ),\n            self.params._get_mask(),\n        )\n        if mask is None:\n            raise ValueError(\"Mask is None.\")\n        return ip.asarray(mask, axes=\"zyx\").set_scale(zyx=loader.scale, unit=\"nm\")\n\n    @magictoolbar\n    class STATools(MagicTemplate):\n        show_template = abstractapi()\n        show_template_original = abstractapi()\n        show_mask = abstractapi()\n\n    @set_design(icon=\"ic:baseline-view-in-ar\", location=STATools)\n    @do_not_record\n    def show_template(self):\n        \"\"\"Load and show template image in the scale of the tomogram.\"\"\"\n        template = self._get_template_image()\n        self._show_rec(template, name=\"Template image\", store=False)\n\n    @set_design(icon=\"material-symbols:view-in-ar\", location=STATools)\n    @do_not_record\n    def show_template_original(self):\n        \"\"\"Load and show template image in the original scale.\"\"\"\n        _input = self._template_params()\n        if _input is None:\n            raise ValueError(\"No template path provided.\")\n        elif isinstance(_input, Path):\n            self._show_rec(ip.imread(_input), name=\"Template image\", store=False)\n        else:\n            for i, fp in enumerate(_input):\n                img = ip.imread(fp)\n                self._show_rec(img, name=f\"Template image [{i}]\", store=False)\n\n    @set_design(icon=\"fluent:shape-organic-20-filled\", location=STATools)\n    @do_not_record\n    def show_mask(self):\n        \"\"\"Load and show mask image in the scale of the tomogram.\"\"\"\n        mask = self._get_mask_image(self._template_params())\n        self._show_rec(mask, name=\"Mask image\", store=False, threshold=0.5)\n\n    @property\n    def last_average(self) -&gt; \"ip.ImgArray | None\":\n        \"\"\"Last averaged image if exists.\"\"\"\n        return StaParameters._last_average\n\n    def _get_shape_in_nm(self, default: int | None = None) -&gt; tuple[nm, nm, nm]:\n        if default is None:\n            tmp = self._get_template_image()\n            return tuple(np.array(tmp.sizesof(\"zyx\")) * tmp.scale.x)\n        else:\n            return (default,) * 3\n\n    @thread_worker.callback\n    def _show_rec(self, img: ip.ImgArray, name: str, store=True, threshold=None):\n        return self.params._show_reconstruction(img, name, store, threshold=threshold)\n\n    def _get_loader(\n        self,\n        binsize: int,\n        molecules: Molecules,\n        shape: tuple[nm, nm, nm] = None,\n        order: int = 1,\n    ) -&gt; SubtomogramLoader:\n        \"\"\"\n        Returns proper subtomogram loader, template image and mask image that matche the\n        bin size.\n        \"\"\"\n        return self._get_main().tomogram.get_subtomogram_loader(\n            molecules,\n            binsize=binsize,\n            order=order,\n            output_shape=shape,\n        )\n\n    def _get_dummy_loader(self):\n        return self._get_loader(binsize=1, molecules=Molecules.empty())\n\n    def _get_available_binsize(self, _=None) -&gt; list[tuple[str, int]]:\n        return self._get_main()._get_available_binsize()\n\n    @set_design(text=\"Extract subtomograms\", location=Averaging)\n    @dask_worker.with_progress(desc=_pdesc.fmt_layers(\"Extract subtomograms of {!r}\"))\n    def extract_subtomograms(\n        self,\n        layers: MoleculesLayersType,\n        size: _SubVolumeSize = None,\n        interpolation: Annotated[int, {\"choices\": INTERPOLATION_CHOICES}] = 1,\n        bin_size: Annotated[int, {\"choices\": _get_available_binsize}] = 1,\n        compute: bool = False,\n    ):\n        \"\"\"Extract subtomograms around molecules in the selected layer(s).\n\n        Extracted 3D images will be sent to the sub-viewer. Note that this extraction\n        operation is NOT needed for subsequent averaging/alignment operations, as they\n        internally extract subtomograms by themselves.\n\n        Parameters\n        ----------\n        {layers}{size}{interpolation}{bin_size}\n        compute : bool, default: False\n            If True, the subtomograms will be computed immediately, and in-memory data\n            will be sent to the sub-viewer.\n        \"\"\"\n        layers = assert_list_of_layers(layers, self.parent_viewer)\n        parent = self._get_main()\n        tomo = parent.tomogram\n        shape = self._get_shape_in_nm(size)\n        loader = tomo.get_subtomogram_loader(\n            _concat_molecules(layers), shape, binsize=bin_size, order=interpolation\n        )\n        subtomos = ip.lazy.asarray(loader.construct_dask(), axes=\"pzyx\")\n        if compute:\n            subtomos = subtomos.compute()\n        return self._show_rec.with_args(\n            subtomos, f\"[Subtomos]{_avg_name(layers)}\", store=False\n        )\n\n    @set_design(text=\"Average all molecules\", location=Averaging)\n    @dask_worker.with_progress(desc=_pdesc.fmt_layers(\"Subtomogram averaging of {!r}\"))\n    def average_all(\n        self,\n        layers: MoleculesLayersType,\n        size: _SubVolumeSize = None,\n        interpolation: Annotated[int, {\"choices\": INTERPOLATION_CHOICES}] = 1,\n        bin_size: Annotated[int, {\"choices\": _get_available_binsize}] = 1,\n    ):\n        \"\"\"Subtomogram averaging using all the molecules in the selected layer(s).\n\n        If multiple layers are selected, subtomograms around all the molecules will\n        be averaged.\n\n        Parameters\n        ----------\n        {layers}{size}{interpolation}{bin_size}\n        \"\"\"\n        t0 = timer()\n        layers = assert_list_of_layers(layers, self.parent_viewer)\n        parent = self._get_main()\n        tomo = parent.tomogram\n        shape = self._get_shape_in_nm(size)\n        loader = tomo.get_subtomogram_loader(\n            _concat_molecules(layers), shape, binsize=bin_size, order=interpolation\n        )\n        img = ip.asarray(loader.average(), axes=\"zyx\")\n        img.set_scale(zyx=loader.scale, unit=\"nm\")\n        t0.toc()\n        _Logger.print_html(\n            f\"{loader.molecules.count()} molecules. Image size: {shape[0]:.2f} nm ({img.shape[0]} pixel)\"\n        )\n        return self._show_rec.with_args(img, f\"[AVG]{_avg_name(layers)}\")\n\n    @set_design(text=\"Average subset of molecules\", location=Averaging)\n    @dask_worker.with_progress(desc=_pdesc.fmt_layers(\"Subtomogram averaging (subset) of {!r}\"))  # fmt: skip\n    def average_subset(\n        self,\n        layers: MoleculesLayersType,\n        size: _SubVolumeSize = None,\n        method: Literal[\"steps\", \"first\", \"last\", \"random\"] = \"steps\",\n        number: int = 64,\n        bin_size: Annotated[int, {\"choices\": _get_available_binsize}] = 1,\n    ):\n        \"\"\"Subtomogram averaging using a subset of subvolumes.\n\n        If multiple layers are selected, subtomograms around all the molecules will\n        be concatenated before choosing a subset.\n\n        Parameters\n        ----------\n        {layers}{size}\n        method : str, optional\n            How to choose subtomogram subset.\n            (1) steps: Each 'steps' subtomograms from the tip of spline.\n            (2) first: First subtomograms.\n            (3) last: Last subtomograms.\n            (4) random: choose randomly.\n        number : int, default\n            Number of subtomograms to use.\n        {bin_size}\n        \"\"\"\n        t0 = timer()\n        layers = assert_list_of_layers(layers, self.parent_viewer)\n        parent = self._get_main()\n        molecules = _concat_molecules(layers)\n        nmole = len(molecules)\n        shape = self._get_shape_in_nm(size)\n        sl = _get_slice_for_average_subset(method, nmole, number)\n        mole = molecules.subset(sl)\n        loader = parent.tomogram.get_subtomogram_loader(\n            mole, shape, binsize=bin_size, order=1\n        )\n        img = ip.asarray(loader.average(), axes=\"zyx\").set_scale(zyx=loader.scale)\n        t0.toc()\n        return self._show_rec.with_args(img, f\"[AVG(n={number})]{_avg_name(layers)}\")\n\n    @set_design(text=\"Average group-wise\", location=Averaging)\n    @dask_worker.with_progress(desc=_pdesc.fmt_layers(\"Grouped subtomogram averaging of {!r}\"))  # fmt: skip\n    def average_groups(\n        self,\n        layers: MoleculesLayersType,\n        size: _SubVolumeSize = None,\n        by: PolarsExprStr = \"col('pf-id')\",\n        interpolation: Annotated[int, {\"choices\": INTERPOLATION_CHOICES}] = 1,\n        bin_size: Annotated[int, {\"choices\": _get_available_binsize}] = 1,\n    ):\n        \"\"\"Group-wise subtomogram averaging.\n\n        This method first group molecules by its features, and then average each group.\n        This method is useful for such as get average of each protofilament and segmented\n        subtomogram averaging.\n\n        Parameters\n        ----------\n        {layers}{size}\n        by : str or polars expression\n            Expression to group molecules.\n        {interpolation}{bin_size}\n        \"\"\"\n        t0 = timer()\n        layers = assert_list_of_layers(layers, self.parent_viewer)\n        parent = self._get_main()\n        tomo = parent.tomogram\n        shape = self._get_shape_in_nm(size)\n        loader = tomo.get_subtomogram_loader(\n            _concat_molecules(layers), shape, binsize=bin_size, order=interpolation\n        )\n        expr = widget_utils.norm_expr(by)\n        groups = loader.groupby(expr)\n        avg_dict = groups.average()\n        avgs = np.stack([avg_dict[k] for k in sorted(avg_dict.keys())], axis=0)\n        img = ip.asarray(avgs, axes=\"pzyx\")\n        img.set_scale(zyx=loader.scale, unit=\"nm\")\n        t0.toc()\n        mole_counts = [sub.molecules.count() for _, sub in groups]\n        _Logger.print_html(\n            f\"Averages of {len(avg_dict)} groups, {mole_counts} molecules \"\n            f\"respectively.\\nImage size: {shape[0]:.2f} nm ({img.shape[-1]} pixel)\"\n        )\n        return self._show_rec.with_args(img, f\"[AVG]{_avg_name(layers)}\")\n\n    @set_design(text=\"Average filtered\", location=Averaging)\n    @dask_worker.with_progress(desc=_pdesc.fmt_layers(\"Filtered subtomogram averaging of {!r}\"))  # fmt: skip\n    def average_filtered(\n        self,\n        layers: MoleculesLayersType,\n        size: _SubVolumeSize = None,\n        predicate: PolarsExprStr = \"col('pf-id') == 0\",\n        interpolation: Annotated[int, {\"choices\": INTERPOLATION_CHOICES}] = 1,\n        bin_size: Annotated[int, {\"choices\": _get_available_binsize}] = 1,\n    ):\n        \"\"\"Subtomogram averaging using molecules filtered by the given expression.\n\n        This method first concatenate molecules in the selected layers, and then filter them\n        by the predicate.\n\n        Parameters\n        ----------\n        {layers}{size}\n        predicate : str or polars expression\n            Filter expression to select molecules.\n        {interpolation}{bin_size}\n        \"\"\"\n        t0 = timer()\n        layers = assert_list_of_layers(layers, self.parent_viewer)\n        parent = self._get_main()\n        tomo = parent.tomogram\n        shape = self._get_shape_in_nm(size)\n        loader = tomo.get_subtomogram_loader(\n            _concat_molecules(layers), shape, binsize=bin_size, order=interpolation\n        ).filter(widget_utils.norm_expr(predicate))\n        avg = loader.average()\n        img = ip.asarray(avg, axes=\"zyx\")\n        img.set_scale(zyx=loader.scale, unit=\"nm\")\n        t0.toc()\n        _Logger.print_html(\n            f\"Average of {loader.molecules.count()} molecules. Image size: {shape[0]:.2f} nm ({img.shape[0]} pixel)\"\n        )\n        return self._show_rec.with_args(img, f\"[AVG]{_avg_name(layers)}\")\n\n    @set_design(text=\"Align average to template\", location=Alignment)\n    @dask_worker.with_progress()\n    def align_averaged(\n        self,\n        layers: MoleculesLayersType,\n        template_path: Annotated[_PathOrNone, {\"bind\": _template_param}],\n        mask_params: Annotated[Any, {\"bind\": _get_mask_params}],\n        max_shifts: Optional[_MaxShifts] = None,\n        rotations: _Rotations = ((0.0, 0.0), (15.0, 1.0), (3.0, 1.0)),\n        bin_size: Annotated[int, {\"choices\": _get_available_binsize}] = 1,\n        method: Annotated[str, {\"choices\": METHOD_CHOICES}] = \"zncc\",\n    ):  # fmt: skip\n        \"\"\"Align the averaged image at current monomers to the template image.\n\n        This function creates a new layer with transformed monomers, which should\n        align well with template image.\n\n        Parameters\n        ----------\n        {layers}{template_path}{mask_params}{max_shifts}{rotations}{bin_size}{method}\n        \"\"\"\n        t0 = timer()\n        layers = assert_list_of_layers(layers, self.parent_viewer)\n        parent = self._get_main()\n\n        new_layers = list[MoleculesLayer]()\n        total = 2 * len(layers) + 1\n        yield thread_worker.description(\n            f\"(0/{total}) Preparing template images for alignment\"\n        )\n\n        @thread_worker.callback\n        def _on_yield(mole_trans: Molecules, layer: MoleculesLayer):\n            points = parent.add_molecules(\n                mole_trans,\n                name=_coerce_aligned_name(layer.name, self.parent_viewer),\n                source=layer.source_component,\n            )\n            new_layers.append(points)\n            layer.visible = False\n            _Logger.print_html(f\"{layer.name!r} &amp;#8594; {points.name!r}\")\n\n        mole = layers[0].molecules\n        loader = self._get_loader(bin_size, mole, order=1)\n        template, mask = loader.normalize_input(\n            template=self.params._norm_template_param(\n                template_path, allow_multiple=False\n            ),\n            mask=self.params._get_mask(params=mask_params),\n        )\n        temp_norm = utils.normalize_image(template)\n\n        _scale = parent.tomogram.scale * bin_size\n\n        if max_shifts is None:\n            max_shifts = _default_align_averaged_shifts(mole)\n\n        model = _get_alignment(method)(\n            template,\n            mask,\n            rotations=rotations,\n            tilt=None,  # NOTE: because input is an average\n        )\n        _spl_globs = list[\n            tuple[weakref.ReferenceType[\"CylSpline\"], pl.DataFrame, pl.DataFrame]\n        ]()\n        for i, layer in enumerate(layers):\n            mole = layer.molecules\n            loader = self._get_loader(bin_size, mole, order=1)\n            yield thread_worker.description(\n                f\"({i * 2 + 1}/{total}) Subtomogram averaging of {layer.name!r}\"\n            )\n            avg = loader.average(template.shape)\n            yield thread_worker.description(\n                f\"({i * 2 + 2}/{total}) Aligning template to the average image of {layer.name!r}\"\n            )\n            _img_trans, result = model.fit(\n                avg,\n                max_shifts=[_s / _scale for _s in max_shifts],\n            )\n\n            rotator = Rotation.from_quat(result.quat)\n            svec = result.shift * _scale\n            _mole_trans = mole.linear_transform(result.shift * _scale, rotator)\n\n            # write offsets to spline globalprops if available\n            if spl := layer.source_spline:\n                _Logger.print(\n                    f\"Layer {layer.name} has a source spline, update its globalprops.\"\n                )\n                _mole_trans = widget_utils.update_mole_pos(_mole_trans, mole, spl)\n                if spl.radius is None:\n                    _radius: nm = cylmeasure.calc_radius(mole, spl).mean()\n                else:\n                    _radius = spl.radius\n                _glob_old = spl.props.glob.clone()\n                _glob_new = _update_offset(spl, rotator.apply(svec), _radius)\n                spl.props.glob = _glob_new\n                _spl_globs.append((weakref.ref(spl), _glob_old, _glob_new))\n\n            yield _on_yield.with_args(_mole_trans, layer)\n\n            # create images for visualization in the logger. Image is magenta, template is green\n            img_norm = utils.normalize_image(_img_trans)\n            merge = np.stack([img_norm, temp_norm, img_norm], axis=-1)\n            with _Logger.set_plt():\n                widget_utils.plot_projections(merge)\n\n            # logging\n            rvec = rotator.as_rotvec()\n            _fmt = \"  {:.2f}  \".format\n            _Logger.print_table(\n                [\n                    [\"\", \"X\", \"Y\", \"Z\"],\n                    [\"Shift (nm)\", _fmt(svec[2]), _fmt(svec[1]), _fmt(svec[0])],\n                    [\"Rot vector\", _fmt(rvec[2]), _fmt(rvec[1]), _fmt(rvec[0])],\n                ],\n                header=False,\n                index=False,\n            )\n\n        t0.toc()\n\n        @thread_worker.callback\n        def _align_averaged_on_return():\n            @undo_callback\n            def _out():\n                parent._try_removing_layers(new_layers)\n                for spl_ref, old, _ in _spl_globs:\n                    if spl := spl_ref():\n                        spl.props.glob = old\n\n            @_out.with_redo\n            def _out():\n                parent._add_layers_future(new_layers)()\n                for spl_ref, _, new in _spl_globs:\n                    if spl := spl_ref():\n                        spl.props.glob = new\n\n            return _out\n\n        return _align_averaged_on_return.with_desc(\"Finished\")\n\n    sep0 = Separator\n\n    @set_design(text=\"Align all molecules\", location=Alignment)\n    @dask_worker.with_progress(descs=_pdesc.align_all_fmt)\n    def align_all(\n        self,\n        layers: MoleculesLayersType,\n        template_path: Annotated[_PathOrPathsOrNone, {\"bind\": _template_params}],\n        mask_params: Annotated[Any, {\"bind\": _get_mask_params}],\n        max_shifts: _MaxShifts = (1.0, 1.0, 1.0),\n        rotations: _Rotations = ((0.0, 0.0), (0.0, 0.0), (0.0, 0.0)),\n        cutoff: _CutoffFreq = 0.5,\n        interpolation: Annotated[int, {\"choices\": INTERPOLATION_CHOICES}] = 3,\n        method: Annotated[str, {\"choices\": METHOD_CHOICES}] = \"zncc\",\n        bin_size: Annotated[int, {\"choices\": _get_available_binsize}] = 1,\n    ):  # fmt: skip\n        \"\"\"Align the input template image to all the molecules.\n\n        Parameters\n        ----------\n        {layers}{template_path}{mask_params}{max_shifts}{rotations}{cutoff}\n        {interpolation}{method}{bin_size}\n        \"\"\"\n        t0 = timer()\n        layers = assert_list_of_layers(layers, self.parent_viewer)\n        main = self._get_main()\n\n        combiner = widget_utils.MoleculesCombiner()\n\n        loader = self._get_loader(\n            binsize=bin_size,\n            molecules=combiner.concat(layer.molecules for layer in layers),\n            order=interpolation,\n        )\n        _Logger.print(f\"Aligning {loader.molecules.count()} molecules ...\")\n        aligned_loader = loader.align(\n            template=self.params._norm_template_param(\n                template_path, allow_multiple=True\n            ),\n            mask=self.params._get_mask(params=mask_params),\n            max_shifts=max_shifts,\n            rotations=rotations,\n            cutoff=cutoff,\n            alignment_model=_get_alignment(method),\n            tilt=main.tomogram.tilt_model,\n        )\n        molecules = combiner.split(aligned_loader.molecules, layers)\n        t0.toc()\n        return self._align_all_on_return.with_args(molecules, layers)\n\n    @set_design(text=\"Align all (template-free)\", location=Alignment)\n    @dask_worker.with_progress()\n    def align_all_template_free(\n        self,\n        layers: MoleculesLayersType,\n        mask_params: Annotated[Any, {\"bind\": _get_mask_params}],\n        size: _SubVolumeSize = 12.0,\n        max_shifts: _MaxShifts = (1.0, 1.0, 1.0),\n        rotations: _Rotations = ((0.0, 0.0), (0.0, 0.0), (0.0, 0.0)),\n        interpolation: Annotated[int, {\"choices\": INTERPOLATION_CHOICES}] = 3,\n        method: Annotated[str, {\"choices\": METHOD_CHOICES}] = \"zncc\",\n        bin_size: Annotated[int, {\"choices\": _get_available_binsize}] = 1,\n        seed: Annotated[Optional[int], {\"text\": \"Do not use random seed.\"}] = 0,\n        tolerance: float = 0.01,\n    ):  # fmt: skip\n        \"\"\"Iteratively align molecules and validate using FSC without template.\n\n        Parameters\n        ----------\n        {layers}{mask_params}{size}{max_shifts}{rotations}{interpolation}\n        {method}{bin_size}\n        seed : int, optional\n            Random seed for FSC calculation.\n        tolerance : float, default 0.01\n            Tolerance for convergence of the FSC calculation.\n        \"\"\"\n        t0 = timer()\n        rng = np.random.default_rng(seed)\n        layers = assert_list_of_layers(layers, self.parent_viewer)\n        main = self._get_main()\n        combiner = widget_utils.MoleculesCombiner()\n        molecules = combiner.concat(layer.molecules for layer in layers)\n        mask = self.params._get_mask(params=mask_params)\n        if size is None:\n            raise NotImplementedError(\"'size' must be given.\")\n        else:\n            shape = tuple(\n                main.tomogram.nm2pixel(self._get_shape_in_nm(size), binsize=bin_size)\n            )\n        aligned_loader = current_loader = self._get_loader(\n            binsize=bin_size, molecules=molecules, order=interpolation\n        ).reshape(shape=shape)\n        _alignment_state = widget_utils.TemplateFreeAlignmentState(rng=rng)\n        _Logger.print(f\"Start alignment ({molecules.count()} molecules) ...\")\n        while True:\n            yield thread_worker.description(\n                f\"Calculating FSC for iteration {_alignment_state.niter}\"\n            )\n            fsc_result, avg = _alignment_state.eval_fsc(\n                aligned_loader,\n                mask,\n                tolerance=tolerance,\n            )\n            yield _plot_current_fsc.with_args(\n                fsc_result, _alignment_state.niter, avg\n            ).with_desc(f\"Alignment for iteration {_alignment_state.niter}\")\n            if _alignment_state.converged:\n                _Logger.print(\"FSC converged.\")\n                yield self._show_rec.with_args(avg, f\"[Aligned]{_avg_name(layers)}\")\n                break\n            _alignment_state.niter += 1\n            aligned_loader = current_loader.align(\n                avg, mask=mask, max_shifts=max_shifts, rotations=rotations,\n                cutoff=current_loader.scale / fsc_result.get_resolution(0.143),\n                alignment_model=_get_alignment(method),\n            )  # fmt: skip\n\n        molecules = combiner.split(aligned_loader.molecules, layers)\n        t0.toc()\n        return self._align_all_on_return.with_args(molecules, layers)\n\n    sep1 = Separator\n\n    @set_design(text=\"Viterbi Alignment\", location=Alignment)\n    @dask_worker.with_progress(descs=_pdesc.align_viterbi_fmt)\n    def align_all_viterbi(\n        self,\n        layer: MoleculesLayerType,\n        template_path: Annotated[_PathOrPathsOrNone, {\"bind\": _template_params}],\n        mask_params: Annotated[Any, {\"bind\": _get_mask_params}] = None,\n        max_shifts: _MaxShifts = (0.8, 0.8, 0.8),\n        rotations: _Rotations = ((0.0, 0.0), (0.0, 0.0), (0.0, 0.0)),\n        cutoff: _CutoffFreq = 0.5,\n        interpolation: Annotated[int, {\"choices\": INTERPOLATION_CHOICES}] = 3,\n        range_long: _DistRangeLon = (4.0, 4.28),\n        angle_max: _AngleMaxLon = 5.0,\n        bin_size: Annotated[int, {\"choices\": _get_available_binsize}] = 1,\n        upsample_factor: Annotated[int, {\"min\": 1, \"max\": 20}] = 5,\n    ):  # fmt: skip\n        \"\"\"Subtomogram alignment using 1D Viterbi alignment.\n\n        1D Viterbi alignment is an alignment algorithm that considers the distance and\n        the skew angle between every longitudinally adjacent monomers. The classical\n        Viterbi algorithm is used to find the global optimal solution of the alignment.\n        Note that Viterbi alignment is data size dependent, i.e. the alignment result\n        of molecules may vary depending on the total number of molecules in the dataset.\n\n        Parameters\n        ----------\n        {layer}{template_path}{mask_params}{max_shifts}{rotations}{cutoff}\n        {interpolation}{range_long}{angle_max}{bin_size}{upsample_factor}\n        \"\"\"\n        t0 = timer()\n        layer = assert_layer(layer, self.parent_viewer)\n        landscape, _ = self._construct_landscape(\n            molecules=layer.molecules,\n            template_path=template_path,\n            mask_params=mask_params,\n            max_shifts=max_shifts,\n            rotations=rotations,\n            cutoff=cutoff,\n            order=interpolation,\n            upsample_factor=upsample_factor,\n            bin_size=bin_size,\n        )\n\n        yield\n        mole = landscape.run_viterbi_along_spline(\n            spl=layer.source_spline,\n            range_long=range_long,\n            angle_max=angle_max,\n        )\n        t0.toc()\n        return self._align_all_on_return.with_args([mole], [layer])\n\n    @property\n    def align_all_annealing(self):  # pragma: no cover\n        warnings.warn(\n            \"align_all_annealing is deprecated. Use align_all_rma instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        return self.align_all_rma\n\n    @set_design(text=\"Simulated annealing (RMA)\", location=Alignment)\n    @dask_worker.with_progress(descs=_pdesc.align_annealing_fmt)\n    def align_all_rma(\n        self,\n        layer: MoleculesLayerType,\n        template_path: Annotated[_PathOrPathsOrNone, {\"bind\": _template_params}],\n        mask_params: Annotated[Any, {\"bind\": _get_mask_params}] = None,\n        max_shifts: _MaxShifts = (0.8, 0.8, 0.8),\n        rotations: _Rotations = ((0.0, 0.0), (0.0, 0.0), (0.0, 0.0)),\n        cutoff: _CutoffFreq = 0.5,\n        interpolation: Annotated[int, {\"choices\": INTERPOLATION_CHOICES}] = 3,\n        range_long: _DistRangeLon = (4.0, 4.28),\n        range_lat: _DistRangeLat = (5.1, 5.3),\n        angle_max: _AngleMaxLon = 5.0,\n        bin_size: Annotated[int, {\"choices\": _get_available_binsize}] = 1,\n        temperature_time_const: Annotated[float, {\"min\": 0.01, \"max\": 10.0}] = 1.0,\n        upsample_factor: Annotated[int, {\"min\": 1, \"max\": 20}] = 5,\n        random_seeds: _RandomSeeds = (0, 1, 2, 3, 4),\n    ):  # fmt: skip\n        \"\"\"2D-constrained subtomogram alignment using simulated annealing.\n\n        This alignment method considers the distance between every adjacent monomers.\n        Two-dimensionally connected optimization can be approximated by the simulated\n        annealing algorithm.\n\n        Parameters\n        ----------\n        {layer}{template_path}{mask_params}{max_shifts}{rotations}{cutoff}\n        {interpolation}{range_long}{range_lat}{angle_max}{bin_size}\n        {temperature_time_const}{upsample_factor}{random_seeds}\n        \"\"\"\n        t0 = timer()\n        layer = assert_layer(layer, self.parent_viewer)\n        if layer.source_spline is None:\n            raise ValueError(\n                \"RMA requires a spline but the input layer is not connected to any splines.\"\n            )\n        main = self._get_main()\n        _Logger.print(\n            f\"Constructing correlation landscape on {layer.name} ({layer.molecules.count()} molecules) for RMA ...\"\n        )\n        landscape, _ = self._construct_landscape(\n            molecules=layer.molecules,\n            template_path=template_path,\n            mask_params=mask_params,\n            max_shifts=max_shifts,\n            rotations=rotations,\n            cutoff=cutoff,\n            order=interpolation,\n            bin_size=bin_size,\n            upsample_factor=upsample_factor,\n        )\n        yield\n        mole, results = landscape.run_annealing_along_spline(\n            layer.source_spline,\n            range_long=range_long,\n            range_lat=range_lat,\n            angle_max=angle_max,\n            temperature_time_const=temperature_time_const,\n            random_seeds=random_seeds,\n        )\n        t0.toc()\n\n        @thread_worker.callback\n        def _on_return():\n            points = main.add_molecules(\n                mole,\n                name=_coerce_aligned_name(layer.name, self.parent_viewer),\n                source=layer.source_component,\n                metadata={ANNEALING_RESULT: results[0]},\n            )\n            layer.visible = False\n            with _Logger.set_plt():\n                _annealing.plot_annealing_result(results)\n            return self._undo_for_new_layer([layer.name], [points])\n\n        return _on_return\n\n    @set_design(text=\"Simulated annealing (RMA, template free)\", location=Alignment)\n    @dask_worker.with_progress()\n    def align_all_rma_template_free(\n        self,\n        layer: MoleculesLayerType,\n        mask_params: Annotated[Any, {\"bind\": _get_mask_params}] = None,\n        size: _SubVolumeSize = 12.0,\n        max_shifts: _MaxShifts = (0.8, 0.8, 0.8),\n        rotations: _Rotations = ((0.0, 0.0), (0.0, 0.0), (0.0, 0.0)),\n        interpolation: Annotated[int, {\"choices\": INTERPOLATION_CHOICES}] = 3,\n        method: Annotated[str, {\"choices\": METHOD_CHOICES}] = \"zncc\",\n        range_long: _DistRangeLon = (4.0, 4.28),\n        range_lat: _DistRangeLat = (5.1, 5.3),\n        angle_max: _AngleMaxLon = 5.0,\n        bin_size: Annotated[int, {\"choices\": _get_available_binsize}] = 1,\n        temperature_time_const: Annotated[float, {\"min\": 0.01, \"max\": 10.0}] = 0.7,\n        upsample_factor: Annotated[int, {\"min\": 1, \"max\": 20}] = 5,\n        seed: Annotated[Optional[int], {\"text\": \"Do not use random seed.\"}] = 0,\n        tolerance: float = 0.01,\n    ):  # fmt: skip\n        \"\"\"2D-constrained subtomogram alignment using simulated annealing.\n\n        This alignment method considers the distance between every adjacent monomers.\n        Two-dimensionally connected optimization can be approximated by the simulated\n        annealing algorithm.\n\n        Parameters\n        ----------\n        {layer}{mask_params}{max_shifts}{rotations}{interpolation}{range_long}\n        {range_lat}{angle_max}{bin_size}\n        {temperature_time_const}{upsample_factor}\n        seed : int, optional\n            Random seed for FSC calculation.\n        tolerance : float, default 0.01\n            Tolerance for convergence of the FSC calculation.\n        \"\"\"\n        t0 = timer()\n        layer = assert_layer(layer, self.parent_viewer)\n        if layer.source_spline is None:\n            raise ValueError(\n                \"RMA requires a spline but the input layer is not connected to any splines.\"\n            )\n        main = self._get_main()\n        if size is None:\n            raise NotImplementedError(\"'size' must be given.\")\n        else:\n            shape = tuple(\n                main.tomogram.nm2pixel(self._get_shape_in_nm(size), binsize=bin_size)\n            )\n        rng = np.random.default_rng(seed)\n        mask = self.params._get_mask(params=mask_params)\n\n        aligned_loader = current_loader = self._get_loader(\n            binsize=bin_size, molecules=layer.molecules, order=interpolation\n        ).reshape(shape=shape)\n        _alignment_state = widget_utils.TemplateFreeAlignmentState(rng=rng)\n\n        @thread_worker.callback\n        def _plot_annealing_result(results):\n            with _Logger.set_plt():\n                _annealing.plot_annealing_result(results)\n\n        next_layer_name = _coerce_aligned_name(layer.name, self.parent_viewer)\n        while True:\n            yield thread_worker.description(\n                f\"Calculating FSC (iteration {_alignment_state.niter})\"\n            )\n            fsc_result, avg = _alignment_state.eval_fsc(\n                aligned_loader, mask, tolerance=tolerance\n            )\n            yield _plot_current_fsc.with_args(\n                fsc_result, _alignment_state.niter, avg\n            ).with_desc(f\"Landscape construction (iteration {_alignment_state.niter})\")\n            if _alignment_state.converged:\n                _Logger.print(\"FSC converged.\")\n                yield self._show_rec.with_args(avg, f\"[Aligned]{next_layer_name}\")\n                break\n            _alignment_state.niter += 1\n            landscape = Landscape.from_loader(\n                loader=current_loader,\n                template=avg,\n                mask=self.params._get_mask(params=mask_params),\n                max_shifts=max_shifts,\n                upsample_factor=upsample_factor,\n                alignment_model=_get_alignment(method).with_params(\n                    rotations=rotations,\n                    cutoff=current_loader.scale / fsc_result.get_resolution(0.143),\n                    tilt=main.tomogram.tilt_model,\n                ),\n            )\n            yield thread_worker.description(\n                f\"Running RMA (iteration {_alignment_state.niter})\"\n            )\n            mole, results = landscape.run_annealing_along_spline(\n                layer.source_spline,\n                range_long=range_long,\n                range_lat=range_lat,\n                angle_max=angle_max,\n                temperature_time_const=temperature_time_const,\n                random_seeds=rng.integers(0, 2**32, size=3).tolist(),\n            )\n            aligned_loader = SubtomogramLoader(\n                current_loader.image,\n                mole,\n                order=current_loader.order,\n                scale=current_loader.scale,\n                output_shape=current_loader.output_shape,\n            )\n            yield _plot_annealing_result.with_args(results)\n\n        t0.toc()\n\n        @thread_worker.callback\n        def _on_return():\n            points = main.add_molecules(\n                aligned_loader.molecules,\n                name=next_layer_name,\n                source=layer.source_component,\n                metadata={ANNEALING_RESULT: results[0]},\n            )\n            layer.visible = False\n            with _Logger.set_plt():\n                _annealing.plot_annealing_result(results)\n            return self._undo_for_new_layer([layer.name], [points])\n\n        return _on_return\n\n    @set_design(text=\"Simulated annealing (RFA)\", location=Alignment)\n    @dask_worker.with_progress(descs=_pdesc.align_annealing_fmt)\n    def align_all_rfa(\n        self,\n        layer: MoleculesLayerType,\n        template_path: Annotated[_PathOrPathsOrNone, {\"bind\": _template_params}],\n        mask_params: Annotated[Any, {\"bind\": _get_mask_params}] = None,\n        max_shifts: _MaxShifts = (0.8, 0.8, 0.8),\n        rotations: _Rotations = ((0.0, 0.0), (0.0, 0.0), (0.0, 0.0)),\n        cutoff: _CutoffFreq = 0.5,\n        interpolation: Annotated[int, {\"choices\": INTERPOLATION_CHOICES}] = 3,\n        range_long: _DistRangeLon = (4.0, 4.28),\n        angle_max: _AngleMaxLon = 5.0,\n        bin_size: Annotated[int, {\"choices\": _get_available_binsize}] = 1,\n        temperature_time_const: Annotated[float, {\"min\": 0.01, \"max\": 10.0}] = 1.0,\n        upsample_factor: Annotated[int, {\"min\": 1, \"max\": 20}] = 5,\n        random_seeds: _RandomSeeds = (0, 1, 2, 3, 4),\n    ):\n        \"\"\"1D-constrained subtomogram alignment on a filament using simulated annealing.\n\n        This alignment method considers the distance between every adjacent monomers on\n        the filament.\n\n        Parameters\n        ----------\n        {layer}{template_path}{mask_params}{max_shifts}{rotations}{cutoff}\n        {interpolation}{range_long}{angle_max}{bin_size}{temperature_time_const}\n        {upsample_factor}{random_seeds}\n        \"\"\"\n        t0 = timer()\n        layer = assert_layer(layer, self.parent_viewer)\n        if layer.source_spline is None:\n            raise ValueError(\"RMA requires a spline.\")\n        main = self._get_main()\n        _Logger.print(\n            f\"Constructing correlation landscape on {layer.name} ({layer.molecules.count()} molecules) for RFA ...\"\n        )\n        landscape, _ = self._construct_landscape(\n            molecules=layer.molecules,\n            template_path=template_path,\n            mask_params=mask_params,\n            max_shifts=max_shifts,\n            rotations=rotations,\n            cutoff=cutoff,\n            order=interpolation,\n            bin_size=bin_size,\n            upsample_factor=upsample_factor,\n        )\n        yield\n        mole, results = landscape.run_filamentous_annealing(\n            range=range_long,\n            angle_max=angle_max,\n            temperature_time_const=temperature_time_const,\n            random_seeds=random_seeds,\n        )\n        t0.toc()\n\n        @thread_worker.callback\n        def _on_return():\n            points = main.add_molecules(\n                mole,\n                name=_coerce_aligned_name(layer.name, self.parent_viewer),\n                source=layer.source_component,\n                metadata={ANNEALING_RESULT: results[0]},\n            )\n            layer.visible = False\n            with _Logger.set_plt():\n                _annealing.plot_annealing_result(results)\n\n            return self._undo_for_new_layer([layer.name], [points])\n\n        return _on_return\n\n    def _get_splines(self, *_) -&gt; list[int]:\n        return self._get_main()._get_splines()\n\n    @set_design(text=\"Fit spline by RFA\", location=Alignment)\n    @dask_worker.with_progress(descs=_pdesc.fit_spline_rfa_fmt)\n    def fit_spline_rfa(\n        self,\n        spline: Annotated[int, {\"choices\": _get_splines}],\n        template_path: Annotated[_PathOrPathsOrNone, {\"bind\": _template_params}],\n        forward_is: Literal[\"PlusToMinus\", \"MinusToPlus\"] = \"MinusToPlus\",\n        interval: PolarsExprStrOrScalar = \"4.1\",\n        err_max: Annotated[nm, {\"label\": \"Max fit error (nm)\", \"step\": 0.1}] = 0.5,\n        mask_params: Annotated[Any, {\"bind\": _get_mask_params}] = None,\n        max_shifts: _MaxShifts = (2.0, 2.0, 2.0),\n        rotations: _Rotations = ((0.0, 0.0), (15.0, 5.0), (0.0, 0.0)),\n        cutoff: _CutoffFreq = 0.5,\n        interpolation: Annotated[int, {\"choices\": INTERPOLATION_CHOICES}] = 3,\n        range_long: _DistRangeLon = (4.0, 4.28),\n        angle_max: _AngleMaxLon = 5.0,\n        bin_size: Annotated[int, {\"choices\": _get_available_binsize}] = 1,\n        temperature_time_const: Annotated[float, {\"min\": 0.01, \"max\": 100.0}] = 10.0,\n        upsample_factor: Annotated[int, {\"min\": 1, \"max\": 20}] = 5,\n        random_seeds: _RandomSeeds = (0, 1, 2, 3, 4),\n    ):\n        \"\"\"Fit spline by RFA.\n\n        This algorithm uses a template image to precisely determine the center line of\n        filaments. By comparing the score, the orientation of the filament will also be\n        determined.\n\n        Parameters\n        ----------\n        {spline}{template_path}\n        forward_is : \"PlusToMinus\" or \"MinusToPlus\", default \"MinusToPlus\"\n            Which orientation is the forward direction. Set \"PlusToMinus\" if the\n            template image is oriented from the plus end to the minus end in the y\n            direction.\n        interval : float or str expression, default 4.1\n            Interval of the sampling points along the spline.\n        {err_max}{mask_params}{max_shifts}{rotations}{cutoff}{interpolation}{range_long}\n        {angle_max}{bin_size}{temperature_time_const}{upsample_factor}{random_seeds}\n        \"\"\"\n        t0 = timer()\n        main = self._get_main()\n        tomo = main.tomogram\n        spl_old = tomo.splines[spline]\n        interv_expr = widget_utils.norm_scalar_expr(interval)\n        mole_fw = tomo.map_centers(\n            i=spline,\n            interval=spl_old.props.get_glob(interv_expr),\n            rotate_molecules=False,\n        )\n        mole_rv = mole_fw.rotate_by_rotvec([np.pi, 0, 0])  # invert\n\n        @thread_worker.callback\n        def _on_yield(results):\n            with _Logger.set_plt():\n                _annealing.plot_annealing_result(results)\n\n        def _construct_landscape(mole_):\n            landscape_, _ = self._construct_landscape(\n                molecules=mole_, template_path=template_path, mask_params=mask_params,\n                max_shifts=max_shifts, rotations=rotations, cutoff=cutoff, norm=False,\n                order=interpolation, bin_size=bin_size, upsample_factor=upsample_factor,\n            )  # fmt: skip\n            yield\n            mole, results = landscape_.run_filamentous_annealing(\n                range=range_long,\n                angle_max=angle_max,\n                temperature_time_const=temperature_time_const,\n                random_seeds=random_seeds,\n            )\n            yield _on_yield.with_args(results)\n            return mole, results\n\n        mole_opt_fw, results_fw = yield from _construct_landscape(mole_fw)\n        mole_opt_rv, results_rv = yield from _construct_landscape(mole_rv)\n\n        if results_fw[0].energies[-1] &lt; results_rv[0].energies[-1]:  # forward is better\n            mole_opt = mole_opt_fw\n            ori = Ori(forward_is)\n        else:  # reverse is better\n            mole_opt = mole_opt_rv\n            ori = Ori.invert(Ori(forward_is))\n\n        # calculate distances for logging\n        _ds = np.diff(mole_opt.pos, axis=0)\n        _dist: NDArray[np.float32] = np.sqrt(np.sum(_ds**2, axis=1))\n\n        spl_new = CylSpline(\n            order=spl_old.order,\n            config=spl_old.config,\n            extrapolate=spl_old.extrapolate,\n        ).fit(mole_opt.pos, err_max=err_max)\n        spl_new.props.loc = spl_old.props.loc\n        spl_new.props.glob = spl_old.props.glob\n        spl_new.orientation = ori\n        tomo.splines[spline] = spl_new\n        t0.toc()\n\n        @thread_worker.callback\n        def _on_return():\n            main._update_splines_in_images()\n            _Logger.print(f\"Orientation: {ori.value}\")\n            _Logger.print(\n                f\"Distance: mean = {_dist.mean():.3f} nm (ranging from \"\n                f\"{_dist.min():.3f} to {_dist.max():.3f}) nm \"\n            )\n            main.reset_choices()\n\n            @undo_callback\n            def _out():\n                tomo.splines[spline] = spl_old\n                main._update_splines_in_images()\n\n            @_out.with_redo\n            def _out():\n                tomo.splines[spline] = spl_new\n                main._update_splines_in_images()\n\n            return _out\n\n        return _on_return\n\n    @set_design(text=capitalize, location=LandscapeMenu)\n    @dask_worker.with_progress(descs=_pdesc.construct_landscape_fmt)\n    def construct_landscape(\n        self,\n        layer: MoleculesLayerType,\n        template_path: Annotated[_PathOrPathsOrNone, {\"bind\": _template_params}],\n        mask_params: Annotated[Any, {\"bind\": _get_mask_params}] = None,\n        max_shifts: _MaxShifts = (0.8, 0.8, 0.8),\n        rotations: _Rotations = ((0.0, 0.0), (0.0, 0.0), (0.0, 0.0)),\n        cutoff: _CutoffFreq = 0.5,\n        interpolation: Annotated[int, {\"choices\": INTERPOLATION_CHOICES}] = 3,\n        bin_size: Annotated[int, {\"choices\": _get_available_binsize}] = 1,\n        upsample_factor: Annotated[int, {\"min\": 1, \"max\": 20}] = 5,\n        method: Annotated[str, {\"choices\": METHOD_CHOICES}] = \"zncc\",\n        norm: bool = True,\n    ):\n        \"\"\"Construct a cross-correlation landscape for subtomogram alignment.\n\n        Parameters\n        ----------\n        {layer}{template_path}{mask_params}{max_shifts}{rotations}{cutoff}\n        {interpolation}{bin_size}{upsample_factor}{method}\n        norm: bool, default True\n            If true, each landscape will be normalized by its mean and standard\n            deviation.\n        \"\"\"\n        layer = assert_layer(layer, self.parent_viewer)\n        lnd, _ = self._construct_landscape(\n            molecules=layer.molecules, template_path=template_path,\n            mask_params=mask_params, max_shifts=max_shifts, rotations=rotations,\n            cutoff=cutoff, order=interpolation, bin_size=bin_size, norm=norm,\n            upsample_factor=upsample_factor, method=method,\n        )  # fmt: skip\n        surf = LandscapeSurface(lnd, name=f\"{LANDSCAPE_PREFIX}{layer.name}\")\n        surf.source_component = layer.source_component\n\n        @thread_worker.callback\n        def _on_return():\n            self.parent_viewer.add_layer(surf)\n            self._get_main()._reserved_layers.to_be_removed.add(surf)\n            layer.visible = False\n\n        return _on_return\n\n    @set_design(text=\"Run alignment\", location=LandscapeMenu)\n    @dask_worker.with_progress(desc=\"Peak detection on landscape\")\n    def run_align_on_landscape(self, landscape_layer: _LandscapeLayer):\n        \"\"\"Find the optimal displacement for each molecule on the landscape.\"\"\"\n        landscape_layer = _assert_landscape_layer(landscape_layer, self.parent_viewer)\n        landscape = landscape_layer.landscape\n        spl = landscape_layer.source_spline\n        mole_opt, _ = landscape.run_min_energy(spl)\n        return self._align_on_landscape_on_return.with_args(\n            mole_opt, landscape_layer.name, spl\n        )\n\n    @set_design(text=\"Run Viterbi alignment\", location=LandscapeMenu)\n    @dask_worker.with_progress(desc=\"Running Viterbi alignment\")\n    def run_viterbi_on_landscape(\n        self,\n        landscape_layer: _LandscapeLayer,\n        range_long: _DistRangeLon = (4.0, 4.28),\n        angle_max: _AngleMaxLon = 5.0,\n    ):\n        \"\"\"Run Viterbi alignment on the landscape.\n\n        Parameters\n        ----------\n        {landscape_layer}{range_long}{angle_max}\n        \"\"\"\n        t0 = timer()\n        landscape_layer = _assert_landscape_layer(landscape_layer, self.parent_viewer)\n        spl = landscape_layer.source_spline\n        mole = landscape_layer.landscape.run_viterbi_along_spline(\n            spl=spl,\n            range_long=range_long,\n            angle_max=angle_max,\n        )\n        t0.toc()\n        return self._align_on_landscape_on_return.with_args(\n            mole, landscape_layer.name, spl\n        )\n\n    @property\n    def run_annealing_on_landscape(self):  # pragma: no cover\n        warnings.warn(\n            \"run_annealing_on_landscape is deprecated. Use run_rma_on_landscape instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        return self.run_rma_on_landscape\n\n    @set_design(text=\"Run annealing (RMA)\", location=LandscapeMenu)\n    @dask_worker.with_progress(desc=\"Running simulated annealing\")\n    def run_rma_on_landscape(\n        self,\n        landscape_layer: _LandscapeLayer,\n        range_long: _DistRangeLon = (4.0, 4.28),\n        range_lat: _DistRangeLat = (5.1, 5.3),\n        angle_max: _AngleMaxLon = 5.0,\n        temperature_time_const: Annotated[float, {\"min\": 0.01, \"max\": 10.0}] = 1.0,\n        random_seeds: _RandomSeeds = (0, 1, 2, 3, 4),\n    ):\n        \"\"\"Run simulated annealing on the landscape, supposing a cylindric structure.\n\n        Parameters\n        ----------\n        {landscape_layer}{range_long}{range_lat}{angle_max}{temperature_time_const}\n        {random_seeds}\n        \"\"\"\n        t0 = timer()\n        landscape_layer = _assert_landscape_layer(landscape_layer, self.parent_viewer)\n        spl = landscape_layer.source_spline\n        if spl is None:\n            raise ValueError(\"RMA requires a spline.\")\n        mole, results = landscape_layer.landscape.run_annealing_along_spline(\n            spl=spl,\n            range_long=range_long,\n            range_lat=range_lat,\n            angle_max=angle_max,\n            temperature_time_const=temperature_time_const,\n            random_seeds=random_seeds,\n        )\n        t0.toc()\n\n        @thread_worker.callback\n        def _plot_result():\n            with _Logger.set_plt():\n                _annealing.plot_annealing_result(results)\n\n        yield _plot_result\n        return self._align_on_landscape_on_return.with_args(\n            mole,\n            landscape_layer.name,\n            source=spl,\n            metadata={ANNEALING_RESULT: results[0]},\n        )\n\n    @set_design(text=\"Run annealing (RFA)\", location=LandscapeMenu)\n    @dask_worker.with_progress(desc=\"Running simulated annealing\")\n    def run_rfa_on_landscape(\n        self,\n        landscape_layer: _LandscapeLayer,\n        range_long: _DistRangeLon = (4.0, 4.28),\n        angle_max: _AngleMaxLon = 5.0,\n        temperature_time_const: Annotated[float, {\"min\": 0.01, \"max\": 10.0}] = 1.0,\n        random_seeds: _RandomSeeds = (0, 1, 2, 3, 4),\n    ):\n        \"\"\"Run simulated annealing on the landscape, supposing a filamentous structure.\n\n        Parameters\n        ----------\n        {landscape_layer}{range_long}{angle_max}{temperature_time_const}{random_seeds}\n        \"\"\"\n        t0 = timer()\n        landscape_layer = _assert_landscape_layer(landscape_layer, self.parent_viewer)\n        mole, results = landscape_layer.landscape.run_filamentous_annealing(\n            range=range_long,\n            angle_max=angle_max,\n            temperature_time_const=temperature_time_const,\n            random_seeds=random_seeds,\n        )\n        t0.toc()\n\n        @thread_worker.callback\n        def _plot_result():\n            with _Logger.set_plt():\n                _annealing.plot_annealing_result(results)\n\n        yield _plot_result\n        return self._align_on_landscape_on_return.with_args(\n            mole,\n            landscape_layer.name,\n            source=landscape_layer.source_spline,\n            metadata={ANNEALING_RESULT: results[0]},\n        )\n\n    @set_design(text=capitalize, location=LandscapeMenu)\n    def remove_landscape_outliers(\n        self,\n        landscape_layer: _LandscapeLayer,\n        lower: Annotated[Optional[float], {\"text\": \"Do not process lower outliers\"}] = None,\n        upper: Annotated[Optional[float], {\"text\": \"Do not process upper outliers\"}] = None,\n    ):  # fmt: skip\n        \"\"\"Remove outliers from the landscape.\n\n        This method will replace energy (inverse score) outliers with the thresholds.\n        This method is useful for lattice with such as defects or strong artifacts.\n\n        Parameters\n        ----------\n        {landscape_layer}\n        lower : float, optional\n            Lower limit of the energy.\n        upper : float, optional\n            Upper limit of the energy.\n        \"\"\"\n        landscape_layer = _assert_landscape_layer(landscape_layer, self.parent_viewer)\n        new = landscape_layer.landscape.clip_energies(lower, upper)\n        surf = LandscapeSurface(new, name=f\"{landscape_layer}-Clip\")\n        return self._add_new_landscape_layer(landscape_layer, surf)\n\n    @set_design(text=capitalize, location=LandscapeMenu)\n    def normalize_landscape(\n        self,\n        landscape_layer: _LandscapeLayer,\n        norm_sd: bool = True,\n    ):\n        \"\"\"Normalize the landscape.\n\n        Parameters\n        ----------\n        {landscape_layer}\n        norm_sd : bool, default True\n            If true, each landscape will also be normalized by its standard deviation.\n        \"\"\"\n        landscape_layer = _assert_landscape_layer(landscape_layer, self.parent_viewer)\n        new = landscape_layer.landscape.normed(sd=norm_sd)\n        surf = LandscapeSurface(new, name=f\"{landscape_layer}-Norm\")\n        return self._add_new_landscape_layer(landscape_layer, surf)\n\n    def _add_new_landscape_layer(self, old: LandscapeSurface, new: LandscapeSurface):\n        new.source_component = old.source_component\n\n        self.parent_viewer.add_layer(new)\n        self._get_main()._reserved_layers.to_be_removed.add(new)\n        old.visible = False\n        return None\n\n    def _get_layers_with_annealing_result(self, *_) -&gt; list[MoleculesLayer]:\n        if self.parent_viewer is None:\n            return []\n        return [\n            (layer.name, layer)\n            for layer in self.parent_viewer.layers\n            if ANNEALING_RESULT in layer.metadata\n        ]\n\n    @set_design(text=capitalize, location=Alignment)\n    @do_not_record\n    def save_annealing_scores(\n        self,\n        layer: Annotated[MoleculesLayer, {\"choices\": _get_layers_with_annealing_result}],\n        path: Path.Save[FileFilter.CSV],\n    ):  # fmt: skip\n        \"\"\"Save RMA scores to a CSV file.\"\"\"\n        layer = assert_layer(layer, self.parent_viewer)\n        try:\n            result: AnnealingResult = layer.metadata[ANNEALING_RESULT]\n        except KeyError:\n            raise ValueError(\n                f\"Layer {layer!r} does not have annealing result.\"\n            ) from None\n        x = result.batch_size * np.arange(result.energies.size)\n        df = pl.DataFrame({\"iteration\": x, \"score\": -result.energies})\n        return df.write_csv(path, include_header=False)\n\n    @set_design(text=capitalize, location=STAnalysis)\n    @dask_worker.with_progress(desc=_pdesc.fmt_layers(\"Calculating correlations of {!r}\"))  # fmt: skip\n    def calculate_correlation(\n        self,\n        layers: MoleculesLayersType,\n        template_path: Annotated[_PathOrPathsOrNone, {\"bind\": _template_params}],\n        mask_params: Annotated[Any, {\"bind\": _get_mask_params}] = None,\n        interpolation: Annotated[int, {\"choices\": INTERPOLATION_CHOICES}] = 3,\n        cutoff: _CutoffFreq = 0.5,\n        bin_size: Annotated[int, {\"choices\": _get_available_binsize}] = 1,\n        method: Annotated[str, {\"choices\": METHOD_CHOICES}] = \"zncc\",\n        column_prefix: str = \"score\",\n    ):\n        \"\"\"Calculate correlation between template images and the subtomograms.\n\n        This method will load every subtomograms, calculate the correlation between\n        the template images and each subtomogram, and save the correlation values\n        as new columns in the molecules features.\n\n        Parameters\n        ----------\n        {layers}{template_path}{mask_params}{interpolation}{cutoff}{bin_size}{method}\n        column_prefix : str, default \"score\"\n            Prefix of the column names of the calculated correlations.\n        \"\"\"\n        layers = assert_list_of_layers(layers, self.parent_viewer)\n        main = self._get_main()\n        combiner = widget_utils.MoleculesCombiner()\n\n        if isinstance(template_path, (Path, str)):\n            template_path = [template_path]\n        mask = self.params._get_mask(mask_params)\n        all_mole = combiner.concat(layer.molecules for layer in layers)\n\n        out = main.tomogram.get_subtomogram_loader(\n            all_mole,\n            order=interpolation,\n            binsize=bin_size,\n        ).score(\n            templates=[pipe.from_file(t) for t in template_path],\n            mask=mask,\n            alignment_model=_get_alignment(method),\n            cutoff=cutoff,\n            tilt=main.tomogram.tilt_model,\n        )\n        all_mole = all_mole.with_features(\n            pl.Series(f\"{column_prefix}_{i}\", col) for i, col in enumerate(out)\n        )\n\n        @thread_worker.callback\n        def _on_return():\n            moles = combiner.split(all_mole, layers)\n            for layer, each_mole in zip(layers, moles, strict=True):\n                features = each_mole.features.select(\n                    [f\"{column_prefix}_{i}\" for i in range(len(out))]\n                )\n                layer.set_molecules_with_new_features(\n                    layer.molecules.with_features(features)\n                )\n\n        return _on_return\n\n    @set_design(text=\"Calculate FSC\", location=STAnalysis)\n    @dask_worker.with_progress(desc=_pdesc.fmt_layers(\"Calculating FSC of {!r}\"))\n    def calculate_fsc(\n        self,\n        layers: MoleculesLayersType,\n        template_path: Annotated[_PathOrNone, {\"bind\": _template_param}] = None,\n        mask_params: Annotated[Any, {\"bind\": _get_mask_params}] = None,\n        size: _SubVolumeSize = None,\n        seed: Annotated[Optional[int], {\"text\": \"Do not use random seed.\"}] = 0,\n        interpolation: Annotated[int, {\"choices\": INTERPOLATION_CHOICES}] = 1,\n        n_pairs: Annotated[int, {\"min\": 1, \"label\": \"number of image pairs\"}] = 1,\n        show_average: bool = True,\n        dfreq: FSCFreq = None,\n    ):\n        \"\"\"Calculate Fourier Shell Correlation using the selected monomer layer.\n\n        Parameters\n        ----------\n        {layers}\n        template_path : template input type\n            Used only when soft-Otsu mask parameters are given.\n        {mask_params}{size}\n        seed : int, optional\n            Random seed used for subtomogram sampling.\n        {interpolation}\n        n_pairs : int, default 1\n            How many sets of image pairs will be generated to average FSC.\n        show_average : bool, default True\n            If true, subtomogram average will be shown after FSC calculation.\n        dfreq : float, default 0.02\n            Precision of frequency to calculate FSC. \"0.02\" means that FSC will be\n            calculated at frequency 0.01, 0.03, 0.05, ..., 0.45.\n        \"\"\"\n        t0 = timer()\n        layers = assert_list_of_layers(layers, self.parent_viewer)\n        main = self._get_main()\n        mole = _concat_molecules(layers)\n\n        loader = main.tomogram.get_subtomogram_loader(mole, order=interpolation)\n        template, mask = loader.normalize_input(\n            template=self.params._norm_template_param(template_path, allow_none=True),\n            mask=self.params._get_mask(params=mask_params),\n        )\n        fsc, (img_0, img_1), img_mask = loader.reshape(\n            template=template if size is None else None,\n            mask=mask,\n            shape=None if size is None else (main.tomogram.nm2pixel(size),) * 3,\n        ).fsc_with_halfmaps(mask, seed=seed, n_set=n_pairs, dfreq=dfreq, squeeze=False)\n\n        def _as_imgarray(im, axes: str = \"zyx\") -&gt; ip.ImgArray | None:\n            if np.isscalar(im):\n                return None\n            return ip.asarray(im, axes=axes).set_scale(zyx=loader.scale, unit=\"nm\")\n\n        if show_average:\n            avg = (img_0[0] + img_1[0]) / 2\n            img_avg = _as_imgarray(avg)\n        else:\n            img_avg = None\n\n        result = widget_utils.FscResult.from_dataframe(fsc, loader.scale)\n        criteria = [0.5, 0.143]\n        _name = _avg_name(layers)\n        t0.toc()\n\n        @thread_worker.callback\n        def _calculate_fsc_on_return():\n            _Logger.print_html(f\"&lt;b&gt;Fourier Shell Correlation of {_name!r}&lt;/b&gt;\")\n            with _Logger.set_plt():\n                result.plot(criteria)\n                plt.tight_layout()\n                plt.show()\n            for _c in criteria:\n                _r = result.get_resolution(_c)\n                _Logger.print_html(f\"Resolution at FSC={_c:.3f} ... &lt;b&gt;{_r:.3f} nm&lt;/b&gt;\")\n\n            if img_avg is not None:\n                _imlayer: Image = self._show_rec(img_avg, name=f\"[AVG]{_name}\")\n                _imlayer.metadata[\"fsc\"] = result\n                _imlayer.metadata[\"fsc_halfmaps\"] = (\n                    _as_imgarray(img_0, axes=\"izyx\"),\n                    _as_imgarray(img_1, axes=\"izyx\"),\n                )\n                _imlayer.metadata[\"fsc_mask\"] = _as_imgarray(img_mask)\n\n        return _calculate_fsc_on_return\n\n    @set_design(text=\"PCA/K-means classification\", location=STAnalysis)\n    @dask_worker.with_progress(descs=_pdesc.classify_pca_fmt)\n    def classify_pca(\n        self,\n        layer: MoleculesLayerType,\n        template_path: Annotated[_PathOrNone, {\"bind\": _template_param}] = None,\n        mask_params: Annotated[Any, {\"bind\": _get_mask_params}] = None,\n        size: _SubVolumeSize = None,\n        cutoff: _CutoffFreq = 0.5,\n        interpolation: Annotated[int, {\"choices\": INTERPOLATION_CHOICES}] = 3,\n        bin_size: Annotated[int, {\"choices\": _get_available_binsize}] = 1,\n        n_components: Annotated[int, {\"min\": 2, \"max\": 20}] = 2,\n        n_clusters: Annotated[int, {\"min\": 2, \"max\": 100}] = 2,\n        seed: Annotated[Optional[int], {\"text\": \"Do not use random seed.\"}] = 0,\n    ):  # fmt: skip\n        \"\"\"Classify molecules in a layer using PCA and K-means clustering.\n\n        Parameters\n        ----------\n        {layer}\n        template_path : template input type\n            Used only when soft-Otsu mask parameters are given.\n        {mask_params}{size}{cutoff}{interpolation}{bin_size}\n        n_components : int, default 2\n            The number of PCA dimensions.\n        n_clusters : int, default\n            The number of clusters.\n        seed : int, default 0\n            Random seed.\n        \"\"\"\n        from cylindra.components.visualize import plot_pca_classification\n\n        t0 = timer()\n        layer = assert_layer(layer, self.parent_viewer)\n        tomo = self._get_main().tomogram\n        loader = self._get_loader(\n            binsize=bin_size, molecules=layer.molecules, order=interpolation\n        )\n        template, mask = loader.normalize_input(\n            template=self.params._norm_template_param(template_path, allow_none=True),\n            mask=self.params._get_mask(params=mask_params),\n        )\n        shape = None\n        if size is not None and mask is None:\n            shape = (tomo.nm2pixel(size, binsize=bin_size),) * 3\n        out, pca = loader.reshape(\n            template=template if mask is None and shape is None else None,\n            mask=mask,\n            shape=shape,\n        ).classify(\n            mask=mask,\n            seed=seed,\n            cutoff=cutoff,\n            n_components=n_components,\n            n_clusters=n_clusters,\n            label_name=\"cluster\",\n        )\n\n        avgs_dict = out.groupby(\"cluster\").average()\n        avgs = ip.asarray(\n            np.stack(list(avgs_dict.values()), axis=0), axes=[\"cluster\", \"z\", \"y\", \"x\"]\n        ).set_scale(zyx=loader.scale, unit=\"nm\")\n\n        transformed = pca.get_transform()\n        t0.toc()\n\n        @thread_worker.callback\n        def _on_return():\n            layer.molecules = out.molecules  # update features\n            with _Logger.set_plt():\n                plot_pca_classification(pca, transformed)\n            self._show_rec(avgs, name=f\"[PCA]{layer.name}\", store=False)\n\n        return _on_return\n\n    @set_design(text=\"Seam search by correlation\", location=STAnalysis.SeamSearch)\n    @dask_worker.with_progress(desc=_pdesc.fmt_layer(\"Seam search of {!r}\"))\n    def seam_search(\n        self,\n        layer: MoleculesLayerType,\n        template_path: Annotated[_PathOrNone, {\"bind\": _template_param}],\n        mask_params: Annotated[Any, {\"bind\": _get_mask_params}],\n        anti_template_path: Annotated[Optional[Path.Read[FileFilter.IMAGE]], {\"text\": \"Do not use anti-template\", \"label\": \"anti-template path\"}] = None,\n        interpolation: Annotated[int, {\"choices\": INTERPOLATION_CHOICES}] = 3,\n        npf: Annotated[Optional[int], {\"text\": \"use global properties\"}] = None,\n        show_average: Annotated[str, {\"label\": \"show averages as\", \"choices\": [None, \"Raw\", \"Filtered\"]}] = \"Filtered\",\n        cutoff: _CutoffFreq = 0.25,\n    ):  # fmt: skip\n        \"\"\"Search for the best seam position.\n\n        Try all patterns of seam positions and compare cross correlation values. If\n        molecule assembly has 13 protofilaments, this method will try 26 patterns.\n\n        Parameters\n        ----------\n        {layer}{template_path}{mask_params}\n        anti_template_path : Path, optional\n            The anti-template used for seam search. For instance, if the template is\n            beta-tubulin, the anti-template is alpha-tubulin.\n        {interpolation}\n        npf : int, optional\n            Number of protofilaments. By default the global properties stored in the\n            corresponding spline will be used.\n        show_average : bool, default True\n            If true, all the subtomogram averages will be shown.\n        {cutoff}\n        \"\"\"\n        t0 = timer()\n        layer = assert_layer(layer, self.parent_viewer)\n        loader, npf = self._seam_search_input(layer, npf, interpolation)\n        template, mask = loader.normalize_input(\n            template=self.params._norm_template_param(template_path),\n            mask=self.params._get_mask(params=mask_params),\n        )\n        if anti_template_path is not None:\n            anti_template = ip.asarray(\n                pipe.from_file(anti_template_path).provide(loader.scale),\n                axes=\"zyx\",\n            )\n        else:\n            anti_template = None\n\n        seam_searcher = CorrelationSeamSearcher(npf)\n        result = seam_searcher.search(\n            loader=loader,\n            template=ip.asarray(template, axes=\"zyx\"),\n            anti_template=anti_template,\n            mask=mask,\n            cutoff=cutoff,\n        )\n\n        t0.toc()\n\n        @thread_worker.callback\n        def _seam_search_on_return():\n            new_feat = result.as_series(loader.molecules.count())\n            layer.features = layer.molecules.features.with_columns(new_feat)\n            layer.metadata[SEAM_SEARCH_RESULT] = result\n            if show_average is not None:\n                if show_average == \"Filtered\":\n                    sigma = 0.25 / loader.scale\n                    result.averages.gaussian_filter(sigma=sigma, update=True)\n                _imlayer: Image = self._show_rec(\n                    result.averages, layer.name, store=False\n                )\n                _imlayer.metadata[SEAM_SEARCH_RESULT] = result\n\n            # plot all the correlation\n            _Logger.print_html(\"&lt;code&gt;seam_search&lt;/code&gt;\")\n            with _Logger.set_plt():\n                _Logger.print(f\"layer = {layer.name!r}\")\n                _Logger.print(f\"template = {Path(template_path).as_posix()!r}\")\n                if anti_template_path is not None:\n                    _Logger.print(\n                        f\"anti_template = {Path(anti_template_path).as_posix()!r}\"\n                    )\n                widget_utils.plot_seam_search_result(result.scores, npf)\n\n        return _seam_search_on_return\n\n    @set_design(text=capitalize, location=STAnalysis.SeamSearch)\n    def seam_search_by_feature(\n        self,\n        layer: MoleculesLayerType,\n        by: Annotated[str, {\"choices\": _choice_getter(\"seam_search_by_feature\")}],\n    ):\n        \"\"\"Search for seams by a feature.\n\n        Parameters\n        ----------\n        {layer}\n        by : str\n            Name of the feature that will be used for seam search.\n        \"\"\"\n        ui = self._get_main()\n        layer = assert_layer(layer, ui.parent_viewer)\n        feat = layer.molecules.features\n        if by not in feat.columns:\n            raise ValueError(f\"Column {by} does not exist.\")\n        npf = utils.roundint(layer.molecules.features[Mole.pf].max() + 1)\n        seam_searcher = BooleanSeamSearcher(npf)\n        result = seam_searcher.search(feat[by])\n        new_feat = result.as_series(feat.shape[0])\n        layer.features = layer.molecules.features.with_columns(new_feat)\n        ui.reset_choices()  # choices regarding of features need update\n        return undo_callback(layer.feature_setter(feat, layer.colormap_info))\n\n    @set_design(text=capitalize, location=STAnalysis.SeamSearch)\n    def seam_search_manually(\n        self,\n        layer: MoleculesLayerType,\n        location: int = 0,\n    ):\n        \"\"\"Search for seams manually.\n\n        Seam location is represented by a number in the range [0, 2 * npf - 1].\n\n        Parameters\n        ----------\n        {layer}\n        location : int\n            Seam location.\n        \"\"\"\n        ui = self._get_main()\n        layer = assert_layer(layer, ui.parent_viewer)\n        feat = layer.molecules.features\n        npf = utils.roundint(layer.molecules.features[Mole.pf].max() + 1)\n        seam_searcher = ManualSeamSearcher(npf)\n        result = seam_searcher.search(location)\n        new_feat = result.as_series(feat.shape[0])\n        layer.features = layer.molecules.features.with_columns(new_feat)\n        ui.reset_choices()  # choices regarding of features need update\n        return undo_callback(layer.feature_setter(feat, layer.colormap_info))\n\n    def _seam_search_input(\n        self, layer: MoleculesLayer, npf: int | None, order: int\n    ) -&gt; tuple[SubtomogramLoader, int]:\n        parent = self._get_main()\n        mole = layer.molecules\n        loader = parent.tomogram.get_subtomogram_loader(mole, order=order)\n        if npf is None:\n            npf = mole.features[Mole.pf].unique().len()\n        return loader, npf\n\n    @set_design(text=\"Save last average\", location=STAnalysis)\n    def save_last_average(self, path: Path.Save[FileFilter.IMAGE]):\n        \"\"\"Save the lastly generated average image.\"\"\"\n        path = Path(path)\n        img = self.last_average\n        if img is None:\n            raise ValueError(\n                \"No average image is available. You have to average subtomograms first.\"\n            )\n        return img.imsave(path)\n\n    @average_all.started.connect\n    @align_averaged.started.connect\n    @align_all.started.connect\n    @calculate_fsc.started.connect\n    def _show_subtomogram_averaging(self):\n        return self.show()\n\n    @thread_worker.callback\n    def _align_all_on_return(\n        self, molecules: list[Molecules], old_layers: list[MoleculesLayer]\n    ):\n        \"\"\"The return callback function for alignment methods.\"\"\"\n        main = self._get_main()\n        new_layers = list[MoleculesLayer]()\n        for mole, layer in zip(molecules, old_layers, strict=True):\n            points = main.add_molecules(\n                mole,\n                name=_coerce_aligned_name(layer.name, self.parent_viewer),\n                source=layer.source_component,\n            )\n            new_layers.append(points)\n            layer.visible = False\n            _Logger.print_html(f\"{layer.name!r} &amp;#8594; {points.name!r}\")\n        return self._undo_for_new_layer([l.name for l in old_layers], new_layers)\n\n    @thread_worker.callback\n    def _align_on_landscape_on_return(\n        self,\n        mole: Molecules,\n        name: str,\n        source=None,\n        metadata: dict[str, Any] = {},\n    ):\n        main = self._get_main()\n        if name.startswith(LANDSCAPE_PREFIX):\n            nchars = len(LANDSCAPE_PREFIX)\n            mole_name = name[nchars:].strip()\n        else:\n            mole_name = name\n        points = main.add_molecules(\n            mole,\n            name=_coerce_aligned_name(mole_name, self.parent_viewer),\n            source=source,\n            metadata=metadata,\n        )\n        _Logger.print_html(f\"{name!r} &amp;#8594; {points.name!r}\")\n        return mole\n\n    def _undo_for_new_layer(\n        self,\n        old_names: list[str],\n        new_layers: list[MoleculesLayer],\n    ):\n        @undo_callback\n        def out():\n            main = self._get_main()\n            main._try_removing_layers(new_layers)\n            for name in old_names:\n                if name not in main.parent_viewer.layers:\n                    continue\n                main.parent_viewer.layers[name].visible = True\n\n        @out.with_redo\n        def out():\n            main = self._get_main()\n            for points in new_layers:\n                main.parent_viewer.add_layer(points)\n\n        return out\n\n    @nogui\n    @do_not_record\n    def get_template(\n        self, template_path: str | Path, scale: float | None = None\n    ) -&gt; ip.ImgArray:\n        \"\"\"A non-GUI method to get the template\"\"\"\n        if scale is None:\n            scale = self._get_main().tomogram.scale\n        img = self.params._norm_template_param(template_path).provide(scale)\n        return ip.asarray(img, axes=\"zyx\").set_scale(zyx=scale)\n\n    @nogui\n    @do_not_record\n    def get_mask(\n        self,\n        mask_params: Any,\n        scale: float | None = None,\n        template_path: str | Path | None = None,\n    ) -&gt; ip.ImgArray:\n        \"\"\"A non-GUI method to get the mask.\"\"\"\n        if scale is None:\n            scale = self._get_main().tomogram.scale\n        if isinstance(mask_params, tuple):\n            if template_path is None:\n                raise ValueError(\"Template path is required when using soft-Otsu mask.\")\n            template = self.params._norm_template_param(template_path).provide(scale)\n            radius, sigma = mask_params\n            mask = pipe.soft_otsu(radius=radius, sigma=sigma).convert(template, scale)\n        elif isinstance(mask_params, (str, Path)):\n            mask = pipe.from_file(mask_params).provide(scale)\n        else:\n            raise TypeError(\n                f\"Cannot create mask image using parameter: {mask_params!r}\"\n            )\n        return ip.asarray(mask, axes=\"zyx\").set_scale(zyx=scale)\n\n    @nogui\n    @do_not_record\n    def get_subtomograms(\n        self,\n        layers: str | MoleculesLayer | list[str | MoleculesLayer],\n        shape: tuple[nm, nm, nm],\n        bin_size: int = 1,\n        order: int = 3,\n    ) -&gt; \"Array\":\n        \"\"\"A non-GUI method to get all the subtomograms as a dask array.\n\n        Parameters\n        ----------\n        layers : str, MoleculesLayer or list of them\n            All the layers that will be used to construct the subtomogram array.\n        shape : (nm, nm, nm)\n            Shape of output subtomograms.\n        bin_size : int, default\n            Bin size of the subtomograms.\n        order : int, default 3\n            Interpolation order.\n\n        Returns\n        -------\n        Array\n            4D Dask array.\n        \"\"\"\n        layers = assert_list_of_layers(layers, self.parent_viewer)\n        parent = self._get_main()\n        tomo = parent.tomogram\n        loader = tomo.get_subtomogram_loader(\n            _concat_molecules(layers), shape, binsize=bin_size, order=order\n        )\n        return loader.construct_dask()\n\n    def _get_simple_annealing_model(self, layer: MoleculesLayer):\n        # TODO: This method should finally be moved to some utils module since\n        # this analysis is independent of annealing. Currently annealing and\n        # graph construction cannot be separated.\n        parent = self._get_main()\n        scale = parent.tomogram.scale\n        return _annealing.get_annealing_model(\n            layer.molecules,\n            layer.source_spline,\n            (0, 0, 0),\n            scale,\n        )\n\n    def _construct_landscape(\n        self,\n        molecules: Molecules,\n        template_path: Any,\n        mask_params=None,\n        max_shifts: tuple[nm, nm, nm] = (0.8, 0.8, 0.8),\n        rotations: _Rotations = ((0.0, 0.0), (0.0, 0.0), (0.0, 0.0)),\n        cutoff: float = 0.5,\n        order: int = 3,\n        upsample_factor: int = 5,\n        bin_size: int = 1,\n        method: str = \"zncc\",\n        norm: bool = True,\n    ) -&gt; tuple[Landscape, SubtomogramLoader]:\n        parent = self._get_main()\n        loader = parent.tomogram.get_subtomogram_loader(\n            molecules, binsize=bin_size, order=order\n        )\n        model = _get_alignment(method)\n        tmp_prov = self.params._norm_template_param(template_path, allow_multiple=True)\n        landscape = Landscape.from_loader(\n            loader=loader,\n            template=tmp_prov.provide(loader.scale),\n            mask=self.params._get_mask(params=mask_params),\n            max_shifts=max_shifts,\n            upsample_factor=upsample_factor,\n            alignment_model=model.with_params(\n                rotations=rotations,\n                cutoff=cutoff,\n                tilt=parent.tomogram.tilt_model,\n            ),\n        )\n        return landscape.normed() if norm else landscape, loader\n</code></pre>"},{"location":"api/widgets/sta/#cylindra.widgets.sta.SubtomogramAveraging.last_average","title":"<code>last_average</code>  <code>property</code>","text":"<p>Last averaged image if exists.</p>"},{"location":"api/widgets/sta/#cylindra.widgets.sta.SubtomogramAveraging.sub_viewer","title":"<code>sub_viewer</code>  <code>property</code>","text":"<p>The napari viewer for subtomogram averaging.</p>"},{"location":"api/widgets/sta/#cylindra.widgets.sta.SubtomogramAveraging.align_all","title":"<code>align_all(layers, template_path, mask_params, max_shifts=(1.0, 1.0, 1.0), rotations=((0.0, 0.0), (0.0, 0.0), (0.0, 0.0)), cutoff=0.5, interpolation=3, method='zncc', bin_size=1)</code>","text":"<p>Align the input template image to all the molecules.</p> <p>Parameters:</p> Name Type Description Default <code>layers</code> <code>list of MoleculesLayer</code> <p>All the points layers of molecules to be used.</p> required <code>template_path</code> <code>Path or str</code> <p>Path to template image.</p> required <code>mask_params</code> <code>str or (float, float)</code> <p>Mask image path or dilation/Gaussian blur parameters. If a path is given, image must in the same shape as the template.</p> required <code>max_shifts</code> <code>int or tuple of int</code> <p>Maximum shift between subtomograms and template in nm. ZYX order.</p> <code>(1.0, 1.0, 1.0)</code> <code>rotations</code> <code>((float, float), (float, float), (float, float))</code> <p>Rotation in external degree around each axis.</p> <code>((0.0, 0.0), (0.0, 0.0), (0.0, 0.0))</code> <code>cutoff</code> <code>float</code> <p>Cutoff frequency of low-pass filter applied in each subtomogram.</p> <code>0.5</code> <code>interpolation</code> <code>int</code> <p>Interpolation order.</p> <code>3</code> <code>method</code> <code>str</code> <p>Correlation metrics for alignment.</p> <code>'zncc'</code> <code>bin_size</code> <code>int</code> <p>Bin size of multiscale image to be used. Set to &gt;1 to boost performance.</p> <code>1</code> Source code in <code>cylindra/widgets/sta.py</code> <pre><code>@set_design(text=\"Align all molecules\", location=Alignment)\n@dask_worker.with_progress(descs=_pdesc.align_all_fmt)\ndef align_all(\n    self,\n    layers: MoleculesLayersType,\n    template_path: Annotated[_PathOrPathsOrNone, {\"bind\": _template_params}],\n    mask_params: Annotated[Any, {\"bind\": _get_mask_params}],\n    max_shifts: _MaxShifts = (1.0, 1.0, 1.0),\n    rotations: _Rotations = ((0.0, 0.0), (0.0, 0.0), (0.0, 0.0)),\n    cutoff: _CutoffFreq = 0.5,\n    interpolation: Annotated[int, {\"choices\": INTERPOLATION_CHOICES}] = 3,\n    method: Annotated[str, {\"choices\": METHOD_CHOICES}] = \"zncc\",\n    bin_size: Annotated[int, {\"choices\": _get_available_binsize}] = 1,\n):  # fmt: skip\n    \"\"\"Align the input template image to all the molecules.\n\n    Parameters\n    ----------\n    {layers}{template_path}{mask_params}{max_shifts}{rotations}{cutoff}\n    {interpolation}{method}{bin_size}\n    \"\"\"\n    t0 = timer()\n    layers = assert_list_of_layers(layers, self.parent_viewer)\n    main = self._get_main()\n\n    combiner = widget_utils.MoleculesCombiner()\n\n    loader = self._get_loader(\n        binsize=bin_size,\n        molecules=combiner.concat(layer.molecules for layer in layers),\n        order=interpolation,\n    )\n    _Logger.print(f\"Aligning {loader.molecules.count()} molecules ...\")\n    aligned_loader = loader.align(\n        template=self.params._norm_template_param(\n            template_path, allow_multiple=True\n        ),\n        mask=self.params._get_mask(params=mask_params),\n        max_shifts=max_shifts,\n        rotations=rotations,\n        cutoff=cutoff,\n        alignment_model=_get_alignment(method),\n        tilt=main.tomogram.tilt_model,\n    )\n    molecules = combiner.split(aligned_loader.molecules, layers)\n    t0.toc()\n    return self._align_all_on_return.with_args(molecules, layers)\n</code></pre>"},{"location":"api/widgets/sta/#cylindra.widgets.sta.SubtomogramAveraging.align_all_rfa","title":"<code>align_all_rfa(layer, template_path, mask_params=None, max_shifts=(0.8, 0.8, 0.8), rotations=((0.0, 0.0), (0.0, 0.0), (0.0, 0.0)), cutoff=0.5, interpolation=3, range_long=(4.0, 4.28), angle_max=5.0, bin_size=1, temperature_time_const=1.0, upsample_factor=5, random_seeds=(0, 1, 2, 3, 4))</code>","text":"<p>1D-constrained subtomogram alignment on a filament using simulated annealing.</p> <p>This alignment method considers the distance between every adjacent monomers on the filament.</p> <p>Parameters:</p> Name Type Description Default <code>layer</code> <code>MoleculesLayer</code> <p>Points layer of molecules to be used.</p> required <code>template_path</code> <code>Path or str</code> <p>Path to template image.</p> required <code>mask_params</code> <code>str or (float, float)</code> <p>Mask image path or dilation/Gaussian blur parameters. If a path is given, image must in the same shape as the template.</p> <code>None</code> <code>max_shifts</code> <code>int or tuple of int</code> <p>Maximum shift between subtomograms and template in nm. ZYX order.</p> <code>(0.8, 0.8, 0.8)</code> <code>rotations</code> <code>((float, float), (float, float), (float, float))</code> <p>Rotation in external degree around each axis.</p> <code>((0.0, 0.0), (0.0, 0.0), (0.0, 0.0))</code> <code>cutoff</code> <code>float</code> <p>Cutoff frequency of low-pass filter applied in each subtomogram.</p> <code>0.5</code> <code>interpolation</code> <code>int</code> <p>Interpolation order.</p> <code>3</code> <code>range_long</code> <code>(float, float)</code> <p>Minimum and maximum allowed distances between longitudinally consecutive monomers</p> <code>(4.0, 4.28)</code> <code>angle_max</code> <code>float</code> <p>Maximum allowed angle between longitudinally consecutive monomers and the Y axis.</p> <code>5.0</code> <code>bin_size</code> <code>int</code> <p>Bin size of multiscale image to be used. Set to &gt;1 to boost performance.</p> <code>1</code> <code>temperature_time_const</code> <code>float</code> <p>Time constant of the temperature decay during annealing. Larger value results in slower annealing. 1.0 is a moderate value.</p> <code>1.0</code> <code>upsample_factor</code> <code>int</code> <p>Upsampling factor of ZNCC landscape. Be careful not to set this parameter too large.  Calculation will take much longer for larger <code>upsample_factor</code>.</p> <code>5</code> <code>random_seeds</code> <code>iterable of int</code> <p>Random seed integers. Number of integers will be the number of trials.</p> <code>(0, 1, 2, 3, 4)</code> Source code in <code>cylindra/widgets/sta.py</code> <pre><code>@set_design(text=\"Simulated annealing (RFA)\", location=Alignment)\n@dask_worker.with_progress(descs=_pdesc.align_annealing_fmt)\ndef align_all_rfa(\n    self,\n    layer: MoleculesLayerType,\n    template_path: Annotated[_PathOrPathsOrNone, {\"bind\": _template_params}],\n    mask_params: Annotated[Any, {\"bind\": _get_mask_params}] = None,\n    max_shifts: _MaxShifts = (0.8, 0.8, 0.8),\n    rotations: _Rotations = ((0.0, 0.0), (0.0, 0.0), (0.0, 0.0)),\n    cutoff: _CutoffFreq = 0.5,\n    interpolation: Annotated[int, {\"choices\": INTERPOLATION_CHOICES}] = 3,\n    range_long: _DistRangeLon = (4.0, 4.28),\n    angle_max: _AngleMaxLon = 5.0,\n    bin_size: Annotated[int, {\"choices\": _get_available_binsize}] = 1,\n    temperature_time_const: Annotated[float, {\"min\": 0.01, \"max\": 10.0}] = 1.0,\n    upsample_factor: Annotated[int, {\"min\": 1, \"max\": 20}] = 5,\n    random_seeds: _RandomSeeds = (0, 1, 2, 3, 4),\n):\n    \"\"\"1D-constrained subtomogram alignment on a filament using simulated annealing.\n\n    This alignment method considers the distance between every adjacent monomers on\n    the filament.\n\n    Parameters\n    ----------\n    {layer}{template_path}{mask_params}{max_shifts}{rotations}{cutoff}\n    {interpolation}{range_long}{angle_max}{bin_size}{temperature_time_const}\n    {upsample_factor}{random_seeds}\n    \"\"\"\n    t0 = timer()\n    layer = assert_layer(layer, self.parent_viewer)\n    if layer.source_spline is None:\n        raise ValueError(\"RMA requires a spline.\")\n    main = self._get_main()\n    _Logger.print(\n        f\"Constructing correlation landscape on {layer.name} ({layer.molecules.count()} molecules) for RFA ...\"\n    )\n    landscape, _ = self._construct_landscape(\n        molecules=layer.molecules,\n        template_path=template_path,\n        mask_params=mask_params,\n        max_shifts=max_shifts,\n        rotations=rotations,\n        cutoff=cutoff,\n        order=interpolation,\n        bin_size=bin_size,\n        upsample_factor=upsample_factor,\n    )\n    yield\n    mole, results = landscape.run_filamentous_annealing(\n        range=range_long,\n        angle_max=angle_max,\n        temperature_time_const=temperature_time_const,\n        random_seeds=random_seeds,\n    )\n    t0.toc()\n\n    @thread_worker.callback\n    def _on_return():\n        points = main.add_molecules(\n            mole,\n            name=_coerce_aligned_name(layer.name, self.parent_viewer),\n            source=layer.source_component,\n            metadata={ANNEALING_RESULT: results[0]},\n        )\n        layer.visible = False\n        with _Logger.set_plt():\n            _annealing.plot_annealing_result(results)\n\n        return self._undo_for_new_layer([layer.name], [points])\n\n    return _on_return\n</code></pre>"},{"location":"api/widgets/sta/#cylindra.widgets.sta.SubtomogramAveraging.align_all_rma","title":"<code>align_all_rma(layer, template_path, mask_params=None, max_shifts=(0.8, 0.8, 0.8), rotations=((0.0, 0.0), (0.0, 0.0), (0.0, 0.0)), cutoff=0.5, interpolation=3, range_long=(4.0, 4.28), range_lat=(5.1, 5.3), angle_max=5.0, bin_size=1, temperature_time_const=1.0, upsample_factor=5, random_seeds=(0, 1, 2, 3, 4))</code>","text":"<p>2D-constrained subtomogram alignment using simulated annealing.</p> <p>This alignment method considers the distance between every adjacent monomers. Two-dimensionally connected optimization can be approximated by the simulated annealing algorithm.</p> <p>Parameters:</p> Name Type Description Default <code>layer</code> <code>MoleculesLayer</code> <p>Points layer of molecules to be used.</p> required <code>template_path</code> <code>Path or str</code> <p>Path to template image.</p> required <code>mask_params</code> <code>str or (float, float)</code> <p>Mask image path or dilation/Gaussian blur parameters. If a path is given, image must in the same shape as the template.</p> <code>None</code> <code>max_shifts</code> <code>int or tuple of int</code> <p>Maximum shift between subtomograms and template in nm. ZYX order.</p> <code>(0.8, 0.8, 0.8)</code> <code>rotations</code> <code>((float, float), (float, float), (float, float))</code> <p>Rotation in external degree around each axis.</p> <code>((0.0, 0.0), (0.0, 0.0), (0.0, 0.0))</code> <code>cutoff</code> <code>float</code> <p>Cutoff frequency of low-pass filter applied in each subtomogram.</p> <code>0.5</code> <code>interpolation</code> <code>int</code> <p>Interpolation order.</p> <code>3</code> <code>range_long</code> <code>(float, float)</code> <p>Minimum and maximum allowed distances between longitudinally consecutive monomers</p> <code>(4.0, 4.28)</code> <code>range_lat</code> <code>(float, float)</code> <p>Minimum and maximum allowed distances between laterally consecutive monomers</p> <code>(5.1, 5.3)</code> <code>angle_max</code> <code>float</code> <p>Maximum allowed angle between longitudinally consecutive monomers and the Y axis.</p> <code>5.0</code> <code>bin_size</code> <code>int</code> <p>Bin size of multiscale image to be used. Set to &gt;1 to boost performance.</p> <code>1</code> <code>temperature_time_const</code> <code>float</code> <p>Time constant of the temperature decay during annealing. Larger value results in slower annealing. 1.0 is a moderate value.</p> <code>1.0</code> <code>upsample_factor</code> <code>int</code> <p>Upsampling factor of ZNCC landscape. Be careful not to set this parameter too large.  Calculation will take much longer for larger <code>upsample_factor</code>.</p> <code>5</code> <code>random_seeds</code> <code>iterable of int</code> <p>Random seed integers. Number of integers will be the number of trials.</p> <code>(0, 1, 2, 3, 4)</code> Source code in <code>cylindra/widgets/sta.py</code> <pre><code>@set_design(text=\"Simulated annealing (RMA)\", location=Alignment)\n@dask_worker.with_progress(descs=_pdesc.align_annealing_fmt)\ndef align_all_rma(\n    self,\n    layer: MoleculesLayerType,\n    template_path: Annotated[_PathOrPathsOrNone, {\"bind\": _template_params}],\n    mask_params: Annotated[Any, {\"bind\": _get_mask_params}] = None,\n    max_shifts: _MaxShifts = (0.8, 0.8, 0.8),\n    rotations: _Rotations = ((0.0, 0.0), (0.0, 0.0), (0.0, 0.0)),\n    cutoff: _CutoffFreq = 0.5,\n    interpolation: Annotated[int, {\"choices\": INTERPOLATION_CHOICES}] = 3,\n    range_long: _DistRangeLon = (4.0, 4.28),\n    range_lat: _DistRangeLat = (5.1, 5.3),\n    angle_max: _AngleMaxLon = 5.0,\n    bin_size: Annotated[int, {\"choices\": _get_available_binsize}] = 1,\n    temperature_time_const: Annotated[float, {\"min\": 0.01, \"max\": 10.0}] = 1.0,\n    upsample_factor: Annotated[int, {\"min\": 1, \"max\": 20}] = 5,\n    random_seeds: _RandomSeeds = (0, 1, 2, 3, 4),\n):  # fmt: skip\n    \"\"\"2D-constrained subtomogram alignment using simulated annealing.\n\n    This alignment method considers the distance between every adjacent monomers.\n    Two-dimensionally connected optimization can be approximated by the simulated\n    annealing algorithm.\n\n    Parameters\n    ----------\n    {layer}{template_path}{mask_params}{max_shifts}{rotations}{cutoff}\n    {interpolation}{range_long}{range_lat}{angle_max}{bin_size}\n    {temperature_time_const}{upsample_factor}{random_seeds}\n    \"\"\"\n    t0 = timer()\n    layer = assert_layer(layer, self.parent_viewer)\n    if layer.source_spline is None:\n        raise ValueError(\n            \"RMA requires a spline but the input layer is not connected to any splines.\"\n        )\n    main = self._get_main()\n    _Logger.print(\n        f\"Constructing correlation landscape on {layer.name} ({layer.molecules.count()} molecules) for RMA ...\"\n    )\n    landscape, _ = self._construct_landscape(\n        molecules=layer.molecules,\n        template_path=template_path,\n        mask_params=mask_params,\n        max_shifts=max_shifts,\n        rotations=rotations,\n        cutoff=cutoff,\n        order=interpolation,\n        bin_size=bin_size,\n        upsample_factor=upsample_factor,\n    )\n    yield\n    mole, results = landscape.run_annealing_along_spline(\n        layer.source_spline,\n        range_long=range_long,\n        range_lat=range_lat,\n        angle_max=angle_max,\n        temperature_time_const=temperature_time_const,\n        random_seeds=random_seeds,\n    )\n    t0.toc()\n\n    @thread_worker.callback\n    def _on_return():\n        points = main.add_molecules(\n            mole,\n            name=_coerce_aligned_name(layer.name, self.parent_viewer),\n            source=layer.source_component,\n            metadata={ANNEALING_RESULT: results[0]},\n        )\n        layer.visible = False\n        with _Logger.set_plt():\n            _annealing.plot_annealing_result(results)\n        return self._undo_for_new_layer([layer.name], [points])\n\n    return _on_return\n</code></pre>"},{"location":"api/widgets/sta/#cylindra.widgets.sta.SubtomogramAveraging.align_all_rma_template_free","title":"<code>align_all_rma_template_free(layer, mask_params=None, size=12.0, max_shifts=(0.8, 0.8, 0.8), rotations=((0.0, 0.0), (0.0, 0.0), (0.0, 0.0)), interpolation=3, method='zncc', range_long=(4.0, 4.28), range_lat=(5.1, 5.3), angle_max=5.0, bin_size=1, temperature_time_const=0.7, upsample_factor=5, seed=0, tolerance=0.01)</code>","text":"<p>2D-constrained subtomogram alignment using simulated annealing.</p> <p>This alignment method considers the distance between every adjacent monomers. Two-dimensionally connected optimization can be approximated by the simulated annealing algorithm.</p> <p>Parameters:</p> Name Type Description Default <code>layer</code> <code>MoleculesLayer</code> <p>Points layer of molecules to be used.</p> required <code>mask_params</code> <code>str or (float, float)</code> <p>Mask image path or dilation/Gaussian blur parameters. If a path is given, image must in the same shape as the template.</p> <code>None</code> <code>max_shifts</code> <code>int or tuple of int</code> <p>Maximum shift between subtomograms and template in nm. ZYX order.</p> <code>(0.8, 0.8, 0.8)</code> <code>rotations</code> <code>((float, float), (float, float), (float, float))</code> <p>Rotation in external degree around each axis.</p> <code>((0.0, 0.0), (0.0, 0.0), (0.0, 0.0))</code> <code>interpolation</code> <code>int</code> <p>Interpolation order.</p> <code>3</code> <code>range_long</code> <code>(float, float)</code> <p>Minimum and maximum allowed distances between longitudinally consecutive monomers</p> <code>(4.0, 4.28)</code> <code>range_lat</code> <code>(float, float)</code> <p>Minimum and maximum allowed distances between laterally consecutive monomers</p> <code>(5.1, 5.3)</code> <code>angle_max</code> <code>float</code> <p>Maximum allowed angle between longitudinally consecutive monomers and the Y axis.</p> <code>5.0</code> <code>bin_size</code> <code>int</code> <p>Bin size of multiscale image to be used. Set to &gt;1 to boost performance.</p> <code>1</code> <code>temperature_time_const</code> <code>float</code> <p>Time constant of the temperature decay during annealing. Larger value results in slower annealing. 1.0 is a moderate value.</p> <code>0.7</code> <code>upsample_factor</code> <code>int</code> <p>Upsampling factor of ZNCC landscape. Be careful not to set this parameter too large.  Calculation will take much longer for larger <code>upsample_factor</code>.</p> <code>5</code> <code>seed</code> <code>int</code> <p>Random seed for FSC calculation.</p> <code>0</code> <code>tolerance</code> <code>float</code> <p>Tolerance for convergence of the FSC calculation.</p> <code>0.01</code> Source code in <code>cylindra/widgets/sta.py</code> <pre><code>@set_design(text=\"Simulated annealing (RMA, template free)\", location=Alignment)\n@dask_worker.with_progress()\ndef align_all_rma_template_free(\n    self,\n    layer: MoleculesLayerType,\n    mask_params: Annotated[Any, {\"bind\": _get_mask_params}] = None,\n    size: _SubVolumeSize = 12.0,\n    max_shifts: _MaxShifts = (0.8, 0.8, 0.8),\n    rotations: _Rotations = ((0.0, 0.0), (0.0, 0.0), (0.0, 0.0)),\n    interpolation: Annotated[int, {\"choices\": INTERPOLATION_CHOICES}] = 3,\n    method: Annotated[str, {\"choices\": METHOD_CHOICES}] = \"zncc\",\n    range_long: _DistRangeLon = (4.0, 4.28),\n    range_lat: _DistRangeLat = (5.1, 5.3),\n    angle_max: _AngleMaxLon = 5.0,\n    bin_size: Annotated[int, {\"choices\": _get_available_binsize}] = 1,\n    temperature_time_const: Annotated[float, {\"min\": 0.01, \"max\": 10.0}] = 0.7,\n    upsample_factor: Annotated[int, {\"min\": 1, \"max\": 20}] = 5,\n    seed: Annotated[Optional[int], {\"text\": \"Do not use random seed.\"}] = 0,\n    tolerance: float = 0.01,\n):  # fmt: skip\n    \"\"\"2D-constrained subtomogram alignment using simulated annealing.\n\n    This alignment method considers the distance between every adjacent monomers.\n    Two-dimensionally connected optimization can be approximated by the simulated\n    annealing algorithm.\n\n    Parameters\n    ----------\n    {layer}{mask_params}{max_shifts}{rotations}{interpolation}{range_long}\n    {range_lat}{angle_max}{bin_size}\n    {temperature_time_const}{upsample_factor}\n    seed : int, optional\n        Random seed for FSC calculation.\n    tolerance : float, default 0.01\n        Tolerance for convergence of the FSC calculation.\n    \"\"\"\n    t0 = timer()\n    layer = assert_layer(layer, self.parent_viewer)\n    if layer.source_spline is None:\n        raise ValueError(\n            \"RMA requires a spline but the input layer is not connected to any splines.\"\n        )\n    main = self._get_main()\n    if size is None:\n        raise NotImplementedError(\"'size' must be given.\")\n    else:\n        shape = tuple(\n            main.tomogram.nm2pixel(self._get_shape_in_nm(size), binsize=bin_size)\n        )\n    rng = np.random.default_rng(seed)\n    mask = self.params._get_mask(params=mask_params)\n\n    aligned_loader = current_loader = self._get_loader(\n        binsize=bin_size, molecules=layer.molecules, order=interpolation\n    ).reshape(shape=shape)\n    _alignment_state = widget_utils.TemplateFreeAlignmentState(rng=rng)\n\n    @thread_worker.callback\n    def _plot_annealing_result(results):\n        with _Logger.set_plt():\n            _annealing.plot_annealing_result(results)\n\n    next_layer_name = _coerce_aligned_name(layer.name, self.parent_viewer)\n    while True:\n        yield thread_worker.description(\n            f\"Calculating FSC (iteration {_alignment_state.niter})\"\n        )\n        fsc_result, avg = _alignment_state.eval_fsc(\n            aligned_loader, mask, tolerance=tolerance\n        )\n        yield _plot_current_fsc.with_args(\n            fsc_result, _alignment_state.niter, avg\n        ).with_desc(f\"Landscape construction (iteration {_alignment_state.niter})\")\n        if _alignment_state.converged:\n            _Logger.print(\"FSC converged.\")\n            yield self._show_rec.with_args(avg, f\"[Aligned]{next_layer_name}\")\n            break\n        _alignment_state.niter += 1\n        landscape = Landscape.from_loader(\n            loader=current_loader,\n            template=avg,\n            mask=self.params._get_mask(params=mask_params),\n            max_shifts=max_shifts,\n            upsample_factor=upsample_factor,\n            alignment_model=_get_alignment(method).with_params(\n                rotations=rotations,\n                cutoff=current_loader.scale / fsc_result.get_resolution(0.143),\n                tilt=main.tomogram.tilt_model,\n            ),\n        )\n        yield thread_worker.description(\n            f\"Running RMA (iteration {_alignment_state.niter})\"\n        )\n        mole, results = landscape.run_annealing_along_spline(\n            layer.source_spline,\n            range_long=range_long,\n            range_lat=range_lat,\n            angle_max=angle_max,\n            temperature_time_const=temperature_time_const,\n            random_seeds=rng.integers(0, 2**32, size=3).tolist(),\n        )\n        aligned_loader = SubtomogramLoader(\n            current_loader.image,\n            mole,\n            order=current_loader.order,\n            scale=current_loader.scale,\n            output_shape=current_loader.output_shape,\n        )\n        yield _plot_annealing_result.with_args(results)\n\n    t0.toc()\n\n    @thread_worker.callback\n    def _on_return():\n        points = main.add_molecules(\n            aligned_loader.molecules,\n            name=next_layer_name,\n            source=layer.source_component,\n            metadata={ANNEALING_RESULT: results[0]},\n        )\n        layer.visible = False\n        with _Logger.set_plt():\n            _annealing.plot_annealing_result(results)\n        return self._undo_for_new_layer([layer.name], [points])\n\n    return _on_return\n</code></pre>"},{"location":"api/widgets/sta/#cylindra.widgets.sta.SubtomogramAveraging.align_all_template_free","title":"<code>align_all_template_free(layers, mask_params, size=12.0, max_shifts=(1.0, 1.0, 1.0), rotations=((0.0, 0.0), (0.0, 0.0), (0.0, 0.0)), interpolation=3, method='zncc', bin_size=1, seed=0, tolerance=0.01)</code>","text":"<p>Iteratively align molecules and validate using FSC without template.</p> <p>Parameters:</p> Name Type Description Default <code>layers</code> <code>list of MoleculesLayer</code> <p>All the points layers of molecules to be used.</p> required <code>mask_params</code> <code>str or (float, float)</code> <p>Mask image path or dilation/Gaussian blur parameters. If a path is given, image must in the same shape as the template.</p> required <code>size</code> <code>nm</code> <p>Size of the template in nm. Use the size of template image by default.</p> <code>12.0</code> <code>max_shifts</code> <code>int or tuple of int</code> <p>Maximum shift between subtomograms and template in nm. ZYX order.</p> <code>(1.0, 1.0, 1.0)</code> <code>rotations</code> <code>((float, float), (float, float), (float, float))</code> <p>Rotation in external degree around each axis.</p> <code>((0.0, 0.0), (0.0, 0.0), (0.0, 0.0))</code> <code>interpolation</code> <code>int</code> <p>Interpolation order.</p> <code>3</code> <code>method</code> <code>str</code> <p>Correlation metrics for alignment.</p> <code>'zncc'</code> <code>bin_size</code> <code>int</code> <p>Bin size of multiscale image to be used. Set to &gt;1 to boost performance.</p> <code>1</code> <code>seed</code> <code>int</code> <p>Random seed for FSC calculation.</p> <code>0</code> <code>tolerance</code> <code>float</code> <p>Tolerance for convergence of the FSC calculation.</p> <code>0.01</code> Source code in <code>cylindra/widgets/sta.py</code> <pre><code>@set_design(text=\"Align all (template-free)\", location=Alignment)\n@dask_worker.with_progress()\ndef align_all_template_free(\n    self,\n    layers: MoleculesLayersType,\n    mask_params: Annotated[Any, {\"bind\": _get_mask_params}],\n    size: _SubVolumeSize = 12.0,\n    max_shifts: _MaxShifts = (1.0, 1.0, 1.0),\n    rotations: _Rotations = ((0.0, 0.0), (0.0, 0.0), (0.0, 0.0)),\n    interpolation: Annotated[int, {\"choices\": INTERPOLATION_CHOICES}] = 3,\n    method: Annotated[str, {\"choices\": METHOD_CHOICES}] = \"zncc\",\n    bin_size: Annotated[int, {\"choices\": _get_available_binsize}] = 1,\n    seed: Annotated[Optional[int], {\"text\": \"Do not use random seed.\"}] = 0,\n    tolerance: float = 0.01,\n):  # fmt: skip\n    \"\"\"Iteratively align molecules and validate using FSC without template.\n\n    Parameters\n    ----------\n    {layers}{mask_params}{size}{max_shifts}{rotations}{interpolation}\n    {method}{bin_size}\n    seed : int, optional\n        Random seed for FSC calculation.\n    tolerance : float, default 0.01\n        Tolerance for convergence of the FSC calculation.\n    \"\"\"\n    t0 = timer()\n    rng = np.random.default_rng(seed)\n    layers = assert_list_of_layers(layers, self.parent_viewer)\n    main = self._get_main()\n    combiner = widget_utils.MoleculesCombiner()\n    molecules = combiner.concat(layer.molecules for layer in layers)\n    mask = self.params._get_mask(params=mask_params)\n    if size is None:\n        raise NotImplementedError(\"'size' must be given.\")\n    else:\n        shape = tuple(\n            main.tomogram.nm2pixel(self._get_shape_in_nm(size), binsize=bin_size)\n        )\n    aligned_loader = current_loader = self._get_loader(\n        binsize=bin_size, molecules=molecules, order=interpolation\n    ).reshape(shape=shape)\n    _alignment_state = widget_utils.TemplateFreeAlignmentState(rng=rng)\n    _Logger.print(f\"Start alignment ({molecules.count()} molecules) ...\")\n    while True:\n        yield thread_worker.description(\n            f\"Calculating FSC for iteration {_alignment_state.niter}\"\n        )\n        fsc_result, avg = _alignment_state.eval_fsc(\n            aligned_loader,\n            mask,\n            tolerance=tolerance,\n        )\n        yield _plot_current_fsc.with_args(\n            fsc_result, _alignment_state.niter, avg\n        ).with_desc(f\"Alignment for iteration {_alignment_state.niter}\")\n        if _alignment_state.converged:\n            _Logger.print(\"FSC converged.\")\n            yield self._show_rec.with_args(avg, f\"[Aligned]{_avg_name(layers)}\")\n            break\n        _alignment_state.niter += 1\n        aligned_loader = current_loader.align(\n            avg, mask=mask, max_shifts=max_shifts, rotations=rotations,\n            cutoff=current_loader.scale / fsc_result.get_resolution(0.143),\n            alignment_model=_get_alignment(method),\n        )  # fmt: skip\n\n    molecules = combiner.split(aligned_loader.molecules, layers)\n    t0.toc()\n    return self._align_all_on_return.with_args(molecules, layers)\n</code></pre>"},{"location":"api/widgets/sta/#cylindra.widgets.sta.SubtomogramAveraging.align_all_viterbi","title":"<code>align_all_viterbi(layer, template_path, mask_params=None, max_shifts=(0.8, 0.8, 0.8), rotations=((0.0, 0.0), (0.0, 0.0), (0.0, 0.0)), cutoff=0.5, interpolation=3, range_long=(4.0, 4.28), angle_max=5.0, bin_size=1, upsample_factor=5)</code>","text":"<p>Subtomogram alignment using 1D Viterbi alignment.</p> <p>1D Viterbi alignment is an alignment algorithm that considers the distance and the skew angle between every longitudinally adjacent monomers. The classical Viterbi algorithm is used to find the global optimal solution of the alignment. Note that Viterbi alignment is data size dependent, i.e. the alignment result of molecules may vary depending on the total number of molecules in the dataset.</p> <p>Parameters:</p> Name Type Description Default <code>layer</code> <code>MoleculesLayer</code> <p>Points layer of molecules to be used.</p> required <code>template_path</code> <code>Path or str</code> <p>Path to template image.</p> required <code>mask_params</code> <code>str or (float, float)</code> <p>Mask image path or dilation/Gaussian blur parameters. If a path is given, image must in the same shape as the template.</p> <code>None</code> <code>max_shifts</code> <code>int or tuple of int</code> <p>Maximum shift between subtomograms and template in nm. ZYX order.</p> <code>(0.8, 0.8, 0.8)</code> <code>rotations</code> <code>((float, float), (float, float), (float, float))</code> <p>Rotation in external degree around each axis.</p> <code>((0.0, 0.0), (0.0, 0.0), (0.0, 0.0))</code> <code>cutoff</code> <code>float</code> <p>Cutoff frequency of low-pass filter applied in each subtomogram.</p> <code>0.5</code> <code>interpolation</code> <code>int</code> <p>Interpolation order.</p> <code>3</code> <code>range_long</code> <code>(float, float)</code> <p>Minimum and maximum allowed distances between longitudinally consecutive monomers</p> <code>(4.0, 4.28)</code> <code>angle_max</code> <code>float</code> <p>Maximum allowed angle between longitudinally consecutive monomers and the Y axis.</p> <code>5.0</code> <code>bin_size</code> <code>int</code> <p>Bin size of multiscale image to be used. Set to &gt;1 to boost performance.</p> <code>1</code> <code>upsample_factor</code> <code>int</code> <p>Upsampling factor of ZNCC landscape. Be careful not to set this parameter too large.  Calculation will take much longer for larger <code>upsample_factor</code>.</p> <code>5</code> Source code in <code>cylindra/widgets/sta.py</code> <pre><code>@set_design(text=\"Viterbi Alignment\", location=Alignment)\n@dask_worker.with_progress(descs=_pdesc.align_viterbi_fmt)\ndef align_all_viterbi(\n    self,\n    layer: MoleculesLayerType,\n    template_path: Annotated[_PathOrPathsOrNone, {\"bind\": _template_params}],\n    mask_params: Annotated[Any, {\"bind\": _get_mask_params}] = None,\n    max_shifts: _MaxShifts = (0.8, 0.8, 0.8),\n    rotations: _Rotations = ((0.0, 0.0), (0.0, 0.0), (0.0, 0.0)),\n    cutoff: _CutoffFreq = 0.5,\n    interpolation: Annotated[int, {\"choices\": INTERPOLATION_CHOICES}] = 3,\n    range_long: _DistRangeLon = (4.0, 4.28),\n    angle_max: _AngleMaxLon = 5.0,\n    bin_size: Annotated[int, {\"choices\": _get_available_binsize}] = 1,\n    upsample_factor: Annotated[int, {\"min\": 1, \"max\": 20}] = 5,\n):  # fmt: skip\n    \"\"\"Subtomogram alignment using 1D Viterbi alignment.\n\n    1D Viterbi alignment is an alignment algorithm that considers the distance and\n    the skew angle between every longitudinally adjacent monomers. The classical\n    Viterbi algorithm is used to find the global optimal solution of the alignment.\n    Note that Viterbi alignment is data size dependent, i.e. the alignment result\n    of molecules may vary depending on the total number of molecules in the dataset.\n\n    Parameters\n    ----------\n    {layer}{template_path}{mask_params}{max_shifts}{rotations}{cutoff}\n    {interpolation}{range_long}{angle_max}{bin_size}{upsample_factor}\n    \"\"\"\n    t0 = timer()\n    layer = assert_layer(layer, self.parent_viewer)\n    landscape, _ = self._construct_landscape(\n        molecules=layer.molecules,\n        template_path=template_path,\n        mask_params=mask_params,\n        max_shifts=max_shifts,\n        rotations=rotations,\n        cutoff=cutoff,\n        order=interpolation,\n        upsample_factor=upsample_factor,\n        bin_size=bin_size,\n    )\n\n    yield\n    mole = landscape.run_viterbi_along_spline(\n        spl=layer.source_spline,\n        range_long=range_long,\n        angle_max=angle_max,\n    )\n    t0.toc()\n    return self._align_all_on_return.with_args([mole], [layer])\n</code></pre>"},{"location":"api/widgets/sta/#cylindra.widgets.sta.SubtomogramAveraging.align_averaged","title":"<code>align_averaged(layers, template_path, mask_params, max_shifts=None, rotations=((0.0, 0.0), (15.0, 1.0), (3.0, 1.0)), bin_size=1, method='zncc')</code>","text":"<p>Align the averaged image at current monomers to the template image.</p> <p>This function creates a new layer with transformed monomers, which should align well with template image.</p> <p>Parameters:</p> Name Type Description Default <code>layers</code> <code>list of MoleculesLayer</code> <p>All the points layers of molecules to be used.</p> required <code>template_path</code> <code>Path or str</code> <p>Path to template image.</p> required <code>mask_params</code> <code>str or (float, float)</code> <p>Mask image path or dilation/Gaussian blur parameters. If a path is given, image must in the same shape as the template.</p> required <code>max_shifts</code> <code>int or tuple of int</code> <p>Maximum shift between subtomograms and template in nm. ZYX order.</p> <code>None</code> <code>rotations</code> <code>((float, float), (float, float), (float, float))</code> <p>Rotation in external degree around each axis.</p> <code>((0.0, 0.0), (15.0, 1.0), (3.0, 1.0))</code> <code>bin_size</code> <code>int</code> <p>Bin size of multiscale image to be used. Set to &gt;1 to boost performance.</p> <code>1</code> <code>method</code> <code>str</code> <p>Correlation metrics for alignment.</p> <code>'zncc'</code> Source code in <code>cylindra/widgets/sta.py</code> <pre><code>@set_design(text=\"Align average to template\", location=Alignment)\n@dask_worker.with_progress()\ndef align_averaged(\n    self,\n    layers: MoleculesLayersType,\n    template_path: Annotated[_PathOrNone, {\"bind\": _template_param}],\n    mask_params: Annotated[Any, {\"bind\": _get_mask_params}],\n    max_shifts: Optional[_MaxShifts] = None,\n    rotations: _Rotations = ((0.0, 0.0), (15.0, 1.0), (3.0, 1.0)),\n    bin_size: Annotated[int, {\"choices\": _get_available_binsize}] = 1,\n    method: Annotated[str, {\"choices\": METHOD_CHOICES}] = \"zncc\",\n):  # fmt: skip\n    \"\"\"Align the averaged image at current monomers to the template image.\n\n    This function creates a new layer with transformed monomers, which should\n    align well with template image.\n\n    Parameters\n    ----------\n    {layers}{template_path}{mask_params}{max_shifts}{rotations}{bin_size}{method}\n    \"\"\"\n    t0 = timer()\n    layers = assert_list_of_layers(layers, self.parent_viewer)\n    parent = self._get_main()\n\n    new_layers = list[MoleculesLayer]()\n    total = 2 * len(layers) + 1\n    yield thread_worker.description(\n        f\"(0/{total}) Preparing template images for alignment\"\n    )\n\n    @thread_worker.callback\n    def _on_yield(mole_trans: Molecules, layer: MoleculesLayer):\n        points = parent.add_molecules(\n            mole_trans,\n            name=_coerce_aligned_name(layer.name, self.parent_viewer),\n            source=layer.source_component,\n        )\n        new_layers.append(points)\n        layer.visible = False\n        _Logger.print_html(f\"{layer.name!r} &amp;#8594; {points.name!r}\")\n\n    mole = layers[0].molecules\n    loader = self._get_loader(bin_size, mole, order=1)\n    template, mask = loader.normalize_input(\n        template=self.params._norm_template_param(\n            template_path, allow_multiple=False\n        ),\n        mask=self.params._get_mask(params=mask_params),\n    )\n    temp_norm = utils.normalize_image(template)\n\n    _scale = parent.tomogram.scale * bin_size\n\n    if max_shifts is None:\n        max_shifts = _default_align_averaged_shifts(mole)\n\n    model = _get_alignment(method)(\n        template,\n        mask,\n        rotations=rotations,\n        tilt=None,  # NOTE: because input is an average\n    )\n    _spl_globs = list[\n        tuple[weakref.ReferenceType[\"CylSpline\"], pl.DataFrame, pl.DataFrame]\n    ]()\n    for i, layer in enumerate(layers):\n        mole = layer.molecules\n        loader = self._get_loader(bin_size, mole, order=1)\n        yield thread_worker.description(\n            f\"({i * 2 + 1}/{total}) Subtomogram averaging of {layer.name!r}\"\n        )\n        avg = loader.average(template.shape)\n        yield thread_worker.description(\n            f\"({i * 2 + 2}/{total}) Aligning template to the average image of {layer.name!r}\"\n        )\n        _img_trans, result = model.fit(\n            avg,\n            max_shifts=[_s / _scale for _s in max_shifts],\n        )\n\n        rotator = Rotation.from_quat(result.quat)\n        svec = result.shift * _scale\n        _mole_trans = mole.linear_transform(result.shift * _scale, rotator)\n\n        # write offsets to spline globalprops if available\n        if spl := layer.source_spline:\n            _Logger.print(\n                f\"Layer {layer.name} has a source spline, update its globalprops.\"\n            )\n            _mole_trans = widget_utils.update_mole_pos(_mole_trans, mole, spl)\n            if spl.radius is None:\n                _radius: nm = cylmeasure.calc_radius(mole, spl).mean()\n            else:\n                _radius = spl.radius\n            _glob_old = spl.props.glob.clone()\n            _glob_new = _update_offset(spl, rotator.apply(svec), _radius)\n            spl.props.glob = _glob_new\n            _spl_globs.append((weakref.ref(spl), _glob_old, _glob_new))\n\n        yield _on_yield.with_args(_mole_trans, layer)\n\n        # create images for visualization in the logger. Image is magenta, template is green\n        img_norm = utils.normalize_image(_img_trans)\n        merge = np.stack([img_norm, temp_norm, img_norm], axis=-1)\n        with _Logger.set_plt():\n            widget_utils.plot_projections(merge)\n\n        # logging\n        rvec = rotator.as_rotvec()\n        _fmt = \"  {:.2f}  \".format\n        _Logger.print_table(\n            [\n                [\"\", \"X\", \"Y\", \"Z\"],\n                [\"Shift (nm)\", _fmt(svec[2]), _fmt(svec[1]), _fmt(svec[0])],\n                [\"Rot vector\", _fmt(rvec[2]), _fmt(rvec[1]), _fmt(rvec[0])],\n            ],\n            header=False,\n            index=False,\n        )\n\n    t0.toc()\n\n    @thread_worker.callback\n    def _align_averaged_on_return():\n        @undo_callback\n        def _out():\n            parent._try_removing_layers(new_layers)\n            for spl_ref, old, _ in _spl_globs:\n                if spl := spl_ref():\n                    spl.props.glob = old\n\n        @_out.with_redo\n        def _out():\n            parent._add_layers_future(new_layers)()\n            for spl_ref, _, new in _spl_globs:\n                if spl := spl_ref():\n                    spl.props.glob = new\n\n        return _out\n\n    return _align_averaged_on_return.with_desc(\"Finished\")\n</code></pre>"},{"location":"api/widgets/sta/#cylindra.widgets.sta.SubtomogramAveraging.average_all","title":"<code>average_all(layers, size=None, interpolation=1, bin_size=1)</code>","text":"<p>Subtomogram averaging using all the molecules in the selected layer(s).</p> <p>If multiple layers are selected, subtomograms around all the molecules will be averaged.</p> <p>Parameters:</p> Name Type Description Default <code>layers</code> <code>list of MoleculesLayer</code> <p>All the points layers of molecules to be used.</p> required <code>size</code> <code>nm</code> <p>Size of the template in nm. Use the size of template image by default.</p> <code>None</code> <code>interpolation</code> <code>int</code> <p>Interpolation order.</p> <code>1</code> <code>bin_size</code> <code>int</code> <p>Bin size of multiscale image to be used. Set to &gt;1 to boost performance.</p> <code>1</code> Source code in <code>cylindra/widgets/sta.py</code> <pre><code>@set_design(text=\"Average all molecules\", location=Averaging)\n@dask_worker.with_progress(desc=_pdesc.fmt_layers(\"Subtomogram averaging of {!r}\"))\ndef average_all(\n    self,\n    layers: MoleculesLayersType,\n    size: _SubVolumeSize = None,\n    interpolation: Annotated[int, {\"choices\": INTERPOLATION_CHOICES}] = 1,\n    bin_size: Annotated[int, {\"choices\": _get_available_binsize}] = 1,\n):\n    \"\"\"Subtomogram averaging using all the molecules in the selected layer(s).\n\n    If multiple layers are selected, subtomograms around all the molecules will\n    be averaged.\n\n    Parameters\n    ----------\n    {layers}{size}{interpolation}{bin_size}\n    \"\"\"\n    t0 = timer()\n    layers = assert_list_of_layers(layers, self.parent_viewer)\n    parent = self._get_main()\n    tomo = parent.tomogram\n    shape = self._get_shape_in_nm(size)\n    loader = tomo.get_subtomogram_loader(\n        _concat_molecules(layers), shape, binsize=bin_size, order=interpolation\n    )\n    img = ip.asarray(loader.average(), axes=\"zyx\")\n    img.set_scale(zyx=loader.scale, unit=\"nm\")\n    t0.toc()\n    _Logger.print_html(\n        f\"{loader.molecules.count()} molecules. Image size: {shape[0]:.2f} nm ({img.shape[0]} pixel)\"\n    )\n    return self._show_rec.with_args(img, f\"[AVG]{_avg_name(layers)}\")\n</code></pre>"},{"location":"api/widgets/sta/#cylindra.widgets.sta.SubtomogramAveraging.average_filtered","title":"<code>average_filtered(layers, size=None, predicate=\"col('pf-id') == 0\", interpolation=1, bin_size=1)</code>","text":"<p>Subtomogram averaging using molecules filtered by the given expression.</p> <p>This method first concatenate molecules in the selected layers, and then filter them by the predicate.</p> <p>Parameters:</p> Name Type Description Default <code>layers</code> <code>list of MoleculesLayer</code> <p>All the points layers of molecules to be used.</p> required <code>size</code> <code>nm</code> <p>Size of the template in nm. Use the size of template image by default.</p> <code>None</code> <code>predicate</code> <code>str or polars expression</code> <p>Filter expression to select molecules.</p> <code>\"col('pf-id') == 0\"</code> <code>interpolation</code> <code>int</code> <p>Interpolation order.</p> <code>1</code> <code>bin_size</code> <code>int</code> <p>Bin size of multiscale image to be used. Set to &gt;1 to boost performance.</p> <code>1</code> Source code in <code>cylindra/widgets/sta.py</code> <pre><code>@set_design(text=\"Average filtered\", location=Averaging)\n@dask_worker.with_progress(desc=_pdesc.fmt_layers(\"Filtered subtomogram averaging of {!r}\"))  # fmt: skip\ndef average_filtered(\n    self,\n    layers: MoleculesLayersType,\n    size: _SubVolumeSize = None,\n    predicate: PolarsExprStr = \"col('pf-id') == 0\",\n    interpolation: Annotated[int, {\"choices\": INTERPOLATION_CHOICES}] = 1,\n    bin_size: Annotated[int, {\"choices\": _get_available_binsize}] = 1,\n):\n    \"\"\"Subtomogram averaging using molecules filtered by the given expression.\n\n    This method first concatenate molecules in the selected layers, and then filter them\n    by the predicate.\n\n    Parameters\n    ----------\n    {layers}{size}\n    predicate : str or polars expression\n        Filter expression to select molecules.\n    {interpolation}{bin_size}\n    \"\"\"\n    t0 = timer()\n    layers = assert_list_of_layers(layers, self.parent_viewer)\n    parent = self._get_main()\n    tomo = parent.tomogram\n    shape = self._get_shape_in_nm(size)\n    loader = tomo.get_subtomogram_loader(\n        _concat_molecules(layers), shape, binsize=bin_size, order=interpolation\n    ).filter(widget_utils.norm_expr(predicate))\n    avg = loader.average()\n    img = ip.asarray(avg, axes=\"zyx\")\n    img.set_scale(zyx=loader.scale, unit=\"nm\")\n    t0.toc()\n    _Logger.print_html(\n        f\"Average of {loader.molecules.count()} molecules. Image size: {shape[0]:.2f} nm ({img.shape[0]} pixel)\"\n    )\n    return self._show_rec.with_args(img, f\"[AVG]{_avg_name(layers)}\")\n</code></pre>"},{"location":"api/widgets/sta/#cylindra.widgets.sta.SubtomogramAveraging.average_groups","title":"<code>average_groups(layers, size=None, by=\"col('pf-id')\", interpolation=1, bin_size=1)</code>","text":"<p>Group-wise subtomogram averaging.</p> <p>This method first group molecules by its features, and then average each group. This method is useful for such as get average of each protofilament and segmented subtomogram averaging.</p> <p>Parameters:</p> Name Type Description Default <code>layers</code> <code>list of MoleculesLayer</code> <p>All the points layers of molecules to be used.</p> required <code>size</code> <code>nm</code> <p>Size of the template in nm. Use the size of template image by default.</p> <code>None</code> <code>by</code> <code>str or polars expression</code> <p>Expression to group molecules.</p> <code>\"col('pf-id')\"</code> <code>interpolation</code> <code>int</code> <p>Interpolation order.</p> <code>1</code> <code>bin_size</code> <code>int</code> <p>Bin size of multiscale image to be used. Set to &gt;1 to boost performance.</p> <code>1</code> Source code in <code>cylindra/widgets/sta.py</code> <pre><code>@set_design(text=\"Average group-wise\", location=Averaging)\n@dask_worker.with_progress(desc=_pdesc.fmt_layers(\"Grouped subtomogram averaging of {!r}\"))  # fmt: skip\ndef average_groups(\n    self,\n    layers: MoleculesLayersType,\n    size: _SubVolumeSize = None,\n    by: PolarsExprStr = \"col('pf-id')\",\n    interpolation: Annotated[int, {\"choices\": INTERPOLATION_CHOICES}] = 1,\n    bin_size: Annotated[int, {\"choices\": _get_available_binsize}] = 1,\n):\n    \"\"\"Group-wise subtomogram averaging.\n\n    This method first group molecules by its features, and then average each group.\n    This method is useful for such as get average of each protofilament and segmented\n    subtomogram averaging.\n\n    Parameters\n    ----------\n    {layers}{size}\n    by : str or polars expression\n        Expression to group molecules.\n    {interpolation}{bin_size}\n    \"\"\"\n    t0 = timer()\n    layers = assert_list_of_layers(layers, self.parent_viewer)\n    parent = self._get_main()\n    tomo = parent.tomogram\n    shape = self._get_shape_in_nm(size)\n    loader = tomo.get_subtomogram_loader(\n        _concat_molecules(layers), shape, binsize=bin_size, order=interpolation\n    )\n    expr = widget_utils.norm_expr(by)\n    groups = loader.groupby(expr)\n    avg_dict = groups.average()\n    avgs = np.stack([avg_dict[k] for k in sorted(avg_dict.keys())], axis=0)\n    img = ip.asarray(avgs, axes=\"pzyx\")\n    img.set_scale(zyx=loader.scale, unit=\"nm\")\n    t0.toc()\n    mole_counts = [sub.molecules.count() for _, sub in groups]\n    _Logger.print_html(\n        f\"Averages of {len(avg_dict)} groups, {mole_counts} molecules \"\n        f\"respectively.\\nImage size: {shape[0]:.2f} nm ({img.shape[-1]} pixel)\"\n    )\n    return self._show_rec.with_args(img, f\"[AVG]{_avg_name(layers)}\")\n</code></pre>"},{"location":"api/widgets/sta/#cylindra.widgets.sta.SubtomogramAveraging.average_subset","title":"<code>average_subset(layers, size=None, method='steps', number=64, bin_size=1)</code>","text":"<p>Subtomogram averaging using a subset of subvolumes.</p> <p>If multiple layers are selected, subtomograms around all the molecules will be concatenated before choosing a subset.</p> <p>Parameters:</p> Name Type Description Default <code>layers</code> <code>list of MoleculesLayer</code> <p>All the points layers of molecules to be used.</p> required <code>size</code> <code>nm</code> <p>Size of the template in nm. Use the size of template image by default.</p> <code>None</code> <code>method</code> <code>str</code> <p>How to choose subtomogram subset. (1) steps: Each 'steps' subtomograms from the tip of spline. (2) first: First subtomograms. (3) last: Last subtomograms. (4) random: choose randomly.</p> <code>'steps'</code> <code>number</code> <code>(int, default)</code> <p>Number of subtomograms to use.</p> <code>64</code> <code>bin_size</code> <code>int</code> <p>Bin size of multiscale image to be used. Set to &gt;1 to boost performance.</p> <code>1</code> Source code in <code>cylindra/widgets/sta.py</code> <pre><code>@set_design(text=\"Average subset of molecules\", location=Averaging)\n@dask_worker.with_progress(desc=_pdesc.fmt_layers(\"Subtomogram averaging (subset) of {!r}\"))  # fmt: skip\ndef average_subset(\n    self,\n    layers: MoleculesLayersType,\n    size: _SubVolumeSize = None,\n    method: Literal[\"steps\", \"first\", \"last\", \"random\"] = \"steps\",\n    number: int = 64,\n    bin_size: Annotated[int, {\"choices\": _get_available_binsize}] = 1,\n):\n    \"\"\"Subtomogram averaging using a subset of subvolumes.\n\n    If multiple layers are selected, subtomograms around all the molecules will\n    be concatenated before choosing a subset.\n\n    Parameters\n    ----------\n    {layers}{size}\n    method : str, optional\n        How to choose subtomogram subset.\n        (1) steps: Each 'steps' subtomograms from the tip of spline.\n        (2) first: First subtomograms.\n        (3) last: Last subtomograms.\n        (4) random: choose randomly.\n    number : int, default\n        Number of subtomograms to use.\n    {bin_size}\n    \"\"\"\n    t0 = timer()\n    layers = assert_list_of_layers(layers, self.parent_viewer)\n    parent = self._get_main()\n    molecules = _concat_molecules(layers)\n    nmole = len(molecules)\n    shape = self._get_shape_in_nm(size)\n    sl = _get_slice_for_average_subset(method, nmole, number)\n    mole = molecules.subset(sl)\n    loader = parent.tomogram.get_subtomogram_loader(\n        mole, shape, binsize=bin_size, order=1\n    )\n    img = ip.asarray(loader.average(), axes=\"zyx\").set_scale(zyx=loader.scale)\n    t0.toc()\n    return self._show_rec.with_args(img, f\"[AVG(n={number})]{_avg_name(layers)}\")\n</code></pre>"},{"location":"api/widgets/sta/#cylindra.widgets.sta.SubtomogramAveraging.calculate_correlation","title":"<code>calculate_correlation(layers, template_path, mask_params=None, interpolation=3, cutoff=0.5, bin_size=1, method='zncc', column_prefix='score')</code>","text":"<p>Calculate correlation between template images and the subtomograms.</p> <p>This method will load every subtomograms, calculate the correlation between the template images and each subtomogram, and save the correlation values as new columns in the molecules features.</p> <p>Parameters:</p> Name Type Description Default <code>layers</code> <code>list of MoleculesLayer</code> <p>All the points layers of molecules to be used.</p> required <code>template_path</code> <code>Path or str</code> <p>Path to template image.</p> required <code>mask_params</code> <code>str or (float, float)</code> <p>Mask image path or dilation/Gaussian blur parameters. If a path is given, image must in the same shape as the template.</p> <code>None</code> <code>interpolation</code> <code>int</code> <p>Interpolation order.</p> <code>3</code> <code>cutoff</code> <code>float</code> <p>Cutoff frequency of low-pass filter applied in each subtomogram.</p> <code>0.5</code> <code>bin_size</code> <code>int</code> <p>Bin size of multiscale image to be used. Set to &gt;1 to boost performance.</p> <code>1</code> <code>method</code> <code>str</code> <p>Correlation metrics for alignment.</p> <code>'zncc'</code> <code>column_prefix</code> <code>str</code> <p>Prefix of the column names of the calculated correlations.</p> <code>\"score\"</code> Source code in <code>cylindra/widgets/sta.py</code> <pre><code>@set_design(text=capitalize, location=STAnalysis)\n@dask_worker.with_progress(desc=_pdesc.fmt_layers(\"Calculating correlations of {!r}\"))  # fmt: skip\ndef calculate_correlation(\n    self,\n    layers: MoleculesLayersType,\n    template_path: Annotated[_PathOrPathsOrNone, {\"bind\": _template_params}],\n    mask_params: Annotated[Any, {\"bind\": _get_mask_params}] = None,\n    interpolation: Annotated[int, {\"choices\": INTERPOLATION_CHOICES}] = 3,\n    cutoff: _CutoffFreq = 0.5,\n    bin_size: Annotated[int, {\"choices\": _get_available_binsize}] = 1,\n    method: Annotated[str, {\"choices\": METHOD_CHOICES}] = \"zncc\",\n    column_prefix: str = \"score\",\n):\n    \"\"\"Calculate correlation between template images and the subtomograms.\n\n    This method will load every subtomograms, calculate the correlation between\n    the template images and each subtomogram, and save the correlation values\n    as new columns in the molecules features.\n\n    Parameters\n    ----------\n    {layers}{template_path}{mask_params}{interpolation}{cutoff}{bin_size}{method}\n    column_prefix : str, default \"score\"\n        Prefix of the column names of the calculated correlations.\n    \"\"\"\n    layers = assert_list_of_layers(layers, self.parent_viewer)\n    main = self._get_main()\n    combiner = widget_utils.MoleculesCombiner()\n\n    if isinstance(template_path, (Path, str)):\n        template_path = [template_path]\n    mask = self.params._get_mask(mask_params)\n    all_mole = combiner.concat(layer.molecules for layer in layers)\n\n    out = main.tomogram.get_subtomogram_loader(\n        all_mole,\n        order=interpolation,\n        binsize=bin_size,\n    ).score(\n        templates=[pipe.from_file(t) for t in template_path],\n        mask=mask,\n        alignment_model=_get_alignment(method),\n        cutoff=cutoff,\n        tilt=main.tomogram.tilt_model,\n    )\n    all_mole = all_mole.with_features(\n        pl.Series(f\"{column_prefix}_{i}\", col) for i, col in enumerate(out)\n    )\n\n    @thread_worker.callback\n    def _on_return():\n        moles = combiner.split(all_mole, layers)\n        for layer, each_mole in zip(layers, moles, strict=True):\n            features = each_mole.features.select(\n                [f\"{column_prefix}_{i}\" for i in range(len(out))]\n            )\n            layer.set_molecules_with_new_features(\n                layer.molecules.with_features(features)\n            )\n\n    return _on_return\n</code></pre>"},{"location":"api/widgets/sta/#cylindra.widgets.sta.SubtomogramAveraging.calculate_fsc","title":"<code>calculate_fsc(layers, template_path=None, mask_params=None, size=None, seed=0, interpolation=1, n_pairs=1, show_average=True, dfreq=None)</code>","text":"<p>Calculate Fourier Shell Correlation using the selected monomer layer.</p> <p>Parameters:</p> Name Type Description Default <code>layers</code> <code>list of MoleculesLayer</code> <p>All the points layers of molecules to be used.</p> required <code>template_path</code> <code>template input type</code> <p>Used only when soft-Otsu mask parameters are given.</p> <code>None</code> <code>mask_params</code> <code>str or (float, float)</code> <p>Mask image path or dilation/Gaussian blur parameters. If a path is given, image must in the same shape as the template.</p> <code>None</code> <code>size</code> <code>nm</code> <p>Size of the template in nm. Use the size of template image by default.</p> <code>None</code> <code>seed</code> <code>int</code> <p>Random seed used for subtomogram sampling.</p> <code>0</code> <code>interpolation</code> <code>int</code> <p>Interpolation order.</p> <code>1</code> <code>n_pairs</code> <code>int</code> <p>How many sets of image pairs will be generated to average FSC.</p> <code>1</code> <code>show_average</code> <code>bool</code> <p>If true, subtomogram average will be shown after FSC calculation.</p> <code>True</code> <code>dfreq</code> <code>float</code> <p>Precision of frequency to calculate FSC. \"0.02\" means that FSC will be calculated at frequency 0.01, 0.03, 0.05, ..., 0.45.</p> <code>0.02</code> Source code in <code>cylindra/widgets/sta.py</code> <pre><code>@set_design(text=\"Calculate FSC\", location=STAnalysis)\n@dask_worker.with_progress(desc=_pdesc.fmt_layers(\"Calculating FSC of {!r}\"))\ndef calculate_fsc(\n    self,\n    layers: MoleculesLayersType,\n    template_path: Annotated[_PathOrNone, {\"bind\": _template_param}] = None,\n    mask_params: Annotated[Any, {\"bind\": _get_mask_params}] = None,\n    size: _SubVolumeSize = None,\n    seed: Annotated[Optional[int], {\"text\": \"Do not use random seed.\"}] = 0,\n    interpolation: Annotated[int, {\"choices\": INTERPOLATION_CHOICES}] = 1,\n    n_pairs: Annotated[int, {\"min\": 1, \"label\": \"number of image pairs\"}] = 1,\n    show_average: bool = True,\n    dfreq: FSCFreq = None,\n):\n    \"\"\"Calculate Fourier Shell Correlation using the selected monomer layer.\n\n    Parameters\n    ----------\n    {layers}\n    template_path : template input type\n        Used only when soft-Otsu mask parameters are given.\n    {mask_params}{size}\n    seed : int, optional\n        Random seed used for subtomogram sampling.\n    {interpolation}\n    n_pairs : int, default 1\n        How many sets of image pairs will be generated to average FSC.\n    show_average : bool, default True\n        If true, subtomogram average will be shown after FSC calculation.\n    dfreq : float, default 0.02\n        Precision of frequency to calculate FSC. \"0.02\" means that FSC will be\n        calculated at frequency 0.01, 0.03, 0.05, ..., 0.45.\n    \"\"\"\n    t0 = timer()\n    layers = assert_list_of_layers(layers, self.parent_viewer)\n    main = self._get_main()\n    mole = _concat_molecules(layers)\n\n    loader = main.tomogram.get_subtomogram_loader(mole, order=interpolation)\n    template, mask = loader.normalize_input(\n        template=self.params._norm_template_param(template_path, allow_none=True),\n        mask=self.params._get_mask(params=mask_params),\n    )\n    fsc, (img_0, img_1), img_mask = loader.reshape(\n        template=template if size is None else None,\n        mask=mask,\n        shape=None if size is None else (main.tomogram.nm2pixel(size),) * 3,\n    ).fsc_with_halfmaps(mask, seed=seed, n_set=n_pairs, dfreq=dfreq, squeeze=False)\n\n    def _as_imgarray(im, axes: str = \"zyx\") -&gt; ip.ImgArray | None:\n        if np.isscalar(im):\n            return None\n        return ip.asarray(im, axes=axes).set_scale(zyx=loader.scale, unit=\"nm\")\n\n    if show_average:\n        avg = (img_0[0] + img_1[0]) / 2\n        img_avg = _as_imgarray(avg)\n    else:\n        img_avg = None\n\n    result = widget_utils.FscResult.from_dataframe(fsc, loader.scale)\n    criteria = [0.5, 0.143]\n    _name = _avg_name(layers)\n    t0.toc()\n\n    @thread_worker.callback\n    def _calculate_fsc_on_return():\n        _Logger.print_html(f\"&lt;b&gt;Fourier Shell Correlation of {_name!r}&lt;/b&gt;\")\n        with _Logger.set_plt():\n            result.plot(criteria)\n            plt.tight_layout()\n            plt.show()\n        for _c in criteria:\n            _r = result.get_resolution(_c)\n            _Logger.print_html(f\"Resolution at FSC={_c:.3f} ... &lt;b&gt;{_r:.3f} nm&lt;/b&gt;\")\n\n        if img_avg is not None:\n            _imlayer: Image = self._show_rec(img_avg, name=f\"[AVG]{_name}\")\n            _imlayer.metadata[\"fsc\"] = result\n            _imlayer.metadata[\"fsc_halfmaps\"] = (\n                _as_imgarray(img_0, axes=\"izyx\"),\n                _as_imgarray(img_1, axes=\"izyx\"),\n            )\n            _imlayer.metadata[\"fsc_mask\"] = _as_imgarray(img_mask)\n\n    return _calculate_fsc_on_return\n</code></pre>"},{"location":"api/widgets/sta/#cylindra.widgets.sta.SubtomogramAveraging.classify_pca","title":"<code>classify_pca(layer, template_path=None, mask_params=None, size=None, cutoff=0.5, interpolation=3, bin_size=1, n_components=2, n_clusters=2, seed=0)</code>","text":"<p>Classify molecules in a layer using PCA and K-means clustering.</p> <p>Parameters:</p> Name Type Description Default <code>layer</code> <code>MoleculesLayer</code> <p>Points layer of molecules to be used.</p> required <code>template_path</code> <code>template input type</code> <p>Used only when soft-Otsu mask parameters are given.</p> <code>None</code> <code>mask_params</code> <code>str or (float, float)</code> <p>Mask image path or dilation/Gaussian blur parameters. If a path is given, image must in the same shape as the template.</p> <code>None</code> <code>size</code> <code>nm</code> <p>Size of the template in nm. Use the size of template image by default.</p> <code>None</code> <code>cutoff</code> <code>float</code> <p>Cutoff frequency of low-pass filter applied in each subtomogram.</p> <code>0.5</code> <code>interpolation</code> <code>int</code> <p>Interpolation order.</p> <code>3</code> <code>bin_size</code> <code>int</code> <p>Bin size of multiscale image to be used. Set to &gt;1 to boost performance.</p> <code>1</code> <code>n_components</code> <code>int</code> <p>The number of PCA dimensions.</p> <code>2</code> <code>n_clusters</code> <code>(int, default)</code> <p>The number of clusters.</p> <code>2</code> <code>seed</code> <code>int</code> <p>Random seed.</p> <code>0</code> Source code in <code>cylindra/widgets/sta.py</code> <pre><code>@set_design(text=\"PCA/K-means classification\", location=STAnalysis)\n@dask_worker.with_progress(descs=_pdesc.classify_pca_fmt)\ndef classify_pca(\n    self,\n    layer: MoleculesLayerType,\n    template_path: Annotated[_PathOrNone, {\"bind\": _template_param}] = None,\n    mask_params: Annotated[Any, {\"bind\": _get_mask_params}] = None,\n    size: _SubVolumeSize = None,\n    cutoff: _CutoffFreq = 0.5,\n    interpolation: Annotated[int, {\"choices\": INTERPOLATION_CHOICES}] = 3,\n    bin_size: Annotated[int, {\"choices\": _get_available_binsize}] = 1,\n    n_components: Annotated[int, {\"min\": 2, \"max\": 20}] = 2,\n    n_clusters: Annotated[int, {\"min\": 2, \"max\": 100}] = 2,\n    seed: Annotated[Optional[int], {\"text\": \"Do not use random seed.\"}] = 0,\n):  # fmt: skip\n    \"\"\"Classify molecules in a layer using PCA and K-means clustering.\n\n    Parameters\n    ----------\n    {layer}\n    template_path : template input type\n        Used only when soft-Otsu mask parameters are given.\n    {mask_params}{size}{cutoff}{interpolation}{bin_size}\n    n_components : int, default 2\n        The number of PCA dimensions.\n    n_clusters : int, default\n        The number of clusters.\n    seed : int, default 0\n        Random seed.\n    \"\"\"\n    from cylindra.components.visualize import plot_pca_classification\n\n    t0 = timer()\n    layer = assert_layer(layer, self.parent_viewer)\n    tomo = self._get_main().tomogram\n    loader = self._get_loader(\n        binsize=bin_size, molecules=layer.molecules, order=interpolation\n    )\n    template, mask = loader.normalize_input(\n        template=self.params._norm_template_param(template_path, allow_none=True),\n        mask=self.params._get_mask(params=mask_params),\n    )\n    shape = None\n    if size is not None and mask is None:\n        shape = (tomo.nm2pixel(size, binsize=bin_size),) * 3\n    out, pca = loader.reshape(\n        template=template if mask is None and shape is None else None,\n        mask=mask,\n        shape=shape,\n    ).classify(\n        mask=mask,\n        seed=seed,\n        cutoff=cutoff,\n        n_components=n_components,\n        n_clusters=n_clusters,\n        label_name=\"cluster\",\n    )\n\n    avgs_dict = out.groupby(\"cluster\").average()\n    avgs = ip.asarray(\n        np.stack(list(avgs_dict.values()), axis=0), axes=[\"cluster\", \"z\", \"y\", \"x\"]\n    ).set_scale(zyx=loader.scale, unit=\"nm\")\n\n    transformed = pca.get_transform()\n    t0.toc()\n\n    @thread_worker.callback\n    def _on_return():\n        layer.molecules = out.molecules  # update features\n        with _Logger.set_plt():\n            plot_pca_classification(pca, transformed)\n        self._show_rec(avgs, name=f\"[PCA]{layer.name}\", store=False)\n\n    return _on_return\n</code></pre>"},{"location":"api/widgets/sta/#cylindra.widgets.sta.SubtomogramAveraging.construct_landscape","title":"<code>construct_landscape(layer, template_path, mask_params=None, max_shifts=(0.8, 0.8, 0.8), rotations=((0.0, 0.0), (0.0, 0.0), (0.0, 0.0)), cutoff=0.5, interpolation=3, bin_size=1, upsample_factor=5, method='zncc', norm=True)</code>","text":"<p>Construct a cross-correlation landscape for subtomogram alignment.</p> <p>Parameters:</p> Name Type Description Default <code>layer</code> <code>MoleculesLayer</code> <p>Points layer of molecules to be used.</p> required <code>template_path</code> <code>Path or str</code> <p>Path to template image.</p> required <code>mask_params</code> <code>str or (float, float)</code> <p>Mask image path or dilation/Gaussian blur parameters. If a path is given, image must in the same shape as the template.</p> <code>None</code> <code>max_shifts</code> <code>int or tuple of int</code> <p>Maximum shift between subtomograms and template in nm. ZYX order.</p> <code>(0.8, 0.8, 0.8)</code> <code>rotations</code> <code>((float, float), (float, float), (float, float))</code> <p>Rotation in external degree around each axis.</p> <code>((0.0, 0.0), (0.0, 0.0), (0.0, 0.0))</code> <code>cutoff</code> <code>float</code> <p>Cutoff frequency of low-pass filter applied in each subtomogram.</p> <code>0.5</code> <code>interpolation</code> <code>int</code> <p>Interpolation order.</p> <code>3</code> <code>bin_size</code> <code>int</code> <p>Bin size of multiscale image to be used. Set to &gt;1 to boost performance.</p> <code>1</code> <code>upsample_factor</code> <code>int</code> <p>Upsampling factor of ZNCC landscape. Be careful not to set this parameter too large.  Calculation will take much longer for larger <code>upsample_factor</code>.</p> <code>5</code> <code>method</code> <code>str</code> <p>Correlation metrics for alignment.</p> <code>'zncc'</code> <code>norm</code> <code>bool</code> <p>If true, each landscape will be normalized by its mean and standard deviation.</p> <code>True</code> Source code in <code>cylindra/widgets/sta.py</code> <pre><code>@set_design(text=capitalize, location=LandscapeMenu)\n@dask_worker.with_progress(descs=_pdesc.construct_landscape_fmt)\ndef construct_landscape(\n    self,\n    layer: MoleculesLayerType,\n    template_path: Annotated[_PathOrPathsOrNone, {\"bind\": _template_params}],\n    mask_params: Annotated[Any, {\"bind\": _get_mask_params}] = None,\n    max_shifts: _MaxShifts = (0.8, 0.8, 0.8),\n    rotations: _Rotations = ((0.0, 0.0), (0.0, 0.0), (0.0, 0.0)),\n    cutoff: _CutoffFreq = 0.5,\n    interpolation: Annotated[int, {\"choices\": INTERPOLATION_CHOICES}] = 3,\n    bin_size: Annotated[int, {\"choices\": _get_available_binsize}] = 1,\n    upsample_factor: Annotated[int, {\"min\": 1, \"max\": 20}] = 5,\n    method: Annotated[str, {\"choices\": METHOD_CHOICES}] = \"zncc\",\n    norm: bool = True,\n):\n    \"\"\"Construct a cross-correlation landscape for subtomogram alignment.\n\n    Parameters\n    ----------\n    {layer}{template_path}{mask_params}{max_shifts}{rotations}{cutoff}\n    {interpolation}{bin_size}{upsample_factor}{method}\n    norm: bool, default True\n        If true, each landscape will be normalized by its mean and standard\n        deviation.\n    \"\"\"\n    layer = assert_layer(layer, self.parent_viewer)\n    lnd, _ = self._construct_landscape(\n        molecules=layer.molecules, template_path=template_path,\n        mask_params=mask_params, max_shifts=max_shifts, rotations=rotations,\n        cutoff=cutoff, order=interpolation, bin_size=bin_size, norm=norm,\n        upsample_factor=upsample_factor, method=method,\n    )  # fmt: skip\n    surf = LandscapeSurface(lnd, name=f\"{LANDSCAPE_PREFIX}{layer.name}\")\n    surf.source_component = layer.source_component\n\n    @thread_worker.callback\n    def _on_return():\n        self.parent_viewer.add_layer(surf)\n        self._get_main()._reserved_layers.to_be_removed.add(surf)\n        layer.visible = False\n\n    return _on_return\n</code></pre>"},{"location":"api/widgets/sta/#cylindra.widgets.sta.SubtomogramAveraging.extract_subtomograms","title":"<code>extract_subtomograms(layers, size=None, interpolation=1, bin_size=1, compute=False)</code>","text":"<p>Extract subtomograms around molecules in the selected layer(s).</p> <p>Extracted 3D images will be sent to the sub-viewer. Note that this extraction operation is NOT needed for subsequent averaging/alignment operations, as they internally extract subtomograms by themselves.</p> <p>Parameters:</p> Name Type Description Default <code>layers</code> <code>list of MoleculesLayer</code> <p>All the points layers of molecules to be used.</p> required <code>size</code> <code>nm</code> <p>Size of the template in nm. Use the size of template image by default.</p> <code>None</code> <code>interpolation</code> <code>int</code> <p>Interpolation order.</p> <code>1</code> <code>bin_size</code> <code>int</code> <p>Bin size of multiscale image to be used. Set to &gt;1 to boost performance.</p> <code>1</code> <code>compute</code> <code>bool</code> <p>If True, the subtomograms will be computed immediately, and in-memory data will be sent to the sub-viewer.</p> <code>False</code> Source code in <code>cylindra/widgets/sta.py</code> <pre><code>@set_design(text=\"Extract subtomograms\", location=Averaging)\n@dask_worker.with_progress(desc=_pdesc.fmt_layers(\"Extract subtomograms of {!r}\"))\ndef extract_subtomograms(\n    self,\n    layers: MoleculesLayersType,\n    size: _SubVolumeSize = None,\n    interpolation: Annotated[int, {\"choices\": INTERPOLATION_CHOICES}] = 1,\n    bin_size: Annotated[int, {\"choices\": _get_available_binsize}] = 1,\n    compute: bool = False,\n):\n    \"\"\"Extract subtomograms around molecules in the selected layer(s).\n\n    Extracted 3D images will be sent to the sub-viewer. Note that this extraction\n    operation is NOT needed for subsequent averaging/alignment operations, as they\n    internally extract subtomograms by themselves.\n\n    Parameters\n    ----------\n    {layers}{size}{interpolation}{bin_size}\n    compute : bool, default: False\n        If True, the subtomograms will be computed immediately, and in-memory data\n        will be sent to the sub-viewer.\n    \"\"\"\n    layers = assert_list_of_layers(layers, self.parent_viewer)\n    parent = self._get_main()\n    tomo = parent.tomogram\n    shape = self._get_shape_in_nm(size)\n    loader = tomo.get_subtomogram_loader(\n        _concat_molecules(layers), shape, binsize=bin_size, order=interpolation\n    )\n    subtomos = ip.lazy.asarray(loader.construct_dask(), axes=\"pzyx\")\n    if compute:\n        subtomos = subtomos.compute()\n    return self._show_rec.with_args(\n        subtomos, f\"[Subtomos]{_avg_name(layers)}\", store=False\n    )\n</code></pre>"},{"location":"api/widgets/sta/#cylindra.widgets.sta.SubtomogramAveraging.fit_spline_rfa","title":"<code>fit_spline_rfa(spline, template_path, forward_is='MinusToPlus', interval='4.1', err_max=0.5, mask_params=None, max_shifts=(2.0, 2.0, 2.0), rotations=((0.0, 0.0), (15.0, 5.0), (0.0, 0.0)), cutoff=0.5, interpolation=3, range_long=(4.0, 4.28), angle_max=5.0, bin_size=1, temperature_time_const=10.0, upsample_factor=5, random_seeds=(0, 1, 2, 3, 4))</code>","text":"<p>Fit spline by RFA.</p> <p>This algorithm uses a template image to precisely determine the center line of filaments. By comparing the score, the orientation of the filament will also be determined.</p> <p>Parameters:</p> Name Type Description Default <code>spline</code> <code>int</code> <p>Index of splines to be used.</p> required <code>template_path</code> <code>Path or str</code> <p>Path to template image.</p> required <code>forward_is</code> <code>PlusToMinus or MinusToPlus</code> <p>Which orientation is the forward direction. Set \"PlusToMinus\" if the template image is oriented from the plus end to the minus end in the y direction.</p> <code>\"MinusToPlus\"</code> <code>interval</code> <code>float or str expression</code> <p>Interval of the sampling points along the spline.</p> <code>4.1</code> <code>err_max</code> <code>float</code> <p>S.D. allowed for spline fitting. Larger value will result in smoother spline, i.e. fewer spline knots.</p> <code>0.5</code> <code>mask_params</code> <code>str or (float, float)</code> <p>Mask image path or dilation/Gaussian blur parameters. If a path is given, image must in the same shape as the template.</p> <code>None</code> <code>max_shifts</code> <code>int or tuple of int</code> <p>Maximum shift between subtomograms and template in nm. ZYX order.</p> <code>(2.0, 2.0, 2.0)</code> <code>rotations</code> <code>((float, float), (float, float), (float, float))</code> <p>Rotation in external degree around each axis.</p> <code>((0.0, 0.0), (15.0, 5.0), (0.0, 0.0))</code> <code>cutoff</code> <code>float</code> <p>Cutoff frequency of low-pass filter applied in each subtomogram.</p> <code>0.5</code> <code>interpolation</code> <code>int</code> <p>Interpolation order.</p> <code>3</code> <code>range_long</code> <code>(float, float)</code> <p>Minimum and maximum allowed distances between longitudinally consecutive monomers</p> <code>(4.0, 4.28)</code> <code>angle_max</code> <code>float</code> <p>Maximum allowed angle between longitudinally consecutive monomers and the Y axis.</p> <code>5.0</code> <code>bin_size</code> <code>int</code> <p>Bin size of multiscale image to be used. Set to &gt;1 to boost performance.</p> <code>1</code> <code>temperature_time_const</code> <code>float</code> <p>Time constant of the temperature decay during annealing. Larger value results in slower annealing. 1.0 is a moderate value.</p> <code>10.0</code> <code>upsample_factor</code> <code>int</code> <p>Upsampling factor of ZNCC landscape. Be careful not to set this parameter too large.  Calculation will take much longer for larger <code>upsample_factor</code>.</p> <code>5</code> <code>random_seeds</code> <code>iterable of int</code> <p>Random seed integers. Number of integers will be the number of trials.</p> <code>(0, 1, 2, 3, 4)</code> Source code in <code>cylindra/widgets/sta.py</code> <pre><code>@set_design(text=\"Fit spline by RFA\", location=Alignment)\n@dask_worker.with_progress(descs=_pdesc.fit_spline_rfa_fmt)\ndef fit_spline_rfa(\n    self,\n    spline: Annotated[int, {\"choices\": _get_splines}],\n    template_path: Annotated[_PathOrPathsOrNone, {\"bind\": _template_params}],\n    forward_is: Literal[\"PlusToMinus\", \"MinusToPlus\"] = \"MinusToPlus\",\n    interval: PolarsExprStrOrScalar = \"4.1\",\n    err_max: Annotated[nm, {\"label\": \"Max fit error (nm)\", \"step\": 0.1}] = 0.5,\n    mask_params: Annotated[Any, {\"bind\": _get_mask_params}] = None,\n    max_shifts: _MaxShifts = (2.0, 2.0, 2.0),\n    rotations: _Rotations = ((0.0, 0.0), (15.0, 5.0), (0.0, 0.0)),\n    cutoff: _CutoffFreq = 0.5,\n    interpolation: Annotated[int, {\"choices\": INTERPOLATION_CHOICES}] = 3,\n    range_long: _DistRangeLon = (4.0, 4.28),\n    angle_max: _AngleMaxLon = 5.0,\n    bin_size: Annotated[int, {\"choices\": _get_available_binsize}] = 1,\n    temperature_time_const: Annotated[float, {\"min\": 0.01, \"max\": 100.0}] = 10.0,\n    upsample_factor: Annotated[int, {\"min\": 1, \"max\": 20}] = 5,\n    random_seeds: _RandomSeeds = (0, 1, 2, 3, 4),\n):\n    \"\"\"Fit spline by RFA.\n\n    This algorithm uses a template image to precisely determine the center line of\n    filaments. By comparing the score, the orientation of the filament will also be\n    determined.\n\n    Parameters\n    ----------\n    {spline}{template_path}\n    forward_is : \"PlusToMinus\" or \"MinusToPlus\", default \"MinusToPlus\"\n        Which orientation is the forward direction. Set \"PlusToMinus\" if the\n        template image is oriented from the plus end to the minus end in the y\n        direction.\n    interval : float or str expression, default 4.1\n        Interval of the sampling points along the spline.\n    {err_max}{mask_params}{max_shifts}{rotations}{cutoff}{interpolation}{range_long}\n    {angle_max}{bin_size}{temperature_time_const}{upsample_factor}{random_seeds}\n    \"\"\"\n    t0 = timer()\n    main = self._get_main()\n    tomo = main.tomogram\n    spl_old = tomo.splines[spline]\n    interv_expr = widget_utils.norm_scalar_expr(interval)\n    mole_fw = tomo.map_centers(\n        i=spline,\n        interval=spl_old.props.get_glob(interv_expr),\n        rotate_molecules=False,\n    )\n    mole_rv = mole_fw.rotate_by_rotvec([np.pi, 0, 0])  # invert\n\n    @thread_worker.callback\n    def _on_yield(results):\n        with _Logger.set_plt():\n            _annealing.plot_annealing_result(results)\n\n    def _construct_landscape(mole_):\n        landscape_, _ = self._construct_landscape(\n            molecules=mole_, template_path=template_path, mask_params=mask_params,\n            max_shifts=max_shifts, rotations=rotations, cutoff=cutoff, norm=False,\n            order=interpolation, bin_size=bin_size, upsample_factor=upsample_factor,\n        )  # fmt: skip\n        yield\n        mole, results = landscape_.run_filamentous_annealing(\n            range=range_long,\n            angle_max=angle_max,\n            temperature_time_const=temperature_time_const,\n            random_seeds=random_seeds,\n        )\n        yield _on_yield.with_args(results)\n        return mole, results\n\n    mole_opt_fw, results_fw = yield from _construct_landscape(mole_fw)\n    mole_opt_rv, results_rv = yield from _construct_landscape(mole_rv)\n\n    if results_fw[0].energies[-1] &lt; results_rv[0].energies[-1]:  # forward is better\n        mole_opt = mole_opt_fw\n        ori = Ori(forward_is)\n    else:  # reverse is better\n        mole_opt = mole_opt_rv\n        ori = Ori.invert(Ori(forward_is))\n\n    # calculate distances for logging\n    _ds = np.diff(mole_opt.pos, axis=0)\n    _dist: NDArray[np.float32] = np.sqrt(np.sum(_ds**2, axis=1))\n\n    spl_new = CylSpline(\n        order=spl_old.order,\n        config=spl_old.config,\n        extrapolate=spl_old.extrapolate,\n    ).fit(mole_opt.pos, err_max=err_max)\n    spl_new.props.loc = spl_old.props.loc\n    spl_new.props.glob = spl_old.props.glob\n    spl_new.orientation = ori\n    tomo.splines[spline] = spl_new\n    t0.toc()\n\n    @thread_worker.callback\n    def _on_return():\n        main._update_splines_in_images()\n        _Logger.print(f\"Orientation: {ori.value}\")\n        _Logger.print(\n            f\"Distance: mean = {_dist.mean():.3f} nm (ranging from \"\n            f\"{_dist.min():.3f} to {_dist.max():.3f}) nm \"\n        )\n        main.reset_choices()\n\n        @undo_callback\n        def _out():\n            tomo.splines[spline] = spl_old\n            main._update_splines_in_images()\n\n        @_out.with_redo\n        def _out():\n            tomo.splines[spline] = spl_new\n            main._update_splines_in_images()\n\n        return _out\n\n    return _on_return\n</code></pre>"},{"location":"api/widgets/sta/#cylindra.widgets.sta.SubtomogramAveraging.get_mask","title":"<code>get_mask(mask_params, scale=None, template_path=None)</code>","text":"<p>A non-GUI method to get the mask.</p> Source code in <code>cylindra/widgets/sta.py</code> <pre><code>@nogui\n@do_not_record\ndef get_mask(\n    self,\n    mask_params: Any,\n    scale: float | None = None,\n    template_path: str | Path | None = None,\n) -&gt; ip.ImgArray:\n    \"\"\"A non-GUI method to get the mask.\"\"\"\n    if scale is None:\n        scale = self._get_main().tomogram.scale\n    if isinstance(mask_params, tuple):\n        if template_path is None:\n            raise ValueError(\"Template path is required when using soft-Otsu mask.\")\n        template = self.params._norm_template_param(template_path).provide(scale)\n        radius, sigma = mask_params\n        mask = pipe.soft_otsu(radius=radius, sigma=sigma).convert(template, scale)\n    elif isinstance(mask_params, (str, Path)):\n        mask = pipe.from_file(mask_params).provide(scale)\n    else:\n        raise TypeError(\n            f\"Cannot create mask image using parameter: {mask_params!r}\"\n        )\n    return ip.asarray(mask, axes=\"zyx\").set_scale(zyx=scale)\n</code></pre>"},{"location":"api/widgets/sta/#cylindra.widgets.sta.SubtomogramAveraging.get_subtomograms","title":"<code>get_subtomograms(layers, shape, bin_size=1, order=3)</code>","text":"<p>A non-GUI method to get all the subtomograms as a dask array.</p> <p>Parameters:</p> Name Type Description Default <code>layers</code> <code>str, MoleculesLayer or list of them</code> <p>All the layers that will be used to construct the subtomogram array.</p> required <code>shape</code> <code>(nm, nm, nm)</code> <p>Shape of output subtomograms.</p> required <code>bin_size</code> <code>(int, default)</code> <p>Bin size of the subtomograms.</p> <code>1</code> <code>order</code> <code>int</code> <p>Interpolation order.</p> <code>3</code> <p>Returns:</p> Type Description <code>Array</code> <p>4D Dask array.</p> Source code in <code>cylindra/widgets/sta.py</code> <pre><code>@nogui\n@do_not_record\ndef get_subtomograms(\n    self,\n    layers: str | MoleculesLayer | list[str | MoleculesLayer],\n    shape: tuple[nm, nm, nm],\n    bin_size: int = 1,\n    order: int = 3,\n) -&gt; \"Array\":\n    \"\"\"A non-GUI method to get all the subtomograms as a dask array.\n\n    Parameters\n    ----------\n    layers : str, MoleculesLayer or list of them\n        All the layers that will be used to construct the subtomogram array.\n    shape : (nm, nm, nm)\n        Shape of output subtomograms.\n    bin_size : int, default\n        Bin size of the subtomograms.\n    order : int, default 3\n        Interpolation order.\n\n    Returns\n    -------\n    Array\n        4D Dask array.\n    \"\"\"\n    layers = assert_list_of_layers(layers, self.parent_viewer)\n    parent = self._get_main()\n    tomo = parent.tomogram\n    loader = tomo.get_subtomogram_loader(\n        _concat_molecules(layers), shape, binsize=bin_size, order=order\n    )\n    return loader.construct_dask()\n</code></pre>"},{"location":"api/widgets/sta/#cylindra.widgets.sta.SubtomogramAveraging.get_template","title":"<code>get_template(template_path, scale=None)</code>","text":"<p>A non-GUI method to get the template</p> Source code in <code>cylindra/widgets/sta.py</code> <pre><code>@nogui\n@do_not_record\ndef get_template(\n    self, template_path: str | Path, scale: float | None = None\n) -&gt; ip.ImgArray:\n    \"\"\"A non-GUI method to get the template\"\"\"\n    if scale is None:\n        scale = self._get_main().tomogram.scale\n    img = self.params._norm_template_param(template_path).provide(scale)\n    return ip.asarray(img, axes=\"zyx\").set_scale(zyx=scale)\n</code></pre>"},{"location":"api/widgets/sta/#cylindra.widgets.sta.SubtomogramAveraging.normalize_landscape","title":"<code>normalize_landscape(landscape_layer, norm_sd=True)</code>","text":"<p>Normalize the landscape.</p> <p>Parameters:</p> Name Type Description Default <code>landscape_layer</code> <code>LandscapeSurface</code> <p>Landscape layer to be used in this algorithm.</p> required <code>norm_sd</code> <code>bool</code> <p>If true, each landscape will also be normalized by its standard deviation.</p> <code>True</code> Source code in <code>cylindra/widgets/sta.py</code> <pre><code>@set_design(text=capitalize, location=LandscapeMenu)\ndef normalize_landscape(\n    self,\n    landscape_layer: _LandscapeLayer,\n    norm_sd: bool = True,\n):\n    \"\"\"Normalize the landscape.\n\n    Parameters\n    ----------\n    {landscape_layer}\n    norm_sd : bool, default True\n        If true, each landscape will also be normalized by its standard deviation.\n    \"\"\"\n    landscape_layer = _assert_landscape_layer(landscape_layer, self.parent_viewer)\n    new = landscape_layer.landscape.normed(sd=norm_sd)\n    surf = LandscapeSurface(new, name=f\"{landscape_layer}-Norm\")\n    return self._add_new_landscape_layer(landscape_layer, surf)\n</code></pre>"},{"location":"api/widgets/sta/#cylindra.widgets.sta.SubtomogramAveraging.remove_landscape_outliers","title":"<code>remove_landscape_outliers(landscape_layer, lower=None, upper=None)</code>","text":"<p>Remove outliers from the landscape.</p> <p>This method will replace energy (inverse score) outliers with the thresholds. This method is useful for lattice with such as defects or strong artifacts.</p> <p>Parameters:</p> Name Type Description Default <code>landscape_layer</code> <code>LandscapeSurface</code> <p>Landscape layer to be used in this algorithm.</p> required <code>lower</code> <code>float</code> <p>Lower limit of the energy.</p> <code>None</code> <code>upper</code> <code>float</code> <p>Upper limit of the energy.</p> <code>None</code> Source code in <code>cylindra/widgets/sta.py</code> <pre><code>@set_design(text=capitalize, location=LandscapeMenu)\ndef remove_landscape_outliers(\n    self,\n    landscape_layer: _LandscapeLayer,\n    lower: Annotated[Optional[float], {\"text\": \"Do not process lower outliers\"}] = None,\n    upper: Annotated[Optional[float], {\"text\": \"Do not process upper outliers\"}] = None,\n):  # fmt: skip\n    \"\"\"Remove outliers from the landscape.\n\n    This method will replace energy (inverse score) outliers with the thresholds.\n    This method is useful for lattice with such as defects or strong artifacts.\n\n    Parameters\n    ----------\n    {landscape_layer}\n    lower : float, optional\n        Lower limit of the energy.\n    upper : float, optional\n        Upper limit of the energy.\n    \"\"\"\n    landscape_layer = _assert_landscape_layer(landscape_layer, self.parent_viewer)\n    new = landscape_layer.landscape.clip_energies(lower, upper)\n    surf = LandscapeSurface(new, name=f\"{landscape_layer}-Clip\")\n    return self._add_new_landscape_layer(landscape_layer, surf)\n</code></pre>"},{"location":"api/widgets/sta/#cylindra.widgets.sta.SubtomogramAveraging.run_align_on_landscape","title":"<code>run_align_on_landscape(landscape_layer)</code>","text":"<p>Find the optimal displacement for each molecule on the landscape.</p> Source code in <code>cylindra/widgets/sta.py</code> <pre><code>@set_design(text=\"Run alignment\", location=LandscapeMenu)\n@dask_worker.with_progress(desc=\"Peak detection on landscape\")\ndef run_align_on_landscape(self, landscape_layer: _LandscapeLayer):\n    \"\"\"Find the optimal displacement for each molecule on the landscape.\"\"\"\n    landscape_layer = _assert_landscape_layer(landscape_layer, self.parent_viewer)\n    landscape = landscape_layer.landscape\n    spl = landscape_layer.source_spline\n    mole_opt, _ = landscape.run_min_energy(spl)\n    return self._align_on_landscape_on_return.with_args(\n        mole_opt, landscape_layer.name, spl\n    )\n</code></pre>"},{"location":"api/widgets/sta/#cylindra.widgets.sta.SubtomogramAveraging.run_rfa_on_landscape","title":"<code>run_rfa_on_landscape(landscape_layer, range_long=(4.0, 4.28), angle_max=5.0, temperature_time_const=1.0, random_seeds=(0, 1, 2, 3, 4))</code>","text":"<p>Run simulated annealing on the landscape, supposing a filamentous structure.</p> <p>Parameters:</p> Name Type Description Default <code>landscape_layer</code> <code>LandscapeSurface</code> <p>Landscape layer to be used in this algorithm.</p> required <code>range_long</code> <code>(float, float)</code> <p>Minimum and maximum allowed distances between longitudinally consecutive monomers</p> <code>(4.0, 4.28)</code> <code>angle_max</code> <code>float</code> <p>Maximum allowed angle between longitudinally consecutive monomers and the Y axis.</p> <code>5.0</code> <code>temperature_time_const</code> <code>float</code> <p>Time constant of the temperature decay during annealing. Larger value results in slower annealing. 1.0 is a moderate value.</p> <code>1.0</code> <code>random_seeds</code> <code>iterable of int</code> <p>Random seed integers. Number of integers will be the number of trials.</p> <code>(0, 1, 2, 3, 4)</code> Source code in <code>cylindra/widgets/sta.py</code> <pre><code>@set_design(text=\"Run annealing (RFA)\", location=LandscapeMenu)\n@dask_worker.with_progress(desc=\"Running simulated annealing\")\ndef run_rfa_on_landscape(\n    self,\n    landscape_layer: _LandscapeLayer,\n    range_long: _DistRangeLon = (4.0, 4.28),\n    angle_max: _AngleMaxLon = 5.0,\n    temperature_time_const: Annotated[float, {\"min\": 0.01, \"max\": 10.0}] = 1.0,\n    random_seeds: _RandomSeeds = (0, 1, 2, 3, 4),\n):\n    \"\"\"Run simulated annealing on the landscape, supposing a filamentous structure.\n\n    Parameters\n    ----------\n    {landscape_layer}{range_long}{angle_max}{temperature_time_const}{random_seeds}\n    \"\"\"\n    t0 = timer()\n    landscape_layer = _assert_landscape_layer(landscape_layer, self.parent_viewer)\n    mole, results = landscape_layer.landscape.run_filamentous_annealing(\n        range=range_long,\n        angle_max=angle_max,\n        temperature_time_const=temperature_time_const,\n        random_seeds=random_seeds,\n    )\n    t0.toc()\n\n    @thread_worker.callback\n    def _plot_result():\n        with _Logger.set_plt():\n            _annealing.plot_annealing_result(results)\n\n    yield _plot_result\n    return self._align_on_landscape_on_return.with_args(\n        mole,\n        landscape_layer.name,\n        source=landscape_layer.source_spline,\n        metadata={ANNEALING_RESULT: results[0]},\n    )\n</code></pre>"},{"location":"api/widgets/sta/#cylindra.widgets.sta.SubtomogramAveraging.run_rma_on_landscape","title":"<code>run_rma_on_landscape(landscape_layer, range_long=(4.0, 4.28), range_lat=(5.1, 5.3), angle_max=5.0, temperature_time_const=1.0, random_seeds=(0, 1, 2, 3, 4))</code>","text":"<p>Run simulated annealing on the landscape, supposing a cylindric structure.</p> <p>Parameters:</p> Name Type Description Default <code>landscape_layer</code> <code>LandscapeSurface</code> <p>Landscape layer to be used in this algorithm.</p> required <code>range_long</code> <code>(float, float)</code> <p>Minimum and maximum allowed distances between longitudinally consecutive monomers</p> <code>(4.0, 4.28)</code> <code>range_lat</code> <code>(float, float)</code> <p>Minimum and maximum allowed distances between laterally consecutive monomers</p> <code>(5.1, 5.3)</code> <code>angle_max</code> <code>float</code> <p>Maximum allowed angle between longitudinally consecutive monomers and the Y axis.</p> <code>5.0</code> <code>temperature_time_const</code> <code>float</code> <p>Time constant of the temperature decay during annealing. Larger value results in slower annealing. 1.0 is a moderate value.</p> <code>1.0</code> <code>random_seeds</code> <code>iterable of int</code> <p>Random seed integers. Number of integers will be the number of trials.</p> <code>(0, 1, 2, 3, 4)</code> Source code in <code>cylindra/widgets/sta.py</code> <pre><code>@set_design(text=\"Run annealing (RMA)\", location=LandscapeMenu)\n@dask_worker.with_progress(desc=\"Running simulated annealing\")\ndef run_rma_on_landscape(\n    self,\n    landscape_layer: _LandscapeLayer,\n    range_long: _DistRangeLon = (4.0, 4.28),\n    range_lat: _DistRangeLat = (5.1, 5.3),\n    angle_max: _AngleMaxLon = 5.0,\n    temperature_time_const: Annotated[float, {\"min\": 0.01, \"max\": 10.0}] = 1.0,\n    random_seeds: _RandomSeeds = (0, 1, 2, 3, 4),\n):\n    \"\"\"Run simulated annealing on the landscape, supposing a cylindric structure.\n\n    Parameters\n    ----------\n    {landscape_layer}{range_long}{range_lat}{angle_max}{temperature_time_const}\n    {random_seeds}\n    \"\"\"\n    t0 = timer()\n    landscape_layer = _assert_landscape_layer(landscape_layer, self.parent_viewer)\n    spl = landscape_layer.source_spline\n    if spl is None:\n        raise ValueError(\"RMA requires a spline.\")\n    mole, results = landscape_layer.landscape.run_annealing_along_spline(\n        spl=spl,\n        range_long=range_long,\n        range_lat=range_lat,\n        angle_max=angle_max,\n        temperature_time_const=temperature_time_const,\n        random_seeds=random_seeds,\n    )\n    t0.toc()\n\n    @thread_worker.callback\n    def _plot_result():\n        with _Logger.set_plt():\n            _annealing.plot_annealing_result(results)\n\n    yield _plot_result\n    return self._align_on_landscape_on_return.with_args(\n        mole,\n        landscape_layer.name,\n        source=spl,\n        metadata={ANNEALING_RESULT: results[0]},\n    )\n</code></pre>"},{"location":"api/widgets/sta/#cylindra.widgets.sta.SubtomogramAveraging.run_viterbi_on_landscape","title":"<code>run_viterbi_on_landscape(landscape_layer, range_long=(4.0, 4.28), angle_max=5.0)</code>","text":"<p>Run Viterbi alignment on the landscape.</p> <p>Parameters:</p> Name Type Description Default <code>landscape_layer</code> <code>LandscapeSurface</code> <p>Landscape layer to be used in this algorithm.</p> required <code>range_long</code> <code>(float, float)</code> <p>Minimum and maximum allowed distances between longitudinally consecutive monomers</p> <code>(4.0, 4.28)</code> <code>angle_max</code> <code>float</code> <p>Maximum allowed angle between longitudinally consecutive monomers and the Y axis.</p> <code>5.0</code> Source code in <code>cylindra/widgets/sta.py</code> <pre><code>@set_design(text=\"Run Viterbi alignment\", location=LandscapeMenu)\n@dask_worker.with_progress(desc=\"Running Viterbi alignment\")\ndef run_viterbi_on_landscape(\n    self,\n    landscape_layer: _LandscapeLayer,\n    range_long: _DistRangeLon = (4.0, 4.28),\n    angle_max: _AngleMaxLon = 5.0,\n):\n    \"\"\"Run Viterbi alignment on the landscape.\n\n    Parameters\n    ----------\n    {landscape_layer}{range_long}{angle_max}\n    \"\"\"\n    t0 = timer()\n    landscape_layer = _assert_landscape_layer(landscape_layer, self.parent_viewer)\n    spl = landscape_layer.source_spline\n    mole = landscape_layer.landscape.run_viterbi_along_spline(\n        spl=spl,\n        range_long=range_long,\n        angle_max=angle_max,\n    )\n    t0.toc()\n    return self._align_on_landscape_on_return.with_args(\n        mole, landscape_layer.name, spl\n    )\n</code></pre>"},{"location":"api/widgets/sta/#cylindra.widgets.sta.SubtomogramAveraging.save_annealing_scores","title":"<code>save_annealing_scores(layer, path)</code>","text":"<p>Save RMA scores to a CSV file.</p> Source code in <code>cylindra/widgets/sta.py</code> <pre><code>@set_design(text=capitalize, location=Alignment)\n@do_not_record\ndef save_annealing_scores(\n    self,\n    layer: Annotated[MoleculesLayer, {\"choices\": _get_layers_with_annealing_result}],\n    path: Path.Save[FileFilter.CSV],\n):  # fmt: skip\n    \"\"\"Save RMA scores to a CSV file.\"\"\"\n    layer = assert_layer(layer, self.parent_viewer)\n    try:\n        result: AnnealingResult = layer.metadata[ANNEALING_RESULT]\n    except KeyError:\n        raise ValueError(\n            f\"Layer {layer!r} does not have annealing result.\"\n        ) from None\n    x = result.batch_size * np.arange(result.energies.size)\n    df = pl.DataFrame({\"iteration\": x, \"score\": -result.energies})\n    return df.write_csv(path, include_header=False)\n</code></pre>"},{"location":"api/widgets/sta/#cylindra.widgets.sta.SubtomogramAveraging.save_last_average","title":"<code>save_last_average(path)</code>","text":"<p>Save the lastly generated average image.</p> Source code in <code>cylindra/widgets/sta.py</code> <pre><code>@set_design(text=\"Save last average\", location=STAnalysis)\ndef save_last_average(self, path: Path.Save[FileFilter.IMAGE]):\n    \"\"\"Save the lastly generated average image.\"\"\"\n    path = Path(path)\n    img = self.last_average\n    if img is None:\n        raise ValueError(\n            \"No average image is available. You have to average subtomograms first.\"\n        )\n    return img.imsave(path)\n</code></pre>"},{"location":"api/widgets/sta/#cylindra.widgets.sta.SubtomogramAveraging.seam_search","title":"<code>seam_search(layer, template_path, mask_params, anti_template_path=None, interpolation=3, npf=None, show_average='Filtered', cutoff=0.25)</code>","text":"<p>Search for the best seam position.</p> <p>Try all patterns of seam positions and compare cross correlation values. If molecule assembly has 13 protofilaments, this method will try 26 patterns.</p> <p>Parameters:</p> Name Type Description Default <code>layer</code> <code>MoleculesLayer</code> <p>Points layer of molecules to be used.</p> required <code>template_path</code> <code>Path or str</code> <p>Path to template image.</p> required <code>mask_params</code> <code>str or (float, float)</code> <p>Mask image path or dilation/Gaussian blur parameters. If a path is given, image must in the same shape as the template.</p> required <code>anti_template_path</code> <code>Path</code> <p>The anti-template used for seam search. For instance, if the template is beta-tubulin, the anti-template is alpha-tubulin.</p> <code>None</code> <code>interpolation</code> <code>int</code> <p>Interpolation order.</p> <code>3</code> <code>npf</code> <code>int</code> <p>Number of protofilaments. By default the global properties stored in the corresponding spline will be used.</p> <code>None</code> <code>show_average</code> <code>bool</code> <p>If true, all the subtomogram averages will be shown.</p> <code>True</code> <code>cutoff</code> <code>float</code> <p>Cutoff frequency of low-pass filter applied in each subtomogram.</p> <code>0.25</code> Source code in <code>cylindra/widgets/sta.py</code> <pre><code>@set_design(text=\"Seam search by correlation\", location=STAnalysis.SeamSearch)\n@dask_worker.with_progress(desc=_pdesc.fmt_layer(\"Seam search of {!r}\"))\ndef seam_search(\n    self,\n    layer: MoleculesLayerType,\n    template_path: Annotated[_PathOrNone, {\"bind\": _template_param}],\n    mask_params: Annotated[Any, {\"bind\": _get_mask_params}],\n    anti_template_path: Annotated[Optional[Path.Read[FileFilter.IMAGE]], {\"text\": \"Do not use anti-template\", \"label\": \"anti-template path\"}] = None,\n    interpolation: Annotated[int, {\"choices\": INTERPOLATION_CHOICES}] = 3,\n    npf: Annotated[Optional[int], {\"text\": \"use global properties\"}] = None,\n    show_average: Annotated[str, {\"label\": \"show averages as\", \"choices\": [None, \"Raw\", \"Filtered\"]}] = \"Filtered\",\n    cutoff: _CutoffFreq = 0.25,\n):  # fmt: skip\n    \"\"\"Search for the best seam position.\n\n    Try all patterns of seam positions and compare cross correlation values. If\n    molecule assembly has 13 protofilaments, this method will try 26 patterns.\n\n    Parameters\n    ----------\n    {layer}{template_path}{mask_params}\n    anti_template_path : Path, optional\n        The anti-template used for seam search. For instance, if the template is\n        beta-tubulin, the anti-template is alpha-tubulin.\n    {interpolation}\n    npf : int, optional\n        Number of protofilaments. By default the global properties stored in the\n        corresponding spline will be used.\n    show_average : bool, default True\n        If true, all the subtomogram averages will be shown.\n    {cutoff}\n    \"\"\"\n    t0 = timer()\n    layer = assert_layer(layer, self.parent_viewer)\n    loader, npf = self._seam_search_input(layer, npf, interpolation)\n    template, mask = loader.normalize_input(\n        template=self.params._norm_template_param(template_path),\n        mask=self.params._get_mask(params=mask_params),\n    )\n    if anti_template_path is not None:\n        anti_template = ip.asarray(\n            pipe.from_file(anti_template_path).provide(loader.scale),\n            axes=\"zyx\",\n        )\n    else:\n        anti_template = None\n\n    seam_searcher = CorrelationSeamSearcher(npf)\n    result = seam_searcher.search(\n        loader=loader,\n        template=ip.asarray(template, axes=\"zyx\"),\n        anti_template=anti_template,\n        mask=mask,\n        cutoff=cutoff,\n    )\n\n    t0.toc()\n\n    @thread_worker.callback\n    def _seam_search_on_return():\n        new_feat = result.as_series(loader.molecules.count())\n        layer.features = layer.molecules.features.with_columns(new_feat)\n        layer.metadata[SEAM_SEARCH_RESULT] = result\n        if show_average is not None:\n            if show_average == \"Filtered\":\n                sigma = 0.25 / loader.scale\n                result.averages.gaussian_filter(sigma=sigma, update=True)\n            _imlayer: Image = self._show_rec(\n                result.averages, layer.name, store=False\n            )\n            _imlayer.metadata[SEAM_SEARCH_RESULT] = result\n\n        # plot all the correlation\n        _Logger.print_html(\"&lt;code&gt;seam_search&lt;/code&gt;\")\n        with _Logger.set_plt():\n            _Logger.print(f\"layer = {layer.name!r}\")\n            _Logger.print(f\"template = {Path(template_path).as_posix()!r}\")\n            if anti_template_path is not None:\n                _Logger.print(\n                    f\"anti_template = {Path(anti_template_path).as_posix()!r}\"\n                )\n            widget_utils.plot_seam_search_result(result.scores, npf)\n\n    return _seam_search_on_return\n</code></pre>"},{"location":"api/widgets/sta/#cylindra.widgets.sta.SubtomogramAveraging.seam_search_by_feature","title":"<code>seam_search_by_feature(layer, by)</code>","text":"<p>Search for seams by a feature.</p> <p>Parameters:</p> Name Type Description Default <code>layer</code> <code>MoleculesLayer</code> <p>Points layer of molecules to be used.</p> required <code>by</code> <code>str</code> <p>Name of the feature that will be used for seam search.</p> required Source code in <code>cylindra/widgets/sta.py</code> <pre><code>@set_design(text=capitalize, location=STAnalysis.SeamSearch)\ndef seam_search_by_feature(\n    self,\n    layer: MoleculesLayerType,\n    by: Annotated[str, {\"choices\": _choice_getter(\"seam_search_by_feature\")}],\n):\n    \"\"\"Search for seams by a feature.\n\n    Parameters\n    ----------\n    {layer}\n    by : str\n        Name of the feature that will be used for seam search.\n    \"\"\"\n    ui = self._get_main()\n    layer = assert_layer(layer, ui.parent_viewer)\n    feat = layer.molecules.features\n    if by not in feat.columns:\n        raise ValueError(f\"Column {by} does not exist.\")\n    npf = utils.roundint(layer.molecules.features[Mole.pf].max() + 1)\n    seam_searcher = BooleanSeamSearcher(npf)\n    result = seam_searcher.search(feat[by])\n    new_feat = result.as_series(feat.shape[0])\n    layer.features = layer.molecules.features.with_columns(new_feat)\n    ui.reset_choices()  # choices regarding of features need update\n    return undo_callback(layer.feature_setter(feat, layer.colormap_info))\n</code></pre>"},{"location":"api/widgets/sta/#cylindra.widgets.sta.SubtomogramAveraging.seam_search_manually","title":"<code>seam_search_manually(layer, location=0)</code>","text":"<p>Search for seams manually.</p> <p>Seam location is represented by a number in the range [0, 2 * npf - 1].</p> <p>Parameters:</p> Name Type Description Default <code>layer</code> <code>MoleculesLayer</code> <p>Points layer of molecules to be used.</p> required <code>location</code> <code>int</code> <p>Seam location.</p> <code>0</code> Source code in <code>cylindra/widgets/sta.py</code> <pre><code>@set_design(text=capitalize, location=STAnalysis.SeamSearch)\ndef seam_search_manually(\n    self,\n    layer: MoleculesLayerType,\n    location: int = 0,\n):\n    \"\"\"Search for seams manually.\n\n    Seam location is represented by a number in the range [0, 2 * npf - 1].\n\n    Parameters\n    ----------\n    {layer}\n    location : int\n        Seam location.\n    \"\"\"\n    ui = self._get_main()\n    layer = assert_layer(layer, ui.parent_viewer)\n    feat = layer.molecules.features\n    npf = utils.roundint(layer.molecules.features[Mole.pf].max() + 1)\n    seam_searcher = ManualSeamSearcher(npf)\n    result = seam_searcher.search(location)\n    new_feat = result.as_series(feat.shape[0])\n    layer.features = layer.molecules.features.with_columns(new_feat)\n    ui.reset_choices()  # choices regarding of features need update\n    return undo_callback(layer.feature_setter(feat, layer.colormap_info))\n</code></pre>"},{"location":"api/widgets/sta/#cylindra.widgets.sta.SubtomogramAveraging.show_mask","title":"<code>show_mask()</code>","text":"<p>Load and show mask image in the scale of the tomogram.</p> Source code in <code>cylindra/widgets/sta.py</code> <pre><code>@set_design(icon=\"fluent:shape-organic-20-filled\", location=STATools)\n@do_not_record\ndef show_mask(self):\n    \"\"\"Load and show mask image in the scale of the tomogram.\"\"\"\n    mask = self._get_mask_image(self._template_params())\n    self._show_rec(mask, name=\"Mask image\", store=False, threshold=0.5)\n</code></pre>"},{"location":"api/widgets/sta/#cylindra.widgets.sta.SubtomogramAveraging.show_template","title":"<code>show_template()</code>","text":"<p>Load and show template image in the scale of the tomogram.</p> Source code in <code>cylindra/widgets/sta.py</code> <pre><code>@set_design(icon=\"ic:baseline-view-in-ar\", location=STATools)\n@do_not_record\ndef show_template(self):\n    \"\"\"Load and show template image in the scale of the tomogram.\"\"\"\n    template = self._get_template_image()\n    self._show_rec(template, name=\"Template image\", store=False)\n</code></pre>"},{"location":"api/widgets/sta/#cylindra.widgets.sta.SubtomogramAveraging.show_template_original","title":"<code>show_template_original()</code>","text":"<p>Load and show template image in the original scale.</p> Source code in <code>cylindra/widgets/sta.py</code> <pre><code>@set_design(icon=\"material-symbols:view-in-ar\", location=STATools)\n@do_not_record\ndef show_template_original(self):\n    \"\"\"Load and show template image in the original scale.\"\"\"\n    _input = self._template_params()\n    if _input is None:\n        raise ValueError(\"No template path provided.\")\n    elif isinstance(_input, Path):\n        self._show_rec(ip.imread(_input), name=\"Template image\", store=False)\n    else:\n        for i, fp in enumerate(_input):\n            img = ip.imread(fp)\n            self._show_rec(img, name=f\"Template image [{i}]\", store=False)\n</code></pre>"},{"location":"api/widgets/subwidgets/","title":"cylindra.widgets.subwidgets","text":""},{"location":"api/widgets/subwidgets/#simulator","title":"Simulator","text":"<p>Methods are available in the namespace <code>ui.simulator</code>.</p> Source code in <code>cylindra/widgets/subwidgets/simulator.py</code> <pre><code>@magicclass(use_native_menubar=False)\nclass Simulator(ChildWidget):\n    @magicmenu(name=\"Create\")\n    class CreateMenu(ChildWidget):\n        create_empty_image = abstractapi()\n        create_straight_line = abstractapi()\n        create_image_with_straight_line = abstractapi()\n\n    @magicmenu(name=\"Simulate\")\n    class SimulateMenu(ChildWidget):\n        simulate_tomogram = abstractapi()\n        simulate_tomogram_from_tilt_series = abstractapi()\n        simulate_tomogram_and_open = abstractapi()\n        simulate_tilt_series = abstractapi()\n\n    @magictoolbar\n    class SimulatorTools(ChildWidget):\n        add_component = abstractapi()\n        sep0 = Separator\n        generate_molecules = abstractapi()\n        expand = abstractapi()\n        twist = abstractapi()\n        dilate = abstractapi()\n        displace = abstractapi()\n\n    component_list = field(ComponentList, name=\"components\")\n\n    def _prep_radon(\n        self,\n        components: list[tuple[str, Path]],\n        degrees: NDArray[np.floating],\n        order: int = 3,\n    ) -&gt; ip.ImgArray:\n        # noise-free tomogram generation from the current cylinder model\n        main = self._get_main()\n        tomo = main.tomogram\n        scale = tomo.scale\n        shape = tomo.image.shape\n        simulator = TomogramSimulator(order=order, scale=scale)\n        for layer_name, temp_path in components:\n            mole = main.mole_layers[layer_name].molecules\n            simulator.add_molecules(mole, pipe.from_file(temp_path))\n        tilt_series = simulator.simulate_tilt_series(degrees=degrees, shape=shape)\n        tilt_series = ip.asarray(\n            tilt_series, axes=[\"degree\", \"y\", \"x\"], name=\"Simulated\"\n        )\n        return tilt_series.set_scale(y=scale, x=scale)\n\n    def _get_proper_molecules_layers(self, *_):\n        out = list[MoleculesLayer]()\n        for layer in self._get_main().mole_layers:\n            if layer.source_spline is None:\n                continue\n            mole = layer.molecules\n            cols = mole.features.columns\n            if Mole.nth in cols and Mole.pf in cols and mole.count() &gt; 0:\n                out.append(layer)\n        return out\n\n    _ModeledMoleculesLayer = Annotated[\n        MoleculesLayer,\n        {\"choices\": _get_proper_molecules_layers, \"validator\": _as_layer_name},\n    ]\n\n    @set_design(icon=\"fluent:cloud-add-16-filled\", location=SimulatorTools)\n    @do_not_record\n    def add_component(\n        self,\n        layer: MoleculesLayerType,\n        template_path: Path.Read[FileFilter.IMAGE],\n    ):\n        \"\"\"Add a set of template and a molecules as a simulation component.\n\n        A component defines which molecules corresponds to what template image.\n        Multiple components can be added to simulate a tomogram with different\n        materials.\n\n        Parameters\n        ----------\n        layer : MoleculesLayer\n            Layer to be used for simulation.\n        template_path : Path\n            Path to the template image that will be used to simulate the\n            corresponding molecules layer.\n        \"\"\"\n        layer = assert_layer(layer, self.parent_viewer)\n        self.component_list.append(Component(template_path, layer))\n        self.component_list._on_children_change()\n\n    @set_design(text=capitalize, location=CreateMenu)\n    @thread_worker.with_progress(desc=\"Creating an image\")\n    @confirm(\n        text=\"You have an opened image. Run anyway?\",\n        condition=\"not self._get_main().tomogram.is_dummy\",\n    )\n    def create_empty_image(\n        self,\n        size: _ImageSize = (60.0, 200.0, 60.0),\n        scale: Annotated[nm, {\"label\": \"pixel scale (nm/pixel)\"}] = 0.25,\n    ):  # fmt: skip\n        \"\"\"Create an empty image with the given size and scale, and send it to the viewer.\n\n        Parameters\n        ----------\n        size : (nm, nm, nm), default (60., 200., 60.)\n            Size of the image in nm, of (Z, Y, X).\n        scale : nm, default 0.25\n            Pixel size of the image.\n        \"\"\"\n        main = self._get_main()\n        shape = tuple(roundint(s / scale) for s in size)\n\n        binsize = ceilint(0.96 / scale)\n        # NOTE: zero-filled image breaks contrast limit calculation, and bad for\n        # visual detection of the image edges.\n        tomo = CylTomogram.dummy(scale=scale, binsize=binsize, shape=shape)\n        main._init_macro_state()\n\n        @thread_worker.callback\n        def _out():\n            main._send_tomogram_to_viewer(tomo)\n            main._reserved_layers.image.bounding_box.visible = True\n\n        return _out\n\n    @set_design(text=capitalize, location=CreateMenu)\n    def create_straight_line(self, start: _Point3D, end: _Point3D):\n        \"\"\"Create a straight line as a spline.\n\n        Parameters\n        ----------\n        start : (nm, nm, nm)\n            Start point of the line.\n        end : (nm, nm, nm)\n            End point of the line.\n        \"\"\"\n        spl = CylSpline.line(start, end)\n        main = self._get_main()\n        main.tomogram.splines.append(spl)\n        main._add_spline_instance(spl)\n        return undo_callback(main.delete_spline).with_args(-1)\n\n    @set_design(text=capitalize, location=CreateMenu)\n    @thread_worker.with_progress(desc=\"Creating an image\")\n    @confirm(\n        text=\"You have an opened image. Run anyway?\",\n        condition=\"not self._get_main().tomogram.is_dummy\",\n    )\n    def create_image_with_straight_line(\n        self,\n        length: nm = 150.0,\n        size: _ImageSize = (60.0, 200.0, 60.0),\n        scale: Annotated[nm, {\"label\": \"pixel scale (nm/pixel)\"}] = 0.25,\n        yxrotation: Annotated[float, {\"max\": 90, \"step\": 1, \"label\": \"Rotation in YX plane (deg)\"}] = 0.0,\n        zxrotation: Annotated[float, {\"max\": 90, \"step\": 1, \"label\": \"Rotation in ZX plane (deg)\"}] = 0.0,\n    ):  # fmt: skip\n        \"\"\"Create a straight line as a cylinder spline.\n\n        Parameters\n        ----------\n        length : nm, default 150.0\n            Length if the straight line in nm.\n        size : (nm, nm, nm), (60.0, 200.0, 60.0)\n            Size of the tomogram in which the spline will reside.\n        scale : nm, default 0.25\n            Scale of pixel in nm/pixel.\n        yxrotation : float, optional\n            Rotation in YX plane. This rotation will be applied before ZX rotation.\n        zxrotation : float, optional\n            Rotation in ZX plane. This rotation will be applied before YX rotation.\n        \"\"\"\n        yxrot = Rotation.from_rotvec([np.deg2rad(yxrotation), 0.0, 0.0])\n        zxrot = Rotation.from_rotvec([0.0, 0.0, np.deg2rad(zxrotation)])\n        start_shift = zxrot.apply(yxrot.apply(np.array([0.0, -length / 2, 0.0])))\n        end_shift = zxrot.apply(yxrot.apply(np.array([0.0, length / 2, 0.0])))\n        center = np.array(size) / 2\n        yield from self.create_empty_image.arun(size=size, scale=scale)\n        cb = thread_worker.callback(self.create_straight_line)\n        yield cb.with_args(start_shift + center, end_shift + center)\n\n    def _get_spline_idx(self, *_) -&gt; int:\n        return self._get_main()._get_spline_idx()\n\n    @set_design(icon=\"fluent:select-object-skew-20-regular\", location=SimulatorTools)\n    def generate_molecules(\n        self,\n        spline: Annotated[int, {\"bind\": _get_spline_idx}] = 0,\n        spacing: Annotated[nm, {\"min\": 0.2, \"max\": 100.0, \"step\": 0.01, \"label\": \"spacing (nm)\"}] = 1.0,\n        twist: Annotated[float, {\"min\": -45.0, \"max\": 45.0, \"label\": \"twist (deg)\"}] = 0.0,\n        start: Annotated[int, {\"min\": -50, \"max\": 50, \"label\": \"start\"}] = 0,\n        npf: Annotated[int, {\"min\": 1, \"label\": \"number of PF\"}] = 2,\n        radius: Annotated[nm, {\"min\": 0.5, \"max\": 50.0, \"step\": 0.5, \"label\": \"radius (nm)\"}] = 10.0,\n        offsets: tuple[float, float] = (0.0, 0.0),\n        update_glob: Annotated[bool, {\"label\": \"update spline global properties\"}] = True,\n    ):  # fmt: skip\n        \"\"\"Update cylinder model with new parameters.\n\n        Local structural displacement will be deleted because this function may change\n        the number of molecules. This function should be called first.\n\n        Parameters\n        ----------\n        spacing : nm\n            Axial spacing between molecules.\n        twist : float\n            Monomer twist of the cylinder.\n        start : int\n            The start number.\n        npf : int\n            Number of protofilaments.\n        radius : nm\n            Radius of the cylinder.\n        \"\"\"\n        # NOTE: these parameters are hard-coded for microtubule for now.\n        main = self._get_main()\n        spl = main.splines[spline]\n        model = self._prep_model(spl, spacing, twist, start, npf, radius, offsets)\n        mole = model.to_molecules(spl)\n        name = _make_simulated_mole_name(main.parent_viewer)\n        layer = main.add_molecules(mole, name=name, source=spl)\n        _set_simulation_model(layer, model)\n        old_props = spl.props.glob\n        if update_glob:\n            cparams = spl.copy(copy_props=False).cylinder_params(\n                spacing=spacing, twist=twist, start=start, npf=npf, radius=radius\n            )\n            spl.update_glob_by_cylinder_params(cparams)\n\n        @undo_callback\n        def _out():\n            main._undo_callback_for_layer(layer).run()\n            spl.props.glob = old_props\n\n        return _out\n\n    @impl_preview(generate_molecules, auto_call=True)\n    def _preview_generate_molecules(\n        self,\n        spline: int,\n        spacing: nm,\n        twist: float,\n        start: int,\n        npf: int,\n        radius: nm,\n        offsets: tuple[float, float],\n    ):\n        main = self._get_main()\n        spl = main.splines[spline]\n        model = self._prep_model(spl, spacing, twist, start, npf, radius, offsets)\n        out = model.to_molecules(spl)\n        viewer = main.parent_viewer\n        if PREVIEW_LAYER_NAME in viewer.layers:\n            layer: Layer = viewer.layers[PREVIEW_LAYER_NAME]\n            layer.data = out.pos\n        else:\n            layer = main.add_molecules(\n                out, name=PREVIEW_LAYER_NAME, face_color=\"crimson\"\n            )\n        is_active = yield\n        if not is_active and layer in viewer.layers:\n            viewer.layers.remove(layer)\n\n    def _prep_model(\n        self,\n        spl: CylSpline,\n        spacing: nm,\n        twist: float,\n        start: int,\n        npf: int,\n        radius: nm,\n        offsets: tuple[float, float],\n    ) -&gt; CylinderModel:\n        kwargs = {\n            H.spacing: spacing,\n            H.twist: twist,\n            H.start: start,\n            H.npf: npf,\n            H.radius: radius,\n        }\n        model = spl.copy(copy_props=False).cylinder_model(offsets=offsets, **kwargs)\n        return model\n\n    def _get_components(self, *_):\n        return self.component_list._as_input()\n\n    @set_design(text=capitalize, location=SimulateMenu)\n    @dask_thread_worker.with_progress()\n    def simulate_tomogram(\n        self,\n        components: Annotated[Any, {\"bind\": _get_components}],\n        save_dir: Annotated[Path.Save, {\"label\": \"Save at\"}],\n        nsr: _NSRatios = [1.5],\n        tilt_range: _TiltRange = (-60.0, 60.0),\n        n_tilt: Annotated[int, {\"label\": \"Number of tilts\"}] = 21,\n        ctf: Annotated[CTFDict, {\"widget_type\": CTFParams}] = None,\n        interpolation: Annotated[int, {\"choices\": INTERPOLATION_CHOICES}] = 3,\n        seed: Optional[Annotated[int, {\"min\": 0, \"max\": 1e8}]] = None,\n    ):  # fmt: skip\n        \"\"\"Simulate tomographic images using the current model and save the images.\n\n        This function projects the template image to each tilt series, adding\n        Gaussian noise, and back-projects the noisy tilt series to the tomogram.\n\n        Parameters\n        ----------\n        components : list of (str, Path)\n            List of tuples of layer name and path to the template image.\n        save_dir : Path\n            Path to the directory where the images will be saved.\n        nsr : list of float\n            Noise-to-signal ratio. It is defined by N/S, where S is the maximum\n            value of the true monomer density and N is the standard deviation of\n            the Gaussian noise. Duplicate values are allowed, which is useful\n            for simulation of multiple images with the same noise level.\n        tilt_range : tuple of float\n            Minimum and maximum tilt angles in degree.\n        n_tilt : int\n            Number of tilt angles between minimum and maximum angles.\n        ctf : CTFDict\n            Parameters to construct a CTF (Contrast Transfer Function) model that will\n            be applied to the projections.\n        interpolation : int\n            Interpolation method used during the simulation.\n        seed : int, optional\n            Random seed used for the Gaussian noise.\n        \"\"\"\n        save_dir = _norm_save_dir(save_dir)\n        components = _norm_components(components)\n        nsr = [round(float(_nsr), 4) for _nsr in nsr]\n        N = len(nsr)\n        yield thread_worker.callback().with_desc(\"Simulating projections\")\n        main = self._get_main()\n        degrees = np.linspace(*tilt_range, n_tilt)\n        _ctf = _CTFInputTuple.from_dict(ctf)\n        ts = self._prep_radon(components, degrees, order=interpolation)\n\n        yield _on_radon_finished.with_args(ts, degrees, _ctf.ctf_model).with_desc(\n            f\"Back-projection of 0/{N}-th image\"\n        )\n\n        rng = ip.random.default_rng(seed)\n        imax = ts.max()\n        ts_conv = _ctf.convolve(ts)\n        for i, nsr_val in enumerate(nsr):\n            rec = (\n                _ctf.recover(_add_noise(ts_conv, imax * nsr_val, rng))\n                .iradon(\n                    degrees,\n                    central_axis=\"y\",\n                    height=main.tomogram.image.shape[0],\n                    order=interpolation,\n                )\n                .set_scale(zyx=main.tomogram.scale, unit=\"nm\")\n            )\n            yield (\n                _on_iradon_finished.with_args(\n                    rec.mean(\"z\"), f\"N/S = {nsr_val:.1f}\"\n                ).with_desc(f\"Back-projection of {i + 1}/{N}-th image\")\n            )\n\n            file_name = save_dir / f\"image-{i}.mrc\"\n            rec.imsave(file_name)\n            _Logger.print(f\"Image saved at {file_name}.\")\n\n        main.save_project(save_dir / PROJECT_NAME, molecules_ext=\".parquet\")\n        return None\n\n    @set_design(text=capitalize, location=SimulateMenu)\n    @dask_thread_worker.with_progress()\n    @confirm(\n        text=\"You have an opened image. Run anyway?\",\n        condition=\"not self._get_main().tomogram.is_dummy\",\n    )\n    def simulate_tomogram_from_tilt_series(\n        self,\n        path: Path.Read[FileFilter.IMAGE],\n        nsr: _NSRatio = 1.5,\n        bin_size: Annotated[list[int], {\"options\": {\"min\": 1, \"max\": 32}}] = [1],\n        tilt_range: _TiltRange = (-60.0, 60.0),\n        height: Annotated[nm, {\"label\": \"height (nm)\"}] = 50,\n        ctf: Annotated[CTFDict, {\"widget_type\": CTFParams}] = None,\n        interpolation: Annotated[int, {\"choices\": INTERPOLATION_CHOICES}] = 3,\n        seed: Optional[Annotated[int, {\"min\": 0, \"max\": 1e8}]] = None,\n    ):\n        \"\"\"Simulate tomographic images using a tilt series.\n\n        Parameters\n        ----------\n        path : Path\n            Path to the tilt series image.\n        nsr : float\n            Noise-to-signal ratio. It is defined by N/S, where S is the maximum\n            value of the tilt series. If the input image is already noisy, you\n            can set this value to zero to avoid adding more noises.\n        bin_size : list of int\n            Bin sizes used to create multi-scaled images from the simulated image.\n        tilt_range : tuple of float\n            Minimum and maximum tilt angles in degree.\n        height : int\n            Height of the simulated tomogram in nm.\n        ctf : CTFDict\n            Parameters to construct a CTF (Contrast Transfer Function) model that will\n            be applied to the projections.\n        interpolation : int\n            Interpolation method used during the simulation.\n        seed : int, optional\n            Random seed used for the Gaussian noise.\n        \"\"\"\n        main = self._get_main()\n        yield thread_worker.callback().with_desc(\"(0/3) Reading tilt series\")\n        ts = ip.imread(path)\n        scale = ts.scale.x\n        if ts.ndim != 3:\n            raise ValueError(\"Input image must be a 3D image.\")\n        _ctf = _CTFInputTuple.from_dict(ctf)\n        degrees = np.linspace(*tilt_range, ts.shape[0])\n        rng = ip.random.default_rng(seed)\n        imax = ts.max()\n        yield (\n            on_ctf_finished.with_args(_ctf.ctf_model, scale=ts.scale.x).with_desc(\n                \"(1/3) Back-projection\"\n            )\n        )\n        rec = (\n            _ctf.recover(_add_noise(_ctf.convolve(ts), imax * nsr, rng))\n            .iradon(\n                degrees,\n                central_axis=\"y\",\n                height=roundint(height / scale),\n                order=interpolation,\n            )\n            .set_scale(zyx=scale, unit=\"nm\")\n        )\n        yield (\n            _on_iradon_finished.with_args(rec.mean(\"z\"), f\"N/S = {nsr:.1f}\").with_desc(\n                \"(2/3) Reading tomogram\"\n            )\n        )\n        rec.name = SIMULATED_IMAGE_NAME\n        tomo = CylTomogram.from_image(\n            rec, scale=scale, tilt=tilt_range, binsize=bin_size\n        )\n        main._init_macro_state()\n        return main._send_tomogram_to_viewer.with_args(tomo)\n\n    @set_design(text=capitalize, location=SimulateMenu)\n    @dask_thread_worker.with_progress(desc=\"Simulating tomogram...\")\n    @confirm(\n        text=\"You have an opened image. Run anyway?\",\n        condition=\"not self._get_main().tomogram.is_dummy\",\n    )\n    def simulate_tomogram_and_open(\n        self,\n        components: Annotated[Any, {\"bind\": _get_components}],\n        nsr: _NSRatio = 1.5,\n        bin_size: Annotated[list[int], {\"options\": {\"min\": 1, \"max\": 32}}] = [1],\n        tilt_range: _TiltRange = (-60.0, 60.0),\n        n_tilt: Annotated[int, {\"label\": \"Number of tilts\"}] = 21,\n        ctf: Annotated[CTFDict, {\"widget_type\": CTFParams}] = None,\n        interpolation: Annotated[int, {\"choices\": INTERPOLATION_CHOICES}] = 3,\n        seed: Optional[Annotated[int, {\"min\": 0, \"max\": 1e8}]] = None,\n    ):  # fmt: skip\n        \"\"\"Simulate a tomogram and open the image immediately.\n\n        This function projects the template image to each tilt series, adding\n        Gaussian noise, and back-projects the noisy tilt series to the tomogram.\n\n        Parameters\n        ----------\n        components : list of (str, Path)\n            List of tuples of layer name and path to the template image.\n        nsr : float\n            Noise-to-signal ratio. It is defined by N/S, where S is the maximum\n            value of the true monomer density and N is the standard deviation of\n            the Gaussian noise.\n        bin_size : list of int\n            Bin sizes used to create multi-scaled images from the simulated image.\n        tilt_range : tuple of float\n            Minimum and maximum tilt angles in degree.\n        n_tilt : int\n            Number of tilt angles between minimum and maximum angles.\n        ctf : CTFDict\n            Parameters to construct a CTF (Contrast Transfer Function) model that will\n            be applied to the projections.\n        interpolation : int\n            Interpolation method used during the simulation.\n        seed : int, optional\n            Random seed used for the Gaussian noise.\n        \"\"\"\n        nsr = round(float(nsr), 4)\n        components = _norm_components(components)\n        main = self._get_main()\n        degrees = np.linspace(*tilt_range, n_tilt)\n        mole_layers = [main.mole_layers[layer_name] for layer_name, _ in components]\n        sources = [layer.source_spline for layer in mole_layers]\n        yield thread_worker.callback().with_desc(\"Simulating projections\")\n        ts = self._prep_radon(components, degrees, order=interpolation)\n        _ctf = _CTFInputTuple.from_dict(ctf)\n\n        yield _on_radon_finished.with_args(ts, degrees, _ctf.ctf_model).with_desc(\n            \"Back-projection ...\"\n        )\n\n        rng = ip.random.default_rng(seed)\n        imax = ts.max()\n        rec = (\n            _ctf.recover(_add_noise(_ctf.convolve(ts), imax * nsr, rng))\n            .iradon(\n                degrees,\n                central_axis=\"y\",\n                height=main.tomogram.image.shape[0],\n                order=interpolation,\n            )\n            .set_scale(zyx=ts.scale.x, unit=\"nm\")\n        )\n        yield _on_iradon_finished.with_args(rec.mean(\"z\"), f\"N/S = {nsr:.1f}\")\n\n        rec.name = SIMULATED_IMAGE_NAME\n        tomo = CylTomogram.from_image(\n            rec, scale=ts.scale.x, tilt=tilt_range, binsize=bin_size\n        )\n        tomo.splines.extend(sources)\n        yield main._send_tomogram_to_viewer.with_args(tomo)\n\n        @thread_worker.callback\n        def _on_return():\n            for layer, source_spline in zip(mole_layers, sources, strict=True):\n                main.parent_viewer.add_layer(layer)\n                if source_spline is not None:\n                    layer.source_component = source_spline\n            if len(main.splines) &gt; 0:\n                main._update_splines_in_images()\n\n        return _on_return\n\n    @set_design(text=capitalize, location=SimulateMenu)\n    @dask_thread_worker.with_progress(desc=\"Simulating tilt series...\")\n    def simulate_tilt_series(\n        self,\n        components: Annotated[Any, {\"bind\": _get_components}],\n        save_dir: Annotated[Path.Save, {\"label\": \"Save at\"}],\n        nsr: _NSRatios = [0],\n        tilt_range: _TiltRange = (-60.0, 60.0),\n        n_tilt: Annotated[int, {\"label\": \"Number of tilts\"}] = 21,\n        interpolation: Annotated[int, {\"choices\": INTERPOLATION_CHOICES}] = 3,\n        ctf: Annotated[CTFDict, {\"widget_type\": CTFParams}] = None,\n        seed: Optional[Annotated[int, {\"min\": 0, \"max\": 1e8}]] = None,\n    ):  # fmt: skip\n        \"\"\"Simulate tilt series using the current model and save the images.\n\n        Parameters\n        ----------\n        components : list of (str, Path)\n            List of tuples of layer name and path to the template image.\n        save_dir : Path\n            Directory path where the tilt series will be saved.\n        tilt_range : tuple of float\n            Minimum and maximum tilt angles in degree.\n        n_tilt : int\n            Number of tilt angles between minimum and maximum angles.\n        interpolation : int\n            Interpolation method used during the simulation.\n        \"\"\"\n        save_dir = _norm_save_dir(save_dir)\n        components = _norm_components(components)\n        degrees = np.linspace(*tilt_range, n_tilt)\n        _ctf = _CTFInputTuple.from_dict(ctf)\n        scale = self._get_main().tomogram.scale\n        yield on_ctf_finished.with_args(_ctf.ctf_model, scale=scale)\n        ts = self._prep_radon(components, degrees, order=interpolation)\n        _Logger.print(\n            f\"Tilt series simulated. Shape: {ts.shape}, size: {ts.nbytes / 2**20:.2f} MB\"\n        )\n\n        # apply CTF and noise\n        rng = ip.random.default_rng(seed)\n        imax = ts.max()\n        _Logger.print(\"Convolving CTF ...\")\n        ts_conv = _ctf.convolve(ts)\n        for i, nsr_val in enumerate(nsr):\n            ts_noise = _ctf.recover(_add_noise(ts_conv, imax * nsr_val, rng))\n            save_path = save_dir / f\"image-{i}.mrc\"\n            ts_noise.set_axes(\"zyx\").set_scale(zyx=scale, unit=\"nm\").imsave(save_path)\n            _Logger.print(f\"{i}-th tilt series saved at {save_path}.\")\n        self._get_main().save_project(save_dir / PROJECT_NAME, molecules_ext=\".parquet\")\n        return None\n\n    @set_design(icon=\"iconoir:expand-lines\", location=SimulatorTools)\n    def expand(\n        self,\n        layer: _ModeledMoleculesLayer,\n        by: Annotated[float, {\"min\": -100, \"max\": 100}] = 0.0,\n        yrange: Annotated[tuple[int, int], {\"widget_type\": RangeSlider}] = (0, 1),\n        arange: Annotated[tuple[int, int], {\"widget_type\": RangeSlider}] = (0, 1),\n        allev: bool = False,\n    ):\n        \"\"\"Apply local expansion to molecules.\n\n        Parameters\n        ----------\n        layer : MoleculesLayer\n            Layer to be transformed.\n        by : float\n            Amount of expansion in nm.\n        yrange : tuple of int\n            Range of Y axis to be transformed. Range is [a, b).\n        arange : tuple of int\n            Range of angle axis to be transformed. Range is [a, b).\n        allev : bool\n            Alleviation of the local expansion. If true, the surrounding molecules\n            will be shifted to alleviate the local expansion.\n        \"\"\"\n        layer = assert_layer(layer, self.parent_viewer)\n        spl, model = _local_transform(\n            CylinderModel.expand, layer, by, yrange, arange, allev\n        )\n        layer.molecules = model.to_molecules(spl, layer.molecules.features)\n        _set_simulation_model(layer, model)\n        return None\n\n    @set_design(icon=\"mingcute:rotate-x-line\", location=SimulatorTools)\n    def twist(\n        self,\n        layer: _ModeledMoleculesLayer,\n        by: Annotated[float, {\"min\": -100, \"max\": 100}] = 0.0,\n        yrange: Annotated[tuple[int, int], {\"widget_type\": RangeSlider}] = (0, 1),\n        arange: Annotated[tuple[int, int], {\"widget_type\": RangeSlider}] = (0, 1),\n        allev: bool = False,\n    ):\n        \"\"\"Apply local twist to molecules.\n\n        Parameters\n        ----------\n        layer : MoleculesLayer\n            Layer to be transformed.\n        by : float\n            Amount of twist in degree.\n        yrange : tuple of int\n            Range of Y axis to be transformed. Range is [a, b).\n        arange : tuple of int\n            Range of angle axis to be transformed. Range is [a, b).\n        allev : bool\n            Alleviation of the local expansion. If true, the surrounding molecules\n            will be shifted to alleviate the local expansion.\n        \"\"\"\n        layer = assert_layer(layer, self.parent_viewer)\n        spl, model = _local_transform(\n            CylinderModel.twist, layer, np.deg2rad(by), yrange, arange, allev\n        )\n        layer.molecules = model.to_molecules(spl, layer.molecules.features)\n        _set_simulation_model(layer, model)\n        return None\n\n    @set_design(icon=\"iconoir:scale-frame-enlarge\", location=SimulatorTools)\n    def dilate(\n        self,\n        layer: _ModeledMoleculesLayer,\n        by: Annotated[float, {\"min\": -100, \"max\": 100}] = 0.0,\n        yrange: Annotated[tuple[int, int], {\"widget_type\": RangeSlider}] = (0, 1),\n        arange: Annotated[tuple[int, int], {\"widget_type\": RangeSlider}] = (0, 1),\n        allev: bool = False,\n    ):\n        \"\"\"Apply local dilation to molecules.\n\n        Parameters\n        ----------\n        layer : MoleculesLayer\n            Layer to be transformed.\n        by : float\n            Amount of dilation in nm.\n        yrange : tuple of int\n            Range of Y axis to be transformed. Range is [a, b).\n        arange : tuple of int\n            Range of angle axis to be transformed. Range is [a, b).\n        allev : bool\n            Alleviation of the local expansion. If true, the surrounding molecules\n            will be shifted to alleviate the local expansion.\n        \"\"\"\n        layer = assert_layer(layer, self.parent_viewer)\n        spl, model = _local_transform(\n            CylinderModel.dilate, layer, by, yrange, arange, allev\n        )\n        layer.molecules = model.to_molecules(spl, layer.molecules.features)\n        _set_simulation_model(layer, model)\n        return None\n\n    @set_design(icon=\"fluent:arrow-move-20-filled\", location=SimulatorTools)\n    def displace(\n        self,\n        layer: _ModeledMoleculesLayer,\n        expand: ExprStr.In[POLARS_NAMESPACE] = 0.0,\n        twist: ExprStr.In[POLARS_NAMESPACE] = 0.0,\n        dilate: ExprStr.In[POLARS_NAMESPACE] = 0.0,\n    ):\n        \"\"\"Detailed local transformation of molecules.\n\n        In this method, you'll have to specify the displacement for each molecule\n        using polars expressions. For example, if you want to expand the molecules\n        with odd numbering by 0.1 nm, you can set `expand` to\n        &gt;&gt;&gt; pl.when(pl.col(\"nth\") % 2 == 0).then(0).otherwise(0.1)\n\n        Parameters\n        ----------\n        layer : ModelLayer\n            Layer to be transformed.\n        expand : str, pl.Expr or constant\n            Displacement in the longitudinal direction (nm).\n        twist : str, pl.Expr or constant\n            Displacement in the angular direction (degree).\n        dilate : str, pl.Expr or constant\n            Displacement from the center (nm).\n        \"\"\"\n        layer = assert_layer(layer, self.parent_viewer)\n        new_model = _get_shifted_model(layer, expand, twist, dilate)\n        layer.molecules = new_model.to_molecules(\n            layer.source_spline, layer.molecules.features\n        )\n        return _set_simulation_model(layer, new_model)\n</code></pre>"},{"location":"api/widgets/subwidgets/#cylindra.widgets.subwidgets.Simulator.add_component","title":"<code>add_component(layer, template_path)</code>","text":"<p>Add a set of template and a molecules as a simulation component.</p> <p>A component defines which molecules corresponds to what template image. Multiple components can be added to simulate a tomogram with different materials.</p> <p>Parameters:</p> Name Type Description Default <code>layer</code> <code>MoleculesLayer</code> <p>Layer to be used for simulation.</p> required <code>template_path</code> <code>Path</code> <p>Path to the template image that will be used to simulate the corresponding molecules layer.</p> required Source code in <code>cylindra/widgets/subwidgets/simulator.py</code> <pre><code>@set_design(icon=\"fluent:cloud-add-16-filled\", location=SimulatorTools)\n@do_not_record\ndef add_component(\n    self,\n    layer: MoleculesLayerType,\n    template_path: Path.Read[FileFilter.IMAGE],\n):\n    \"\"\"Add a set of template and a molecules as a simulation component.\n\n    A component defines which molecules corresponds to what template image.\n    Multiple components can be added to simulate a tomogram with different\n    materials.\n\n    Parameters\n    ----------\n    layer : MoleculesLayer\n        Layer to be used for simulation.\n    template_path : Path\n        Path to the template image that will be used to simulate the\n        corresponding molecules layer.\n    \"\"\"\n    layer = assert_layer(layer, self.parent_viewer)\n    self.component_list.append(Component(template_path, layer))\n    self.component_list._on_children_change()\n</code></pre>"},{"location":"api/widgets/subwidgets/#cylindra.widgets.subwidgets.Simulator.create_empty_image","title":"<code>create_empty_image(size=(60.0, 200.0, 60.0), scale=0.25)</code>","text":"<p>Create an empty image with the given size and scale, and send it to the viewer.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>(nm, nm, nm)</code> <p>Size of the image in nm, of (Z, Y, X).</p> <code>(60., 200., 60.)</code> <code>scale</code> <code>nm</code> <p>Pixel size of the image.</p> <code>0.25</code> Source code in <code>cylindra/widgets/subwidgets/simulator.py</code> <pre><code>@set_design(text=capitalize, location=CreateMenu)\n@thread_worker.with_progress(desc=\"Creating an image\")\n@confirm(\n    text=\"You have an opened image. Run anyway?\",\n    condition=\"not self._get_main().tomogram.is_dummy\",\n)\ndef create_empty_image(\n    self,\n    size: _ImageSize = (60.0, 200.0, 60.0),\n    scale: Annotated[nm, {\"label\": \"pixel scale (nm/pixel)\"}] = 0.25,\n):  # fmt: skip\n    \"\"\"Create an empty image with the given size and scale, and send it to the viewer.\n\n    Parameters\n    ----------\n    size : (nm, nm, nm), default (60., 200., 60.)\n        Size of the image in nm, of (Z, Y, X).\n    scale : nm, default 0.25\n        Pixel size of the image.\n    \"\"\"\n    main = self._get_main()\n    shape = tuple(roundint(s / scale) for s in size)\n\n    binsize = ceilint(0.96 / scale)\n    # NOTE: zero-filled image breaks contrast limit calculation, and bad for\n    # visual detection of the image edges.\n    tomo = CylTomogram.dummy(scale=scale, binsize=binsize, shape=shape)\n    main._init_macro_state()\n\n    @thread_worker.callback\n    def _out():\n        main._send_tomogram_to_viewer(tomo)\n        main._reserved_layers.image.bounding_box.visible = True\n\n    return _out\n</code></pre>"},{"location":"api/widgets/subwidgets/#cylindra.widgets.subwidgets.Simulator.create_image_with_straight_line","title":"<code>create_image_with_straight_line(length=150.0, size=(60.0, 200.0, 60.0), scale=0.25, yxrotation=0.0, zxrotation=0.0)</code>","text":"<p>Create a straight line as a cylinder spline.</p> <p>Parameters:</p> Name Type Description Default <code>length</code> <code>nm</code> <p>Length if the straight line in nm.</p> <code>150.0</code> <code>size</code> <code>((nm, nm, nm), (60.0, 200.0, 60.0))</code> <p>Size of the tomogram in which the spline will reside.</p> <code>(60.0, 200.0, 60.0)</code> <code>scale</code> <code>nm</code> <p>Scale of pixel in nm/pixel.</p> <code>0.25</code> <code>yxrotation</code> <code>float</code> <p>Rotation in YX plane. This rotation will be applied before ZX rotation.</p> <code>0.0</code> <code>zxrotation</code> <code>float</code> <p>Rotation in ZX plane. This rotation will be applied before YX rotation.</p> <code>0.0</code> Source code in <code>cylindra/widgets/subwidgets/simulator.py</code> <pre><code>@set_design(text=capitalize, location=CreateMenu)\n@thread_worker.with_progress(desc=\"Creating an image\")\n@confirm(\n    text=\"You have an opened image. Run anyway?\",\n    condition=\"not self._get_main().tomogram.is_dummy\",\n)\ndef create_image_with_straight_line(\n    self,\n    length: nm = 150.0,\n    size: _ImageSize = (60.0, 200.0, 60.0),\n    scale: Annotated[nm, {\"label\": \"pixel scale (nm/pixel)\"}] = 0.25,\n    yxrotation: Annotated[float, {\"max\": 90, \"step\": 1, \"label\": \"Rotation in YX plane (deg)\"}] = 0.0,\n    zxrotation: Annotated[float, {\"max\": 90, \"step\": 1, \"label\": \"Rotation in ZX plane (deg)\"}] = 0.0,\n):  # fmt: skip\n    \"\"\"Create a straight line as a cylinder spline.\n\n    Parameters\n    ----------\n    length : nm, default 150.0\n        Length if the straight line in nm.\n    size : (nm, nm, nm), (60.0, 200.0, 60.0)\n        Size of the tomogram in which the spline will reside.\n    scale : nm, default 0.25\n        Scale of pixel in nm/pixel.\n    yxrotation : float, optional\n        Rotation in YX plane. This rotation will be applied before ZX rotation.\n    zxrotation : float, optional\n        Rotation in ZX plane. This rotation will be applied before YX rotation.\n    \"\"\"\n    yxrot = Rotation.from_rotvec([np.deg2rad(yxrotation), 0.0, 0.0])\n    zxrot = Rotation.from_rotvec([0.0, 0.0, np.deg2rad(zxrotation)])\n    start_shift = zxrot.apply(yxrot.apply(np.array([0.0, -length / 2, 0.0])))\n    end_shift = zxrot.apply(yxrot.apply(np.array([0.0, length / 2, 0.0])))\n    center = np.array(size) / 2\n    yield from self.create_empty_image.arun(size=size, scale=scale)\n    cb = thread_worker.callback(self.create_straight_line)\n    yield cb.with_args(start_shift + center, end_shift + center)\n</code></pre>"},{"location":"api/widgets/subwidgets/#cylindra.widgets.subwidgets.Simulator.create_straight_line","title":"<code>create_straight_line(start, end)</code>","text":"<p>Create a straight line as a spline.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>(nm, nm, nm)</code> <p>Start point of the line.</p> required <code>end</code> <code>(nm, nm, nm)</code> <p>End point of the line.</p> required Source code in <code>cylindra/widgets/subwidgets/simulator.py</code> <pre><code>@set_design(text=capitalize, location=CreateMenu)\ndef create_straight_line(self, start: _Point3D, end: _Point3D):\n    \"\"\"Create a straight line as a spline.\n\n    Parameters\n    ----------\n    start : (nm, nm, nm)\n        Start point of the line.\n    end : (nm, nm, nm)\n        End point of the line.\n    \"\"\"\n    spl = CylSpline.line(start, end)\n    main = self._get_main()\n    main.tomogram.splines.append(spl)\n    main._add_spline_instance(spl)\n    return undo_callback(main.delete_spline).with_args(-1)\n</code></pre>"},{"location":"api/widgets/subwidgets/#cylindra.widgets.subwidgets.Simulator.dilate","title":"<code>dilate(layer, by=0.0, yrange=(0, 1), arange=(0, 1), allev=False)</code>","text":"<p>Apply local dilation to molecules.</p> <p>Parameters:</p> Name Type Description Default <code>layer</code> <code>MoleculesLayer</code> <p>Layer to be transformed.</p> required <code>by</code> <code>float</code> <p>Amount of dilation in nm.</p> <code>0.0</code> <code>yrange</code> <code>tuple of int</code> <p>Range of Y axis to be transformed. Range is [a, b).</p> <code>(0, 1)</code> <code>arange</code> <code>tuple of int</code> <p>Range of angle axis to be transformed. Range is [a, b).</p> <code>(0, 1)</code> <code>allev</code> <code>bool</code> <p>Alleviation of the local expansion. If true, the surrounding molecules will be shifted to alleviate the local expansion.</p> <code>False</code> Source code in <code>cylindra/widgets/subwidgets/simulator.py</code> <pre><code>@set_design(icon=\"iconoir:scale-frame-enlarge\", location=SimulatorTools)\ndef dilate(\n    self,\n    layer: _ModeledMoleculesLayer,\n    by: Annotated[float, {\"min\": -100, \"max\": 100}] = 0.0,\n    yrange: Annotated[tuple[int, int], {\"widget_type\": RangeSlider}] = (0, 1),\n    arange: Annotated[tuple[int, int], {\"widget_type\": RangeSlider}] = (0, 1),\n    allev: bool = False,\n):\n    \"\"\"Apply local dilation to molecules.\n\n    Parameters\n    ----------\n    layer : MoleculesLayer\n        Layer to be transformed.\n    by : float\n        Amount of dilation in nm.\n    yrange : tuple of int\n        Range of Y axis to be transformed. Range is [a, b).\n    arange : tuple of int\n        Range of angle axis to be transformed. Range is [a, b).\n    allev : bool\n        Alleviation of the local expansion. If true, the surrounding molecules\n        will be shifted to alleviate the local expansion.\n    \"\"\"\n    layer = assert_layer(layer, self.parent_viewer)\n    spl, model = _local_transform(\n        CylinderModel.dilate, layer, by, yrange, arange, allev\n    )\n    layer.molecules = model.to_molecules(spl, layer.molecules.features)\n    _set_simulation_model(layer, model)\n    return None\n</code></pre>"},{"location":"api/widgets/subwidgets/#cylindra.widgets.subwidgets.Simulator.displace","title":"<code>displace(layer, expand=0.0, twist=0.0, dilate=0.0)</code>","text":"<p>Detailed local transformation of molecules.</p> <p>In this method, you'll have to specify the displacement for each molecule using polars expressions. For example, if you want to expand the molecules with odd numbering by 0.1 nm, you can set <code>expand</code> to <pre><code>pl.when(pl.col(\"nth\") % 2 == 0).then(0).otherwise(0.1)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>layer</code> <code>ModelLayer</code> <p>Layer to be transformed.</p> required <code>expand</code> <code>(str, Expr or constant)</code> <p>Displacement in the longitudinal direction (nm).</p> <code>0.0</code> <code>twist</code> <code>(str, Expr or constant)</code> <p>Displacement in the angular direction (degree).</p> <code>0.0</code> <code>dilate</code> <code>(str, Expr or constant)</code> <p>Displacement from the center (nm).</p> <code>0.0</code> Source code in <code>cylindra/widgets/subwidgets/simulator.py</code> <pre><code>@set_design(icon=\"fluent:arrow-move-20-filled\", location=SimulatorTools)\ndef displace(\n    self,\n    layer: _ModeledMoleculesLayer,\n    expand: ExprStr.In[POLARS_NAMESPACE] = 0.0,\n    twist: ExprStr.In[POLARS_NAMESPACE] = 0.0,\n    dilate: ExprStr.In[POLARS_NAMESPACE] = 0.0,\n):\n    \"\"\"Detailed local transformation of molecules.\n\n    In this method, you'll have to specify the displacement for each molecule\n    using polars expressions. For example, if you want to expand the molecules\n    with odd numbering by 0.1 nm, you can set `expand` to\n    &gt;&gt;&gt; pl.when(pl.col(\"nth\") % 2 == 0).then(0).otherwise(0.1)\n\n    Parameters\n    ----------\n    layer : ModelLayer\n        Layer to be transformed.\n    expand : str, pl.Expr or constant\n        Displacement in the longitudinal direction (nm).\n    twist : str, pl.Expr or constant\n        Displacement in the angular direction (degree).\n    dilate : str, pl.Expr or constant\n        Displacement from the center (nm).\n    \"\"\"\n    layer = assert_layer(layer, self.parent_viewer)\n    new_model = _get_shifted_model(layer, expand, twist, dilate)\n    layer.molecules = new_model.to_molecules(\n        layer.source_spline, layer.molecules.features\n    )\n    return _set_simulation_model(layer, new_model)\n</code></pre>"},{"location":"api/widgets/subwidgets/#cylindra.widgets.subwidgets.Simulator.expand","title":"<code>expand(layer, by=0.0, yrange=(0, 1), arange=(0, 1), allev=False)</code>","text":"<p>Apply local expansion to molecules.</p> <p>Parameters:</p> Name Type Description Default <code>layer</code> <code>MoleculesLayer</code> <p>Layer to be transformed.</p> required <code>by</code> <code>float</code> <p>Amount of expansion in nm.</p> <code>0.0</code> <code>yrange</code> <code>tuple of int</code> <p>Range of Y axis to be transformed. Range is [a, b).</p> <code>(0, 1)</code> <code>arange</code> <code>tuple of int</code> <p>Range of angle axis to be transformed. Range is [a, b).</p> <code>(0, 1)</code> <code>allev</code> <code>bool</code> <p>Alleviation of the local expansion. If true, the surrounding molecules will be shifted to alleviate the local expansion.</p> <code>False</code> Source code in <code>cylindra/widgets/subwidgets/simulator.py</code> <pre><code>@set_design(icon=\"iconoir:expand-lines\", location=SimulatorTools)\ndef expand(\n    self,\n    layer: _ModeledMoleculesLayer,\n    by: Annotated[float, {\"min\": -100, \"max\": 100}] = 0.0,\n    yrange: Annotated[tuple[int, int], {\"widget_type\": RangeSlider}] = (0, 1),\n    arange: Annotated[tuple[int, int], {\"widget_type\": RangeSlider}] = (0, 1),\n    allev: bool = False,\n):\n    \"\"\"Apply local expansion to molecules.\n\n    Parameters\n    ----------\n    layer : MoleculesLayer\n        Layer to be transformed.\n    by : float\n        Amount of expansion in nm.\n    yrange : tuple of int\n        Range of Y axis to be transformed. Range is [a, b).\n    arange : tuple of int\n        Range of angle axis to be transformed. Range is [a, b).\n    allev : bool\n        Alleviation of the local expansion. If true, the surrounding molecules\n        will be shifted to alleviate the local expansion.\n    \"\"\"\n    layer = assert_layer(layer, self.parent_viewer)\n    spl, model = _local_transform(\n        CylinderModel.expand, layer, by, yrange, arange, allev\n    )\n    layer.molecules = model.to_molecules(spl, layer.molecules.features)\n    _set_simulation_model(layer, model)\n    return None\n</code></pre>"},{"location":"api/widgets/subwidgets/#cylindra.widgets.subwidgets.Simulator.generate_molecules","title":"<code>generate_molecules(spline=0, spacing=1.0, twist=0.0, start=0, npf=2, radius=10.0, offsets=(0.0, 0.0), update_glob=True)</code>","text":"<p>Update cylinder model with new parameters.</p> <p>Local structural displacement will be deleted because this function may change the number of molecules. This function should be called first.</p> <p>Parameters:</p> Name Type Description Default <code>spacing</code> <code>nm</code> <p>Axial spacing between molecules.</p> <code>1.0</code> <code>twist</code> <code>float</code> <p>Monomer twist of the cylinder.</p> <code>0.0</code> <code>start</code> <code>int</code> <p>The start number.</p> <code>0</code> <code>npf</code> <code>int</code> <p>Number of protofilaments.</p> <code>2</code> <code>radius</code> <code>nm</code> <p>Radius of the cylinder.</p> <code>10.0</code> Source code in <code>cylindra/widgets/subwidgets/simulator.py</code> <pre><code>@set_design(icon=\"fluent:select-object-skew-20-regular\", location=SimulatorTools)\ndef generate_molecules(\n    self,\n    spline: Annotated[int, {\"bind\": _get_spline_idx}] = 0,\n    spacing: Annotated[nm, {\"min\": 0.2, \"max\": 100.0, \"step\": 0.01, \"label\": \"spacing (nm)\"}] = 1.0,\n    twist: Annotated[float, {\"min\": -45.0, \"max\": 45.0, \"label\": \"twist (deg)\"}] = 0.0,\n    start: Annotated[int, {\"min\": -50, \"max\": 50, \"label\": \"start\"}] = 0,\n    npf: Annotated[int, {\"min\": 1, \"label\": \"number of PF\"}] = 2,\n    radius: Annotated[nm, {\"min\": 0.5, \"max\": 50.0, \"step\": 0.5, \"label\": \"radius (nm)\"}] = 10.0,\n    offsets: tuple[float, float] = (0.0, 0.0),\n    update_glob: Annotated[bool, {\"label\": \"update spline global properties\"}] = True,\n):  # fmt: skip\n    \"\"\"Update cylinder model with new parameters.\n\n    Local structural displacement will be deleted because this function may change\n    the number of molecules. This function should be called first.\n\n    Parameters\n    ----------\n    spacing : nm\n        Axial spacing between molecules.\n    twist : float\n        Monomer twist of the cylinder.\n    start : int\n        The start number.\n    npf : int\n        Number of protofilaments.\n    radius : nm\n        Radius of the cylinder.\n    \"\"\"\n    # NOTE: these parameters are hard-coded for microtubule for now.\n    main = self._get_main()\n    spl = main.splines[spline]\n    model = self._prep_model(spl, spacing, twist, start, npf, radius, offsets)\n    mole = model.to_molecules(spl)\n    name = _make_simulated_mole_name(main.parent_viewer)\n    layer = main.add_molecules(mole, name=name, source=spl)\n    _set_simulation_model(layer, model)\n    old_props = spl.props.glob\n    if update_glob:\n        cparams = spl.copy(copy_props=False).cylinder_params(\n            spacing=spacing, twist=twist, start=start, npf=npf, radius=radius\n        )\n        spl.update_glob_by_cylinder_params(cparams)\n\n    @undo_callback\n    def _out():\n        main._undo_callback_for_layer(layer).run()\n        spl.props.glob = old_props\n\n    return _out\n</code></pre>"},{"location":"api/widgets/subwidgets/#cylindra.widgets.subwidgets.Simulator.simulate_tilt_series","title":"<code>simulate_tilt_series(components, save_dir, nsr=[0], tilt_range=(-60.0, 60.0), n_tilt=21, interpolation=3, ctf=None, seed=None)</code>","text":"<p>Simulate tilt series using the current model and save the images.</p> <p>Parameters:</p> Name Type Description Default <code>components</code> <code>list of (str, Path)</code> <p>List of tuples of layer name and path to the template image.</p> required <code>save_dir</code> <code>Path</code> <p>Directory path where the tilt series will be saved.</p> required <code>tilt_range</code> <code>tuple of float</code> <p>Minimum and maximum tilt angles in degree.</p> <code>(-60.0, 60.0)</code> <code>n_tilt</code> <code>int</code> <p>Number of tilt angles between minimum and maximum angles.</p> <code>21</code> <code>interpolation</code> <code>int</code> <p>Interpolation method used during the simulation.</p> <code>3</code> Source code in <code>cylindra/widgets/subwidgets/simulator.py</code> <pre><code>@set_design(text=capitalize, location=SimulateMenu)\n@dask_thread_worker.with_progress(desc=\"Simulating tilt series...\")\ndef simulate_tilt_series(\n    self,\n    components: Annotated[Any, {\"bind\": _get_components}],\n    save_dir: Annotated[Path.Save, {\"label\": \"Save at\"}],\n    nsr: _NSRatios = [0],\n    tilt_range: _TiltRange = (-60.0, 60.0),\n    n_tilt: Annotated[int, {\"label\": \"Number of tilts\"}] = 21,\n    interpolation: Annotated[int, {\"choices\": INTERPOLATION_CHOICES}] = 3,\n    ctf: Annotated[CTFDict, {\"widget_type\": CTFParams}] = None,\n    seed: Optional[Annotated[int, {\"min\": 0, \"max\": 1e8}]] = None,\n):  # fmt: skip\n    \"\"\"Simulate tilt series using the current model and save the images.\n\n    Parameters\n    ----------\n    components : list of (str, Path)\n        List of tuples of layer name and path to the template image.\n    save_dir : Path\n        Directory path where the tilt series will be saved.\n    tilt_range : tuple of float\n        Minimum and maximum tilt angles in degree.\n    n_tilt : int\n        Number of tilt angles between minimum and maximum angles.\n    interpolation : int\n        Interpolation method used during the simulation.\n    \"\"\"\n    save_dir = _norm_save_dir(save_dir)\n    components = _norm_components(components)\n    degrees = np.linspace(*tilt_range, n_tilt)\n    _ctf = _CTFInputTuple.from_dict(ctf)\n    scale = self._get_main().tomogram.scale\n    yield on_ctf_finished.with_args(_ctf.ctf_model, scale=scale)\n    ts = self._prep_radon(components, degrees, order=interpolation)\n    _Logger.print(\n        f\"Tilt series simulated. Shape: {ts.shape}, size: {ts.nbytes / 2**20:.2f} MB\"\n    )\n\n    # apply CTF and noise\n    rng = ip.random.default_rng(seed)\n    imax = ts.max()\n    _Logger.print(\"Convolving CTF ...\")\n    ts_conv = _ctf.convolve(ts)\n    for i, nsr_val in enumerate(nsr):\n        ts_noise = _ctf.recover(_add_noise(ts_conv, imax * nsr_val, rng))\n        save_path = save_dir / f\"image-{i}.mrc\"\n        ts_noise.set_axes(\"zyx\").set_scale(zyx=scale, unit=\"nm\").imsave(save_path)\n        _Logger.print(f\"{i}-th tilt series saved at {save_path}.\")\n    self._get_main().save_project(save_dir / PROJECT_NAME, molecules_ext=\".parquet\")\n    return None\n</code></pre>"},{"location":"api/widgets/subwidgets/#cylindra.widgets.subwidgets.Simulator.simulate_tomogram","title":"<code>simulate_tomogram(components, save_dir, nsr=[1.5], tilt_range=(-60.0, 60.0), n_tilt=21, ctf=None, interpolation=3, seed=None)</code>","text":"<p>Simulate tomographic images using the current model and save the images.</p> <p>This function projects the template image to each tilt series, adding Gaussian noise, and back-projects the noisy tilt series to the tomogram.</p> <p>Parameters:</p> Name Type Description Default <code>components</code> <code>list of (str, Path)</code> <p>List of tuples of layer name and path to the template image.</p> required <code>save_dir</code> <code>Path</code> <p>Path to the directory where the images will be saved.</p> required <code>nsr</code> <code>list of float</code> <p>Noise-to-signal ratio. It is defined by N/S, where S is the maximum value of the true monomer density and N is the standard deviation of the Gaussian noise. Duplicate values are allowed, which is useful for simulation of multiple images with the same noise level.</p> <code>[1.5]</code> <code>tilt_range</code> <code>tuple of float</code> <p>Minimum and maximum tilt angles in degree.</p> <code>(-60.0, 60.0)</code> <code>n_tilt</code> <code>int</code> <p>Number of tilt angles between minimum and maximum angles.</p> <code>21</code> <code>ctf</code> <code>CTFDict</code> <p>Parameters to construct a CTF (Contrast Transfer Function) model that will be applied to the projections.</p> <code>None</code> <code>interpolation</code> <code>int</code> <p>Interpolation method used during the simulation.</p> <code>3</code> <code>seed</code> <code>int</code> <p>Random seed used for the Gaussian noise.</p> <code>None</code> Source code in <code>cylindra/widgets/subwidgets/simulator.py</code> <pre><code>@set_design(text=capitalize, location=SimulateMenu)\n@dask_thread_worker.with_progress()\ndef simulate_tomogram(\n    self,\n    components: Annotated[Any, {\"bind\": _get_components}],\n    save_dir: Annotated[Path.Save, {\"label\": \"Save at\"}],\n    nsr: _NSRatios = [1.5],\n    tilt_range: _TiltRange = (-60.0, 60.0),\n    n_tilt: Annotated[int, {\"label\": \"Number of tilts\"}] = 21,\n    ctf: Annotated[CTFDict, {\"widget_type\": CTFParams}] = None,\n    interpolation: Annotated[int, {\"choices\": INTERPOLATION_CHOICES}] = 3,\n    seed: Optional[Annotated[int, {\"min\": 0, \"max\": 1e8}]] = None,\n):  # fmt: skip\n    \"\"\"Simulate tomographic images using the current model and save the images.\n\n    This function projects the template image to each tilt series, adding\n    Gaussian noise, and back-projects the noisy tilt series to the tomogram.\n\n    Parameters\n    ----------\n    components : list of (str, Path)\n        List of tuples of layer name and path to the template image.\n    save_dir : Path\n        Path to the directory where the images will be saved.\n    nsr : list of float\n        Noise-to-signal ratio. It is defined by N/S, where S is the maximum\n        value of the true monomer density and N is the standard deviation of\n        the Gaussian noise. Duplicate values are allowed, which is useful\n        for simulation of multiple images with the same noise level.\n    tilt_range : tuple of float\n        Minimum and maximum tilt angles in degree.\n    n_tilt : int\n        Number of tilt angles between minimum and maximum angles.\n    ctf : CTFDict\n        Parameters to construct a CTF (Contrast Transfer Function) model that will\n        be applied to the projections.\n    interpolation : int\n        Interpolation method used during the simulation.\n    seed : int, optional\n        Random seed used for the Gaussian noise.\n    \"\"\"\n    save_dir = _norm_save_dir(save_dir)\n    components = _norm_components(components)\n    nsr = [round(float(_nsr), 4) for _nsr in nsr]\n    N = len(nsr)\n    yield thread_worker.callback().with_desc(\"Simulating projections\")\n    main = self._get_main()\n    degrees = np.linspace(*tilt_range, n_tilt)\n    _ctf = _CTFInputTuple.from_dict(ctf)\n    ts = self._prep_radon(components, degrees, order=interpolation)\n\n    yield _on_radon_finished.with_args(ts, degrees, _ctf.ctf_model).with_desc(\n        f\"Back-projection of 0/{N}-th image\"\n    )\n\n    rng = ip.random.default_rng(seed)\n    imax = ts.max()\n    ts_conv = _ctf.convolve(ts)\n    for i, nsr_val in enumerate(nsr):\n        rec = (\n            _ctf.recover(_add_noise(ts_conv, imax * nsr_val, rng))\n            .iradon(\n                degrees,\n                central_axis=\"y\",\n                height=main.tomogram.image.shape[0],\n                order=interpolation,\n            )\n            .set_scale(zyx=main.tomogram.scale, unit=\"nm\")\n        )\n        yield (\n            _on_iradon_finished.with_args(\n                rec.mean(\"z\"), f\"N/S = {nsr_val:.1f}\"\n            ).with_desc(f\"Back-projection of {i + 1}/{N}-th image\")\n        )\n\n        file_name = save_dir / f\"image-{i}.mrc\"\n        rec.imsave(file_name)\n        _Logger.print(f\"Image saved at {file_name}.\")\n\n    main.save_project(save_dir / PROJECT_NAME, molecules_ext=\".parquet\")\n    return None\n</code></pre>"},{"location":"api/widgets/subwidgets/#cylindra.widgets.subwidgets.Simulator.simulate_tomogram_and_open","title":"<code>simulate_tomogram_and_open(components, nsr=1.5, bin_size=[1], tilt_range=(-60.0, 60.0), n_tilt=21, ctf=None, interpolation=3, seed=None)</code>","text":"<p>Simulate a tomogram and open the image immediately.</p> <p>This function projects the template image to each tilt series, adding Gaussian noise, and back-projects the noisy tilt series to the tomogram.</p> <p>Parameters:</p> Name Type Description Default <code>components</code> <code>list of (str, Path)</code> <p>List of tuples of layer name and path to the template image.</p> required <code>nsr</code> <code>float</code> <p>Noise-to-signal ratio. It is defined by N/S, where S is the maximum value of the true monomer density and N is the standard deviation of the Gaussian noise.</p> <code>1.5</code> <code>bin_size</code> <code>list of int</code> <p>Bin sizes used to create multi-scaled images from the simulated image.</p> <code>[1]</code> <code>tilt_range</code> <code>tuple of float</code> <p>Minimum and maximum tilt angles in degree.</p> <code>(-60.0, 60.0)</code> <code>n_tilt</code> <code>int</code> <p>Number of tilt angles between minimum and maximum angles.</p> <code>21</code> <code>ctf</code> <code>CTFDict</code> <p>Parameters to construct a CTF (Contrast Transfer Function) model that will be applied to the projections.</p> <code>None</code> <code>interpolation</code> <code>int</code> <p>Interpolation method used during the simulation.</p> <code>3</code> <code>seed</code> <code>int</code> <p>Random seed used for the Gaussian noise.</p> <code>None</code> Source code in <code>cylindra/widgets/subwidgets/simulator.py</code> <pre><code>@set_design(text=capitalize, location=SimulateMenu)\n@dask_thread_worker.with_progress(desc=\"Simulating tomogram...\")\n@confirm(\n    text=\"You have an opened image. Run anyway?\",\n    condition=\"not self._get_main().tomogram.is_dummy\",\n)\ndef simulate_tomogram_and_open(\n    self,\n    components: Annotated[Any, {\"bind\": _get_components}],\n    nsr: _NSRatio = 1.5,\n    bin_size: Annotated[list[int], {\"options\": {\"min\": 1, \"max\": 32}}] = [1],\n    tilt_range: _TiltRange = (-60.0, 60.0),\n    n_tilt: Annotated[int, {\"label\": \"Number of tilts\"}] = 21,\n    ctf: Annotated[CTFDict, {\"widget_type\": CTFParams}] = None,\n    interpolation: Annotated[int, {\"choices\": INTERPOLATION_CHOICES}] = 3,\n    seed: Optional[Annotated[int, {\"min\": 0, \"max\": 1e8}]] = None,\n):  # fmt: skip\n    \"\"\"Simulate a tomogram and open the image immediately.\n\n    This function projects the template image to each tilt series, adding\n    Gaussian noise, and back-projects the noisy tilt series to the tomogram.\n\n    Parameters\n    ----------\n    components : list of (str, Path)\n        List of tuples of layer name and path to the template image.\n    nsr : float\n        Noise-to-signal ratio. It is defined by N/S, where S is the maximum\n        value of the true monomer density and N is the standard deviation of\n        the Gaussian noise.\n    bin_size : list of int\n        Bin sizes used to create multi-scaled images from the simulated image.\n    tilt_range : tuple of float\n        Minimum and maximum tilt angles in degree.\n    n_tilt : int\n        Number of tilt angles between minimum and maximum angles.\n    ctf : CTFDict\n        Parameters to construct a CTF (Contrast Transfer Function) model that will\n        be applied to the projections.\n    interpolation : int\n        Interpolation method used during the simulation.\n    seed : int, optional\n        Random seed used for the Gaussian noise.\n    \"\"\"\n    nsr = round(float(nsr), 4)\n    components = _norm_components(components)\n    main = self._get_main()\n    degrees = np.linspace(*tilt_range, n_tilt)\n    mole_layers = [main.mole_layers[layer_name] for layer_name, _ in components]\n    sources = [layer.source_spline for layer in mole_layers]\n    yield thread_worker.callback().with_desc(\"Simulating projections\")\n    ts = self._prep_radon(components, degrees, order=interpolation)\n    _ctf = _CTFInputTuple.from_dict(ctf)\n\n    yield _on_radon_finished.with_args(ts, degrees, _ctf.ctf_model).with_desc(\n        \"Back-projection ...\"\n    )\n\n    rng = ip.random.default_rng(seed)\n    imax = ts.max()\n    rec = (\n        _ctf.recover(_add_noise(_ctf.convolve(ts), imax * nsr, rng))\n        .iradon(\n            degrees,\n            central_axis=\"y\",\n            height=main.tomogram.image.shape[0],\n            order=interpolation,\n        )\n        .set_scale(zyx=ts.scale.x, unit=\"nm\")\n    )\n    yield _on_iradon_finished.with_args(rec.mean(\"z\"), f\"N/S = {nsr:.1f}\")\n\n    rec.name = SIMULATED_IMAGE_NAME\n    tomo = CylTomogram.from_image(\n        rec, scale=ts.scale.x, tilt=tilt_range, binsize=bin_size\n    )\n    tomo.splines.extend(sources)\n    yield main._send_tomogram_to_viewer.with_args(tomo)\n\n    @thread_worker.callback\n    def _on_return():\n        for layer, source_spline in zip(mole_layers, sources, strict=True):\n            main.parent_viewer.add_layer(layer)\n            if source_spline is not None:\n                layer.source_component = source_spline\n        if len(main.splines) &gt; 0:\n            main._update_splines_in_images()\n\n    return _on_return\n</code></pre>"},{"location":"api/widgets/subwidgets/#cylindra.widgets.subwidgets.Simulator.simulate_tomogram_from_tilt_series","title":"<code>simulate_tomogram_from_tilt_series(path, nsr=1.5, bin_size=[1], tilt_range=(-60.0, 60.0), height=50, ctf=None, interpolation=3, seed=None)</code>","text":"<p>Simulate tomographic images using a tilt series.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to the tilt series image.</p> required <code>nsr</code> <code>float</code> <p>Noise-to-signal ratio. It is defined by N/S, where S is the maximum value of the tilt series. If the input image is already noisy, you can set this value to zero to avoid adding more noises.</p> <code>1.5</code> <code>bin_size</code> <code>list of int</code> <p>Bin sizes used to create multi-scaled images from the simulated image.</p> <code>[1]</code> <code>tilt_range</code> <code>tuple of float</code> <p>Minimum and maximum tilt angles in degree.</p> <code>(-60.0, 60.0)</code> <code>height</code> <code>int</code> <p>Height of the simulated tomogram in nm.</p> <code>50</code> <code>ctf</code> <code>CTFDict</code> <p>Parameters to construct a CTF (Contrast Transfer Function) model that will be applied to the projections.</p> <code>None</code> <code>interpolation</code> <code>int</code> <p>Interpolation method used during the simulation.</p> <code>3</code> <code>seed</code> <code>int</code> <p>Random seed used for the Gaussian noise.</p> <code>None</code> Source code in <code>cylindra/widgets/subwidgets/simulator.py</code> <pre><code>@set_design(text=capitalize, location=SimulateMenu)\n@dask_thread_worker.with_progress()\n@confirm(\n    text=\"You have an opened image. Run anyway?\",\n    condition=\"not self._get_main().tomogram.is_dummy\",\n)\ndef simulate_tomogram_from_tilt_series(\n    self,\n    path: Path.Read[FileFilter.IMAGE],\n    nsr: _NSRatio = 1.5,\n    bin_size: Annotated[list[int], {\"options\": {\"min\": 1, \"max\": 32}}] = [1],\n    tilt_range: _TiltRange = (-60.0, 60.0),\n    height: Annotated[nm, {\"label\": \"height (nm)\"}] = 50,\n    ctf: Annotated[CTFDict, {\"widget_type\": CTFParams}] = None,\n    interpolation: Annotated[int, {\"choices\": INTERPOLATION_CHOICES}] = 3,\n    seed: Optional[Annotated[int, {\"min\": 0, \"max\": 1e8}]] = None,\n):\n    \"\"\"Simulate tomographic images using a tilt series.\n\n    Parameters\n    ----------\n    path : Path\n        Path to the tilt series image.\n    nsr : float\n        Noise-to-signal ratio. It is defined by N/S, where S is the maximum\n        value of the tilt series. If the input image is already noisy, you\n        can set this value to zero to avoid adding more noises.\n    bin_size : list of int\n        Bin sizes used to create multi-scaled images from the simulated image.\n    tilt_range : tuple of float\n        Minimum and maximum tilt angles in degree.\n    height : int\n        Height of the simulated tomogram in nm.\n    ctf : CTFDict\n        Parameters to construct a CTF (Contrast Transfer Function) model that will\n        be applied to the projections.\n    interpolation : int\n        Interpolation method used during the simulation.\n    seed : int, optional\n        Random seed used for the Gaussian noise.\n    \"\"\"\n    main = self._get_main()\n    yield thread_worker.callback().with_desc(\"(0/3) Reading tilt series\")\n    ts = ip.imread(path)\n    scale = ts.scale.x\n    if ts.ndim != 3:\n        raise ValueError(\"Input image must be a 3D image.\")\n    _ctf = _CTFInputTuple.from_dict(ctf)\n    degrees = np.linspace(*tilt_range, ts.shape[0])\n    rng = ip.random.default_rng(seed)\n    imax = ts.max()\n    yield (\n        on_ctf_finished.with_args(_ctf.ctf_model, scale=ts.scale.x).with_desc(\n            \"(1/3) Back-projection\"\n        )\n    )\n    rec = (\n        _ctf.recover(_add_noise(_ctf.convolve(ts), imax * nsr, rng))\n        .iradon(\n            degrees,\n            central_axis=\"y\",\n            height=roundint(height / scale),\n            order=interpolation,\n        )\n        .set_scale(zyx=scale, unit=\"nm\")\n    )\n    yield (\n        _on_iradon_finished.with_args(rec.mean(\"z\"), f\"N/S = {nsr:.1f}\").with_desc(\n            \"(2/3) Reading tomogram\"\n        )\n    )\n    rec.name = SIMULATED_IMAGE_NAME\n    tomo = CylTomogram.from_image(\n        rec, scale=scale, tilt=tilt_range, binsize=bin_size\n    )\n    main._init_macro_state()\n    return main._send_tomogram_to_viewer.with_args(tomo)\n</code></pre>"},{"location":"api/widgets/subwidgets/#cylindra.widgets.subwidgets.Simulator.twist","title":"<code>twist(layer, by=0.0, yrange=(0, 1), arange=(0, 1), allev=False)</code>","text":"<p>Apply local twist to molecules.</p> <p>Parameters:</p> Name Type Description Default <code>layer</code> <code>MoleculesLayer</code> <p>Layer to be transformed.</p> required <code>by</code> <code>float</code> <p>Amount of twist in degree.</p> <code>0.0</code> <code>yrange</code> <code>tuple of int</code> <p>Range of Y axis to be transformed. Range is [a, b).</p> <code>(0, 1)</code> <code>arange</code> <code>tuple of int</code> <p>Range of angle axis to be transformed. Range is [a, b).</p> <code>(0, 1)</code> <code>allev</code> <code>bool</code> <p>Alleviation of the local expansion. If true, the surrounding molecules will be shifted to alleviate the local expansion.</p> <code>False</code> Source code in <code>cylindra/widgets/subwidgets/simulator.py</code> <pre><code>@set_design(icon=\"mingcute:rotate-x-line\", location=SimulatorTools)\ndef twist(\n    self,\n    layer: _ModeledMoleculesLayer,\n    by: Annotated[float, {\"min\": -100, \"max\": 100}] = 0.0,\n    yrange: Annotated[tuple[int, int], {\"widget_type\": RangeSlider}] = (0, 1),\n    arange: Annotated[tuple[int, int], {\"widget_type\": RangeSlider}] = (0, 1),\n    allev: bool = False,\n):\n    \"\"\"Apply local twist to molecules.\n\n    Parameters\n    ----------\n    layer : MoleculesLayer\n        Layer to be transformed.\n    by : float\n        Amount of twist in degree.\n    yrange : tuple of int\n        Range of Y axis to be transformed. Range is [a, b).\n    arange : tuple of int\n        Range of angle axis to be transformed. Range is [a, b).\n    allev : bool\n        Alleviation of the local expansion. If true, the surrounding molecules\n        will be shifted to alleviate the local expansion.\n    \"\"\"\n    layer = assert_layer(layer, self.parent_viewer)\n    spl, model = _local_transform(\n        CylinderModel.twist, layer, np.deg2rad(by), yrange, arange, allev\n    )\n    layer.molecules = model.to_molecules(spl, layer.molecules.features)\n    _set_simulation_model(layer, model)\n    return None\n</code></pre>"},{"location":"api/widgets/subwidgets/#spline-slicer","title":"Spline Slicer","text":"<p>Methods are available in the namespace <code>ui.spline_slicer</code>.</p> <p>Slicer along spline.</p> <p>Attributes:</p> Name Type Description <code>show_what</code> <code>str</code> <p>Specifies what type of slice image will be shown in the canvas.</p> <code>radius</code> <code>nm</code> <p>Radius of the cylinder. This value is used to restrict the xy size of the Y-projection and build cylindrical coordinate system. Changing this value does not overwrite the \"radius\" property of the spline. To overwrite, please use the \"Apply radius and thickness\" method.</p> <code>post_filter</code> <code>str</code> <p>Post-filtering method to denoise the sliced image. This is usually used for denoising the Y-projection images.</p> <code>thickness_inner</code> <code>nm</code> <p>Thickness of the cylinder inside the radius.</p> <code>thickness_outer</code> <code>nm</code> <p>Thickness of the cylinder outside the radius.</p> Source code in <code>cylindra/widgets/subwidgets/slicer.py</code> <pre><code>@magicclass(record=False)\nclass SplineSlicer(ChildWidget):\n    \"\"\"Slicer along spline.\n\n    Attributes\n    ----------\n    show_what : str\n        Specifies what type of slice image will be shown in the canvas.\n    radius : nm\n        Radius of the cylinder. This value is used to restrict the xy size of the\n        Y-projection and build cylindrical coordinate system. Changing this value does\n        not overwrite the \"radius\" property of the spline. To overwrite, please use the\n        \"Apply radius and thickness\" method.\n    post_filter : str\n        Post-filtering method to denoise the sliced image. This is usually used for\n        denoising the Y-projection images.\n    thickness_inner : nm\n        Thickness of the cylinder inside the radius.\n    thickness_outer : nm\n        Thickness of the cylinder outside the radius.\n    \"\"\"\n\n    show_what = vfield(label=\"kind\").with_choices(_CHOICES)\n\n    def __init__(self):\n        self._current_cparams = None\n\n    @magicclass(layout=\"horizontal\")\n    class params(ChildWidget):\n        \"\"\"Slicing parameters.\n\n        Attributes\n        ----------\n        depth : float\n            The depth of the projection along splines. For instance, depth=50.0 means\n            that Y-projection will be calculated using subvolume of size L * 50.0 nm * L.\n        binsize : int\n            The size of the binning. For instance, binsize=2 means that the image will\n            be binned by 2 before projection and/or Fourier transformation.\n        \"\"\"\n\n        def __init__(self):\n            self._old_binsize = 1\n\n        def _get_available_binsize(self, widget=None) -&gt; \"list[int]\":\n            try:\n                return self._get_main()._get_available_binsize(widget)\n            except Exception:\n                return []\n\n        depth = vfield(50.0, label=\"depth (nm)\").with_options(min=1.0, max=200.0)\n        binsize = vfield().with_choices(_get_available_binsize)\n\n    @magicclass(layout=\"horizontal\")\n    class Row0(ChildWidget):\n        radius = abstractapi()\n        post_filter = abstractapi()\n\n    @magicclass(layout=\"horizontal\")\n    class Row1(ChildWidget):\n        thickness_inner = abstractapi()\n        thickness_outer = abstractapi()\n\n    radius = vfield(Optional[nm], label=\"Radius (nm)\", location=Row0).with_options(\n        text=\"Use spline global radius\",\n        options={\"min\": 1.0, \"max\": 200.0, \"step\": 0.5, \"value\": 10.0},\n    )\n    post_filter = vfield(label=\"Filter\", location=Row0).with_choices(POST_FILTERS)\n    thickness_inner = vfield(2.0, label=\"Inner thickness (nm)\", location=Row1).with_options(min=0.1, max=10.0, step=0.1)  # fmt: skip\n    thickness_outer = vfield(2.0, label=\"Outer thickness (nm)\", location=Row1).with_options(min=0.1, max=10.0, step=0.1)  # fmt: skip\n    canvas = field(QtImageCanvas).with_options(lock_contrast_limits=True)\n\n    @magicclass(widget_type=\"frame\")\n    class controller(ChildWidget):\n        \"\"\"Control spline positions.\n\n        Attributes\n        ----------\n        spline_id : int\n            Current spline ID to analyze.\n        pos : nm\n            Position along the spline in nm.\n        \"\"\"\n\n        def _get_spline_id(self, widget=None) -&gt; \"list[tuple[str, int]]\":\n            try:\n                return self._get_main()._get_splines(widget)\n            except Exception:\n                return []\n\n        spline_id = vfield(label=\"Spline\").with_choices(_get_spline_id)\n        pos = field(nm, label=\"Position (nm)\", widget_type=\"FloatSlider\").with_options(max=0)  # fmt: skip\n\n    @magicclass(layout=\"horizontal\")\n    class Row2(ChildWidget):\n        measure_radius = abstractapi()\n        measure_cft_here = abstractapi()\n        measure_clockwise = abstractapi()\n\n    @magicclass(layout=\"horizontal\")\n    class Row3(ChildWidget):\n        fit_spline_manually = abstractapi()\n        apply_radius_and_thickness = abstractapi()\n        refresh_widget_state = abstractapi()\n\n    def __post_init__(self):\n        self._circ_inner = self.canvas.add_curve(\n            [], [], color=\"lime\", lw=2, ls=\"--\", antialias=True\n        )\n        self._circ_outer = self.canvas.add_curve(\n            [], [], color=\"lime\", lw=2, ls=\"--\", antialias=True\n        )\n\n    def _update_circles(self, radius: float | None):\n        if self.show_what != YPROJ or radius is None:\n            self._circ_inner.visible = False\n            self._circ_outer.visible = False\n            return\n        self._circ_inner.visible = True\n        self._circ_outer.visible = True\n        _scale = self._get_main().tomogram.scale * self.params.binsize\n        r_inner = max(radius - self.thickness_inner, 0) / _scale\n        r_outer = (radius + self.thickness_outer) / _scale\n\n        theta = np.linspace(0, 2 * np.pi, 100, endpoint=True)\n        ny, nx = self.canvas.image.shape\n        self._circ_inner.data = (\n            r_inner * np.cos(theta) + (nx - 1) / 2,\n            r_inner * np.sin(theta) + (ny - 1) / 2,\n        )\n        self._circ_outer.data = (\n            r_outer * np.cos(theta) + (nx - 1) / 2,\n            r_outer * np.sin(theta) + (ny - 1) / 2,\n        )\n\n    @bind_key(\"Up\")\n    @bind_key(\"F\")\n    def _next_pos(self):\n        c = self.controller\n        depth = self.params.depth\n        c.pos.value = min(c.pos.value + depth, c.pos.max)\n\n    @bind_key(\"Down\")\n    @bind_key(\"B\")\n    def _prev_pos(self):\n        c = self.controller\n        c.pos.value = max(c.pos.value - 1, c.pos.min)\n\n    @set_design(text=\"Measure radius\", location=Row2)\n    def measure_radius(self):\n        \"\"\"Measure the radius for the current spline.\"\"\"\n        idx = self.controller.spline_id\n        main = self._get_main()\n        main.measure_radius([idx], bin_size=self.params.binsize)\n        self.radius = main.tomogram.splines[idx].radius\n\n    @set_design(text=\"Measure CFT\", location=Row2)\n    def measure_cft_here(self):\n        \"\"\"Measure CFT parameters at the current position.\"\"\"\n        idx, pos, depth = self._get_cropping_params()\n        binsize = self.params.binsize\n        radius = self._get_radius()\n        img = self.get_cylindric_image(\n            idx, pos, depth=depth, binsize=binsize, radius=radius, order=3\n        )\n        tomo = self._get_main().tomogram\n        spl = tomo.splines[idx]\n        analyzer = LatticeAnalyzer(spl.config)\n        rc = radius + (-spl.config.thickness_inner + self.thickness_outer) / 2\n        params = analyzer.estimate_lattice_params_polar(img, rc)\n        spl_info = _col(f\"spline ID = {idx}; position = {pos:.2f} nm\", color=\"#003FFF\")\n        _Logger.print_html(\n            f\"{spl_info}&lt;br&gt;\"\n            f\"{_col('spacing:')} {params.spacing:.3f} nm&lt;br&gt;\"\n            f\"{_col('rise angle:')} {params.rise_angle:.3f} \u00b0&lt;br&gt;\"\n            f\"{_col('rise length:')} {params.rise_length:.3f} nm&lt;br&gt;\"\n            f\"{_col('twist:')} {params.twist:.3f} \u00b0&lt;br&gt;\"\n            f\"{_col('skew angle:')} {params.skew:.3f} \u00b0&lt;br&gt;\"\n            f\"{_col('PF:')} {params.npf}&lt;br&gt;\"\n            f\"{_col('start:')} {params.start}\"\n        )\n\n    @set_design(text=\"Fit spline manually ...\", location=Row3)\n    def fit_spline_manually(self):\n        \"\"\"Open the spline fitter and run fitting tasks there.\"\"\"\n        main = self._get_main()\n        main.SplinesMenu.Fitting.fit_splines_manually()\n        main.spline_fitter.num.value = self.controller.spline_id\n\n    @set_design(text=\"Measure CW/CCW\", location=Row2)\n    def measure_clockwise(self):\n        \"\"\"Measure if the helix is clockwise or counter-clockwise.\"\"\"\n        idx, pos, depth = self._get_cropping_params()\n        binsize = self.params.binsize\n        radius = self._get_radius()\n        img = self.get_cylindric_image(\n            idx, pos, depth=depth, binsize=binsize, radius=radius, order=3\n        )\n        tomo = self._get_main().tomogram\n        spl = tomo.splines[idx]\n        is_cw = is_clockwise(spl.config, img)\n        spl_info = _col(f\"spline ID = {idx}; position = {pos:.2f} nm\", color=\"#003FFF\")\n        direction = \"clockwise\" if is_cw else \"counter-clockwise\"\n        _Logger.print_html(f\"{spl_info}&lt;br&gt;The helix is {_col(direction)}.\")\n\n    @set_design(text=\"Refresh\", location=Row3)\n    def refresh_widget_state(self):\n        \"\"\"Refresh widget state.\"\"\"\n        self._spline_changed(self.controller.spline_id, refer_config=False)\n        return self._update_canvas()\n\n    @set_design(text=\"Apply radius and thickness\", location=Row3)\n    def apply_radius_and_thickness(self):\n        \"\"\"Apply the current radius and thickness to the current spline.\"\"\"\n        idx = self.controller.spline_id\n        main = self._get_main()\n        main.update_spline_config(\n            [idx],\n            thickness_inner=self.thickness_inner,\n            thickness_outer=self.thickness_outer,\n        )  # fmt: skip\n        if (r0 := self.radius) is not None:\n            main.set_radius([idx], r0)\n        self._spline_changed(idx, refer_config=False)\n\n    def _get_cropping_params(self) -&gt; tuple[int, nm, nm]:\n        idx = self.controller.spline_id\n        if idx is None:\n            return self._show_overlay_text(\"No spline exists.\")\n        depth = self.params.depth\n        pos = self.controller.pos.value\n        return idx, pos, depth\n\n    @controller.spline_id.connect\n    def _spline_changed(self, idx: int, refer_config: bool = True):\n        try:\n            spl = self._get_main().tomogram.splines[idx]\n            self.controller.pos.max = max(spl.length(), 0)\n            if refer_config:\n                self.thickness_inner = spl.config.thickness_inner\n                self.thickness_outer = spl.config.thickness_outer\n        except Exception:\n            pass\n        else:\n            with suppress(Exception):\n                self._current_cparams = spl.cylinder_params()\n\n    @show_what.connect_async(timeout=0.1)\n    @params.binsize.connect_async(timeout=0.1)\n    def _on_show_what_changed(self):\n        if self.visible:\n            yield from self._update_canvas.arun(update_clim=True)\n        return None\n\n    @params.depth.connect_async(timeout=0.1)\n    @radius.connect_async(timeout=0.1)\n    @post_filter.connect_async(timeout=0.1)\n    @controller.spline_id.connect_async(timeout=0.1)\n    @controller.pos.connect_async(timeout=0.1, abort_limit=0.5)\n    @thickness_inner.connect_async(timeout=0.1)\n    @thickness_outer.connect_async(timeout=0.1)\n    def _on_widget_state_changed(self):\n        if self.visible:\n            yield from self._update_canvas.arun()\n        return None\n\n    @thread_worker(force_async=True)\n    def _update_canvas(self, update_clim: bool = False):\n        _type = self.show_what\n        idx = self.controller.spline_id\n        if idx is None:\n            return self._show_overlay_text_cb.with_args(\"No spline exists.\")\n        depth = self.params.depth\n        pos = self.controller.pos.value\n        if _type == RPROJ:\n            result = self._current_cylindrical_img(idx, pos, depth)\n            if isinstance(result, Exception):\n                return self._show_overlay_text_cb.with_args(result)\n            yield\n            img2d = result.mean(axis=\"r\")\n            yield\n            img = self.post_filter(img2d).value\n        elif _type == YPROJ:\n            result = self._current_cartesian_img(idx, pos, depth)\n            if isinstance(result, Exception):\n                return self._show_overlay_text_cb.with_args(result)\n            yield\n            img2d = result.mean(axis=\"y\")[ip.slicer.x[::-1]]\n            yield\n            img = self.post_filter(img2d).value\n        elif _type == CFT:\n            result = self._current_cps(idx, pos, depth)\n            if isinstance(result, Exception):\n                return self._show_overlay_text_cb.with_args(result)\n            yield\n            result[:] = result / result.max()\n            img = result.value\n        elif _type == CFT_UP:\n            result = self._current_cylindrical_img(idx, pos, depth)\n            if isinstance(result, Exception):\n                return self._show_overlay_text_cb.with_args(result)\n            yield\n            spl = self._get_main().tomogram.splines[idx]\n\n            y0 = int(round(depth / spl.config.spacing_range.max * 1.2))\n            a0 = int(round(spl.config.npf_range.max * 6))\n            pw = result.local_power_spectra(\n                f\"y={-y0}:{y0+1};a={-a0}:{a0+1}\", dims=\"rya\", upsample_factor=[1, 5, 5]\n            ).mean(axis=\"r\")\n            yield\n            pw[:] = pw / pw.max()\n            img = pw.value\n        elif _type == RPROJ_FILT:\n            result = self.post_filter(self._current_cylindrical_img(idx, pos, depth))\n            if isinstance(result, Exception):\n                return self._show_overlay_text_cb.with_args(result)\n            yield\n            ft = result.fft(shift=False, dims=\"rya\")\n            yield\n            peaks = self._infer_peak_positions(ft)\n            if isinstance(peaks, Exception):\n                return self._show_overlay_text_cb.with_args(peaks)\n            yield\n            mask = _create_mask(ft.shape[1:], peaks)\n            yield\n            ft0 = ft[0] * mask\n            img = ft0.ifft(shift=False, dims=ft0.axes).value\n        else:\n            raise RuntimeError(_type)\n\n        yield\n\n        @thread_worker.callback\n        def _update_image():\n            self.canvas.image = img\n            self.canvas.text_overlay.visible = False\n            factor = self.params._old_binsize / self.params.binsize\n            if factor != 1:\n                xlim = [(v + 0.5) * factor - 0.5 for v in self.canvas.xlim]\n                ylim = [(v + 0.5) * factor - 0.5 for v in self.canvas.ylim]\n                self.canvas.xlim = xlim\n                self.canvas.ylim = ylim\n            self.params._old_binsize = self.params.binsize\n            self._update_circles(self._get_radius())\n\n        yield _update_image\n\n        if update_clim:\n            lims = img.min(), img.max()\n\n            @thread_worker.callback\n            def _update_clim():\n                self.canvas.contrast_limits = lims\n\n            return _update_clim\n        return None\n\n    def _show_overlay_text(self, txt):\n        self.canvas.text_overlay.visible = True\n        self.canvas.text_overlay.text = str(txt)\n        self.canvas.text_overlay.anchor = (0, 0)\n        self.canvas.text_overlay.color = \"yellow\"\n        self.canvas.text_overlay.font_size = 20\n        del self.canvas.image\n        return\n\n    @thread_worker.callback\n    def _show_overlay_text_cb(self, txt):\n        return self._show_overlay_text(txt)\n\n    def _current_cartesian_img(\n        self, idx: int, pos: nm, depth: nm\n    ) -&gt; \"ip.ImgArray | Exception\":\n        \"\"\"Return local Cartesian image at the current position.\"\"\"\n        binsize = self.params.binsize\n        if self.radius is None:\n            hwidth = None\n        else:\n            hwidth = self.radius + self.thickness_outer * 2\n        try:\n            return self.get_cartesian_image(\n                idx,\n                pos,\n                depth=depth,\n                binsize=binsize,\n                half_width=hwidth,\n                order=1,\n                use_orig_config=False,\n            )\n        except Exception as e:\n            return e\n\n    def _current_cylindrical_img(\n        self, idx: int, pos: nm, depth: nm\n    ) -&gt; \"ip.ImgArray | Exception\":\n        \"\"\"Return cylindric-transformed image at the current position\"\"\"\n        binsize = self.params.binsize\n        try:\n            return self.get_cylindric_image(\n                idx,\n                pos,\n                depth=depth,\n                binsize=binsize,\n                radius=self.radius,\n                order=1,\n                use_orig_config=False,\n            )\n        except Exception as e:\n            return e\n\n    def _current_cps(self, idx: int, pos: nm, depth: nm) -&gt; \"ip.ImgArray | Exception\":\n        \"\"\"Return local power spectrum at the current position.\"\"\"\n        binsize = self.params.binsize\n        try:\n            return self.get_cylindric_power_spectrum(\n                idx,\n                pos,\n                depth=depth,\n                binsize=binsize,\n                order=1,\n                use_orig_config=False,\n            )\n        except Exception as e:\n            return e\n\n    def _get_radius(self) -&gt; nm:\n        if self.radius is None:\n            idx = self.controller.spline_id\n            if idx is None:\n                raise ValueError(\"No spline exists.\")\n            spl = self._get_main().tomogram.splines[idx]\n            return spl.radius\n        return self.radius\n\n    @nogui\n    def get_cartesian_image(\n        self,\n        spline: int,\n        pos: nm,\n        *,\n        depth: nm = 50.0,\n        binsize: int = 1,\n        order: int = 3,\n        half_width: nm | None = None,\n        use_orig_config: bool = True,\n    ) -&gt; ip.ImgArray:\n        \"\"\"Get XYZ-coordinated image along a spline.\n\n        Parameters\n        ----------\n        spline : int\n            The spline index.\n        pos : nm\n            Position of the center of the image. `pos` nm from the spline start\n            point will be used.\n        depth : nm, default 50.0\n            Depth of the output image. Depth corresponds to the length of the\n            direction parallel to the spline vector at the given position.\n        binsize : int, default\n            Image bin size to use.\n        order : int, default 3\n            Interpolation order.\n        half_width : nm, optional\n            Half width size of the image. (depth, 2 * half_width, 2 * half_width)\n            will be the output image shape.\n\n        Returns\n        -------\n        ip.ImgArray\n            Cropped XYZ image.\n        \"\"\"\n        tomo = self._get_main().tomogram\n        spl = tomo.splines[spline]\n        if half_width is None and spl.radius is None:\n            raise ValueError(\n                \"Radius not set to the spline. Measure spline radius using the \"\n                \"'Measure radius' button or manually set it by 'Radius (nm)' entry.\"\n            )\n        if use_orig_config:\n            r = half_width or spl.radius + spl.config.thickness_outer * 2\n        else:\n            r = half_width or spl.radius + self.thickness_outer * 2\n        coords = spl.translate(\n            [-tomo.multiscale_translation(binsize)] * 3\n        ).local_cartesian(\n            shape=(2 * r, 2 * r),\n            depth=depth,\n            u=pos / spl.length(),\n            scale=tomo.scale * binsize,\n        )\n        img = tomo._get_multiscale_or_original(binsize)\n        out = map_coordinates(img, coords, order=order)\n        out = ip.asarray(out, axes=\"zyx\")\n        out.set_scale(img, unit=img.scale_unit)\n        return out\n\n    @nogui\n    def get_cylindric_image(\n        self,\n        spline: int,\n        pos: nm,\n        *,\n        depth: nm = 50.0,\n        binsize: int = 1,\n        order: int = 3,\n        radius: nm | None = None,\n        use_orig_config: bool = True,\n    ) -&gt; ip.ImgArray:\n        \"\"\"Get RY\u0398-coordinated cylindric image.\n\n        Parameters\n        ----------\n        spline : int\n            The spline index.\n        pos : nm\n            Position of the center of the image. `pos` nm from the spline start\n            point will be used.\n        depth : nm, default 50.0\n            Depth of the output image. Depth corresponds to the length of the\n            direction parallel to the spline vector at the given position.\n        binsize : int, default 1\n            Image bin size to use.\n        order : int, default 3\n            Interpolation order.\n        radius : nm, optional\n            Radius peak of the cylinder.\n\n        Returns\n        -------\n        ip.ImgArray\n            Cylindric image.\n        \"\"\"\n        tomo = self._get_main().tomogram\n        spl = tomo.splines[spline]\n        r = radius or spl.radius\n        if r is None:\n            raise ValueError(\"Radius not available in the input spline.\")\n        img = tomo._get_multiscale_or_original(binsize)\n        _scale = img.scale.x\n        rmin, rmax = spl.with_config(\n            {\n                \"thickness_inner\": self.thickness_inner,\n                \"thickness_outer\": self.thickness_outer,\n            },\n            copy_props=True,\n        ).radius_range()\n        spl_trans = spl.translate([-tomo.multiscale_translation(binsize)] * 3)\n        anc = pos / spl.length()\n        coords = spl_trans.local_cylindrical((rmin, rmax), depth, anc, scale=_scale)\n        return get_polar_image(img, coords, radius=(rmin + rmax) / 2, order=order)\n\n    @nogui\n    def get_cylindric_power_spectrum(\n        self,\n        spline: int,\n        pos: nm,\n        *,\n        depth: nm = 50.0,\n        binsize: int = 1,\n        order: int = 3,\n        use_orig_config: bool = True,\n    ) -&gt; ip.ImgArray:\n        \"\"\"Get cylindric power spectrum of given position.\n\n        Parameters\n        ----------\n        spline : int\n            The spline index.\n        pos : nm\n            Position of the center of the image. `pos` nm from the spline start\n            point will be used.\n        depth : nm, default 50.0\n            Depth of the output image. Depth corresponds to the length of the\n            direction parallel to the spline vector at the given position.\n        binsize : int, default 1\n            Image bin size to use.\n        order : int, default 3\n            Interpolation order.\n\n        Returns\n        -------\n        ip.ImgArray\n            Cylindric power spectrum.\n        \"\"\"\n        result = self.get_cylindric_image(\n            spline,\n            pos,\n            depth=depth,\n            binsize=binsize,\n            order=order,\n            use_orig_config=use_orig_config,\n        )\n        pw = result.power_spectra(zero_norm=True, dims=\"rya\").mean(axis=\"r\")\n        return pw\n\n    @bind_key(\"Esc\")\n    def _close_this_window(self):\n        return self.close()\n\n    def _infer_peak_positions(\n        self,\n        img_cyl: ip.ImgArray,\n        vsub: int = 2,\n        hsub: int = 1,\n        max_order: int = 1,\n    ) -&gt; \"list[tuple[float, float]] | ValueError\":\n        cp = self._current_cparams\n        if cp is None:\n            return ValueError(\"No spline parameter can be used.\")\n        idx = self.controller.spline_id\n        if idx is None:\n            return ValueError(\"No spline exists.\")\n        ya_ratio = img_cyl.scale.y / img_cyl.scale.a\n        vy = img_cyl.scale.y / cp.pitch\n        vx = vy * cp.tan_rise_raw / ya_ratio\n        hx = img_cyl.scale.a / cp.lat_spacing_proj\n        hy = hx * cp.tan_skew / ya_ratio\n        v = np.array([vy, vx]) / vsub\n        h = np.array([hy, hx]) / hsub\n        v0, h0 = max_order * vsub, max_order * hsub\n        vmesh, hmesh = np.meshgrid(range(-v0, v0 + 1), range(-h0, h0 + 1))\n        pos_all = vmesh.reshape(-1, 1) * v + hmesh.reshape(-1, 1) * h\n        posv = pos_all[:, 0]\n        posh = pos_all[:, 1]\n        pos_valid = (\n            (-0.5 &lt;= posv)\n            &amp; (posv &lt;= 0.5)\n            &amp; (-0.5 &lt;= posh)\n            &amp; (posh &lt;= 0.5)\n            &amp; (posv**2 + posh**2 &gt; 0)\n        )\n        pos = pos_all[pos_valid]\n        ny = img_cyl.shape.y\n        na = img_cyl.shape.a\n        return [(p[0] * ny, p[1] * na) for p in pos]\n</code></pre>"},{"location":"api/widgets/subwidgets/#cylindra.widgets.subwidgets.SplineSlicer.controller","title":"<code>controller</code>","text":"<p>Control spline positions.</p> <p>Attributes:</p> Name Type Description <code>spline_id</code> <code>int</code> <p>Current spline ID to analyze.</p> <code>pos</code> <code>nm</code> <p>Position along the spline in nm.</p> Source code in <code>cylindra/widgets/subwidgets/slicer.py</code> <pre><code>@magicclass(widget_type=\"frame\")\nclass controller(ChildWidget):\n    \"\"\"Control spline positions.\n\n    Attributes\n    ----------\n    spline_id : int\n        Current spline ID to analyze.\n    pos : nm\n        Position along the spline in nm.\n    \"\"\"\n\n    def _get_spline_id(self, widget=None) -&gt; \"list[tuple[str, int]]\":\n        try:\n            return self._get_main()._get_splines(widget)\n        except Exception:\n            return []\n\n    spline_id = vfield(label=\"Spline\").with_choices(_get_spline_id)\n    pos = field(nm, label=\"Position (nm)\", widget_type=\"FloatSlider\").with_options(max=0)  # fmt: skip\n</code></pre>"},{"location":"api/widgets/subwidgets/#cylindra.widgets.subwidgets.SplineSlicer.params","title":"<code>params</code>","text":"<p>Slicing parameters.</p> <p>Attributes:</p> Name Type Description <code>depth</code> <code>float</code> <p>The depth of the projection along splines. For instance, depth=50.0 means that Y-projection will be calculated using subvolume of size L * 50.0 nm * L.</p> <code>binsize</code> <code>int</code> <p>The size of the binning. For instance, binsize=2 means that the image will be binned by 2 before projection and/or Fourier transformation.</p> Source code in <code>cylindra/widgets/subwidgets/slicer.py</code> <pre><code>@magicclass(layout=\"horizontal\")\nclass params(ChildWidget):\n    \"\"\"Slicing parameters.\n\n    Attributes\n    ----------\n    depth : float\n        The depth of the projection along splines. For instance, depth=50.0 means\n        that Y-projection will be calculated using subvolume of size L * 50.0 nm * L.\n    binsize : int\n        The size of the binning. For instance, binsize=2 means that the image will\n        be binned by 2 before projection and/or Fourier transformation.\n    \"\"\"\n\n    def __init__(self):\n        self._old_binsize = 1\n\n    def _get_available_binsize(self, widget=None) -&gt; \"list[int]\":\n        try:\n            return self._get_main()._get_available_binsize(widget)\n        except Exception:\n            return []\n\n    depth = vfield(50.0, label=\"depth (nm)\").with_options(min=1.0, max=200.0)\n    binsize = vfield().with_choices(_get_available_binsize)\n</code></pre>"},{"location":"api/widgets/subwidgets/#cylindra.widgets.subwidgets.SplineSlicer.apply_radius_and_thickness","title":"<code>apply_radius_and_thickness()</code>","text":"<p>Apply the current radius and thickness to the current spline.</p> Source code in <code>cylindra/widgets/subwidgets/slicer.py</code> <pre><code>@set_design(text=\"Apply radius and thickness\", location=Row3)\ndef apply_radius_and_thickness(self):\n    \"\"\"Apply the current radius and thickness to the current spline.\"\"\"\n    idx = self.controller.spline_id\n    main = self._get_main()\n    main.update_spline_config(\n        [idx],\n        thickness_inner=self.thickness_inner,\n        thickness_outer=self.thickness_outer,\n    )  # fmt: skip\n    if (r0 := self.radius) is not None:\n        main.set_radius([idx], r0)\n    self._spline_changed(idx, refer_config=False)\n</code></pre>"},{"location":"api/widgets/subwidgets/#cylindra.widgets.subwidgets.SplineSlicer.fit_spline_manually","title":"<code>fit_spline_manually()</code>","text":"<p>Open the spline fitter and run fitting tasks there.</p> Source code in <code>cylindra/widgets/subwidgets/slicer.py</code> <pre><code>@set_design(text=\"Fit spline manually ...\", location=Row3)\ndef fit_spline_manually(self):\n    \"\"\"Open the spline fitter and run fitting tasks there.\"\"\"\n    main = self._get_main()\n    main.SplinesMenu.Fitting.fit_splines_manually()\n    main.spline_fitter.num.value = self.controller.spline_id\n</code></pre>"},{"location":"api/widgets/subwidgets/#cylindra.widgets.subwidgets.SplineSlicer.get_cartesian_image","title":"<code>get_cartesian_image(spline, pos, *, depth=50.0, binsize=1, order=3, half_width=None, use_orig_config=True)</code>","text":"<p>Get XYZ-coordinated image along a spline.</p> <p>Parameters:</p> Name Type Description Default <code>spline</code> <code>int</code> <p>The spline index.</p> required <code>pos</code> <code>nm</code> <p>Position of the center of the image. <code>pos</code> nm from the spline start point will be used.</p> required <code>depth</code> <code>nm</code> <p>Depth of the output image. Depth corresponds to the length of the direction parallel to the spline vector at the given position.</p> <code>50.0</code> <code>binsize</code> <code>(int, default)</code> <p>Image bin size to use.</p> <code>1</code> <code>order</code> <code>int</code> <p>Interpolation order.</p> <code>3</code> <code>half_width</code> <code>nm</code> <p>Half width size of the image. (depth, 2 * half_width, 2 * half_width) will be the output image shape.</p> <code>None</code> <p>Returns:</p> Type Description <code>ImgArray</code> <p>Cropped XYZ image.</p> Source code in <code>cylindra/widgets/subwidgets/slicer.py</code> <pre><code>@nogui\ndef get_cartesian_image(\n    self,\n    spline: int,\n    pos: nm,\n    *,\n    depth: nm = 50.0,\n    binsize: int = 1,\n    order: int = 3,\n    half_width: nm | None = None,\n    use_orig_config: bool = True,\n) -&gt; ip.ImgArray:\n    \"\"\"Get XYZ-coordinated image along a spline.\n\n    Parameters\n    ----------\n    spline : int\n        The spline index.\n    pos : nm\n        Position of the center of the image. `pos` nm from the spline start\n        point will be used.\n    depth : nm, default 50.0\n        Depth of the output image. Depth corresponds to the length of the\n        direction parallel to the spline vector at the given position.\n    binsize : int, default\n        Image bin size to use.\n    order : int, default 3\n        Interpolation order.\n    half_width : nm, optional\n        Half width size of the image. (depth, 2 * half_width, 2 * half_width)\n        will be the output image shape.\n\n    Returns\n    -------\n    ip.ImgArray\n        Cropped XYZ image.\n    \"\"\"\n    tomo = self._get_main().tomogram\n    spl = tomo.splines[spline]\n    if half_width is None and spl.radius is None:\n        raise ValueError(\n            \"Radius not set to the spline. Measure spline radius using the \"\n            \"'Measure radius' button or manually set it by 'Radius (nm)' entry.\"\n        )\n    if use_orig_config:\n        r = half_width or spl.radius + spl.config.thickness_outer * 2\n    else:\n        r = half_width or spl.radius + self.thickness_outer * 2\n    coords = spl.translate(\n        [-tomo.multiscale_translation(binsize)] * 3\n    ).local_cartesian(\n        shape=(2 * r, 2 * r),\n        depth=depth,\n        u=pos / spl.length(),\n        scale=tomo.scale * binsize,\n    )\n    img = tomo._get_multiscale_or_original(binsize)\n    out = map_coordinates(img, coords, order=order)\n    out = ip.asarray(out, axes=\"zyx\")\n    out.set_scale(img, unit=img.scale_unit)\n    return out\n</code></pre>"},{"location":"api/widgets/subwidgets/#cylindra.widgets.subwidgets.SplineSlicer.get_cylindric_image","title":"<code>get_cylindric_image(spline, pos, *, depth=50.0, binsize=1, order=3, radius=None, use_orig_config=True)</code>","text":"<p>Get RY\u0398-coordinated cylindric image.</p> <p>Parameters:</p> Name Type Description Default <code>spline</code> <code>int</code> <p>The spline index.</p> required <code>pos</code> <code>nm</code> <p>Position of the center of the image. <code>pos</code> nm from the spline start point will be used.</p> required <code>depth</code> <code>nm</code> <p>Depth of the output image. Depth corresponds to the length of the direction parallel to the spline vector at the given position.</p> <code>50.0</code> <code>binsize</code> <code>int</code> <p>Image bin size to use.</p> <code>1</code> <code>order</code> <code>int</code> <p>Interpolation order.</p> <code>3</code> <code>radius</code> <code>nm</code> <p>Radius peak of the cylinder.</p> <code>None</code> <p>Returns:</p> Type Description <code>ImgArray</code> <p>Cylindric image.</p> Source code in <code>cylindra/widgets/subwidgets/slicer.py</code> <pre><code>@nogui\ndef get_cylindric_image(\n    self,\n    spline: int,\n    pos: nm,\n    *,\n    depth: nm = 50.0,\n    binsize: int = 1,\n    order: int = 3,\n    radius: nm | None = None,\n    use_orig_config: bool = True,\n) -&gt; ip.ImgArray:\n    \"\"\"Get RY\u0398-coordinated cylindric image.\n\n    Parameters\n    ----------\n    spline : int\n        The spline index.\n    pos : nm\n        Position of the center of the image. `pos` nm from the spline start\n        point will be used.\n    depth : nm, default 50.0\n        Depth of the output image. Depth corresponds to the length of the\n        direction parallel to the spline vector at the given position.\n    binsize : int, default 1\n        Image bin size to use.\n    order : int, default 3\n        Interpolation order.\n    radius : nm, optional\n        Radius peak of the cylinder.\n\n    Returns\n    -------\n    ip.ImgArray\n        Cylindric image.\n    \"\"\"\n    tomo = self._get_main().tomogram\n    spl = tomo.splines[spline]\n    r = radius or spl.radius\n    if r is None:\n        raise ValueError(\"Radius not available in the input spline.\")\n    img = tomo._get_multiscale_or_original(binsize)\n    _scale = img.scale.x\n    rmin, rmax = spl.with_config(\n        {\n            \"thickness_inner\": self.thickness_inner,\n            \"thickness_outer\": self.thickness_outer,\n        },\n        copy_props=True,\n    ).radius_range()\n    spl_trans = spl.translate([-tomo.multiscale_translation(binsize)] * 3)\n    anc = pos / spl.length()\n    coords = spl_trans.local_cylindrical((rmin, rmax), depth, anc, scale=_scale)\n    return get_polar_image(img, coords, radius=(rmin + rmax) / 2, order=order)\n</code></pre>"},{"location":"api/widgets/subwidgets/#cylindra.widgets.subwidgets.SplineSlicer.get_cylindric_power_spectrum","title":"<code>get_cylindric_power_spectrum(spline, pos, *, depth=50.0, binsize=1, order=3, use_orig_config=True)</code>","text":"<p>Get cylindric power spectrum of given position.</p> <p>Parameters:</p> Name Type Description Default <code>spline</code> <code>int</code> <p>The spline index.</p> required <code>pos</code> <code>nm</code> <p>Position of the center of the image. <code>pos</code> nm from the spline start point will be used.</p> required <code>depth</code> <code>nm</code> <p>Depth of the output image. Depth corresponds to the length of the direction parallel to the spline vector at the given position.</p> <code>50.0</code> <code>binsize</code> <code>int</code> <p>Image bin size to use.</p> <code>1</code> <code>order</code> <code>int</code> <p>Interpolation order.</p> <code>3</code> <p>Returns:</p> Type Description <code>ImgArray</code> <p>Cylindric power spectrum.</p> Source code in <code>cylindra/widgets/subwidgets/slicer.py</code> <pre><code>@nogui\ndef get_cylindric_power_spectrum(\n    self,\n    spline: int,\n    pos: nm,\n    *,\n    depth: nm = 50.0,\n    binsize: int = 1,\n    order: int = 3,\n    use_orig_config: bool = True,\n) -&gt; ip.ImgArray:\n    \"\"\"Get cylindric power spectrum of given position.\n\n    Parameters\n    ----------\n    spline : int\n        The spline index.\n    pos : nm\n        Position of the center of the image. `pos` nm from the spline start\n        point will be used.\n    depth : nm, default 50.0\n        Depth of the output image. Depth corresponds to the length of the\n        direction parallel to the spline vector at the given position.\n    binsize : int, default 1\n        Image bin size to use.\n    order : int, default 3\n        Interpolation order.\n\n    Returns\n    -------\n    ip.ImgArray\n        Cylindric power spectrum.\n    \"\"\"\n    result = self.get_cylindric_image(\n        spline,\n        pos,\n        depth=depth,\n        binsize=binsize,\n        order=order,\n        use_orig_config=use_orig_config,\n    )\n    pw = result.power_spectra(zero_norm=True, dims=\"rya\").mean(axis=\"r\")\n    return pw\n</code></pre>"},{"location":"api/widgets/subwidgets/#cylindra.widgets.subwidgets.SplineSlicer.measure_cft_here","title":"<code>measure_cft_here()</code>","text":"<p>Measure CFT parameters at the current position.</p> Source code in <code>cylindra/widgets/subwidgets/slicer.py</code> <pre><code>@set_design(text=\"Measure CFT\", location=Row2)\ndef measure_cft_here(self):\n    \"\"\"Measure CFT parameters at the current position.\"\"\"\n    idx, pos, depth = self._get_cropping_params()\n    binsize = self.params.binsize\n    radius = self._get_radius()\n    img = self.get_cylindric_image(\n        idx, pos, depth=depth, binsize=binsize, radius=radius, order=3\n    )\n    tomo = self._get_main().tomogram\n    spl = tomo.splines[idx]\n    analyzer = LatticeAnalyzer(spl.config)\n    rc = radius + (-spl.config.thickness_inner + self.thickness_outer) / 2\n    params = analyzer.estimate_lattice_params_polar(img, rc)\n    spl_info = _col(f\"spline ID = {idx}; position = {pos:.2f} nm\", color=\"#003FFF\")\n    _Logger.print_html(\n        f\"{spl_info}&lt;br&gt;\"\n        f\"{_col('spacing:')} {params.spacing:.3f} nm&lt;br&gt;\"\n        f\"{_col('rise angle:')} {params.rise_angle:.3f} \u00b0&lt;br&gt;\"\n        f\"{_col('rise length:')} {params.rise_length:.3f} nm&lt;br&gt;\"\n        f\"{_col('twist:')} {params.twist:.3f} \u00b0&lt;br&gt;\"\n        f\"{_col('skew angle:')} {params.skew:.3f} \u00b0&lt;br&gt;\"\n        f\"{_col('PF:')} {params.npf}&lt;br&gt;\"\n        f\"{_col('start:')} {params.start}\"\n    )\n</code></pre>"},{"location":"api/widgets/subwidgets/#cylindra.widgets.subwidgets.SplineSlicer.measure_clockwise","title":"<code>measure_clockwise()</code>","text":"<p>Measure if the helix is clockwise or counter-clockwise.</p> Source code in <code>cylindra/widgets/subwidgets/slicer.py</code> <pre><code>@set_design(text=\"Measure CW/CCW\", location=Row2)\ndef measure_clockwise(self):\n    \"\"\"Measure if the helix is clockwise or counter-clockwise.\"\"\"\n    idx, pos, depth = self._get_cropping_params()\n    binsize = self.params.binsize\n    radius = self._get_radius()\n    img = self.get_cylindric_image(\n        idx, pos, depth=depth, binsize=binsize, radius=radius, order=3\n    )\n    tomo = self._get_main().tomogram\n    spl = tomo.splines[idx]\n    is_cw = is_clockwise(spl.config, img)\n    spl_info = _col(f\"spline ID = {idx}; position = {pos:.2f} nm\", color=\"#003FFF\")\n    direction = \"clockwise\" if is_cw else \"counter-clockwise\"\n    _Logger.print_html(f\"{spl_info}&lt;br&gt;The helix is {_col(direction)}.\")\n</code></pre>"},{"location":"api/widgets/subwidgets/#cylindra.widgets.subwidgets.SplineSlicer.measure_radius","title":"<code>measure_radius()</code>","text":"<p>Measure the radius for the current spline.</p> Source code in <code>cylindra/widgets/subwidgets/slicer.py</code> <pre><code>@set_design(text=\"Measure radius\", location=Row2)\ndef measure_radius(self):\n    \"\"\"Measure the radius for the current spline.\"\"\"\n    idx = self.controller.spline_id\n    main = self._get_main()\n    main.measure_radius([idx], bin_size=self.params.binsize)\n    self.radius = main.tomogram.splines[idx].radius\n</code></pre>"},{"location":"api/widgets/subwidgets/#cylindra.widgets.subwidgets.SplineSlicer.refresh_widget_state","title":"<code>refresh_widget_state()</code>","text":"<p>Refresh widget state.</p> Source code in <code>cylindra/widgets/subwidgets/slicer.py</code> <pre><code>@set_design(text=\"Refresh\", location=Row3)\ndef refresh_widget_state(self):\n    \"\"\"Refresh widget state.\"\"\"\n    self._spline_changed(self.controller.spline_id, refer_config=False)\n    return self._update_canvas()\n</code></pre>"},{"location":"batch/","title":"Working with Many Projects","text":"<p><code>cylindra</code> provides methods and widgets to analyze across projects.</p> <ul> <li>Collect projects</li> <li>Construct batch loaders</li> <li>Average across projects</li> </ul>"},{"location":"batch/average/","title":"Average Across Projects","text":"<p>Subtomogram averaging and analysis can be similarly done as with single tomogram. All the functions are in the menubars on the right side. Instead of selecting a molecules-layer, for batch analysis you'll need to select a loader created as in Construct Batch Loaders.</p>"},{"location":"batch/collect_projects/","title":"Collect projects","text":"<p>The collect_projects method collects projects into a <code>ProjectSequence</code> object, a <code>list</code>-like container with <code>CylindraProject</code> objects.</p> <pre><code>from cylindra import collect_projects\n\ncol = collect_projects(\"path/to/root/*.tar\")\ncol\n</code></pre> Output:<pre><code>ProjectSequence with 20 projects such as CylindraProject(...)\n</code></pre>"},{"location":"batch/collect_projects/#collect-spline-properties","title":"Collect Spline Properties","text":"<p>To analyze all the splines properties in the projects, it is useful to collect them into a single <code>polars.DataFrame</code> object. <code>ProjectSequence</code> has methods to do this. These methods not only collect the properties, but add columns indicating which project or spline the properties belong to.</p> <ul> <li>\"spline-id\": the index of the spline in the project</li> <li>\"image-id\": the index of the image in the project</li> </ul>"},{"location":"batch/collect_projects/#collect_localprops","title":"<code>collect_localprops</code>","text":"<p>This method collects all the local properties of the splines in the projects. For example, following code plots the distribution of the \"twist\" parameters.</p> <pre><code>import matplotlib.pyplot as plt\n\ndf = col.collect_localprops()\nplt.hist(df[\"twist\"])\n</code></pre> <p>Asides from the local properties, it also adds the following columns:</p> <ul> <li>\"spl_pos\": the spline coordinate (between 0 and 1) of the corresponding point in the   spline. For example, if the local property is for the start point of the spline, this   value is 0.0.</li> <li>\"spl_dist\": the distance (nm) of the corresponding point from the start of the spline.</li> </ul>"},{"location":"batch/collect_projects/#collect_globalprops","title":"<code>collect_globalprops</code>","text":"<p>This method collects all the global properties of the splines in the projects. For example, following code returns the number of splines with each orientation.</p> <pre><code>df = col.collect_globalprops()\ndf[\"orientation\"].value_counts()\n</code></pre> Output:<pre><code>shape: (2, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 orientation \u2506 count \u2502\n\u2502 ---         \u2506 ---   \u2502\n\u2502 str         \u2506 u32   \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 MinusToPlus \u2506 12    \u2502\n\u2502 PlusToMinus \u2506 18    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"batch/collect_projects/#collect_joinedprops","title":"<code>collect_joinedprops</code>","text":"<p>This method collects all the local and global properties. The column names of the global properties will be suffixed with \"_glob\". The returned dataframe will have a lot of duplicate values, but it is very useful for rich analysis. For example, following code plots the distribution of the local \"twist\" parameters of 13-protofilament microtubules.</p> <pre><code>df = col.collect_joinedprops()\nplt.hist(df.filter(pl.col(\"npf_glob\") == 13)[\"twist\"])\n</code></pre>"},{"location":"batch/construct/","title":"Construct Batch Loaders","text":"<p>To run subtomogram averaging across many projects, you need to construct a \"batch subtomogram loader\". A batch subtomogram loader is basically a list of image and molecules that you are going to use. Therefore, you need to select the images and, for each image, the molecules.</p> <p>Methods are in the <code>ui.batch</code> namespace. The \"Batch Analysis\" widget is in the menu <code>Analysis &gt; Open batch analyzer</code> or Ctrl+K \u2192 B.</p>"},{"location":"batch/construct/#construct-in-gui","title":"Construct in GUI","text":""},{"location":"batch/construct/#1-add-projects","title":"1. Add projects","text":"<p>Loader construction in GUI begins with adding project files. In the \"Batch Analysis\" widget, there are two menubars. In the left one, click <code>File &gt; Add projects</code> or <code>File &gt; Add projects with wildcard path</code> to add project one by one.</p> <p></p>"},{"location":"batch/construct/#2-select-projects-and-molecules","title":"2. Select projects and molecules","text":"<p>After projects are added, you can select which projects and molecules to be included for loader construction by the checkboxes. You can also select them by name patterns; See <code>Select &gt; Select projects by pattern</code> and <code>Select &gt; Select molecules by pattern</code>.</p>"},{"location":"batch/construct/#3-filter-molecules","title":"3. Filter molecules","text":"<p>If the molecules need filtration, specify the expression in the \"Filter:\" box. Note that the spline global properties are also available as the expression with suffix \"_glob\". For example, to select molecules created from 13-pf microtubules, you can use the expression <code>col(\"npf_glob\") == 13</code>.</p>"},{"location":"batch/construct/#4-construct-a-loader","title":"4. Construct a loader","text":"<p>If everything is ready, click <code>Construct loader</code> button. After it asking you for the loader name, constructed loader will be added to the combo box on the right side.</p>"},{"location":"batch/construct/#construct-programmatically","title":"Construct Programmatically","text":"<p>If you construct loaders programmatically, the process is not split into steps as in GUI. You'll have to specify the paths, filter predicate and the name at once, and the loader will be constructed immediately.</p>"},{"location":"batch/construct/#low-level-api","title":"Low-level API","text":"<p> API: <code>construct_loader</code></p> <p>The low-level API is rarely used on the user side.</p> <pre><code>ui.batch.construct_loader(\n    paths=[\n        (\"path/to/image-0.tif\", [\"Mole-0.csv\"]),\n        (\"path/to/image-1.tif\", [\"Mole-0.csv\", \"Mole-1.csv\"]),\n    ],\n    predicate=None,\n    name=\"Loader\",\n)\n</code></pre>"},{"location":"batch/construct/#construct-from-a-list-of-paths","title":"Construct from a list of paths","text":"<p> API: <code>construct_loader_by_list</code></p> <p>The simplest way to construct a loader is to provide a list of paths of project files.</p> <pre><code>ui.batch.construct_loader_by_list(\n    project_paths=[\n        \"path/to/project-0.zip\",\n        \"path/to/project-1.zip\",\n        \"path/to/project-2.zip\",\n    ],\n    mole_pattern=\"*-ALN1.csv\",  # only use molecules with name ending with \"-ALN1.csv\"\n    predicate=\"col('npf_glob') == 13\",  # only use molecules from 13-pf microtubules\n    name=\"Loader\",\n)\n</code></pre> <p>File patterns can also be used.</p> <pre><code>ui.batch.construct_loader_by_list(\n    \"path/to/project-*.zip\",\n    mole_pattern=\"*-ALN1.csv\",  # only use molecules with name ending with \"-ALN1.csv\"\n    predicate=\"col('npf_glob') == 13\",  # only use molecules from 13-pf microtubules\n    name=\"Loader\",\n)\n</code></pre>"},{"location":"case_studies/","title":"Case Studies","text":""},{"location":"case_studies/#cryo-et-image-analysis","title":"Cryo-ET Image Analysis","text":"<ol> <li>Analyzing Local Structures with RMA</li> <li>Microtubule Seam-search</li> <li>Prepare Spline Configuration for Your Structure of Interest</li> <li>Segmented Subtomogram Averaging (SSTA)</li> </ol>"},{"location":"case_studies/#understanding-how-things-work","title":"Understanding How Things Work","text":"<ol> <li>Learning CFT</li> </ol>"},{"location":"case_studies/#miscellaneous-topics","title":"Miscellaneous Topics","text":"<ol> <li>Microtubule for Figures</li> </ol>"},{"location":"case_studies/custom_config/","title":"Prepare Spline Configuration for Your Structure of Interest","text":"<p>The default spline configuration on startup is optimized for microtubules. If you want to analyze other cylindrical structures, you need to define a custom spline configuration. This is a tedious task, but is very important for successful analysis.</p> <p>A sample containing tobacco mosaic virus (TMV) is used to make the example images below.</p>"},{"location":"case_studies/custom_config/#1-manually-fit-spline","title":"1. Manually fit spline","text":"<p>To define a custom configuration, you will have to prepare a well-fitted spline first.</p> <ol> <li>Draw a spline along your structure of interest. The length of the spline should be    50 - 200 nm, depending on the density of your structure.</li> <li>Open the spline fitter widget from <code>Splines &gt; Open spline fitter</code>.</li> <li>Click \"Auto-center all\" button. If the quality of your tomogram is good enough, you    should see the center of the overlay accurately follows the center of your structure.    If the auto-centering fails, you need to manually click the center of your structure    slice by slice.</li> <li>Click \"Fit\" button to apply the shift to the spline. This will update the spline    coordinates.</li> </ol> <p>If the spline is fitted correctly, you should see the spline follows the center of the structure in the napari viewer.</p> <p></p>"},{"location":"case_studies/custom_config/#2-measure-cylinder-radius-and-thickness","title":"2. Measure cylinder radius and thickness","text":"<p>Building a cylindrical coordinate system requires the radius and the thickness. Radius can be measured for every spline, but the thickness values must be properly predefined in the config.</p> <ol> <li>Open the spline slicer widget from <code>Splines &gt; Open spline slicer</code>. Because the radius    is not known yet, no image will be shown in the canvas.</li> <li>Click the \"Measure radius\" button. This will automatically measure the radius the    spline by detecting the peak of the radial profile around the spline. Cross-sectional    slice will be shown in the canvas, based on the radius. If the measured value largely    deviates from your expectation, you can manually adjust the \"Radius (nm)\" value in    the GUI.</li> <li>In the upper area of the widget, change the bin size and filter so that the    cross-sectional slice clearly displays the structure.</li> <li>Adjust the \"Inner thickness\" and \"Outer thickness\" parameters so that the circles    shown in the canvas accurately represent the inner and outer surfaces of your    structure. Cylindrical coordinate system will be constructed between these two    surfaces.</li> <li>Click \"Apply radius and thickness\" button to update spline radius and config.</li> </ol> <p></p>"},{"location":"case_studies/custom_config/#3-measure-lattice-parameters","title":"3. Measure lattice parameters","text":"<p>Now, we can accurately build the cylindrical coordinate system to measure the lattice parameters.</p> <ol> <li>Open the spectra inspector widget from <code>Analysis &gt; Open spectra inspector</code>.</li> <li>By default, the global-CFT power spectrum of your structure is shown in the canvas.    If you think the resolution of power spectrum is low, you can switch to \"Upsampled    global-CFT\" mode.</li> <li>Enable \"Select axial peak\" mode, and click the axial peak in the power spectrum.</li> <li>Enable \"Select angular peak\" mode, and click the angular peak in the power spectrum.</li> <li>The measured lattice parameters will be shown in the \"Measured parameters\" section.    For later use, you can log these parameters to the console.</li> </ol> <p></p>"},{"location":"case_studies/custom_config/#4-determine-config-parameters","title":"4. Determine config parameters","text":"<p>You now have lattice parameters of a representative segment of your structure. Based on these values, you can determine the config parameters. Open the config editor widget by following these steps:</p> <ol> <li>Open the spline slicer widget.</li> <li><code>thickness_inner</code> and <code>thickness_outer</code> ... Set to the same value as the values you      set in the spline slicer.</li> <li> <p><code>clockwise</code> ... Click \"Measure CW/CCW\" button. This method will measure whether the      current segment has a clockwise (CW) or counter-clockwise (CCW) slew and log the      result in the logger widget. If the result is \"clockwise\" and the current segment      visually appears to have the \"PlusToMinus\" polarity, set this parameter to      \"PlusToMinus\". Do the same for other cases.</p> </li> <li> <p>Open the spectra inspector widget.</p> </li> <li><code>npf_range</code>, <code>spacing_range</code> and <code>twist_range</code> ... Set to a range that covers the      measured parameters in the spectra inspector. There is no standard way to determine      the range, as the actual achievable range depends on both the heterogeneity of the      structure and the noise level of the reconstructed tomograms. The best way is to      try several segments from different tomograms and get a sense of the distribution.</li> <li><code>rise_range</code> and <code>rise_sign</code> ... If the \"rise\" value is positive, leave <code>rise_sign</code>      as is and set <code>rise_range</code> to a range that covers the measured value. If the \"rise\"      value is negative, invert <code>rise_sign</code> and set <code>rise_range</code> to a range that covers      the absolute value of the measured value. For example, if the measured \"rise\" is      -10.5\u00b0 and \"rise_sign\" is -1, you can set <code>rise_sign</code> to 1 and <code>rise_range</code> to      [8, 12].</li> </ol> <p>Range of nPF</p> <p>Although in some cases the number of protofilaments (nPF) is well known to be a fixed value, it is recommended to set a small range. This will help you notice the bad fitting results.</p> <p>Sign of rise</p> <p>The reason why we have a <code>rise_sign</code> parameter is that the <code>rise_angle</code> and <code>start</code> does not span the full minus to plus range for most type of structures, so we can just keep in mind that we always use the positive <code>rise_angle</code> and <code>start</code> \u2014 with <code>rise_sign</code> = 1, the lattice type of microtubule would be \"13_-3\", which is not what we usually see in the literature. Therefore, setting <code>rise_sign</code> does not have any mathematical meaning and will not affect the fitting result.</p>"},{"location":"case_studies/custom_config/#5-save-as-a-config-preset","title":"5. Save as a config preset","text":"<p>Click \"Save as new config\" button to save the current config as a new preset. You can load this preset in the future analyses using the \"Load preset\" on the left panel.</p>"},{"location":"case_studies/learning_cft/","title":"Learning CFT","text":"<p><code>cylindra</code> uses the cylindric Fourier transform (CFT) of a cylinder to calculate its lattice parameters. Although its mathematical background is not very complicated, understanding how lattice structures, tilt series acquisition schemes, and the orientation of the cylinder relative to the tilt axis will affect the CFT is not easy.</p> <p>In this section, you can learn how CFT changes as the result of different parameters by simulating cylindric structures by yourself.</p>"},{"location":"case_studies/learning_cft/#simulate-a-simple-cylinder","title":"Simulate a simple cylinder","text":"<p>Using the simulator widget, you can simulate a tomogram with different components, tilt angles, noise levels and so on. For now, we only need a simple cylinder in a tomogram, so a straight cylinder is enough. For this purpose, <code>create_image_with_straight_line</code> is useful.</p> <p>Note</p> <p>You can also run these methods in GUI. See Simulate Tomograms for more details.</p> <p>Open the integrated console by Ctrl+Shift+C and run:</p> <pre><code>length = 60.0\nui.simulator.create_image_with_straight_line(\n    length=length,  # length of the cylinder\n    size=(40.0, length, 40.0),  # size of the tomogram\n    scale=1.0,  # pixel scale (nm/pixel)\n    yxrotation=20.0,  # rotation of the cylinder (degrees) in the YX plane\n)\n</code></pre> <p>Hint</p> <ol> <li>The size of the empty image is very small to save the reconstruction time, but is    large enough to contain a small cylinder fragment.</li> <li>Don't use pixel sizes as fine as the actual data collection. CFT analysis does    not require high-frequency information, so smaller pixel size just increases the    computation time without any benefit. If the representative periodicity of the    lattice is <code>L</code>, optimal pixel size is between <code>L/8</code> and <code>L/4</code>    (0.5 - 1.0 nm/pixel for microtubules).</li> </ol> <p><code>generate_molecules</code> will assign the given lattice parameters to the spline and map molecules around the spline according to the parameters. Here we will use the parameters for the ordinary 14_3 microtubule.</p> <pre><code>ui.simulator.generate_molecules(\n    spline=0,\n    spacing=4.1,\n    twist=-0.25,\n    start=3,\n    npf=14,\n    radius=11.0\n)\n</code></pre> <p>The viewer canvas now shows a straight cylinder.</p> <p></p>"},{"location":"case_studies/learning_cft/#simulate-a-tomogram","title":"Simulate a tomogram","text":"<p>Now, we can simulate a tomogram with the generated molecules. Because we immediately need the tomogram in the viewer, we can use <code>simulate_tomogram_and_open</code>. You can download a low-resolution tubulin structure in the test directory of <code>cylindra</code> repository.</p> <pre><code>tubulin_path = \"path/to/tubulin.mrc\"\nmole_layer = ui.mole_layers[-1]  # the just added molecules layer\nui.simulator.simulate_tomogram_and_open(\n    components=[(mole_layer, tubulin_path)],\n    nsr=0.1,\n    tilt_range=(-60.0, 60.0),\n    n_tilt=21,\n    interpolation=1,\n)\n</code></pre> <p></p> <p>Hint</p> <p>You don't need to simulate as many tilt angles as the actual data collection. For most of the cases, 21 tilts between -60 and 60 degrees are enough. You can even use <code>n_tilt=13</code> with little difference.</p>"},{"location":"case_studies/learning_cft/#plot-the-power-spectrum","title":"Plot the power spectrum","text":"<p>To sample a short fragment from the tomogram, the <code>spline_slicer</code> widget is useful. It implements methods to get subtomograms and power spectra along the spline. Here we can use <code>get_cylindric_power_spectrum</code> to get the CFT of the cylinder.</p> <p>To plot the power spectra, we can use the popular <code>matplotlib</code> package.</p> <pre><code>img = ui.spline_slicer.get_cylindric_power_spectrum(spline=0, pos=length / 2)\nplt.imshow(img.imshow, cmap=\"gray\")  # plot the power spectrum\n</code></pre> <p></p>"},{"location":"case_studies/make_figure/","title":"Microtubule for Figures","text":"<p>Drawing a microtubule for figures (e.g., for a PowerPoint presentation) is not easy. You usually need to carefully place tubulins so that it looks real. The z-order of tubulins is also important but it is hard to manage.</p> <p>The simulator widget is useful for this purpose.</p>"},{"location":"case_studies/make_figure/#draw-a-spline","title":"Draw a spline","text":"<p>First, draw a spline that represents the microtubule.</p> <ul> <li>Create an empty image and draw manually</li> </ul> <p> API: <code>create_empty_image</code></p> <p> GUI: <code>Simulator widget &gt; Create &gt; Create empty image</code></p> <ul> <li>Create an image with a straight line</li> </ul> <p> API: <code>create_image_with_straight_line</code></p> <p> GUI: <code>Simulator widget &gt; Create &gt; Create image with straight line</code></p> <pre><code>ui.simulator.create_empty_image(size=(60.0, 80.0, 80.0), scale=0.5)\nui.register_path(coords=[[30, -157, 5], [30, -82, 30], [30, -11, 13], [30, 62, 39]])\n</code></pre>"},{"location":"case_studies/make_figure/#generate-tubulins","title":"Generate tubulins","text":"<p>Once splines are drawn, you can generate tubulins along the spline.</p> <pre><code>ui.simulator.generate_molecules(spline=0, spacing=4.08, twist=0.04, start=3, npf=13, radius=10.0)\n</code></pre> <p>You can also adjust the point size and the view mode from the layer control. In the <code>napari</code> file menu, you can copy or save the screenshot of the current view.</p> <p></p>"},{"location":"case_studies/make_figure/#color-by-and-tubulins","title":"Color by \u03b1- and \u03b2-tubulins","text":"<p>Manual seam-searching can be used for coloring tubulins.</p> <pre><code>ui.sta.seam_search_manually(\"Mole(Sim)-0\")  # assign 0 and 1 to tubulins\nui.paint_molecules(\"Mole(Sim)-0\", color_by=\"isotype-id\", cmap={0: \"#A2A2A2\", 1: \"#FFE2E2\"}, limits=(0, 1))\n</code></pre>"},{"location":"case_studies/rma/","title":"Analyzing Microtubule Local Structures with RMA","text":"<p>Because RMA is a highly precise refinement process, proper initialization of the molecule coordinates is crucial. In this section, we will show the routine for the accurate RMA analysis.</p>"},{"location":"case_studies/rma/#step-1-prepare-molecules-aligned-in-the-pattern-of-the-microtubule","title":"Step 1. Prepare molecules aligned in the pattern of the microtubule","text":"<ol> <li> <p>To properly initialize molecule coordinates on the surface of microtubules, splines    should be precisely fitted and the lattice parameters should be determined. These    steps are already described in the Fit Splines and    Measure Lattice Parameters sections.</p> </li> <li> <p>Molecules can now be mapped based on the spline curve and the determined lattice    parameters. You can simply use the <code>map_monomers</code> method (<code>Molecules &gt; From/To Splines &gt; Map monomers</code>) here, as is already described in Spline to Molecules. When you run this method, you should be careful about the    molecules orientation (<code>PlusToMinus</code> or <code>MinusToPlus</code>). This parameter depends on the    template images you prepared. This orientation should match the orientation of the    template images for the later analysis.</p> </li> <li> <p>Although the relative positions of the adjacent molecules are almost correct, the    center of each molecule does not necessarily coincide with the center of the tubulin    density in the tomogram. This is because we have not yet used the information of the    tubulin template image in the above steps. The Align Averaged Image section shows how to move the molecules to the    correct positions using <code>align_averaged</code> method. Success of this step can be checked by the output in the    logger, which shows the projections of the template (green) and the average (magenta)    images. You can further check it by subtomogram averaging of the aligned molecules.</p> <p></p> </li> </ol>"},{"location":"case_studies/rma/#step-2-refine-the-molecule-positions-by-rma","title":"Step 2. Refine the molecule positions by RMA","text":"<p>RMA can be performed by the align_all_rma method, but there are several tips to get better results.</p> <p>RMA is a constrained alignment algorithm that refines the positions of the molecules considering the constraint between longitudinal and lateral tubulin distances. If you set the constraints too strictly or out of the range of the actual structure, results will be highly biased. In the dialog for running RMA, you can preview the constraints overlaid on the histogram of the intermonomer distances.</p> <p></p> <p>Another useful way to determine the constraints is to use the distance array. In the \"longitudinal range (nm)\" and \"lateral range (nm)\" parameter fields, you can use the variable <code>d</code> as the distance array. This variable is an 1D <code>numpy.ndarray</code> object that contains all the distances between the molecules. You can use <code>d.mean() - 0.1</code>, for example, to set the lower limit of the longitudinal range to the mean distance minus 0.1 nm.</p> <p>After the RMA refinement, you can see the refined positions of the molecules. the molecules look very smooth even after the refinement using a single tubulin monomer as the template, owing to the constraints. By averagin all the molecules, you can check if RMA has been performed successfully.</p> <p></p>"},{"location":"case_studies/rma/#step-3-calculate-the-local-lattice-structures","title":"Step 3. Calculate the local lattice structures","text":"<p>As the post-processing of RMA, you will usually call <code>calculate_lattice_structure</code> to calculate the per-molecule lattice parameters. To denoise the estimations, you can also call <code>convolve_feature</code> to apply convolution filters to the features (similar to windowed filters on images but considering all the connectivity between the molecules). For the visualization, <code>paint_molecules</code> method is useful to color the molecules by the feature of interest.</p> <p></p>"},{"location":"case_studies/seam_search/","title":"Microtubule Seam-search","text":"<p>Microtubule seam-search is very important to separate \u03b1- and \u03b2-tubulins.</p> <p>What the seam-search algorithms in <code>cylindra</code> do is simply adding a new column named \"isotype-id\" to the molecules features. As seam-search is usually combined with subtomogram averaging and alignment, these methods are located in the STA widget.</p>"},{"location":"case_studies/seam_search/#seam-search-based-on-cross-correlation","title":"Seam-search Based on Cross-correlation","text":"<p> API: <code>seam_search</code></p> <p> GUI: <code>STA widget &gt; Analysis &gt; Seam search &gt; Seam search by correlation</code></p> <p>Although the structure of \u03b1/\u03b2-tubulins are very similar, it is known that trying all the possible patterns and comparing the cross-correlation is useful to distinguish them.</p> <p></p> List of parameters <ol> <li>\"layer\" is the molecules layer to be seam-searched.</li> <li>Set the template image and mask parameters in the STA widget.</li> <li>\"anti-template path\" is the path to the anti-template image.</li> <li>\"interpolation\" is the interpolation method used for resampling the sub-    volumes.</li> <li>\"npf\" is the number of protofilaments. If molecules are created in <code>cylindra</code>,    this value should already be determined by CFT.</li> <li>You can select how to (or not to) show all the averages for different seam    locations by the \"show averages as\" combobox.</li> <li>\"cutoff\" is the relative cutoff frequency of the low-pass filter. This value is    usually smaller than the value used for subtomogram alignment.</li> </ol> <p>Molecules labeled with <code>0</code> are the molecules that should be considered as the template, and <code>1</code> the anti-template.</p>"},{"location":"case_studies/seam_search/#manual-seam-search","title":"Manual Seam-search","text":"<p> API: <code>seam_search_manually</code></p> <p> GUI: <code>STA widget &gt; Analysis &gt; Seam search &gt; Seam search manually</code></p> <p>This method labels the molecules by the given seam location. <code>location=0</code> will label molecules with</p> <pre><code>[0, 0, ..., 0,\n 1, 1, ..., 1,\n 0, 0, ..., 0,\n 1, 1, ..., 1,]\n</code></pre> <p>and <code>location=1</code> will label molecules with</p> <pre><code>[1, 0, ..., 0,\n 0, 1, ..., 1,\n 1, 0, ..., 0,\n 0, 1, ..., 1,]\n</code></pre>"},{"location":"case_studies/seam_search/#seam-search-by-features","title":"Seam-search by Features","text":"<p> API: <code>seam_search_by_feature</code></p> <p> GUI: <code>STA widget &gt; Analysis &gt; Seam search &gt; Seam search by feature</code></p> <p>This method labels the molecules by the given feature. The feature should be such that approximately label the \u03b1- or \u03b2-tubulins. Usually, molecules should be labeled by classification using microtubule-associated proteins as the fiducials.</p>"},{"location":"case_studies/ssta/","title":"Segmented Subtomogram Averaging (SSTA)","text":"<p>Segmented subtomogram averaging (SSTA) was first introduced by Guyomar et al. In the SSTA workflow, subtomogram averaging is performed along the microtubules segment-by-segment so that the resulting averages reflect the local structural heterogeneity.</p> <p>In <code>cylindra</code>, SSTA can be easily performed owing to the powerful combination of the polars expression system and the built-in methods for cryo-ET.</p> <p>Note</p> <p>The EMPIAR deposition by the authors such as EMPIAR-11253 is very useful to test this workflow.</p>"},{"location":"case_studies/ssta/#preparation","title":"Preparation","text":"<p>After loading the tomogram and the microtubules are properly fitted with splines, molecules can be initialized along each spline at dimeric intervals. The interval can be described by the <code>polars</code> expression <code>col('pitch') * 2</code>, which is evaluated with the \"pitch\" value of spline global properties.</p> <pre><code>ui.infer_polarity(splines=\"all\")\nui.global_cft_analysis(splines=\"all\")  # to get lattice pitch\nui.map_along_spline(\n    splines=\"all\",\n    molecule_interval=\"col('pitch') * 2\",\n    prefix=\"Center\",\n)\n</code></pre> <p>You can further refine the molecules by aligning them to the pre-determined structure of microtubules such as EMD-7974.</p> <p>Note</p> <p>The template image must be rotated in the correct direction so that the axis of the template microtubule matches the y-axis.</p> <pre><code>ui.sta.align_all(\n    layers=['Center-0'],\n    template_path=\"path/to/template.mrc\",\n    mask_params=(0.3, 0.8),\n    max_shifts=(1.0, 1.0, 1.0),\n    rotations=((0.0, 0.0), (10.0, 2.0), (0.0, 0.0)),\n    cutoff=0.2,\n)\n</code></pre> <p>By the standard subtomogram averaging using <code>average_all</code>, you can check if the alignment was successful.</p> <pre><code>ui.sta.average_all(layers=['Center-0-ALN1'], size=48.0)\n</code></pre>"},{"location":"case_studies/ssta/#ssta","title":"SSTA","text":"<p>Molecules can be grouped by its features. This means that you can obtain averages for each group of molecules. The grouped averaging is a generalization of what SSTA supposed to do. What we need here is to correctly label the molecules for each segment, that is, a column with values like <code>[0, 0, 0, 1, 1, 1, ..., n-1, n-1, n-1]</code> is needed supposing that there are <code>n</code> segments.</p> <p>Molecules generated by <code>map_along_spline</code> are already labeled with the <code>nth</code> column, which takes the value of <code>[0, 1, ..., N-1]</code>. Expression <code>col('nth') // Ns</code> will group the molecules into segments of <code>Ns</code> molecules. Since we initialized molecules at dimeric intervals, the intervals are usually ~8.2 nm. For 100-nm SSTA, the <code>Ns</code> value should be \\(100 / 8.2 \\approx 12\\).</p> <pre><code>ui.sta.average_groups(\n    layers=['Center-0-ALN1'],\n    size=48.0,\n    by=\"col('nth') // 12\",\n)\n</code></pre>"},{"location":"extern/","title":"Working with Other Softwares","text":"<p>To maximize the power of computational tools, <code>cylindra</code> provides several functions to import and export data from other softwares. These functions are implemented as built-in plugins using the <code>cylindra</code> plugin system.</p> <p>Currently supported softwares are:</p> <ul> <li>IMOD</li> <li>RELION (\u22655.0.0)</li> </ul>"},{"location":"extern/imod/","title":"IMOD","text":"<p>\u2192 IMOD Home Page</p>"},{"location":"extern/imod/#analyzing-tomograms-reconstructed-by-imod","title":"Analyzing Tomograms Reconstructed by IMOD","text":""},{"location":"extern/imod/#open-a-tomogram-from-an-imod-project","title":"Open A Tomogram from An IMOD Project","text":"<p> API: <code>cylindra_builtins.imod.open_image_from_imod_project</code></p> <p> GUI: <code>Plugins &gt; IMOD &gt; Open image from an IMOD project</code></p> <p>This function uses the <code>.edf</code> files in an IMOD project to open a tomogram. Tilt angles are automatically detected based on the files inside the project directory. For the meaning of each parameter, see the <code>open_image</code> function.</p>"},{"location":"extern/imod/#open-multiple-tomograms-from-imod-projects","title":"Open Multiple Tomograms from IMOD Projects","text":"<p> API: <code>cylindra_builtins.imod.import_imod_projects</code></p> <p> GUI: <code>Plugins &gt; IMOD &gt; Import IMOD projects</code></p> <p>This function imports multiple tomograms from IMOD projects using wildcard paths or list of paths, and adds them directly to the <code>cylindra</code> batch analyzer. You can click the \"Open\" button of the batch analyzer one by one to analyze each tomogram.</p>"},{"location":"extern/imod/#create-a-prm-file-for-peet","title":"Create a <code>.prm</code> File for PEET","text":""},{"location":"extern/imod/#single-tomogram","title":"Single Tomogram","text":"<p> API: <code>cylindra_builtins.imod.export_project</code></p> <p> GUI: <code>Plugins &gt; IMOD &gt; Export project</code></p> <p>For subtomogram averaging and alignment, PEET uses a <code>.prm</code> file for the project configuration. This function refers to the STA widget and creates a <code>.prm</code> file according to the parameters in the widget.</p>"},{"location":"extern/imod/#multiple-tomograms","title":"Multiple Tomograms","text":"<p> API: <code>cylindra_builtins.imod.export_project_batch</code></p> <p> GUI: <code>Plugins &gt; IMOD &gt; Export project as batch</code></p>"},{"location":"extern/imod/#low-level-functions","title":"Low-level Functions","text":""},{"location":"extern/imod/#import-molecules-from-imod","title":"Import Molecules from IMOD","text":"<p> API: <code>cylindra_builtins.imod.load_molecules</code></p> <p> GUI: <code>Plugins &gt; IMOD &gt; Load molecules</code></p> <p>This function reads molecules from files in IMOD format, which are usually used in PEET. Molecule positions are defined in a <code>.mod</code> file, while the molecule rotations are in a CSV file. Additionally, offsets of each molecules may be recorded in the CSV file. By passing the paths to these files, this function add molecules to the viewer.</p>"},{"location":"extern/imod/#export-molecules-for-imod","title":"Export Molecules for IMOD","text":"<p> API: <code>cylindra_builtins.imod.save_molecules</code></p> <p> GUI: <code>Plugins &gt; IMOD &gt; Save molecules</code></p> <p>This function saves the selected molecules as a <code>.mod</code> file and a CSV file in the same directory. Saved files can be directly used in PEET.</p>"},{"location":"extern/imod/#import-lines-as-splines-from-imod","title":"Import Lines as Splines from IMOD","text":"<p> API: <code>cylindra_builtins.imod.load_splines</code></p> <p> GUI: <code>Plugins &gt; IMOD &gt; Load splines</code></p> <p>In IMOD, you can create segmented lines with such as <code>3dmod</code> viewer and save as a <code>.mod</code> file. The lines can be imported as splines in <code>cylindra</code>.</p>"},{"location":"extern/imod/#export-splines-for-imod","title":"Export Splines for IMOD","text":"<p> API: <code>cylindra_builtins.imod.save_splines</code></p> <p> GUI: <code>Plugins &gt; IMOD &gt; Save splines</code></p> <p><code>Spline</code> objects can be converted into segmented lines. This function saves the splines as segmented lines in a <code>.mod</code> file.</p> <p>Warning</p> <p>Reading a <code>.mod</code> file and saving back to a new <code>.mod</code> file does not preserve the original data.</p>"},{"location":"extern/relion/","title":"RELION","text":"<p>\u2192 RELION Documentation</p>"},{"location":"extern/relion/#utilities-for-working-with-relion","title":"Utilities for Working with RELION","text":""},{"location":"extern/relion/#opening-relion-jobs","title":"Opening RELION Jobs","text":"<p> API: <code>cylindra_builtins.relion.open_relion_job</code></p> <p> GUI: <code>Plugins &gt; RELION &gt; Open RELION job</code></p> <p>After reconstruction of a tomogram in RELION, the next step is usually to pick particles from the tomogram. You may also want to check the distribution of the refined particles in the tomogram. This method provides a convenient way to open a RELION job folder and load the tomograms (and particles) directly into the <code>cylindra</code> batch analyzer.</p> <p>In this method, you have to specify the path to the RELION <code>job.star</code> file, which contains the description of the job. Currently, following RELION jobs are supported:</p> <ul> <li>Reconstruct tomograms</li> <li>Denoise tomograms (predict)</li> <li>Pick tomograms</li> <li>Extract subotomos</li> <li>3D initial reference</li> <li>3D auto-refine</li> </ul>"},{"location":"extern/relion/#save-pick-results-for-import-to-relion","title":"Save Pick Results for Import to RELION","text":"<p> API: <code>cylindra_builtins.relion.save_molecules_for_import</code></p> <p> GUI: <code>Plugins &gt; RELION &gt; Save molecules for import</code></p> <p>This method saves the current state of the <code>cylindra</code> batch analyzer, which contains individual tomograms and multiple molecules, as an particle star file. This file can directly be used for the subtomogram extraction job in RELION. To do this, you need to set \"OR: use direct entries?\" to \"Yes\".</p>"},{"location":"extern/relion/#low-level-file-io","title":"Low-level File I/O","text":""},{"location":"extern/relion/#import-molecules-from-relion","title":"Import Molecules from RELION","text":"<p> API: <code>cylindra_builtins.relion.load_molecules</code></p> <p> GUI: <code>Plugins &gt; RELION &gt; Load molecules</code></p> <p>This function read a <code>.star</code> file and add the contents to the viewer as molecules.</p>"},{"location":"extern/relion/#export-molecules-for-relion","title":"Export Molecules for RELION","text":"<p> API: <code>cylindra_builtins.relion.save_molecules</code></p> <p> GUI: <code>Plugins &gt; RELION &gt; Save molecules</code></p> <p>This function saves the selected molecules as a <code>.star</code> file.</p>"},{"location":"extern/relion/#import-splines-from-relion","title":"Import Splines from RELION","text":"<p> API: <code>cylindra_builtins.relion.load_splines</code></p> <p> GUI: <code>Plugins &gt; RELION &gt; Load splines</code></p> <p>The positional coordinates are used for drawing splines. The \"rlnHelicalTubeID\" column is used to group the coordinates into each splines.</p>"},{"location":"extern/relion/#export-splines-for-relion","title":"Export Splines for RELION","text":"<p> API: <code>cylindra_builtins.relion.save_splines</code></p> <p> GUI: <code>Plugins &gt; RELION &gt; Save splines</code></p> <p><code>Spline</code> objects can be converted into segmented lines. This function saves the splines as segmented lines in a <code>.star</code> file. Following the convention, \"rlnHelicalTubeID\" are used as the column name for identifying each splines.</p> <p>Warning</p> <p>Reading a <code>.star</code> file and saving back to a new <code>.star</code> file does not preserve the original data.</p>"},{"location":"molecules/","title":"Molecules","text":"<p>In the field of cryo-ET, proper operations on molecules are essential to get a good result. In this section, you'll learn how to pick, filter, split, combine, transform and analyze molecules.</p> <ul> <li>Pick Molecules</li> <li>Spline to Molecules</li> <li>Molecule Features</li> <li>Expressions</li> <li>Filter molecules</li> <li>Split &amp; Combine</li> <li>Transform Molecules</li> <li>Feature Names</li> </ul>"},{"location":"molecules/expressions/","title":"The \"Expressions\"","text":"<p>In <code>cylindra</code>, molecules are processed largely depending on the expression system of <code>polars</code>. An expression is represented by a <code>polars.Expr</code> object. A <code>polars.Expr</code> object describes a computation that can be applied to a <code>polars.DataFrame</code> object, but at the moment it is created, it doesn't do any calculation.</p> <p>Let's start with a simple example using <code>polars.DataFrame</code>.</p> <pre><code>import polars as pl  # import polars module\n\n# create a DataFrame object\ndf = pl.DataFrame(\n    {\n        \"nth\": [0, 1, 2, 3],\n        \"score\": [0.8, 0.9, 0.4, 0.8]\n    },\n)\ndf\n</code></pre> Output:<pre><code>shape: (4, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 nth \u2506 score \u2502\n\u2502 --- \u2506 ---   \u2502\n\u2502 i64 \u2506 f64   \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 0   \u2506 0.8   \u2502\n\u2502 1   \u2506 0.9   \u2502\n\u2502 2   \u2506 0.4   \u2502\n\u2502 3   \u2506 0.8   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>You can create an expression for a filtration predicate.</p> <pre><code>pl.col(\"score\")  # expression indicating the column named \"score\"\npl.col(\"score\") &gt; 0.7  # expression of \"score is larger than 0.7\"\ndf_filt = df.filter(pl.col(\"score\") &gt; 0.7)  # here the expression is evaluated\ndf_filt\n</code></pre> Output:<pre><code>shape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 nth \u2506 score \u2502\n\u2502 --- \u2506 ---   \u2502\n\u2502 i64 \u2506 f64   \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 0   \u2506 0.8   \u2502\n\u2502 1   \u2506 0.9   \u2502\n\u2502 3   \u2506 0.8   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"molecules/expressions/#expressions-in-cylindra","title":"Expressions in <code>cylindra</code>","text":"<p>The expression system is very useful to describe how to process the molecules (or sometimes splines). It is used in the following methods:</p> <ul> <li>Set spline radius</li> <li>Calculate molecule features</li> <li>Filter molecules</li> <li>Average with filtered molecules</li> <li>Average groups of molecules</li> </ul> <p>In these methods, expressions are given as a <code>str</code>. <code>pl</code> and <code>col</code> is available in the namespace.</p>"},{"location":"molecules/features/","title":"Molecule Features","text":"<p>Molecules are tagged with features. For example, just after mapping molecules from a spline, features will be like this:</p> <pre><code>layer = ui.mole_layers[\"Mole-0\"]  # the molecules layer named \"Mole-0\"\nlayer.molecules.features\n</code></pre> Output:<pre><code>shape: (286, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 nth \u2506 pf-id \u2506 position-nm \u2502\n\u2502 --- \u2506 ---   \u2506 ---         \u2502\n\u2502 i64 \u2506 i64   \u2506 f64         \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 0   \u2506 0     \u2506 6.1548      \u2502\n\u2502 0   \u2506 1     \u2506 5.2079      \u2502\n\u2502 0   \u2506 2     \u2506 4.261       \u2502\n\u2502 0   \u2506 3     \u2506 3.3141      \u2502\n\u2502 \u2026   \u2506 \u2026     \u2506 \u2026           \u2502\n\u2502 21  \u2506 9     \u2506 83.7184     \u2502\n\u2502 21  \u2506 10    \u2506 82.7715     \u2502\n\u2502 21  \u2506 11    \u2506 81.8246     \u2502\n\u2502 21  \u2506 12    \u2506 80.8777     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>The molecule features are stored as a <code>polars.DataFrame</code> object. You can get any of the columns by <code>df[\"column-name\"]</code>.</p> <pre><code>import matplotlib.pyplot as plt\n\ndf = layer.molecules.features\nplt.scatter(df[\"pf-id\"], df[\"score\"])\nplt.show()\n</code></pre>"},{"location":"molecules/features/#paint-molecules-by-features","title":"Paint Molecules by Features","text":"<p> GUI: <code>Molecules &gt; View &gt; Paint molecules</code> or Ctrl+K \u2192 C</p> <p>This method updates the color of each molecule according to the value of a feature column.</p> <p></p>"},{"location":"molecules/features/#calculate-features","title":"Calculate Features","text":"<p> API: <code>calculate_molecule_features</code></p> <p> GUI: <code>Molecules &gt; Features &gt; Calculate molecule features</code></p> <p>This method calculates features from the existing features. The input argument should follow the <code>polars expression</code> syntax.</p> calculate molecule features <p>Following function call will add a new feature named \"pf-is-odd\" to the molecules layer, which indicates whether the molecule id is odd or not.</p> <pre><code>ui.calculate_molecule_features(\n    layer=\"Mole-0\",\n    column_name=\"pf-is-odd\",\n    expression=\"col('pf-id') % 2 == 1\",\n)\nprint(ui.mole_layers[\"Mole-0\"].molecules.features[\"pf-is-odd\"])  # print the feature\n</code></pre>"},{"location":"molecules/features/#calculate-lattice-structures","title":"Calculate Lattice Structures","text":"<p> API: <code>calculate_lattice_structure</code></p> <p> GUI: <code>Molecules &gt; Features &gt; Calculate lattice structure</code></p> <p>Some of the structural parameters equivalent to CFT parameters can be calculated from the molecule coordinates and spline parameters.</p> calculate spacing and twist <pre><code>ui.calculate_lattice_structure(\n    layer=\"Mole-0\",\n    props=[\"spacing\", \"twist\"],\n)\n</code></pre>"},{"location":"molecules/filter_molecules/","title":"Filter Molecules by Features","text":"<p>Filtering refers to the process of selecting a subset of molecules based on given criteria (not image processing such as Gaussian filter). This operation is very useful for rich data analysis.</p>"},{"location":"molecules/filter_molecules/#run-filtering","title":"Run Filtering","text":"<p> API: <code>filter_molecules</code></p> <p> GUI: <code>Molecules &gt; Filter molecules</code></p> <p>This method uses one of the features tagged to the molecules to determine which molecules will be filtered.</p> <p></p> List of parameters <ol> <li>\"layer\" is the molecules layer that will be filtered.</li> <li>\"predicate\" uses <code>polars</code> expression to describe filtering conditions.</li> <li>If the source spline of the original molecules should be inherited to the    filtered molecules, check \"Inherit source spline\".</li> <li>Check \"Preview\" to see the result of the filtering in the viewer. Preview    will be updated when you change the predicate.</li> </ol> <p>The filtered molecules will be added to the viewer as a new layer with suffix <code>\"-Filt\"</code>.</p>"},{"location":"molecules/filter_molecules/#examples","title":"Examples","text":""},{"location":"molecules/filter_molecules/#1-collect-molecules-from-the-tips","title":"1. Collect molecules from the tips","text":"<pre><code>ui.filter_molecules(\"Mole-0\", predicate=\"col('position-nm') &lt; 100\")\nui.mole_layers[\"Mole-0-Filt\"]\n</code></pre>"},{"location":"molecules/filter_molecules/#2-collect-molecules-close-to-a-point","title":"2. Collect molecules close to a point","text":"<p>Coordinates of the molecules can be accessed by column name <code>x</code>, <code>y</code>, and <code>z</code>.</p> <pre><code># square of distance from (10, 20, 15)\ndist2 = (pl.col(\"z\") - 10) ** 2 + (pl.col(\"y\") - 20) ** 2 + (pl.col(\"x\") - 15) ** 2\n\n# molecules whose distance from (10, 20, 15) is less than 50\nis_close = dist2 &lt; 50 ** 2\n\nui.filter_molecules(\"Mole-0\", predicate=is_close)\n</code></pre>"},{"location":"molecules/headers/","title":"Feature Names","text":"<p>Here's the list of the standard feature names and how they will be added.</p> <ul> <li> <p><code>\"nth\"</code></p> <p>The n-th molecule of a protofilament starting from 0. If this value is 3, it means the molecule is the 4th molecule from the tip (= the starting edge of the source spline).</p> <p>This feature is added by:</p> <ul> <li>map_monomers</li> <li>map_monomers_with_extensions</li> </ul> </li> <li> <p><code>\"pf-id\"</code></p> <p>The protofilament ID. Molecules labeled with the same <code>pf-id</code> belong to the same protofilament.</p> <p>This feature is added by:</p> <ul> <li>map_monomers</li> <li>map_monomers_with_extensions</li> </ul> </li> <li> <p><code>\"position\"</code></p> <p>The position of the molecule in the spline coordinate (in nm). This value is useful when you want to know in which position the molecule is located along the spline.</p> <p>This feature is added by:</p> <ul> <li>map_monomers</li> <li>map_monomers_with_extensions</li> </ul> </li> <li> <p><code>\"isotype-id\"</code></p> <p>The isotype ID. Molecules labeled with the same <code>isotype-id</code> belong to the same isotype.</p> <p>This feature is added by:</p> <ul> <li>seam_search</li> <li>seam_search_by_feature</li> <li>seam_search_manually</li> </ul> </li> <li> <p><code>\"score\"</code></p> <p>The alignment score. Higher scores indicate better alignment. Note that the score may be affected by the missing wedge.</p> <p>This feature is added by:</p> <ul> <li>align_all</li> <li>align_all_template_free</li> <li>align_all_viterbi</li> <li>align_all_rma</li> <li>align_all_rfa</li> <li>run_align_on_landscape</li> <li>run_viterbi_on_landscape</li> <li>run_rma_on_landscape</li> <li>run_rfa_on_landscape</li> </ul> </li> </ul> <p>Following values are measured by calculate_lattice_structure.</p> <ul> <li><code>\"spacing\"</code>: projected distance between the longitudinally adjacent molecules.</li> <li><code>\"twist\"</code>: the twist angle between the longitudinally adjacent molecules in degrees.</li> <li><code>\"skew\"</code>: the projected skew angle between the longitudinally adjacent molecules in degrees.</li> <li><code>\"rise\"</code>: the projected rise angle between the laterally adjacent molecules in degrees.</li> <li><code>\"lateral-interval\"</code>: the projected distance between the laterally adjacent molecules.</li> <li><code>\"radius\"</code>: the radius as a cylinder measured from the spline.</li> <li><code>\"curve-index\"</code>: a quantity \u03b7 defined between -1 and 1 that represents whether the   molecule is inside or outside the curve. \u03b7 is calculated by taking the dot product   of the second derivative of the spline and the vector from the spline to the molecule.   Therefore, \u03b7 &gt; 0 means the molecule is inside the curve, and \u03b7 &lt; 0 means the   molecule is outside the curve.</li> <li><code>\"lateral-angle\"</code>: the angle formed by the left and right laterally adjacent molecules.</li> <li><code>\"elevation-angle\"</code>: the angle formed by the vector pointing to the longitudinally   adjacent molecule and the spline tangent vector.</li> </ul>"},{"location":"molecules/pick_molecules/","title":"Pick Molecules","text":"<p>In cryo-ET, particle picking is a critical step for subsequent subtomogram averaging and structural analysis. Although there are many powerful automatic picking tools available to this field, manual picking is still important for many cases.</p> <p>In <code>cylindra</code>,</p> <p>Note</p> <p>If you want to automatically generate molecules along splines rather than picking one by one, see Spline to Molecules.</p>"},{"location":"molecules/pick_molecules/#manual-pick-from-tomogram","title":"Manual pick from tomogram","text":"<p> API: <code>register_molecules</code></p> <p> GUI: <code>Molecules &gt; Register molecules</code></p> <p>As for drawing splines, manually added points in the <code>napari</code> viewer can be converted into molecules with this method. Regardless of how the points were added, this method will work properly without affecting macro recording, as long as the points are added in the drawing layer. This means that you can use any functionalities or <code>napari</code> plugins to pick molecules.</p>"},{"location":"molecules/pick_molecules/#manual-pick-along-splines","title":"Manual pick along splines","text":"<p> GUI: <code>Image &gt; Open manual picker</code></p> <p>Because <code>cylindra</code> has many functions to manipulate splines, sometimes picking molecules along splines will be more efficient. This is especially useful to look for binding proteins along cylindrical structures, such as MAPs on microtubules.</p> <p>The manual picker widget in <code>cylidnra</code> is designed for this purpose. It makes a \"plane\" along the specified spline which can be moved, rotated or shifted relative to the spline. You can imaging you set a camera on a drone and fly it in the spline orbit; you can change the camera angles and focus to take pictures.</p> <p></p> <p>The center of the plane is first defined by the specified position on the spline. The plane normal is parallel to the spline tangent vector, so that the plane is always perpendicular to the spline by default. The plane is first rotated by roll, pitch and yaw Euler angles, and focus offset is applied (shifted towards the direction defined by the plane normal vector). Finally, tomogram is sliced by the user defined width and depth.</p> <p>You can click the 2D slice to add molecules. These molecules are linked to the <code>napari</code> viewer; they are directly added to the <code>napari</code> drawing layer, and all the points in the drawing layer will appear in the 2D slice if it is near the plane.</p>"},{"location":"molecules/spline_to_molecules/","title":"Spline to Molecules","text":"<p>Analysis of tomograms usually starts with placing molecules around densities. What method to be used for this initialization step largely depends on your target; if you have a plausible model of placing and orienting molecules, the task can be solve more efficiently and accurately.</p> <p>As mentioned in the previous sections, <code>cylindra</code> can precisely determine the cylindric lattice parameters. These parameters are very useful for this purpose. For example, lattice spacing tells you in what interval you should place molecules, and the twist angle indicates how much you should rotate the coordinates for every molecule.</p> <p>Note</p> <p>Following methods are prefixed with <code>map_</code> but it does not mean these methods are only for microtubule-associated proteins (MAPs). The \"map\" here came from the mathematical term, as each method defines a map \\(f\\colon \\mathbb{R} \\to \\mathbb{R}^3\\) from the spline coordinate to the world Cartesian coordinate.</p>"},{"location":"molecules/spline_to_molecules/#molecules-on-the-cylinder-surface","title":"Molecules on the Cylinder Surface","text":"<p> API: <code>map_monomers</code></p> <p> GUI: <code>Molecules &gt; From/To Splines &gt; Map monomers</code></p> <p>This method places molecules on the surface of a cylinder. In most cases, this method will be used to determine the coodinates of monomers, such as:</p> <ul> <li>Tubulin monomers in microtubules</li> <li>G-actin in actin filaments</li> </ul> <p></p> List of parameters <ol> <li>In \"splines\", select which splines you will use for placing molecules.</li> <li>\"orientation\" defines in which direction the molecules will face. The y axis of    the molecule local coordinates will be either parallel or anti-parallel to the    spline tangent vector. If the <code>\"orientation\"</code> of the spline is <code>\"MinusToPlus\"</code>    and this parameter is set to <code>\"MinusToPlus\"</code>, the y axis will be parallel to the    spline.</li> <li>\"offsets\" defines the starting point of the first molecule. If the spline has    global properties <code>\"offset_axial\"</code> and <code>\"offset_angular\"</code>, they will be used by    default. You don't have to set this parameter in most cases, as you can use    <code>align_averaged</code> to shift    the molecules.</li> <li>\"radius\" defines the radius of the cylinder. If the spline has global property    <code>\"radius\"</code>, it will be used by default. If the spline has global property    <code>\"offset_radial\"</code>, it will be added to the radius.</li> <li>\"extensions\" is the number of molecules to be prepended and appended. The spline    will be linearly extrapolated to calculate the positions of these molecules.</li> <li>You can use any molecules-layer name prefix you like by providing the <code>\"prefix\"</code>    parameter.</li> </ol> <p>Following image shows an example of the result of this operation.</p> <p></p>"},{"location":"molecules/spline_to_molecules/#molecules-along-the-spline","title":"Molecules Along the Spline","text":""},{"location":"molecules/spline_to_molecules/#simple-mapping","title":"Simple Mapping","text":"<p> API: <code>map_along_spline</code></p> <p> GUI: <code>Molecules &gt; From/To Splines &gt; Map centers</code></p> <p>This method places molecules along the spline. Each molecule will be rotated by the twist angle of the spline. This method will be used for sampling fragments along filaments.</p> <p></p> List of parameters <ol> <li>In \"splines\", select which splines you will use for placing molecules.</li> <li>\"molecule interval\" defines the distance between molecules. This box evaluates    Python literals and the spline global properties are available using the <code>col</code>    function of <code>polars</code>. For example, if the <code>\"spacing\"</code> property is <code>4.05</code> and you    set this parameter to <code>col(\"spacing\") * 2</code>, this input will be evaluated to    <code>8.1</code>. For more details, see Expressions.</li> <li>\"orientation\" defines in which direction the molecules will face. The y axis of    the molecule local coordinates will be either parallel or anti-parallel to the    spline tangent vector. If the <code>\"orientation\"</code> of the spline is <code>\"MinusToPlus\"</code>    and this parameter is set to <code>\"MinusToPlus\"</code>, the y axis will be parallel to the    spline.</li> <li>You can use any molecules-layer name prefix you like by providing the <code>\"prefix\"</code>    parameter.</li> </ol>"},{"location":"molecules/spline_to_molecules/#molecules-for-cylinders-with-helical-symmetry","title":"Molecules for Cylinders with Helical Symmetry","text":"<p> API: <code>map_along_spline_helical_symmetry</code></p> <p> GUI: <code>Molecules &gt; From/To Splines &gt; Map along spline (helical symmetry)</code></p> <p>Technically, running this method is almost equivalent to picking molecules on the cylinder surface and translating them back to the spline; thus, you will see a very dense line filled with molecules.</p> <p></p> <p>Because molecules are generated based on the cylindric parameters, this method is useful prior to subtomogram averaging to checking if the parameters are correct. For example, if you have a 14_3 microtubule in your tomogram, and global-CFT analysis was successful, you should see a 14_3 helical pattern in the average image. If the parameters are not correct (like 14_2), the protofilament pattern or the lateral interactions will be missing.</p> <p></p>"},{"location":"molecules/spline_to_molecules/#molecules-along-a-protofilament","title":"Molecules Along a Protofilament","text":"<p> API: <code>map_along_pf</code></p> <p> GUI: <code>Molecules &gt; From/To Splines &gt; Map along PF</code></p> <p>This method will place a subset of molecules that would be placed by <code>map_monomers</code>. This method will be useful for, for example, placing molecules along the interface between A- and B-tubules of cilia.</p> <p></p> List of parameters <ol> <li>In \"spline\", select which spline you will use for placing molecules.</li> <li>\"molecule interval\" defines the distance between molecules. This box evaluates    Python literals and the spline global properties are available using the <code>col</code>    function of <code>polars</code>. For example, if the <code>\"spacing\"</code> property is <code>4.05</code> and you    set this parameter to <code>col(\"spacing\") * 2</code>, this input will be evaluated to    <code>8.1</code>. For more details, see Expressions.</li> <li>\"offsets\" defines the starting point of the first molecule. This is important to    define in which protofilament molecules will be placed.</li> <li>\"orientation\" defines in which direction the molecules will face. The y axis of    the molecule local coordinates will be either parallel or anti-parallel to the    spline tangent vector. If the <code>\"orientation\"</code> of the spline is <code>\"MinusToPlus\"</code>    and this parameter is set to <code>\"MinusToPlus\"</code>, the y axis will be parallel to the    spline.</li> <li>You can use any molecules-layer name prefix you like by providing the <code>\"prefix\"</code>    parameter.</li> </ol>"},{"location":"molecules/spline_to_molecules/#programmatic-access","title":"Programmatic Access","text":""},{"location":"molecules/spline_to_molecules/#molecules-as-a-layer","title":"Molecules as a layer","text":"<p>All the molecules are added to the <code>napari</code> viewer as a <code>MoleculesLayer</code>, a subclass of the <code>Points</code> layer. In the layer controls, you can adjust how the layer looks, e.g. color, size, and opacity.</p> <p>Note</p> <p>The layer control for <code>MoleculesLayer</code> is different from that of <code>Points</code> layer.</p> <p>All the layers in <code>napari</code> are stored in the <code>layers</code> attribute. For example, you can get the layer named \"Mole-0\" by following code.</p> <pre><code># `viewer` is the napari viewer object.\nviewer.layers[\"Mole-0\"]\n\n# The `parent_viewer` is the parent napari viewer of the `cylindra` GUI, thun points to\n# the same viewer object.\nui.parent_viewer.layers[\"Mole-0\"]\n</code></pre> <p>However, the cylindra GUI has another convenient accessor <code>mole_layers</code> that only considers the <code>MoleculesLayer</code> objects.</p> <pre><code>layer = ui.mole_layers[\"Mole-0\"]  # get the layer named \"Mole-0\"\n\n# iterate over all the molecules-layer\nfor layer in ui.mole_layers:\n    print(layer.name)\n</code></pre> <p>Note</p> <p>Unlike <code>Points</code> layers, <code>MoleculesLayer</code> stores additional components. - <code>layer.molecules</code>: <code>Molecules</code> object of <code>acryo</code>. - <code>layer.source_spline</code>: The source spline object which was used to generate the   molecules (if exists). This is a weak reference, so this spline object will be   deleted if you deleted or updated the spline.</p>"},{"location":"molecules/spline_to_molecules/#positional-coordinates","title":"Positional coordinates","text":"<p>The positional coordinates (in nanometer) of the molecules can be accessed by the <code>data</code> attribute as a <code>numpy</code> array, as in the <code>Points</code> layer. This array is identical to the array returned by the <code>pos</code> property of the <code>Molecules</code> object.</p> <pre><code>layer = ui.mole_layers[\"Mole-0\"]  # get the layer named \"Mole-0\"\nlayer.data  # or `layer.molecules.pos`\n</code></pre> Output:<pre><code>array([[ 18.7135, 187.5845,  40.6184],\n       [ 23.8331, 188.1172,  39.1194],\n       ...\n       [ 10.168 , 114.0109,  59.1649],\n       [ 14.1981, 115.9287,  62.1349]], dtype=float32)\n</code></pre>"},{"location":"molecules/spline_to_molecules/#molecule-rotations","title":"Molecule rotations","text":"<p>The \"rotation\" of a molecule is defined by the transformation to fit the world z, y, x axes to the molecule local z, y, x axes. Rotation is represented by a <code>Rotation</code> object of <code>scipy</code>.</p> <p><code>Rotation</code> object is stored as the <code>rotator</code> attribute of the <code>Molecules</code>.</p> <pre><code>ui.mole_layers[\"Mole-0\"].molecules.rotator\n</code></pre> Output:<pre><code>&lt;scipy.spatial.transform._rotation.Rotation at XXXXXXX&gt;\n</code></pre> <p><code>Rotation</code> object can be converted to many representations including rotation matrix, Euler angles, quaternion and rotation vector. You can get these representations by following methods.</p> <pre><code># get the ZXZ-Euler angles in degrees as (N, 3) array\nMolecules.euler_angle(\"ZXZ\", degrees=True)\n\n# get the rotation vector (z, y, x) as (N, 3) array\nMolecules.rotvec()\n\n# get the Quaternion as (N, 4) array\nMolecules.quaternion()\n\n# get the rotation matrix as (N, 3, 3) array\nMolecules.matrix()\n</code></pre> <p>For more information, see acryo documentation</p>"},{"location":"molecules/split_and_combine/","title":"Split &amp; Combine Molecules","text":""},{"location":"molecules/split_and_combine/#split-molecules","title":"Split Molecules","text":"<p> API: ui.split_molecules</p> <p> GUI: <code>Molecules &gt; Split molecules by features</code></p> <p></p> <p>This method adds multiple <code>Molecules</code> to the viewer by splitting the existing <code>Molecules</code> by a feature column. The feature column should be a categorical column. The new <code>Molecules</code> will be named as <code>&lt;old name&gt;_&lt;feature&gt;</code>. For example, if the original <code>Molecules</code> is named <code>Mole-0</code> and the feature column is <code>pf-id</code>, which takes values <code>0</code>,  <code>1</code> and so on, the new <code>Molecules</code> will be named <code>Mole-0_0</code>, <code>Mole-0_1</code> and so on.</p>"},{"location":"molecules/split_and_combine/#combine-molecules","title":"Combine Molecules","text":"<p>There are several ways to combine informations of multiple molecules.</p>"},{"location":"molecules/split_and_combine/#concatenate-multiple-molecules-into-a-single-molecules-object","title":"Concatenate multiple <code>Molecules</code> into a single <code>Molecules</code> object","text":"<p> API: ui.concatenate_molecules</p> <p> GUI: <code>Molecules &gt; Combine &gt; Concatenate molecules</code></p> <p>This method concatenates positions, rotations and all the features of multiple <code>Molecules</code> objects into a single object. If each <code>Moelcules</code> object has different features, the missing features will be filled with null values.</p> <p></p>"},{"location":"molecules/split_and_combine/#merge-molecules-positions-rotations-and-features","title":"Merge <code>Molecules</code> positions, rotations and features","text":"<p> API: ui.merge_molecule_info</p> <p> GUI: <code>Molecules &gt; Combine &gt; Merge molecule info</code></p> <p>This method create a new <code>Molecules</code> object by referencing the positions, rotations and features of other <code>Molecules</code> objects</p> <p></p>"},{"location":"molecules/split_and_combine/#copy-molecules-feature-into-another","title":"Copy <code>Molecules</code> feature into another","text":"<p> API: ui.copy_molecules_features</p> <p> GUI: <code>Molecules &gt; Combine &gt; Copy molecules features</code></p> <p>This method simply copies the features of one <code>Molecules</code> object into another.</p> <p></p>"},{"location":"molecules/transform/","title":"Transform Molecules","text":""},{"location":"molecules/transform/#translation-of-molecules","title":"Translation of Molecules","text":"<p> API: <code>translate_molecules</code></p> <p> GUI: <code>Molecules &gt; Translate molecules</code></p> <p>Translation is a transformation of positional coordinates without changing the orientation of the molecules. There are two types of translations.</p> <ol> <li>Internal translation: The shifts \\((dz, dy, dx)\\) are applied to the internal    coordinates. For example, internal translation \\((1, 0, 0)\\) of tubulin molecules    results in a microtubule with larger radius.</li> <li>External translation: The shifts \\((dz, dy, dx)\\) are applied to the external    (world) coordinates. For example, external translation \\((1, 0, 0)\\) of tubulin    molecules results in a microtubule that is shifted along the \\(z\\)-axis of the    tomogram.</li> </ol> Kinesin binding sites <p>Following code prepares molecules for the kinesin binding sites, given a molecules layer named \"Mole-0\" is correctly initialized at the tubulin positions.</p> <pre><code>ui.sta.seam_search_manually(layer='Mole-0', location=0)\nui.filter_molecules(layer='Mole-0', predicate='col(\"isotype-id\") == 0')\nui.translate_molecules(layers=['Mole-0-Filt'], translation=(2.0, 2.04, 0.0), internal=True)\n</code></pre>"},{"location":"molecules/transform/#rotation-of-molecules","title":"Rotation of Molecules","text":"<p> API: <code>rotate_molecules</code></p> <p> GUI: <code>Molecules &gt; Rotate molecules</code></p> <p>Rotation is a transformation of the orientation of the molecules without changing the positional coordinates. Only internal rotation is implemented now.</p>"},{"location":"spline/","title":"Spline","text":"<p>A 3D spline is a mapping from a 1D parameter to 3D points \\((z, y, x)\\):</p> \\[ \\boldsymbol{C}(u) \\in \\mathbb{R}^3 \\quad (0\\le u \\le 1) \\] <p>In <code>cylindra</code>, several useful methods are provided to make the most of splines.</p> <ul> <li>Clip and Invert Splines</li> <li>Spline Configurations</li> </ul>"},{"location":"spline/clip/","title":"Clip and Invert Splines","text":"<p>The \"clip\" operation of a spline is not removing the points defining the spline. Instead, it is equivalent to defining a linear transformation on the spline coordinate \\(u\\) as follows:</p> <p>\\(\\boldsymbol{C}_{clipped}(u) = \\boldsymbol{C}(\\alpha _{0} (1 - u) + \\alpha _{1} u)\\)</p> <p>\\(\\boldsymbol{C}_{clipped}(0) = \\boldsymbol{C}(\\alpha _{0})\\) and \\(\\boldsymbol{C}_{clipped}(1) = \\boldsymbol{C}(\\alpha _{1})\\) indicate that the new spline is defined by the \\(\\alpha _{0} \\le u \\le \\alpha _{1}\\) region of the original spline.</p> <p>As it is simply a linear transformation, spline inversion can also be defined the same way:</p> <p>\\(\\boldsymbol{C}_{inv}(u) = \\boldsymbol{C}(1 - u)\\)</p>"},{"location":"spline/clip/#clip-by-length","title":"Clip by Length","text":"<p> API: <code>clip_spline</code></p> <p> GUI: <code>Splines &gt; Clip spline</code> or Ctrl+K \u2192 Ctrl+X</p> <p>This method clips the selected spline at both ends by the given lengths. Local properties of the clipped spline will be discarded, while global properties will not.</p> <p></p>"},{"location":"spline/clip/#spline-clipper","title":"Spline Clipper","text":"<p> GUI: <code>Splines &gt; Open spline clipper</code></p> <p></p> <p>For precise clipping, you can use the spline clipper widget. This widget synchronizes the clipping lengths and the projections of the spline edges. \"Clip here\" will call <code>clip_spline</code> internally.</p>"},{"location":"spline/clip/#invert-splines","title":"Invert Splines","text":"<p> API: <code>invert_spline</code></p> <p> GUI: <code>Splines &gt; Orientation &gt; Invert spline</code></p> <p>This method inverts the selected spline. This operation does not discard the local properties. They will be inverted as well.</p>"},{"location":"spline/config/","title":"Spline Configurations","text":"<p>A spline is tagged with a SplineConfig object. This object is practically used to annotate the spline with structural features. For example, if a spline represent a microtubule, it is tagged with a <code>SplineConfig</code> object with parameters appropriate for microtubules. These parameters are used in spline fitting, CFT analysis, and so on.</p> <p>Every time a new spline is created, it is initialized with the default <code>SplineConfig</code>. Make sure the correct configuration is used before adding splines.</p>"},{"location":"spline/config/#list-of-parameters","title":"List of Parameters","text":"<ul> <li>Parameters used during CFT analysis</li> <li><code>npf_range</code> ... an (<code>int</code>, <code>int</code>) tuple indicating the minimum/maximum of the     number of protofilaments.</li> <li><code>spacing_range</code> ... an (<code>float</code>, <code>float</code>) tuple indicating the minimum/maximum of     longitudinal spacing between monomers (in nanometer).</li> <li><code>twist_range</code> ... an (<code>float</code>, <code>float</code>) tuple indicating the minimum/maximum of     twist angle (in degree).</li> <li><code>rise_range</code> ... an (<code>float</code>, <code>float</code>) tuple indicating the minimum/maximum of     rise angle (in degree).</li> <li> <p><code>rise_sign</code> ... the sign of the rise angle. This parameter is redundant for the     mathematically. It was introduced only to make the rise angle and the start number positive, like \"13_3\" instead of \"13_-3\".</p> </li> <li> <p>Other parameters</p> </li> <li><code>clockwise</code> ... <code>\"PlusToMinus\"</code> or <code>\"MinusToPlus\"</code>. This parameter is used for     automatic polarity determination. If the cross-sectional view of the cylindric     structure in the plus-to-minus orientation has clockwise chirality, set this     parameter to <code>\"PlusToMinus\"</code>.</li> <li><code>thickness_inner</code> ... distance between the inner surface and the peak of the radial     profileradius (in nanometer). This parameter is used for construction of cylindric     coordinate system.</li> <li><code>thickness_inner</code> ... distance between the outer surface and the peak of the radial     profileradius (in nanometer). This parameter is used for construction of cylindric     coordinate system.</li> <li><code>fit_depth</code> ... the depth of sub-volumes used for spline fitting region (in     nanometer).</li> <li><code>fit_width</code> ... the width of sub-volumes used for spline fitting region (in     nanometer).</li> </ul> <p>The default configuration is optimized for microtubules on startup.</p> <pre><code>ui.default_config\n</code></pre> Output<pre><code>SplineConfig(\n    npf_range=Range(min=11, max=17),\n    spacing_range=Range(min=3.9, max=4.3),\n    twist_range=Range(min=-0.65, max=0.65),\n    rise_range=Range(min=5.0, max=13.0),\n    rise_sign=-1,\n    clockwise='MinusToPlus',\n    thickness_inner=2.8,\n    thickness_outer=2.8,\n    fit_depth=49.0,\n    fit_width=40.0\n)\n</code></pre>"},{"location":"spline/config/#edit-the-default-config","title":"Edit the Default Config","text":"<p>The config editor widget is designed to easily edit, apply, and save the spline config.</p> <p> GUI: <code>Splines &gt; Open config editor</code></p> <p></p> <p>The left panel shows the current config. Splines added to the tomogram are initialized with this config. The right panel is used for editing the config without changing the current config. These parameter sets can be copied between each other with the buttons in the middle.</p>"},{"location":"spline/config/#load-presets","title":"Load presets","text":"<p>Presets are stored in the user directory. You can load the presets from the menu.</p> <p>By default, presets for following biological components are available:</p> <ul> <li>F-actin</li> <li>Eukaryotic microtubule</li> <li>BtubAB (a bacterial microtubule)</li> <li>Tobacco mosaic virus</li> </ul>"},{"location":"spline/config/#save-as-a-preset","title":"Save as a preset","text":"<p>You can save current configuration parameters as a preset with an arbitrary name.</p>"}]}