from __future__ import annotations
from typing import overload
import numpy as np
from numpy.typing import NDArray

class ViterbiGrid:
    def __init__(
        self,
        score_array: NDArray[np.float32],
        origin: NDArray[np.float32],
        zvec: NDArray[np.float32],
        yvec: NDArray[np.float32],
        xvec: NDArray[np.float32],
    ) -> None: ...
    @overload
    def viterbi(
        self,
        dist_min: float,
        dist_max: float,
        /,
    ) -> tuple[NDArray[np.int32], float]: ...
    @overload
    def viterbi(
        self,
        dist_min: float,
        dist_max: float,
        skew_max: float,
        /,
    ) -> tuple[NDArray[np.int32], float]: ...
    def world_pos(self, n: int, z: int, y: int, x: int, /) -> NDArray[np.float64]: ...

class Sources:
    def has_longitudinal(self) -> bool: ...
    def has_lateral(self) -> bool: ...
    def __eq__(self, other: list[tuple[int, int]]) -> bool: ...

class Index:
    y: int
    a: int
    def __init__(self, y: int, a: int, /) -> None: ...
    def is_valid(self) -> bool: ...
    def __eq__(self, other: tuple[int, int]) -> bool: ...

class CylinderGeometry:
    def __init__(self, ny: int, na: int, nrise: int, /) -> None: ...
    def source_forward(self, y: int, a: int, /) -> Sources: ...
    def source_backward(self, y: int, a: int, /) -> Sources: ...
    def get_neighbors(self, y: int, a: int, /) -> list[Index]: ...
    def get_index(self, y: int, a: int, /) -> Index: ...
    def convert_angular(self, a: int, /) -> int: ...

class CylindricAnnealingModel:
    def __init__(self, seed: int = 0) -> None: ...
    def simulate(self, niter: int = 10000) -> None: ...
    def iteration(self) -> int: ...
    def with_seed(self, seed: int) -> CylindricAnnealingModel: ...
    def optimization_state(self) -> str: ...
    def energy(self) -> float: ...
    def reservoir(self) -> Reservoir: ...
    def set_reservoir(
        self, temperature: float, time_constant: float, min_temperature: float = 0.0
    ) -> CylindricAnnealingModel: ...
    def graph(self) -> CylindricGraph: ...
    def set_graph(
        self,
        score_array: NDArray[np.float32],
        origin: NDArray[np.float32],
        zvec: NDArray[np.float32],
        yvec: NDArray[np.float32],
        xvec: NDArray[np.float32],
        nrise: int,
    ) -> CylindricAnnealingModel: ...
    def set_box_potential(
        self,
        lon_dist_min: float,
        lon_dist_max: float,
        lat_dist_min: float,
        lat_dist_max: float,
    ) -> CylindricAnnealingModel: ...
    def shifts(self) -> NDArray[np.int32]: ...

class CylindricGraph:
    def node_count(self) -> int: ...
    def edge_count(self) -> int: ...
    def edges(self) -> list[tuple[int, int]]: ...
    def longitudinal_distances(self) -> NDArray[np.float32]: ...
    def lateral_distances(self) -> NDArray[np.float32]: ...

class Reservoir:
    def __init__(
        self, temperature: float, time_constant: float, min_temperature: float
    ) -> None: ...
    def temperature(self) -> float: ...
    def initialize(self) -> None: ...

def alleviate(
    arr: NDArray[np.float64],
    label: NDArray[np.int32],
    nrise: int,
    iterations: int,
    /,
) -> NDArray[np.float64]: ...
